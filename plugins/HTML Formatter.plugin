__id__ = "html_formatter"
__name__ = "HTML Formatter"
__author__ = "@fr1zeeDev"
__version__ = "1.1.0"
__description__ = "ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµÑ‚ HTML-Ñ€Ğ°Ğ·Ğ¼ĞµÑ‚ĞºÑƒ Ğ² Telegram Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ"

import re
from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Text, Input
from markdown_utils import parse_markdown
from java.util import ArrayList

__min_version__ = "11.9.0"
__icon__ = "msg_edit"

class HTMLFormatterPlugin(BasePlugin):
    def on_plugin_load(self):
        self.add_on_send_message_hook()

    def create_settings(self):
        settings_list = [
            Header(text="HTML Formatter"),
            Input(
                key="command_prefix",
                text="ĞŸÑ€ĞµÑ„Ğ¸ĞºÑ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹",
                default=".html",
                icon="msg_edit"
            ),
            Divider(),
            Divider(text="[ ? ] â€¢ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ñ‚ĞµĞ³Ğ¸:"),
            Divider(text="<b> - Ğ–Ğ¸Ñ€Ğ½Ñ‹Ğ¹\n<i> - ĞšÑƒÑ€ÑĞ¸Ğ²\n<u> - ĞŸĞ¾Ğ´Ñ‡Ñ‘Ñ€ĞºĞ½ÑƒÑ‚Ñ‹Ğ¹\n<s> - Ğ—Ğ°Ñ‡Ñ‘Ñ€ĞºĞ½ÑƒÑ‚Ñ‹Ğ¹\n<code> - ĞœĞ¾Ğ½Ğ¾ÑˆĞ¸Ñ€Ğ¸Ğ½Ğ½Ñ‹Ğ¹\n<sp> - Ğ¡Ğ¿Ğ¾Ğ¹Ğ»ĞµÑ€ (ÑĞºÑ€Ñ‹Ñ‚Ñ‹Ğ¹)\n<a href='url'> - Ğ¡cÑ‹Ğ»ĞºĞ°\n<pre> - Ğ‘Ğ»Ğ¾Ğº ĞºĞ¾Ğ´Ğ° (ÑĞ·Ñ‹Ğº - Ğ¿ĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° / ĞºĞ¾Ğ´ - Ğ²Ñ‚Ğ¾Ñ€Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°)\n<h1> - Encoded (Ğ°Ğ½Ğ³Ğ». ÑĞ·Ñ‹Ğº)\n<m> - Typewriter (Ğ°Ğ½Ğ³Ğ». ÑĞ·Ñ‹Ğº)\n<quote> - Ğ¦Ğ¸Ñ‚Ğ°Ñ‚Ğ°\n<quote exp> - Ğ¡Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼Ğ°Ñ Ñ†Ğ¸Ñ‚Ğ°Ñ‚Ğ°"),
            Divider(),
            Divider(text="[ ! ] â€¢ Ğ¢ĞµĞ³Ğ¸ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· </>"),
            Divider(),
            Divider(text="~ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:\n<b><i>Ñ‚ĞµĞºÑÑ‚</></>\n<a href='https://t.me/fr1zeeDev'>Ğ¡ÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ</>\n<quote><b>Ñ†Ğ¸Ñ‚Ğ°Ñ‚Ğ°</></>"),
            Divider(text="[ Â© ] â€¢ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»ÑŒ: @fr1zeeDev [telegram]"),
        ]
        return settings_list

    def on_send_message_hook(self, account, params):
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult()
        
        message = params.message.strip()
        command_prefix = self.get_setting("command_prefix", ".html")
        
        if not message.startswith(command_prefix + ' '):
            return HookResult()
       
        html_content = message[len(command_prefix) + 1:].strip()
        
        if not html_content:
            return HookResult()
        
        formatted_text = self._convert_html_to_telegram(html_content)
        parsed = parse_markdown(formatted_text)
        params.message = parsed.text
        
        if hasattr(params, 'entities'):
            params.entities.clear()
        else:
            params.entities = ArrayList()
            
        for ent in parsed.entities:
            params.entities.add(ent.to_tlrpc_object())
            
        return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def _convert_html_to_telegram(self, html_text):
        text = self._process_special_tags(html_text)
        text = self._process_quotes(text)
        text = self._process_spoilers(text)
        text = self._process_all_tags_recursive(text)
        
        return text

    def _process_all_tags_recursive(self, text):
        previous_text = ""
        
        while previous_text != text:
            previous_text = text
            text = self._process_links(text)
            text = self._process_single_tag_pass(text)
        return text
    def _process_single_tag_pass(self, text):
        tag_map = [
            ('b', '*', '*'),
            ('i', '_', '_'),
            ('u', '__', '__'),
            ('s', '~', '~'),
            ('code', '`', '`'),
            ('pre', '```', '```')
        ]
        for tag_name, open_md, close_md in tag_map:  # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: tag_map Ğ²Ğ¼ĞµÑÑ‚Ğ¾ tags
            pattern_full = f'<{tag_name}>(.*?)</{tag_name}>'
            pattern_short = f'<{tag_name}>(.*?)</>'
            
            def replace_tag(match):
                content = match.group(1)
                return f"{open_md}{content}{close_md}"
            
            text = re.sub(pattern_full, replace_tag, text, flags=re.IGNORECASE | re.DOTALL)
            text = re.sub(pattern_short, replace_tag, text, flags=re.IGNORECASE | re.DOTALL)
        
        return text

    def _process_special_tags(self, text):
        """2"""
        def encoded_replace(match):
            content = match.group(1)
            fullwidth_map = {
                'A': 'ï¼¡', 'B': 'ï¼¢', 'C': 'ï¼£', 'D': 'ï¼¤', 'E': 'ï¼¥', 'F': 'ï¼¦', 'G': 'ï¼§',
                'H': 'ï¼¨', 'I': 'ï¼©', 'J': 'ï¼ª', 'K': 'ï¼«', 'L': 'ï¼¬', 'M': 'ï¼­', 'N': 'ï¼®',
                'O': 'ï¼¯', 'P': 'ï¼°', 'Q': 'ï¼±', 'R': 'ï¼²', 'S': 'ï¼³', 'T': 'ï¼´', 'U': 'ï¼µ',
                'V': 'ï¼¶', 'W': 'ï¼·', 'X': 'ï¼¸', 'Y': 'ï¼¹', 'Z': 'ï¼º',
                'a': 'ï½', 'b': 'ï½‚', 'c': 'ï½ƒ', 'd': 'ï½„', 'e': 'ï½…', 'f': 'ï½†', 'g': 'ï½‡',
                'h': 'ï½ˆ', 'i': 'ï½‰', 'j': 'ï½Š', 'k': 'ï½‹', 'l': 'ï½Œ', 'm': 'ï½', 'n': 'ï½',
                'o': 'ï½', 'p': 'ï½', 'q': 'ï½‘', 'r': 'ï½’', 's': 'ï½“', 't': 'ï½”', 'u': 'ï½•',
                'v': 'ï½–', 'w': 'ï½—', 'x': 'ï½˜', 'y': 'ï½™', 'z': 'ï½š',
                '0': 'ï¼', '1': 'ï¼‘', '2': 'ï¼’', '3': 'ï¼“', '4': 'ï¼”', '5': 'ï¼•', '6': 'ï¼–',
                '7': 'ï¼—', '8': 'ï¼˜', '9': 'ï¼™', ' ': 'ã€€'
            }
            result = ''.join(fullwidth_map.get(c, c) for c in content)
            return result
            
        def typewriter_replace(match):
            content = match.group(1)
            math_map = {
                'A': 'ğ™°', 'B': 'ğ™±', 'C': 'ğ™²', 'D': 'ğ™³', 'E': 'ğ™´', 'F': 'ğ™µ', 'G': 'ğ™¶',
                'H': 'ğ™·', 'I': 'ğ™¸', 'J': 'ğ™¹', 'K': 'ğ™º', 'L': 'ğ™»', 'M': 'ğ™¼', 'N': 'ğ™½',
                'O': 'ğ™¾', 'P': 'ğ™¿', 'Q': 'ğš€', 'R': 'ğš', 'S': 'ğš‚', 'T': 'ğšƒ', 'U': 'ğš„',
                'V': 'ğš…', 'W': 'ğš†', 'X': 'ğš‡', 'Y': 'ğšˆ', 'Z': 'ğš‰',
                'a': 'ğšŠ', 'b': 'ğš‹', 'c': 'ğšŒ', 'd': 'ğš', 'e': 'ğš', 'f': 'ğš', 'g': 'ğš',
                'h': 'ğš‘', 'i': 'ğš’', 'j': 'ğš“', 'k': 'ğš”', 'l': 'ğš•', 'm': 'ğš–', 'n': 'ğš—',
                'o': 'ğš˜', 'p': 'ğš™', 'q': 'ğšš', 'r': 'ğš›', 's': 'ğšœ', 't': 'ğš', 'u': 'ğš',
                'v': 'ğšŸ', 'w': 'ğš ', 'x': 'ğš¡', 'y': 'ğš¢', 'z': 'ğš£'
            }
            result = ''.join(math_map.get(c, c) for c in content)
            return result

        text = re.sub(r'<h1>(.*?)</h1>', encoded_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r'<h1>(.*?)</>', encoded_replace, text, flags=re.IGNORECASE | re.DOTALL)
        
        text = re.sub(r'<m>(.*?)</m>', typewriter_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r'<m>(.*?)</>', typewriter_replace, text, flags=re.IGNORECASE | re.DOTALL)

        return text

    def _process_links(self, text):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¸ ÑÑÑ‹Ğ»ĞºĞ¸"""
        def link_replace(match):
            url = match.group(1)
            link_text = match.group(2)
            return f"[{link_text}]({url})"
        
        # Ğ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ğ¾Ğµ Ñ€ĞµĞ³ÑƒĞ»ÑÑ€Ğ½Ğ¾Ğµ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ ÑÑÑ‹Ğ»Ğ¾Ğº
        text = re.sub(r"<a\s+href=['\"]([^'\"]+)['\"]>([^<]+)</a>", link_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r"<a\s+href=['\"]([^'\"]+)['\"]>([^<]+)</>", link_replace, text, flags=re.IGNORECASE | re.DOTALL)
        return text

    def _process_quotes(self, text):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ†Ğ¸Ñ‚Ğ°Ñ‚Ñ‹"""
        def quote_replace(match):
            content = match.group(1)
            return f"> {content}"
        def expandable_quote_replace(match):
            content = match.group(1)
            return f"```\n{content}\n```"
        text = re.sub(r'<quote>(.*?)</quote>', quote_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r'<quote>(.*?)</>', quote_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r'<quote\s+exp>(.*?)</quote\s+exp>', expandable_quote_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r'<quote\s+exp>(.*?)</>', expandable_quote_replace, text, flags=re.IGNORECASE | re.DOTALL)
        return text

    def _process_spoilers(self, text):
        """ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‚Ğ²Ğ²Ğ°ĞµÑ‚ ÑĞ¿Ğ¾Ğ¹Ğ»ĞµÑ€Ñ‹"""
        def spoiler_replace(match):
            content = match.group(1)
            return f"||{content}||"
        text = re.sub(r'<sp>(.*?)</sp>', spoiler_replace, text, flags=re.IGNORECASE | re.DOTALL)
        text = re.sub(r'<sp>(.*?)</>', spoiler_replace, text, flags=re.IGNORECASE | re.DOTALL)
        return text