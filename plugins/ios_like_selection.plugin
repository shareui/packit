__id__ = "ios_like_selection"
__name__ = "IOS-like selection"
__description__ = "Recreates the effect of selecting a message by tapping like on **IOS**"
__author__ = "@PESSDES_Plugins"
__min_version__ = "12.0.0" 
__icon__ = "VoiceToText7/6"
__version__ = "7.0"

from android.os import Build

SHADER_BLUR_SUPPORTED = Build.VERSION.SDK_INT >= 31

from typing import Any, Callable, Tuple

from android.animation import (Animator, AnimatorSet, ObjectAnimator,
                               ValueAnimator)

if SHADER_BLUR_SUPPORTED:
    from android.graphics import RenderEffect, Shader

import time

from android.graphics import Canvas, Color, PorterDuff
from android.graphics.drawable import BitmapDrawable
from android.view import Gravity, MotionEvent, View, ViewGroup
from android.view.animation import (AccelerateInterpolator,
                                    DecelerateInterpolator)
from android.widget import FrameLayout, LinearLayout, PopupWindow, ScrollView
from android_utils import OnClickListener
from android_utils import log as logcat
from android_utils import run_on_ui_thread
from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment, get_media_controller
from com.exteragram.messenger.components import ActionRow
from hook_utils import get_private_field, set_private_field
from java import dynamic_proxy
from java import jint as JInt
from java.lang import Boolean, Float, Integer, Runnable
from org.telegram.messenger import (AndroidUtilities, MessageObject,
                                    SharedConfig)
from org.telegram.ui import ChatActivity
from org.telegram.ui.ActionBar import ActionBarPopupWindow
from org.telegram.ui.Cells import ChatActionCell, ChatMessageCell
from org.telegram.ui.Components import LayoutHelper, ReactionsContainerLayout
from ui.settings import Divider, Header, Selector, Switch


def log(*msg):
    if len(msg) == 0:
        return
    m = msg if len(msg) > 1 else msg[0]
    if isinstance(m, Exception) and m.__traceback__ is not None:
        m = f"{m.__traceback__.tb_lineno}: {m}"
    logcat(f'[{__id__}] {m}')

def ctx():
    return get_last_fragment().getContext()

def call_private_method(obj, name, *args):
    method = None
    for m in obj.getClass().getDeclaredMethods():
        if m.getName() == name and len(m.getParameterTypes()) == len(args):
            method = m
            break
    if method is None:
        raise Exception(f'Method {name} not found in {obj.getClass()}')
    method.setAccessible(True)
    return method.invoke(obj, *args)

jboolean = Boolean.TYPE
jfloat = Float.TYPE
jint = Integer.TYPE

MATCH_PARENT = ViewGroup.LayoutParams.MATCH_PARENT
WRAP_CONTENT = ViewGroup.LayoutParams.WRAP_CONTENT

def get_display_metrics():
    try:
        display_metrics = ctx().getResources().getDisplayMetrics()
    except Exception as e:
        display_metrics = None
        log(e)
        
    if not display_metrics:
        display_metrics = AndroidUtilities.displayMetrics
        
    if not display_metrics:
        display_metrics = AndroidUtilities.displaySize
        return display_metrics.x, display_metrics.y 

    return display_metrics.widthPixels, display_metrics.heightPixels

def any_eq(obj, *compares):
    return any(x == obj for x in compares)

display_width, display_height = get_display_metrics()

class Plugin(BasePlugin):
    instance: "Plugin | None" = None
    
    def on_plugin_load(self) -> None:
        self.dismiss_hook = None
        self.draw_hook = None
        Plugin.instance = self
        
        self.hook_method(
            [x for x in ChatActivity.getClass().getDeclaredMethods() if x.getName() == "createMenu"][-1], 
            CreateMenuHook())
        
        self.hook_method(
            ActionBarPopupWindow.getClass().getDeclaredMethod("showAtLocation", View, jint, jint, jint),
            ShowPopupHook()
        )
        
        self.hook_method(
            ChatMessageCell.getClass().getDeclaredMethod("onLongPress"),
            PreventTouch()
        )
        
        self.hook_method(
            ChatMessageCell.getClass().getDeclaredMethod("onTouchEvent", MotionEvent),
            PreventTouch()
        )
    
    blurs = [
        25,
        50,
        100,
        150,
        250,
        350
    ]
    
    animations_speed = [
        0.25,
        0.5,
        0.75,
        1,
        1.5,
        2,
        2.5,
        3
    ]
    
    def create_settings(self) -> list[Any]:
        try:
            settings = []
            settings.append(Header("Blur"))
            settings.append(Selector('radius', 'Blur Radius', items=[str(x) for x in self.blurs], icon='msg_palette', default=4, link_alias="blur_radius"))
            if SHADER_BLUR_SUPPORTED:
                settings.append(Switch("force_simple", "Simple mode", True, subtext="Use more optimized blur method", link_alias="simple_mode"))
                if not self.use_alt_blur():
                    settings.append(Divider('A larger blur radius may cause lags'))
            
            settings.append(Header("Animations"))
            settings.append(Switch('enable_animations', 'Enable animations', True, link_alias="animations"))
            if self.get_setting("enable_animations", True):
                settings.append(Selector('animations_speed', 'Animations speed', default=3, items=[f'x{x}' for x in self.animations_speed], icon="msg_premium_speed", link_alias="animations_speed"))
            settings.append(Header("Others"))
            settings.append(Switch("scroll_from_bottom", "Scroll from bottom", True, link_alias="bottom_scroll"))
            settings.append(Switch("sticky_reactions_bar", '"Sticky" reactions bar', True, subtext="Moves the reaction panel over the message like IOS", link_alias="sticky_reactions_bar"))
            return settings
        except Exception as e:
            log(e)
    
    @classmethod
    def get_radius(cls):
        try:
            if not cls.instance:
                return cls.blurs[4]
            return cls.blurs[int(cls.instance.get_setting('radius', 4))]
        except Exception as e:
            log(e)
    
    @classmethod
    def get_animation_speed(cls):
        if not cls.instance:
            return cls.animations_speed[3]
        return 0 if not cls.instance.get_setting("enable_animations", True) else cls.animations_speed[int(cls.instance.get_setting("animations_speed", 3))]
    
    @classmethod
    def scroll_from_bottom(cls):
        if not cls.instance:
            return True
        return cls.instance.get_setting("scroll_from_bottom", True)
    
    @classmethod
    def use_alt_blur(cls):
        if not cls.instance:
            return not SHADER_BLUR_SUPPORTED
        return not SHADER_BLUR_SUPPORTED or cls.instance.get_setting("force_simple", True)

    @classmethod
    def sticky_reactions_bar(cls):
        if not cls.instance:
            return True
        return cls.instance.get_setting("sticky_reactions_bar", True)

class Stopwatch:
    def __init__(self):
        self.reset()
    
    def reset(self):
        self._start = 0
        self._stop = 0
    
    def start(self):
        self._start = time.time()
    
    def stop(self):
        self._stop = time.time()
    
    def ensure(self):
        if self._stop < self._start:
            self._stop = time.time()
        return self._stop - self._start
    
    def ensure_int(self):
        return int(self.ensure())
    
    def pop(self):
        result = self.ensure()
        self.reset()
        return result
    
    def pop_int(self):
        return int(self.pop())

current_chat_activity: ChatActivity | None = None
current_message_cell: ChatMessageCell | ChatActionCell | None = None
touch_stopwatch = Stopwatch()

def apply_blur(view, radius):
    if SHADER_BLUR_SUPPORTED:
        if radius <= 0:
            view.setRenderEffect(None)
        else:
            view.setRenderEffect(RenderEffect.createBlurEffect(radius, radius, Shader.TileMode.MIRROR))

class PreventTouch(MethodHook):
    def before_hooked_method(self, param):
        if param.thisObject.getTag() == __id__:
            param.setResult(False)

class ShowPopupHook(MethodHook):  
    def __init__(self) -> None:
        self.out_animation: AnimatorSet | None = None
        self.cell_stopwatch = Stopwatch()
        
    def before_hooked_method(self, param):
        try:
            if not current_chat_activity or touch_stopwatch.ensure() > 0.25:
                return
            
            self.original_y = param.args[3]
            self.original_x = param.args[2]
            param.args[2] = JInt(0) # x
            param.args[3] = JInt(0) # y
            
            self._before_hooked_method(param.thisObject, *param.args)
        except Exception as e:
            log(e)
    
    def _pop_globals(self) -> Tuple[ChatActivity | None, ChatMessageCell | ChatActionCell | None]:
        global current_chat_activity, current_message_cell
        ca, mc = current_chat_activity, current_message_cell
        current_chat_activity = None
        current_message_cell = None
        return ca, mc
    
    def _before_hooked_method(self, this: ActionBarPopupWindow, *_):   
        try: 
            log("Preparing menu...")
            if self.out_animation is not None and self.out_animation.isRunning():
                self.out_animation.cancel()
                self.out_animation = None
                
            current_chat_activity, current_message_cell = self._pop_globals()
            grouped = isinstance(current_message_cell, ChatMessageCell) and current_message_cell.getCurrentMessagesGroup() is not None
            if grouped or get_media_controller().isPlayingMessage(current_message_cell.getMessageObject()):
                cell = None
            else:
                cell = self._copy_message_cell(current_message_cell)
                if not cell:
                    return

            this.setWidth(MATCH_PARENT)
            this.setHeight(MATCH_PARENT)
            this.setClippingEnabled(False) 
            
            old_content = this.getContentView()
            children = []
            for i in range(old_content.getChildCount()):
                children.append(old_content.getChildAt(i))

            old_content.removeAllViews()

            new_content = FrameLayout(ctx())
            new_content.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            new_content.setClickable(True) 
            new_content.setClipChildren(False)

            scroll_view = ScrollView(ctx())
            scroll_view.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            scroll_view.setFillViewport(True)
            scroll_view.setClipChildren(False)
            scroll_view.setClipToPadding(False)
            scroll_view.setOverScrollMode(View.OVER_SCROLL_NEVER) 
            scroll_view.setVerticalScrollBarEnabled(False)

            inner_container = LinearLayout(ctx())
            inner_container.setOrientation(LinearLayout.VERTICAL)
            inner_container.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            
            w_spec = View.MeasureSpec.makeMeasureSpec(display_width, View.MeasureSpec.AT_MOST)
            h_spec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)

            if current_message_cell is not None:
                is_out = current_message_cell.getMessageObject().isOut()
                is_channel = current_message_cell.getMessageObject().isFromChannel()
            else:
                is_out = None
                is_channel = None
               
            
            if cell:
                gravity = Gravity.RIGHT if is_out and not is_channel else Gravity.LEFT
                lp = LayoutHelper.createLinear(WRAP_CONTENT, WRAP_CONTENT, gravity)
            else:
                gravity = None
                lp = None
                
            reactions_height = 0
            reactions_view: ReactionsContainerLayout | None = None
            if len(children) > 0 and isinstance(children[0], ReactionsContainerLayout):
                reactions_view = children.pop(0)
                if lp:
                    reactions_view.setLayoutParams(lp)
                else:
                    reactions_view.setLayoutParams(LayoutHelper.createLinear(WRAP_CONTENT, WRAP_CONTENT, Gravity.LEFT))
                
                reactions_view.measure(w_spec, h_spec)
                reactions_height = reactions_view.getMeasuredHeight()
            
            if cell:
                cell.setLayoutParams(LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT))
                inner_container.addView(cell)
                cell.setLongClickable(False)
                cell.setClickable(False)
                cell.setOnClickListener(OnClickListener(lambda *_: None))
            
            dismiss = OnClickListener(lambda *_: this.dismiss())
            inner_container.setOnClickListener(dismiss)
            new_content.setOnClickListener(dismiss)
            scroll_view.setOnClickListener(dismiss)
            
            message_height = current_message_cell.getHeight() if cell else 0

            bottom_menu_height = 0
            popup_actions_menu = None
            popup_actions_grouped_menu = None
            
            for child in children:
                if (isinstance(child, FrameLayout) and isinstance(child.getChildAt(0), ActionRow)):
                    popup_actions_grouped_menu = child.getChildAt(0)
                    if gravity:
                        child.getLayoutParams().gravity = gravity
                elif lp:
                    child.setLayoutParams(lp)
                
                inner_container.addView(child)
                child.measure(w_spec, h_spec)
                bottom_menu_height += child.getMeasuredHeight()
                
                if not popup_actions_menu and isinstance(child, ActionBarPopupWindow.ActionBarPopupWindowLayout):
                    popup_actions_menu = child
                    popup_actions_menu.swipeBackGravityRight = gravity == Gravity.RIGHT

                    """ #TODO
                    try:
                        popup_window_layout = get_private_field(popup_actions_menu, "linearLayout")
                        
                        if popup_window_layout:
                            for i in range(popup_window_layout.getChildCount()):
                                btn = popup_window_layout.getChildAt(i)
                                btn.setClickable(False)
                                btn.setLongClickable(False)
                                btn.setFocusable(False)

                            current_pressed_view = None
                            from android.graphics import Rect
                            rect = Rect()
                            
                            def on_touch(view, event):
                                nonlocal current_pressed_view
                                try:
                                    x = int(event.getRawX())
                                    y = int(event.getRawY())
                                    action = event.getAction()
                                    
                                    button_found = False

                                    if action == MotionEvent.ACTION_DOWN or action == MotionEvent.ACTION_MOVE:
                                        scroll_view.requestDisallowInterceptTouchEvent(True)
                                        for i in range(popup_window_layout.getChildCount()):
                                            child = popup_window_layout.getChildAt(i)
                                            
                                            child.getGlobalVisibleRect(rect)
                                            
                                            if rect.contains(x, y):
                                                button_found = True
                                                if current_pressed_view != child:
                                                    if current_pressed_view:
                                                        current_pressed_view.setPressed(False)
                                                    
                                                    current_pressed_view = child
                                                    current_pressed_view.setPressed(True)
                                                    try:
                                                        child.performHapticFeedback(3) 
                                                    except: pass
                                                break
                                        
                                        if not button_found and current_pressed_view:
                                            current_pressed_view.setPressed(False)
                                            current_pressed_view = None
                                    
                                    elif action == MotionEvent.ACTION_UP:
                                        scroll_view.requestDisallowInterceptTouchEvent(False)
                                        if current_pressed_view:
                                            current_pressed_view.setClickable(True)
                                            current_pressed_view.performClick()
                                            current_pressed_view.setClickable(False) 
                                            
                                            current_pressed_view.setPressed(False)
                                            current_pressed_view = None
                                            return True

                                    return button_found
                                except Exception as e:
                                    log("Error in on_touch", e)
                                    return False
                                        
                            popup_window_layout.setOnTouchListener(OnTouchListener(on_touch))
  
                    except Exception as e:
                        log(e)
                    """
            
            scroll_view.addView(inner_container)
            new_content.addView(scroll_view)

            if cell:
                original_msg_x, original_msg_y = AndroidUtils.get_location_on_screen(current_message_cell)
            else:
                original_msg_y = self.original_y + reactions_height
                original_msg_x = 0
                inner_container.setPadding(self.original_x,0,0,0)
            
            top_limit = AndroidUtilities.statusBarHeight + AndroidUtilities.dp(24)
            bottom_limit = AndroidUtilities.navigationBarHeight + AndroidUtilities.dp(12)
            
            padding_top = original_msg_y - reactions_height
            
            menu_height = reactions_height + bottom_menu_height + message_height
            
            if display_height - padding_top < menu_height:
                padding_top = display_height - menu_height

            if padding_top < top_limit:
                padding_top = top_limit
            elif padding_top + menu_height > display_height - bottom_limit:
                padding_top = display_height - bottom_limit - menu_height

            bar = False
            need_scroll = padding_top + menu_height - reactions_height > display_height
            scroll_bottom = False
            if need_scroll:
                if Plugin.scroll_from_bottom():
                    scroll_view.post(RunnableFactory(lambda: scroll_view.fullScroll(View.FOCUS_DOWN)))
                    scroll_bottom = True
                    
                if reactions_view is not None and Plugin.sticky_reactions_bar() and cell and is_out is not None:
                    reactions_bar = FrameLayout(ctx())
                    reactions_bar.addView(reactions_view)
                    reactions_view.setLayoutParams(LayoutHelper.createFrame(WRAP_CONTENT, WRAP_CONTENT, gravity))
                    new_content.addView(reactions_bar, lp)
                    reactions_bar.setTranslationY(padding_top)
                    bar = True
            
            if reactions_view is not None and not bar:
                inner_container.addView(reactions_view, 0)
            
            idk_how_to_name_ts = reactions_height if bar else 0
            if padding_top + menu_height - idk_how_to_name_ts > display_height - bottom_limit:  
                scroll_view.setPadding(0, 0, 0, bottom_limit)
              
            spacer = View(ctx())
            spacer.setLayoutParams(LinearLayout.LayoutParams(MATCH_PARENT, int(padding_top + idk_how_to_name_ts)))
            spacer.setOnClickListener(dismiss)
            inner_container.addView(spacer, 0)
            
            message_y = padding_top + reactions_height
            
            this.setContentView(new_content)
            
            def animate(out):
                if not out and scroll_bottom:
                    scroll_y = menu_height + idk_how_to_name_ts - display_height
                elif out:
                    scroll_y = scroll_view.getScrollY()
                else:
                    scroll_y = 0
                    
                nonlocal original_msg_y
                if cell and out:
                    _, original_msg_y = AndroidUtils.get_location_on_screen(current_message_cell)
                    
                return self.animate(
                    out, 
                    this, 
                    (original_msg_y - message_y + scroll_y) if cell else None, 
                    popup_actions_menu, 
                    current_chat_activity, 
                    current_message_cell if cell else None, 
                    reactions_view, 
                    cell,
                    inner_container)
            
            animate(False)
            
            if gravity != None and isinstance(cell, ChatMessageCell) and (popup_actions_menu != None or reactions_view != None):
                avatar_width = AndroidUtilities.dp(48) if current_message_cell.needDrawAvatar() else 0
                pad = int(SharedConfig.bubbleRadius / 2) if gravity == Gravity.LEFT else AndroidUtilities.dp(8)
                mar = original_msg_x + avatar_width + pad if gravity == Gravity.LEFT else original_msg_x + current_message_cell.getWidth() - current_message_cell.getBoundsRight()
                
                for view in [popup_actions_menu, reactions_view]:
                    if view is None:
                        continue
                    
                    translation = 0
                    if gravity == Gravity.LEFT:
                        width = view.getMeasuredWidth()
                        
                        if mar + width + pad > display_width or mar < pad:
                            translation = pad
                        else:
                            translation = mar
                    elif gravity == Gravity.RIGHT:
                        translation = min(display_width - pad, mar)
                            
                    if translation != 0:
                        view.setTranslationX(translation)
                  
            def _on_dimiss(param):
                if this == param.thisObject:           
                    if param.args[0]: 
                        self._pop_globals()
                        self.out_animation = animation = animate(True)
                        if animation is not None:
                            param.setResult(None)
                            new_content.setClickable(False)
                            scroll_view.setClickable(False)
                            inner_container.setClickable(False)
                            animation.addListener(AnimatorListener(lambda *a: this.dismiss(False)))
                    else:
                        if Plugin.instance.draw_hook:
                            Plugin.instance.unhook_method(Plugin.instance.draw_hook)
                            Plugin.instance.draw_hook = None
                        if Plugin.instance.dismiss_hook:
                            Plugin.instance.unhook_method(Plugin.instance.dismiss_hook)
                            Plugin.instance.dismiss_hook = None

            def _on_draw(param):
                 if param.thisObject.getTag() == __id__:
                    param.thisObject.drawAnimatedEmojis(param.args[0], 1)

            if Plugin.instance:
                if Plugin.instance.dismiss_hook is None:
                    Plugin.instance.dismiss_hook = Plugin.instance.hook_method(
                        ActionBarPopupWindow.getClass().getDeclaredMethod("dismiss", jboolean), 
                        self.Hook(before=_on_dimiss))

                if Plugin.instance.draw_hook is None and isinstance(current_message_cell, ChatMessageCell) and current_message_cell.animatedEmojiStack and not current_message_cell.animatedEmojiStack.holders.isEmpty():
                    Plugin.instance.draw_hook = Plugin.instance.hook_method(
                        ChatMessageCell.getClass().getDeclaredMethod("drawInternal", Canvas),
                        self.Hook(after=_on_draw))
            
        except Exception as e:
            log(e)
    
    class Hook(MethodHook):
        def __init__(self, *, before = None, after = None) -> None:
            super().__init__()
            self.before = before
            self.after = after
            
        def before_hooked_method(self, param):
            try:     
                if self.before:
                    self.before(param)
            except Exception as e:
                log(e)

        def after_hooked_method(self, param):
            try:
                if self.after:
                    self.after(param)
            except Exception as e:
                log(e)
    
    def animate(self, out: bool = False, popup: ActionBarPopupWindow | None = None, message_translation: int | None = None, bottom_menu: FrameLayout | None = None, current_chat_activity: ChatActivity | None = None, current_message_cell: ChatActionCell | ChatMessageCell | None = None, reactions_view: View | None = None, new_cell: ChatActionCell | ChatMessageCell | None = None, inner_container = None):
        try:
            radius = int(Plugin.get_radius() / 3)
            radius_dp = AndroidUtilities.dp(radius)
            speed = Plugin.get_animation_speed()
            duration = int(250 / speed) if speed > 0 else 0
            interploator = AccelerateInterpolator() if out else DecelerateInterpolator()
            alt = Plugin.use_alt_blur()
            
            if message_translation is not None and message_translation == 0:
                message_translation = None
            
            def alt_blur(enable):
                drawable = popup.getBackground()
                if enable and drawable is None and current_chat_activity is not None:
                    drawable = BitmapDrawable(AndroidUtilities.makeBlurBitmap(current_chat_activity.getContentView(), 10, int(radius / 2))).mutate()
                    drawable.setColorFilter(Color.parseColor("#35000000"), PorterDuff.Mode.DARKEN)
                    popup.setBackgroundDrawable(drawable)
                    set_cell_visibility(not out)
                    if speed != 0 and new_cell:
                        new_cell.post(RunnableFactory(lambda: set_cell_visibility(out)))
                elif not enable and drawable is not None:
                    run_on_ui_thread(lambda: popup.setBackgroundDrawable(None), duration)
                
                if speed != 0:
                    animations.append(ObjectAnimator.ofInt(drawable, "alpha", 0, 255))
               
            def set_cell_visibility(visible):
                if not new_cell or not message_translation or not isinstance(current_message_cell, ChatMessageCell):
                    return
                
                if visible:
                    current_message_cell.updateTranslation()
                else:
                    def do():
                        current_message_cell.setTranslationX(current_message_cell.getTranslationX() + display_width * 2)
                    
                    if alt: 
                        do()
                    else:        
                        new_cell.post(RunnableFactory(do))
               
            if speed == 0:  
                set_cell_visibility(out)       
                if not alt:
                    apply_blur(current_chat_activity.getContentView(), radius_dp if not out else 0)
                else:
                    alt_blur(not out)
            else:
                animations = []         
                
                if not out:
                    set_cell_visibility(False)
                
                if current_chat_activity is not None:
                    if not alt:
                        animator = ValueAnimator.ofFloat(0.0, radius_dp)
                        animator.addUpdateListener(AnimatorUpdateListener(lambda animation, c = current_chat_activity: apply_blur(c.getContentView(), animation.getAnimatedValue())))
                        animations.append(animator)
                    else:
                        alt_blur(not out)
                
                if message_translation is not None and popup is not None:
                    c = inner_container or popup.getContentView()
                    animator = ObjectAnimator.ofFloat(c, "translationY", message_translation, 0)
                    animations.append(animator)
                
                def fade_anim(view):
                    animators = [ObjectAnimator.ofFloat(view, "scaleX", 0.3, 1),
                        ObjectAnimator.ofFloat(view, "scaleY", 0.3, 1),
                        ObjectAnimator.ofFloat(view, "alpha", 0 if out else 0.5, 1)
                    ]
                    animations.extend(animators)
                
                if bottom_menu is not None:
                    bottom_menu.setPivotY(0)
                    bottom_menu.setPivotX(bottom_menu.getMeasuredWidth() / 2)
                    fade_anim(bottom_menu)

                if reactions_view is not None:
                    reactions_view.setPivotY(reactions_view.getMeasuredHeight())
                    reactions_view.setPivotX(reactions_view.getMeasuredWidth() / 2)
                    fade_anim(reactions_view)
                
                if len(animations) > 0:
                    set = AnimatorSet()
                    set.playTogether(*animations)
                    set.setDuration(duration)
                    set.setInterpolator(interploator)
                    if not out:
                        set.start()
                    else:
                        set.reverse()
                    
                    if new_cell is not None and message_translation is not None and isinstance(current_message_cell, ChatMessageCell):
                        if out:
                            run_on_ui_thread(lambda: set_cell_visibility(True), max(0, duration - self.cell_stopwatch.pop_int() - 50))
                            def on_end():
                                recycler = current_chat_activity.getChatListView()
                                position = recycler.getChildAdapterPosition(current_message_cell)
                                if position >= 0:
                                    get_private_field(current_chat_activity, "chatAdapter").notifyItemChanged(position)
                            set.addListener(AnimatorListener(lambda *_: on_end()))
                        else:
                            self.cell_stopwatch.start()
                            new_cell.post(RunnableFactory(lambda: self.cell_stopwatch.stop()))
                    else:
                        self.cell_stopwatch.reset()
                    return set
            return None
        except Exception as e:
            log(e)
            return None
    
    @staticmethod
    def _copy_message_cell(cell: ChatMessageCell | ChatActionCell | None):
        if isinstance(cell, ChatMessageCell):
            new_cell = ChatMessageCell(
                ctx(),
                cell.currentAccount)
            cell.copyParamsTo(new_cell)
            
            set_private_field(new_cell, "isThreadPost", get_private_field(cell, "isThreadPost"))
            mobj = cell.getMessageObject()
            
            # thx @mishabotov
            if mobj.type == MessageObject.TYPE_POLL:
                poll_buttons = cell.getPollButtons()
                if poll_buttons and poll_buttons.size() > 0:
                    new_cell.firstVisiblePollButton = 0
                    new_cell.lastVisiblePollButton = poll_buttons.size() - 1
            
            new_cell.setMessageObject(
                mobj, 
                cell.getCurrentMessagesGroup(),
                cell.pinnedBottom,
                cell.pinnedTop,
                cell.firstInChat)
            
            new_cell.setDelegate(cell.getDelegate())
            new_cell.setTag(__id__)
        elif isinstance(cell, ChatActionCell):
            new_cell = ChatActionCell(
                ctx()
            )
            
            new_cell.setMessageObject(cell.getMessageObject(), True)
        else:
            new_cell = None
        return new_cell

class CreateMenuHook(MethodHook):
    def before_hooked_method(self, param):
        global current_chat_activity, current_message_cell
        current_chat_activity = param.thisObject
        current_message_cell = param.args[0]
        touch_stopwatch.start()

class AnimatorUpdateListener(dynamic_proxy(ValueAnimator.AnimatorUpdateListener)):
    def __init__(self, fn: Callable[[ValueAnimator], None]):
        super().__init__()
        self.fn = fn
        
    def onAnimationUpdate(self, animation):
        self.fn(animation)

class OnPopupDismiss(dynamic_proxy(PopupWindow.OnDismissListener)):
    def __init__(self, fn: Callable[[], None]):
        super().__init__()
        self.fn = fn
    
    def onDismiss(self):
        self.fn()

class RunnableFactory(dynamic_proxy(Runnable)):
    def __init__(self, fn: Callable):
        super().__init__()
        self.fn = fn
    
    def run(self):
        self.fn()

class AnimatorListener(dynamic_proxy(Animator.AnimatorListener)):
    def __init__(self, on_end: Callable):
        super().__init__()
        self.on_end = on_end
        
    def onAnimationEnd(self, *a):
        self.on_end(*a)

class OnTouchListener(dynamic_proxy(View.OnTouchListener)):
    def __init__(self, on_touch: Callable):
        super().__init__()
        self.on_touch = on_touch
    
    def onTouch(self, view, event):
        result = self.on_touch(view, event)
        if not isinstance(result, bool):
            return True
        return result

class AndroidUtils:
    @staticmethod
    def get_location_on_screen(view) -> Tuple[int, int]:
        coords = view.getLocationOnScreen()
        return coords[0], coords[1] 
    
    