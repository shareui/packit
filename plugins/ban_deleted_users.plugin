__id__ = "user_manager"
__name__ = "Управление участниками"
__description__ = "Плагин для управления участниками чатов/каналов с быстрым доступом через меню чата и команду .bandel.\n\nДоступные действия:\n• Удалить удалённые аккаунты\n• Удалить ботов\n• Удалить неактивных пользователей\n• Удалить онлайн пользователей\n• Удалить оффлайн пользователей\n• Удалить новых пользователей (рейды)\n\nИспользуйте меню (3 точки) в чате для быстрого доступа или команду .bandel."
__author__ = "Raitorinkus"
__version__ = "2.3.0"
__icon__ = "RTnKs/4"
__min_version__ = "11.12.0"

import threading
import time
import traceback
import re
from typing import Any, List, Dict, Set, Optional
from datetime import datetime, timedelta

from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from client_utils import send_message, send_request, get_messages_controller, get_last_fragment
from ui.settings import Header, Input, Switch, Divider, Text
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import LocaleController, ChatObject, ApplicationLoader, UserConfig, MessagesController
from java.util import ArrayList

class UserManagerPlugin(BasePlugin):
    """
    Оптимизированный плагин для управления участниками чатов/каналов
    """

    def __init__(self):
        super().__init__()
        self._chat_menu_items = {}
        self._current_operation = None
        self._operation_lock = threading.Lock()
        self._current_language = "ru"

    def on_plugin_load(self):
        """Вызывается при загрузке плагина."""
        self.log("Плагин User Manager загружен")
        self._detect_language()
        self._add_chat_menu_items()

    def on_plugin_unload(self):
        """Вызывается при выгрузке плагина."""
        self.log("Плагин User Manager выгружен")
        self._remove_chat_menu_items()

    def _detect_language(self):
        """Определяет язык системы"""
        try:
            locale = LocaleController.getInstance().getCurrentLocale()
            language = locale.getLanguage().lower()
            if language.startswith('ru'):
                self._current_language = "ru"
            else:
                self._current_language = "en"
            self.log(f"Определен язык: {self._current_language}")
        except:
            self._current_language = "ru"

    def get_localized_string(self, key, **kwargs):
        """Возвращает локализованную строку"""
        strings = {
            "ru": {
                # Основные сообщения
                "operation_cancelled": "Операция отменена",
                "chat_info_error": "Не удалось получить информацию о чате",
                "already_running": "Операция уже выполняется...",
                "no_rights": "Недостаточно прав для удаления участников",
                "channel_data_error": "Не удалось получить данные канала",
                "api_error": "Ошибка API: {}",
                "no_users_to_delete": "Участников для удаления не найдено",
                "start_deletion": "Начинаем удаление {} участников...",
                "deleted_count": "Удалено {}/{} участников...",
                "success_deletion": "Успешно удалено {}/{} участников",
                
                # Названия фильтров для подтверждения (правильные формы)
                "confirm_deleted": "удалённые аккаунты",
                "confirm_bots": "ботов", 
                "confirm_inactive": "неактивных пользователей",
                "confirm_online": "онлайн пользователей",
                "confirm_offline": "оффлайн пользователей",
                "confirm_raid": "новых пользователей (рейд)",
                
                # Подтверждения
                "confirm_title": "Подтверждение",
                "confirm_delete": "Вы уверены, что хотите удалить {}? Это действие необратимо.",
                "confirm_button_delete": "Удалить",
                "confirm_button_cancel": "Отмена",
                
                # Время
                "minute_singular": "минуту",
                "minute_dual": "минуты", 
                "minute_plural": "минут",
                "hour_singular": "час",
                "hour_dual": "часа",
                "hour_plural": "часов",
                "and": "и",
                
                # Команда
                "command_help_title": "Использование команды {}",
                "command_help_filters": "Доступные фильтры:",
                "command_help_examples": "Примеры:",
                "command_help_all": "все основные фильтры",
                
                # Меню
                "menu_deleted": "Удалить удалённые",
                "menu_bots": "Удалить ботов",
                "menu_inactive": "Удалить неактивных", 
                "menu_online": "Удалить онлайн",
                "menu_offline": "Удалить оффлайн",
                "menu_raid": "Удалить рейд",
                
                # Настройки
                "settings_command": "Команда для удаления",
                "settings_command_desc": "Основная команда для удаления участников. Можно изменить на любую другую.",
                "settings_confirm": "Подтверждать перед удалением",
                "settings_confirm_desc": "Показывать диалог подтверждения перед удалением участников",
                "settings_filters": "Фильтры участников",
                "settings_deleted": "Удалённые аккаунты",
                "settings_deleted_desc": "Включить фильтр удалённых аккаунтов",
                "settings_bots": "Боты",
                "settings_bots_desc": "Включить фильтр ботов",
                "settings_inactive": "Неактивные пользователи", 
                "settings_inactive_desc": "Включить фильтр неактивных пользователей",
                "settings_online": "Онлайн пользователи",
                "settings_online_desc": "Включить фильтр онлайн пользователей", 
                "settings_offline": "Оффлайн пользователи",
                "settings_offline_desc": "Включить фильтр оффлайн пользователей",
                "settings_raid": "Новые пользователи (рейды)",
                "settings_raid_desc": "Включить фильтр новых пользователей",
                "settings_params": "Параметры фильтров",
                "settings_inactive_days": "Дней неактивности", 
                "settings_inactive_days_desc": "Сколько дней пользователь должен быть неактивен",
                "settings_raid_time": "Время для рейда",
                "settings_raid_time_desc": "Формат: 1m (1 минута) - 24h (24 часа). Примеры: 30m, 2h, 1h30m",
                "settings_exclusions": "Исключения",
                "settings_exclude_usernames": "Имена пользователей",
                "settings_exclude_usernames_desc": "Регулярное выражение, например: admin|bot",
                "settings_exclude_user_ids": "ID пользователей", 
                "settings_exclude_user_ids_desc": "Список ID через запятую",
                "settings_exclude_nicknames": "Отображаемые имена",
                "settings_exclude_nicknames_desc": "Регулярное выражение для имени",
                "settings_guide": "Инструкция по использованию",
            },
            "en": {
                # Основные сообщения
                "operation_cancelled": "Operation cancelled",
                "chat_info_error": "Failed to get chat information", 
                "already_running": "Operation already in progress...",
                "no_rights": "Not enough rights to delete participants",
                "channel_data_error": "Failed to get channel data",
                "api_error": "API error: {}",
                "no_users_to_delete": "No participants found to delete",
                "start_deletion": "Starting deletion of {} participants...",
                "deleted_count": "Deleted {}/{} participants...",
                "success_deletion": "Successfully deleted {}/{} participants",
                
                # Названия фильтров для подтверждения
                "confirm_deleted": "deleted accounts",
                "confirm_bots": "bots",
                "confirm_inactive": "inactive users",
                "confirm_online": "online users", 
                "confirm_offline": "offline users",
                "confirm_raid": "new users (raid)",
                
                # Подтверждения
                "confirm_title": "Confirmation",
                "confirm_delete": "Are you sure you want to delete {}? This action is irreversible.",
                "confirm_button_delete": "Delete", 
                "confirm_button_cancel": "Cancel",
                
                # Время
                "minute_singular": "minute",
                "minute_dual": "minutes",
                "minute_plural": "minutes",
                "hour_singular": "hour",
                "hour_dual": "hours", 
                "hour_plural": "hours",
                "and": "and",
                
                # Команда
                "command_help_title": "Usage of command {}",
                "command_help_filters": "Available filters:",
                "command_help_examples": "Examples:", 
                "command_help_all": "all main filters",
                
                # Меню
                "menu_deleted": "Delete deleted",
                "menu_bots": "Delete bots",
                "menu_inactive": "Delete inactive",
                "menu_online": "Delete online", 
                "menu_offline": "Delete offline",
                "menu_raid": "Delete raid",
                
                # Настройки
                "settings_command": "Delete command",
                "settings_command_desc": "Main command for deleting participants. Can be changed to any other.",
                "settings_confirm": "Confirm before deletion", 
                "settings_confirm_desc": "Show confirmation dialog before deleting participants",
                "settings_filters": "Participant filters",
                "settings_deleted": "Deleted accounts",
                "settings_deleted_desc": "Enable deleted accounts filter",
                "settings_bots": "Bots",
                "settings_bots_desc": "Enable bots filter", 
                "settings_inactive": "Inactive users",
                "settings_inactive_desc": "Enable inactive users filter",
                "settings_online": "Online users",
                "settings_online_desc": "Enable online users filter",
                "settings_offline": "Offline users",
                "settings_offline_desc": "Enable offline users filter", 
                "settings_raid": "New users (raids)",
                "settings_raid_desc": "Enable new users filter",
                "settings_params": "Filter parameters",
                "settings_inactive_days": "Inactivity days",
                "settings_inactive_days_desc": "How many days user should be inactive",
                "settings_raid_time": "Time for raid", 
                "settings_raid_time_desc": "Format: 1m (1 minute) - 24h (24 hours). Examples: 30m, 2h, 1h30m",
                "settings_exclusions": "Exclusions",
                "settings_exclude_usernames": "Usernames",
                "settings_exclude_usernames_desc": "Regular expression, e.g.: admin|bot",
                "settings_exclude_user_ids": "User IDs", 
                "settings_exclude_user_ids_desc": "List of IDs separated by commas",
                "settings_exclude_nicknames": "Display names", 
                "settings_exclude_nicknames_desc": "Regular expression for name",
                "settings_guide": "Usage guide",
            }
        }
        
        lang_strings = strings.get(self._current_language, strings["ru"])
        text = lang_strings.get(key, key)
        
        # Заменяем параметры если есть
        if kwargs:
            try:
                text = text.format(**kwargs)
            except:
                pass
                
        return text

    def _format_time_duration(self, minutes: int) -> str:
        """Форматирует время в читаемый вид с правильными формами слов"""
        if minutes < 60:
            return self._format_minutes(minutes)
        else:
            hours = minutes // 60
            mins = minutes % 60
            
            hours_str = self._format_hours(hours)
            
            if mins == 0:
                return hours_str
            else:
                mins_str = self._format_minutes(mins)
                return f"{hours_str} {self.get_localized_string('and')} {mins_str}"

    def _format_minutes(self, minutes: int) -> str:
        """Форматирует минуты с правильными формами"""
        if self._current_language == "ru":
            if minutes == 1:
                return f"1 {self.get_localized_string('minute_singular')}"
            elif 2 <= minutes <= 4:
                return f"{minutes} {self.get_localized_string('minute_dual')}"
            else:
                return f"{minutes} {self.get_localized_string('minute_plural')}"
        else:
            if minutes == 1:
                return f"1 {self.get_localized_string('minute_singular')}"
            else:
                return f"{minutes} {self.get_localized_string('minute_plural')}"

    def _format_hours(self, hours: int) -> str:
        """Форматирует часы с правильными формами"""
        if self._current_language == "ru":
            if hours == 1:
                return f"1 {self.get_localized_string('hour_singular')}"
            elif 2 <= hours <= 4:
                return f"{hours} {self.get_localized_string('hour_dual')}"
            else:
                return f"{hours} {self.get_localized_string('hour_plural')}"
        else:
            if hours == 1:
                return f"1 {self.get_localized_string('hour_singular')}"
            else:
                return f"{hours} {self.get_localized_string('hour_plural')}"

    def on_send_message_hook(self, account, params) -> HookStrategy:
        """Обработчик отправки сообщений для команды .bandel"""
        try:
            message = params.message
            if not message or not isinstance(message, str):
                return HookStrategy.CONTINUE

            text = message.strip()
            command = self.get_setting("command_name", ".bandel").strip()
            
            if not command:
                command = ".bandel"
                
            # Проверяем, начинается ли сообщение с команды
            if not text.startswith(command):
                return HookStrategy.CONTINUE

            # Отменяем отправку сообщения с командой
            # Получаем аргументы команды
            args_text = text[len(command):].strip()
            args = args_text.split() if args_text else []
            
            # Обрабатываем команду в отдельном потоке
            def process_command():
                self._process_bandel_command(params.dialog_id, args)
            
            threading.Thread(target=process_command, daemon=True).start()
            
            return HookStrategy.CANCEL
            
        except Exception as e:
            self.log(f"Ошибка обработки команды: {e}")
            return HookStrategy.CONTINUE

    def _process_bandel_command(self, dialog_id: int, args: List[str]):
        """Обрабатывает команду .bandel с аргументами"""
        try:
            if not dialog_id:
                BulletinHelper.show_error(self.get_localized_string("chat_info_error"))
                return
                
            chat = get_messages_controller().getChat(abs(dialog_id))
            if not chat:
                BulletinHelper.show_error(self.get_localized_string("chat_info_error"))
                return
                
            # Проверяем права администратора
            if not self._check_admin_rights_directly(chat):
                BulletinHelper.show_error(self.get_localized_string("no_rights"))
                return
            
            # Если нет аргументов, показываем справку
            if not args:
                self._show_command_help(dialog_id)
                return
                
            # Парсим аргументы
            filters = self._parse_command_args(args)
            if not filters:
                self._show_command_help(dialog_id)
                return
                
            # Показываем подтверждение и запускаем удаление
            def start_deletion():
                self._current_operation = "command"
                threading.Thread(
                    target=self._process_delete_command,
                    args=(abs(dialog_id), "", {}, filters),
                    daemon=True
                ).start()
                
            filter_names = self._get_filter_display_names(filters)
            filter_text = ", ".join(filter_names)
            
            if not self.get_setting("confirm_before_delete", True):
                start_deletion()
            else:
                self._show_command_confirmation(filter_text, start_deletion)
                
        except Exception as e:
            self.log(f"Ошибка обработки команды bandel: {e}")
            BulletinHelper.show_error(self.get_localized_string("api_error", error=str(e)))

    def _parse_command_args(self, args: List[str]) -> Dict[str, bool]:
        """Парсит аргументы команды в фильтры"""
        filters = {}
        arg_mapping = {
            'deleted': 'deleted',
            'del': 'deleted',
            'd': 'deleted',
            
            'bots': 'bots', 
            'bot': 'bots',
            'b': 'bots',
            
            'inactive': 'inactive',
            'inact': 'inactive',
            'i': 'inactive',
            
            'online': 'online',
            'on': 'online',
            'o': 'online',
            
            'offline': 'offline',
            'off': 'offline',
            'f': 'offline',
            
            'raid': 'raid',
            'new': 'raid',
            'r': 'raid',
            
            'all': 'all'
        }
        
        for arg in args:
            arg_lower = arg.lower().strip()
            if arg_lower in arg_mapping:
                filter_key = arg_mapping[arg_lower]
                filters[filter_key] = True
                
        # Если указан all, включаем все основные фильтры
        if 'all' in filters:
            filters = {
                'deleted': True,
                'bots': True, 
                'inactive': True,
                'online': False,
                'offline': False,
                'raid': True
            }
            
        return filters

    def _get_filter_display_names(self, filters: Dict[str, bool]) -> List[str]:
        """Возвращает читаемые названия фильтров"""
        names = {
            'deleted': self.get_localized_string("confirm_deleted"),
            'bots': self.get_localized_string("confirm_bots"),
            'inactive': self.get_localized_string("confirm_inactive"), 
            'online': self.get_localized_string("confirm_online"),
            'offline': self.get_localized_string("confirm_offline"),
            'raid': self.get_localized_string("confirm_raid")
        }
        
        result = []
        for filter_key, enabled in filters.items():
            if enabled and filter_key in names:
                result.append(names[filter_key])
                
        return result

    def _show_command_help(self, dialog_id: int):
        """Показывает справку по команде"""
        command = self.get_setting("command_name", ".bandel").strip()
        if not command:
            command = ".bandel"
            
        help_text = f"""
{self.get_localized_string('command_help_title', command=command)}

{self.get_localized_string('command_help_filters')}
deleted - {self.get_localized_string('confirm_deleted')}
bots - {self.get_localized_string('confirm_bots')}  
inactive - {self.get_localized_string('confirm_inactive')}
online - {self.get_localized_string('confirm_online')}
offline - {self.get_localized_string('confirm_offline')}
raid - {self.get_localized_string('confirm_raid')}
all - {self.get_localized_string('command_help_all')}

{self.get_localized_string('command_help_examples')}
{command} deleted - {self.get_localized_string('menu_deleted').lower()}
{command} bots raid - {self.get_localized_string('menu_bots').lower()} {self.get_localized_string('and')} {self.get_localized_string('menu_raid').lower()}
{command} all - {self.get_localized_string('command_help_all')}

Фильтры и исключения можно настроить в настройках плагина
        """
        
        send_message(help_text.strip(), dialog_id)

    def _show_command_confirmation(self, filter_text: str, callback):
        """Показывает подтверждение для команды"""
        def on_confirm(dialog, which):
            callback()
            
        def on_cancel(dialog, which):
            BulletinHelper.show_info(self.get_localized_string("operation_cancelled"))
            
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(self.get_localized_string("confirm_title"))
        builder.set_message(self.get_localized_string("confirm_delete", filters=filter_text))
        builder.set_positive_button(self.get_localized_string("confirm_button_delete"), on_confirm)
        builder.set_negative_button(self.get_localized_string("confirm_button_cancel"), on_cancel)
        builder.set_cancelable(True)
        builder.show()

    def create_settings(self):
        """Создаёт интерфейс настроек плагина."""
        settings = [
            Header(self.get_localized_string("settings_command")),
            Input(
                key="command_name", 
                text=self.get_localized_string("settings_command"), 
                default=".bandel", 
                icon="msg_cmd",
                subtext=self.get_localized_string("settings_command_desc")
            ),
            
            Header(self.get_localized_string("settings_confirm")),
            Switch(
                key="confirm_before_delete", 
                text=self.get_localized_string("settings_confirm"), 
                default=True, 
                icon="msg_warning",
                subtext=self.get_localized_string("settings_confirm_desc")
            ),
            
            Header(self.get_localized_string("settings_filters")),
            Switch(
                key="filter_deleted", 
                text=self.get_localized_string("settings_deleted"), 
                default=True, 
                icon="msg_user_remove",
                subtext=self.get_localized_string("settings_deleted_desc")
            ),
            Switch(
                key="filter_bots", 
                text=self.get_localized_string("settings_bots"), 
                default=False, 
                icon="msg_bots_solar",
                subtext=self.get_localized_string("settings_bots_desc")
            ),
            Switch(
                key="filter_inactive", 
                text=self.get_localized_string("settings_inactive"), 
                default=False, 
                icon="msg_autodelete_1m_solar",
                subtext=self.get_localized_string("settings_inactive_desc")
            ),
            Switch(
                key="filter_online", 
                text=self.get_localized_string("settings_online"), 
                default=False, 
                icon="msg_online",
                subtext=self.get_localized_string("settings_online_desc")
            ),
            Switch(
                key="filter_offline", 
                text=self.get_localized_string("settings_offline"), 
                default=False, 
                icon="msg_contacts_solar",
                subtext=self.get_localized_string("settings_offline_desc")
            ),
            Switch(
                key="filter_raid", 
                text=self.get_localized_string("settings_raid"), 
                default=False, 
                icon="msg_folders_groups_solar",
                subtext=self.get_localized_string("settings_raid_desc")
            ),
            
            Header(self.get_localized_string("settings_params")),
            Input(
                key="inactive_days", 
                text=self.get_localized_string("settings_inactive_days"), 
                default="30", 
                subtext=self.get_localized_string("settings_inactive_days_desc")
            ),
            Input(
                key="raid_time", 
                text=self.get_localized_string("settings_raid_time"), 
                default="1h", 
                subtext=self.get_localized_string("settings_raid_time_desc")
            ),
            
            Header(self.get_localized_string("settings_exclusions")),
            Input(
                key="exclude_usernames", 
                text=self.get_localized_string("settings_exclude_usernames"), 
                default="",
                subtext=self.get_localized_string("settings_exclude_usernames_desc")
            ),
            Input(
                key="exclude_user_ids", 
                text=self.get_localized_string("settings_exclude_user_ids"), 
                default="",
                subtext=self.get_localized_string("settings_exclude_user_ids_desc")
            ),
            Input(
                key="exclude_nicknames", 
                text=self.get_localized_string("settings_exclude_nicknames"), 
                default="",
                subtext=self.get_localized_string("settings_exclude_nicknames_desc")
            ),
            
            Text(
                text=self.get_localized_string("settings_guide"),
                icon="msg_help",
                on_click=self._show_plugin_guide
            )
        ]
        
        return settings

    def _add_chat_menu_items(self):
        """Добавляет пункты меню в чат."""
        menu_items = [
            ('deleted', self.get_localized_string("menu_deleted"), "msg_user_remove", self._on_delete_deleted_accounts),
            ('bots', self.get_localized_string("menu_bots"), "msg_bots_solar", self._on_delete_bots),
            ('inactive', self.get_localized_string("menu_inactive"), "msg_autodelete_1m_solar", self._on_delete_inactive_users),
            ('online', self.get_localized_string("menu_online"), "msg_online", self._on_delete_online_users),
            ('offline', self.get_localized_string("menu_offline"), "msg_contacts_solar", self._on_delete_offline_users),
            ('raid', self.get_localized_string("menu_raid"), "msg_folders_groups_solar", self._on_delete_raid_users)
        ]
        
        for item_id, text, icon, handler in menu_items:
            try:
                self._chat_menu_items[item_id] = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text=text,
                    icon=icon,
                    priority=10 + len(self._chat_menu_items),
                    on_click=handler
                ))
            except Exception as e:
                self.log(f"Ошибка добавления пункта меню {item_id}: {e}")

    def _remove_chat_menu_items(self):
        """Удаляет пункты меню из чата."""
        for menu_item in self._chat_menu_items.values():
            try:
                self.remove_menu_item(menu_item)
            except Exception as e:
                self.log(f"Ошибка удаления пункта меню: {e}")
        self._chat_menu_items.clear()

    def _get_current_chat_info(self):
        """Получает информацию о текущем чате."""
        try:
            fragment = get_last_fragment()
            if not fragment:
                return None, None
            
            dialog_id = fragment.getDialogId()
            if not dialog_id:
                return None, None
                
            chat = get_messages_controller().getChat(abs(dialog_id))
            return dialog_id, chat
        except Exception as e:
            self.log(f"Ошибка получения информации о чате: {e}")
            return None, None

    def _show_confirmation_dialog(self, filter_type: str, callback):
        """Показывает диалог подтверждения с корректными текстами."""
        if not self.get_setting("confirm_before_delete", True):
            callback()
            return
            
        filter_names = {
            'deleted': self.get_localized_string("confirm_deleted"),
            'bots': self.get_localized_string("confirm_bots"),
            'offline': self.get_localized_string("confirm_offline"),
            'online': self.get_localized_string("confirm_online"),
            'inactive': self.get_localized_string("confirm_inactive"),
            'raid': self.get_localized_string("confirm_raid")
        }
        
        filter_name = filter_names.get(filter_type, filter_type)
        
        # Специальное сообщение для рейда с временем
        if filter_type == 'raid':
            raid_time_str = self.get_setting("raid_time", "1h")
            raid_minutes = self._parse_time_string(raid_time_str)
            time_display = self._format_time_duration(raid_minutes)
            
            if self._current_language == "ru":
                filter_name = f"{self.get_localized_string('confirm_raid')}, зашедших за последние {time_display}"
            else:
                filter_name = f"{self.get_localized_string('confirm_raid')} who joined in the last {time_display}"
        
        def on_confirm(dialog, which):
            callback()
            
        def on_cancel(dialog, which):
            BulletinHelper.show_info(self.get_localized_string("operation_cancelled"))
            
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(self.get_localized_string("confirm_title"))
        builder.set_message(self.get_localized_string("confirm_delete", filters=filter_name))
        builder.set_positive_button(self.get_localized_string("confirm_button_delete"), on_confirm)
        builder.set_negative_button(self.get_localized_string("confirm_button_cancel"), on_cancel)
        builder.set_cancelable(True)
        builder.show()

    # Обработчики меню
    def _on_delete_deleted_accounts(self, context):
        self._show_confirmation_dialog('deleted', 
            lambda: self._start_deletion_process('deleted'))

    def _on_delete_bots(self, context):
        self._show_confirmation_dialog('bots',
            lambda: self._start_deletion_process('bots'))

    def _on_delete_inactive_users(self, context):
        self._show_confirmation_dialog('inactive',
            lambda: self._start_deletion_process('inactive'))

    def _on_delete_online_users(self, context):
        self._show_confirmation_dialog('online',
            lambda: self._start_deletion_process('online'))

    def _on_delete_offline_users(self, context):
        self._show_confirmation_dialog('offline', 
            lambda: self._start_deletion_process('offline'))

    def _on_delete_raid_users(self, context):
        self._show_confirmation_dialog('raid',
            lambda: self._start_deletion_process('raid'))

    def _start_deletion_process(self, filter_type: str):
        """Запускает процесс удаления."""
        dialog_id, chat = self._get_current_chat_info()
        if not dialog_id or not chat:
            BulletinHelper.show_error(self.get_localized_string("chat_info_error"))
            return
            
        if self._current_operation:
            BulletinHelper.show_info(self.get_localized_string("already_running"))
            return
            
        self._current_operation = filter_type
        threading.Thread(
            target=self._process_chat_deletion,
            args=(abs(dialog_id), filter_type),
            daemon=True
        ).start()

    def _process_chat_deletion(self, peer_id: int, filter_type: str):
        """Обрабатывает удаление из контекста чата."""
        try:
            self._process_delete_command(peer_id, filter_type, {}, {})
        except Exception as e:
            self.log(f"Ошибка в процессе удаления: {e}")
            BulletinHelper.show_error(self.get_localized_string("api_error", error=str(e)))
        finally:
            self._current_operation = None

    def _process_delete_command(self, peer_id: int, filter_arg: str, exclusions: Dict, command_filters: Dict = None):
        """Основной процесс удаления участников."""
        try:
            chat = get_messages_controller().getChat(abs(peer_id))
            if not chat:
                BulletinHelper.show_error(self.get_localized_string("chat_info_error"))
                return
                
            # Проверяем права администратора перед началом
            if not self._check_admin_rights_directly(chat):
                BulletinHelper.show_error(self.get_localized_string("no_rights"))
                return
                
            # Если переданы фильтры из команды, используем их
            if command_filters is not None:
                self._fetch_chat_participants(peer_id, chat, "", exclusions, command_filters)
            else:
                self._fetch_chat_participants(peer_id, chat, filter_arg, exclusions, {})
                
        except Exception as e:
            self.log(f"Ошибка обработки команды: {e}")
            BulletinHelper.show_error(self.get_localized_string("api_error", error=str(e)))

    def _fetch_chat_participants(self, peer_id: int, chat: TLRPC.Chat, filter_arg: str, exclusions: Dict, command_filters: Dict):
        """Собирает участников чата."""
        if ChatObject.isChannel(chat):
            self._fetch_channel_participants(peer_id, chat, filter_arg, exclusions, command_filters)
        else:
            self._fetch_group_participants(peer_id, chat, filter_arg, exclusions, command_filters)

    def _fetch_channel_participants(self, peer_id: int, chat: TLRPC.Chat, filter_arg: str, exclusions: Dict, command_filters: Dict):
        """Собирает участников канала."""
        input_channel = get_messages_controller().getInputChannel(chat.id)
        if not input_channel:
            BulletinHelper.show_error(self.get_localized_string("channel_data_error"))
            return
            
        self._fetch_channel_recursive(peer_id, input_channel, filter_arg, exclusions, command_filters, 0, {}, [])

    def _fetch_channel_recursive(self, peer_id: int, input_channel: TLRPC.InputChannel, filter_arg: str, 
                               exclusions: Dict, command_filters: Dict, offset: int, all_users: Dict, all_participants: List):
        """Рекурсивно собирает участников канала."""
        if offset >= 10000:  # Лимит для безопасности
            self._process_participants(peer_id, filter_arg, exclusions, command_filters, None, all_users, all_participants)
            return
            
        req = TLRPC.TL_channels_getParticipants()
        req.channel = input_channel
        req.filter = TLRPC.TL_channelParticipantsRecent()  # Получаем всех участников
        req.offset = offset
        req.limit = 200
        req.hash = 0
        
        def callback(response, error):
            if error:
                self.log(f"Ошибка API канала: {error.text}")
                BulletinHelper.show_error(self.get_localized_string("api_error", error=error.text))
                return
                
            if response and hasattr(response, 'users'):
                all_users.update({u.id: u for u in response.users.toArray()})
                
            participants = []
            if response and hasattr(response, 'participants'):
                participants = list(response.participants.toArray())
                all_participants.extend(participants)
                
            if len(participants) >= 199:
                self._fetch_channel_recursive(peer_id, input_channel, filter_arg, exclusions, command_filters,
                                            offset + len(participants), all_users, all_participants)
            else:
                chat = get_messages_controller().getChat(abs(peer_id))
                self._process_participants(peer_id, filter_arg, exclusions, command_filters, chat, all_users, all_participants)
        
        send_request(req, callback)

    def _fetch_group_participants(self, peer_id: int, chat: TLRPC.Chat, filter_arg: str, exclusions: Dict, command_filters: Dict):
        """Собирает участников группы."""
        req = TLRPC.TL_messages_getFullChat()
        req.chat_id = chat.id
        
        def callback(response, error):
            if error:
                self.log(f"Ошибка API группы: {error.text}")
                BulletinHelper.show_error(self.get_localized_string("api_error", error=error.text))
                return
                
            all_users = {}
            all_participants = []
            
            if response and hasattr(response, 'users'):
                all_users.update({u.id: u for u in response.users.toArray()})
                
            if response and hasattr(response, 'full_chat') and hasattr(response.full_chat, 'participants'):
                all_participants = list(response.full_chat.participants.participants.toArray())
                
            self._process_participants(peer_id, filter_arg, exclusions, command_filters, chat, all_users, all_participants)
        
        send_request(req, callback)

    def _process_participants(self, peer_id: int, filter_arg: str, exclusions: Dict, command_filters: Dict,
                            chat: TLRPC.Chat, all_users: Dict, all_participants: List):
        """Обрабатывает собранных участников."""
        try:
            # Проверяем права ещё раз на всякий случай
            if not self._check_admin_rights_directly(chat):
                BulletinHelper.show_error(self.get_localized_string("no_rights"))
                return
                
            # Фильтруем пользователей
            users_to_delete = self._filter_users(all_participants, all_users, filter_arg, exclusions, command_filters)
            
            if not users_to_delete:
                BulletinHelper.show_info(self.get_localized_string("no_users_to_delete"))
                return
                
            # Выполняем удаление
            self._delete_users(chat, users_to_delete)
            
        except Exception as e:
            self.log(f"Ошибка обработки участников: {e}")
            BulletinHelper.show_error(self.get_localized_string("api_error", error=str(e)))

    def _filter_users(self, participants: List, all_users: Dict, filter_arg: str, exclusions: Dict, command_filters: Dict) -> List[TLRPC.User]:
        """Фильтрует пользователей для удаления."""
        # Определяем активные фильтры
        if command_filters:
            active_filters = command_filters
        else:
            active_filters = self._get_active_filters(filter_arg)
            
        my_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
        filtered_users = []
        
        for participant in participants:
            user_id = self._get_user_id_from_participant(participant)
            if not user_id or user_id == my_id:
                continue
                
            user = all_users.get(user_id)
            if not user:
                continue
                
            if self._should_delete_user(user, participant, active_filters) and not self._is_excluded(user, exclusions):
                filtered_users.append(user)
                
        return filtered_users

    def _get_user_id_from_participant(self, participant) -> Optional[int]:
        """Извлекает ID пользователя из участника."""
        if hasattr(participant, 'user_id'):
            return participant.user_id
        elif hasattr(participant, 'peer') and hasattr(participant.peer, 'user_id'):
            return participant.peer.user_id
        return None

    def _get_active_filters(self, filter_arg: str) -> Dict[str, bool]:
        """Определяет активные фильтры из настроек."""
        if filter_arg:
            return {filter_arg.lower(): True}
            
        active_filters = {}
        filter_mapping = {
            'filter_deleted': 'deleted',
            'filter_bots': 'bots', 
            'filter_online': 'online',
            'filter_offline': 'offline',
            'filter_inactive': 'inactive',
            'filter_raid': 'raid'
        }
        
        for setting_key, filter_name in filter_mapping.items():
            active_filters[filter_name] = self.get_setting(setting_key, False)
                
        return active_filters

    def _should_delete_user(self, user: TLRPC.User, participant: Any, active_filters: Dict[str, bool]) -> bool:
        """Определяет, должен ли пользователь быть удалён."""
        # Проверяем каждый активный фильтр
        if active_filters.get('deleted', False) and user.deleted:
            return True
        if active_filters.get('bots', False) and user.bot:
            return True
        if active_filters.get('online', False) and self._is_online(user):
            return True
        if active_filters.get('offline', False) and not self._is_online(user):
            return True
        if active_filters.get('inactive', False) and self._is_inactive(user):
            return True
        if active_filters.get('raid', False) and self._is_raid_user(participant):
            return True
            
        return False

    def _check_admin_rights_directly(self, chat: TLRPC.Chat) -> bool:
        """Прямая проверка прав администратора в чате."""
        try:
            my_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
            
            # Если мы создатель чата - всегда есть права
            if hasattr(chat, 'creator') and chat.creator:
                return True
                
            # Проверяем права администратора через MessagesController
            messages_controller = get_messages_controller()
            
            # Для каналов/супергрупп
            if ChatObject.isChannel(chat):
                # Получаем информацию о канале
                input_channel = messages_controller.getInputChannel(chat.id)
                if not input_channel:
                    return False
                    
                # Запрашиваем информацию о канале для получения прав
                req = TLRPC.TL_channels_getFullChannel()
                req.channel = input_channel
                
                result = [None]
                event = threading.Event()
                
                def callback(response, error):
                    if response and hasattr(response, 'full_chat'):
                        result[0] = response.full_chat
                    event.set()
                
                send_request(req, callback)
                event.wait(timeout=10)
                
                full_chat = result[0]
                if full_chat and hasattr(full_chat, 'admin_rights'):
                    admin_rights = full_chat.admin_rights
                    if admin_rights and hasattr(admin_rights, 'ban_users'):
                        return admin_rights.ban_users
                        
            # Для обычных групп
            else:
                # В группах проверяем через ChatObject
                return ChatObject.canUserDoAdminAction(chat, my_id)
                
            return False
            
        except Exception as e:
            self.log(f"Ошибка проверки прав администратора: {e}")
            return False

    def _is_online(self, user: TLRPC.User) -> bool:
        """Проверяет, находится ли пользователь онлайн."""
        if not user or not user.status:
            return False
            
        return isinstance(user.status, (TLRPC.TL_userStatusOnline, TLRPC.TL_userStatusRecently))

    def _is_inactive(self, user: TLRPC.User) -> bool:
        """Проверяет, является ли пользователь неактивным (по сроку)."""
        if not user or not user.status:
            return False
            
        try:
            inactive_days = int(self.get_setting("inactive_days", "30"))
        except:
            inactive_days = 30
            
        current_time = int(time.time())
        
        # Проверяем время последней активности
        if isinstance(user.status, TLRPC.TL_userStatusOffline):
            last_seen = user.status.was_online
            days_passed = (current_time - last_seen) / (24 * 3600)
            return days_passed >= inactive_days
            
        # Для других статусов, если они не онлайн
        elif not self._is_online(user):
            # Для пользователей, которые давно не были в сети
            return True
            
        return False

    def _is_raid_user(self, participant) -> bool:
        """Проверяет, является ли пользователь частью рейда (новым пользователем)."""
        raid_time_str = self.get_setting("raid_time", "1h")
        raid_minutes = self._parse_time_string(raid_time_str)
            
        # Текущее время
        current_time = int(time.time())
        
        # Время, до которого считаем пользователей новыми (в секундах)
        raid_threshold = current_time - (raid_minutes * 60)
        
        # Получаем дату вступления пользователя
        join_date = getattr(participant, 'date', 0)
        
        # Если пользователь зашёл позже порога - это рейд
        return join_date > raid_threshold

    def _is_excluded(self, user: TLRPC.User, exclusions: Dict) -> bool:
        """Проверяет, исключён ли пользователь."""
        # Проверка по имени пользователя
        exclude_usernames = self.get_setting("exclude_usernames", "").strip()
        if exclude_usernames:
            username = getattr(user, 'username', '') or ''
            if username and re.search(exclude_usernames, username, re.IGNORECASE):
                return True
                
        # Проверка по ID
        exclude_user_ids = self.get_setting("exclude_user_ids", "").strip()
        if exclude_user_ids:
            try:
                ids = [int(x.strip()) for x in exclude_user_ids.split(',') if x.strip().isdigit()]
                if user.id in ids:
                    return True
            except ValueError:
                pass
                
        # Проверка по имени
        exclude_nicknames = self.get_setting("exclude_nicknames", "").strip()
        if exclude_nicknames:
            first_name = getattr(user, 'first_name', '') or ''
            last_name = getattr(user, 'last_name', '') or ''
            full_name = f"{first_name} {last_name}".strip()
            if full_name and re.search(exclude_nicknames, full_name, re.IGNORECASE):
                return True
                
        return False

    def _delete_users(self, chat: TLRPC.Chat, users: List[TLRPC.User]):
        """Удаляет пользователей из чата."""
        total = len(users)
        if total == 0:
            return
            
        BulletinHelper.show_info(self.get_localized_string("start_deletion", total=total))
        deleted_count = 0
        is_channel = ChatObject.isChannel(chat)
        
        for i, user in enumerate(users):
            try:
                self._delete_single_user(chat, user, is_channel)
                deleted_count += 1
                
                # Обновляем прогресс каждые 10 пользователей
                if (i + 1) % 10 == 0:
                    BulletinHelper.show_info(self.get_localized_string("deleted_count", current=deleted_count, total=total))
                    
                time.sleep(0.15)  # Пауза для избежания лимитов
                
            except Exception as e:
                self.log(f"Ошибка удаления пользователя {user.id}: {e}")
                
        BulletinHelper.show_success(self.get_localized_string("success_deletion", deleted=deleted_count, total=total))

    def _delete_single_user(self, chat: TLRPC.Chat, user: TLRPC.User, is_channel: bool):
        """Удаляет одного пользователя."""
        if is_channel:
            # Для каналов/супергрупп
            req = TLRPC.TL_channels_editBanned()
            req.channel = get_messages_controller().getInputChannel(chat.id)
            req.participant = TLRPC.TL_inputPeerUser()
            req.participant.user_id = user.id
            req.participant.access_hash = getattr(user, 'access_hash', 0)
            req.banned_rights = TLRPC.TL_chatBannedRights()
            req.banned_rights.view_messages = True
            req.banned_rights.until_date = 0
        else:
            # Для обычных групп
            req = TLRPC.TL_messages_deleteChatUser()
            req.chat_id = chat.id
            req.user_id = TLRPC.TL_inputUser()
            req.user_id.user_id = user.id
            req.user_id.access_hash = getattr(user, 'access_hash', 0)
            
        send_request(req, lambda r, e: None)

    def _parse_time_string(self, time_str: str) -> int:
        """Парсит строку времени в минуты."""
        try:
            time_str = time_str.strip().lower()
            
            # Если строка пустая, возвращаем 60 минут по умолчанию
            if not time_str:
                return 60
                
            total_minutes = 0
            
            # Регулярное выражение для поиска чисел с суффиксами h и m
            pattern = r'(\d+)([hm])'
            matches = re.findall(pattern, time_str)
            
            if not matches:
                # Если нет суффиксов, пробуем распарсить как число (считаем минутами)
                try:
                    minutes = int(time_str)
                    return max(1, min(minutes, 1440))  # Ограничение 1-1440 минут
                except:
                    return 60  # Значение по умолчанию при ошибке
            
            for value, unit in matches:
                num = int(value)
                if unit == 'h':
                    total_minutes += num * 60
                elif unit == 'm':
                    total_minutes += num
            
            # Ограничиваем диапазон от 1 минуты до 24 часов (1440 минут)
            return max(1, min(total_minutes, 1440))
            
        except Exception as e:
            self.log(f"Ошибка парсинга времени: {e}")
            return 60  # Значение по умолчанию при ошибке

    def _show_plugin_guide(self, view=None):
        """Показывает инструкцию по использованию."""
        command = self.get_setting("command_name", ".bandel").strip()
        if not command:
            command = ".bandel"
            
        if self._current_language == "ru":
            title = "Управление участниками - Руководство"
            text = f"""
Быстрое управление через меню чата (3 точки):

• {self.get_localized_string("menu_deleted")} - удаляет удалённые аккаунты
• {self.get_localized_string("menu_bots")} - удаляет всех ботов  
• {self.get_localized_string("menu_inactive")} - удаляет пользователей, неактивных более N дней
• {self.get_localized_string("menu_online")} - удаляет пользователей, которые сейчас онлайн
• {self.get_localized_string("menu_offline")} - удаляет всех, кто сейчас не в сети
• {self.get_localized_string("menu_raid")} - удаляет новых пользователей (за последние N минут)

Команда {command}

Используйте команду в чате для быстрого удаления:

{command} deleted - {self.get_localized_string("menu_deleted").lower()}
{command} bots raid - {self.get_localized_string("menu_bots").lower()} {self.get_localized_string('and')} {self.get_localized_string("menu_raid").lower()}  
{command} all - все основные фильтры

Настройки фильтров:

• Дней неактивности - сколько дней пользователь должен быть неактивен
• Время для рейда - за какое время считать пользователей новыми
• Исключения - защита определённых пользователей от удаления

Система исключений:

• Имена пользователей - регулярное выражение для @username
• ID пользователей - список ID через запятую
• Отображаемые имена - регулярное выражение для имён

ВАЖНО!
- Используйте с осторожностью, действия необратимы!
- Всегда проверяйте права администратора
- Настройте исключения для защиты важных пользователей
- Перед массовым удалением сделайте тест на небольшой группе

Советы:
1. Сначала протестируйте на маленькой группе
2. Настройте исключения для администраторов и ботов
3. Используйте подтверждение перед удалением
4. Проверяйте результаты удаления
            """
        else:
            title = "User Management - Guide"
            text = f"""
Quick management via chat menu (3 dots):

• {self.get_localized_string("menu_deleted")} - deletes deleted accounts
• {self.get_localized_string("menu_bots")} - deletes all bots  
• {self.get_localized_string("menu_inactive")} - deletes users inactive for more than N days
• {self.get_localized_string("menu_online")} - deletes users who are currently online
• {self.get_localized_string("menu_offline")} - deletes all who are currently offline
• {self.get_localized_string("menu_raid")} - deletes new users (joined in last N minutes)

Command {command}

Use command in chat for quick deletion:

{command} deleted - {self.get_localized_string("menu_deleted").lower()}
{command} bots raid - {self.get_localized_string("menu_bots").lower()} {self.get_localized_string('and')} {self.get_localized_string("menu_raid").lower()}  
{command} all - all main filters

Filter settings:

• Inactivity days - how many days user should be inactive
• Raid time - for what time consider users as new
• Exclusions - protect certain users from deletion

Exclusion system:

• Usernames - regular expression for @username
• User IDs - list of IDs separated by commas
• Display names - regular expression for names

IMPORTANT!
- Use with caution, actions are irreversible!
- Always check administrator rights
- Set up exclusions to protect important users
- Test on a small group before mass deletion

Tips:
1. First test on a small group
2. Set up exclusions for administrators and bots
3. Use confirmation before deletion
4. Check deletion results
            """
        
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(title)
        builder.set_message(text.strip())
        builder.set_positive_button("OK", lambda d, w: None)
        builder.set_cancelable(True)
        builder.show()

    def log(self, message: str):
        """Логирование с префиксом плагина."""
        print(f"[UserManager] {message}")