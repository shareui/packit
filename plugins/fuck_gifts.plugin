from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from ui.settings import Switch, Header, Divider

import hashlib
import json
import os
import threading
import time
import urllib.request
import uuid

__id__ = "fuck_gifts"
__name__ = "No Gifts"
__description__ = "убирает подарки из чатов, профилей и строки ввода (сосать капитализм)\n\nесть сбор статистики mkStats"
__icon__ = "feature_plugins/1"
__version__ = "2.3"
__min_version__ = "12.1.1"
__author__ = "@feature_plugins"

# === RPC Gift Filter: Data-level blocking ===
class GiftRPCFilter:
    """Filters TLRPC objects to remove gift-related data at RPC level"""
    
    def __init__(self):
        self.gift_classes = {}
        self.filter_stats = {"tabs_removed": 0, "actions_removed": 0}
        self._init_classes()
    
    def _init_classes(self):
        """Initialize TLRPC class references - safe initialization"""
        # MessageAction gift classes
        self.gift_classes["message_action"] = []
        for class_name in [
            "org.telegram.tgnet.TLRPC$TL_messageActionGift",
            "org.telegram.tgnet.TLRPC$TL_messageActionStarGift", 
            "org.telegram.tgnet.TLRPC$TL_messageActionGiftCode",
            "org.telegram.tgnet.TLRPC$TL_messageActionStarGiftUnique",
            "org.telegram.tgnet.TLRPC$TL_messageActionStarGiftPurchaseOffer",
            "org.telegram.tgnet.TLRPC$TL_messageActionGiftStars",
            "org.telegram.tgnet.TLRPC$TL_messageActionGiftTon",
            "org.telegram.tgnet.TLRPC$TL_messageActionGiftPremium"
        ]:
            try:
                cls = find_class(class_name)
                if cls:
                    self.gift_classes["message_action"].append(cls)
            except:
                pass
        
        # ProfileTab and other classes
        for key, class_name in [
            ("profile_tab_gifts", "org.telegram.tgnet.TLRPC$TL_profileTabGifts"),
            ("user_full", "org.telegram.tgnet.TLRPC$TL_userFull"),
            ("chat_full", "org.telegram.tgnet.TLRPC$TL_channelFull"),
            ("message", "org.telegram.tgnet.TLRPC$Message"),
        ]:
            try:
                cls = find_class(class_name)
                if cls:
                    self.gift_classes[key] = cls
            except:
                pass
    
    def filter_rpc_response(self, obj):
        """Filter TLRPC response object - robust version"""
        if not obj:
            return obj
        
        try:
            # Try to get class info
            if not hasattr(obj, "getClass"):
                return obj
            
            obj_class_name = obj.getClass().getSimpleName()
            
            # Check ProfileTab - by name and class
            if "UserFull" in obj_class_name or "ChannelFull" in obj_class_name:
                self._filter_profile_tabs(obj)
            
            # Check Message - by name and class
            if "Message" in obj_class_name and not "RichText" in obj_class_name:
                self._filter_message_action(obj)
            
            # Check if it's a list/array of messages
            if isinstance(obj, (list, tuple)):
                for item in obj:
                    self.filter_rpc_response(item)
        except:
            pass
        
        return obj
    
    def _filter_profile_tabs(self, profile_obj):
        """Remove TL_profileTabGifts from all tab containers"""
        tabs_to_check = [
            ("main_tab", "main_tab"),
            ("profileTabs", "profileTabs"),
            ("tabs", "tabs"),
            ("savedTabs", "savedTabs"),
        ]
        
        for attr_name, display_name in tabs_to_check:
            try:
                if hasattr(profile_obj, attr_name):
                    tabs = getattr(profile_obj, attr_name, None)
                    if tabs:
                        self._remove_gift_tabs_from_array(tabs)
            except:
                pass
    
    def _remove_gift_tabs_from_array(self, tabs_array):
        """Remove gift tabs - handle all container types"""
        if not tabs_array:
            return
        
        try:
            array_type = str(type(tabs_array))
            
            # Handle Java collections (Vector, ArrayList, etc)
            if "Vector" in array_type or "ArrayList" in array_type or "List" in array_type:
                self._remove_from_list(tabs_array)
            # Handle Java arrays
            elif "Array" in array_type and not "SparseArray" in array_type:
                self._remove_from_array(tabs_array)
            # Handle Python lists
            elif isinstance(tabs_array, list):
                self._remove_from_python_list(tabs_array)
        except:
            pass
    
    def _remove_from_list(self, java_list):
        """Remove gifts from Java List/Vector"""
        try:
            if not hasattr(java_list, "size"):
                return
            
            size = java_list.size()
            indices_to_remove = []
            
            for i in range(size):
                try:
                    tab = java_list.get(i)
                    if self._is_gift_tab(tab):
                        indices_to_remove.append(i)
                except:
                    pass
            
            # Remove in reverse to keep indices valid
            for i in reversed(indices_to_remove):
                try:
                    java_list.remove(i)
                    self.filter_stats["tabs_removed"] += 1
                except:
                    pass
        except:
            pass
    
    def _remove_from_array(self, java_array):
        """Remove gifts from Java array"""
        try:
            # Java arrays are tricky - try to convert to list first
            if hasattr(java_array, "clone"):
                new_array = []
                for i in range(len(java_array)):
                    tab = java_array[i]
                    if not self._is_gift_tab(tab):
                        new_array.append(tab)
                # Cannot directly replace Java array, skip
        except:
            pass
    
    def _remove_from_python_list(self, py_list):
        """Remove gifts from Python list"""
        try:
            to_remove = [tab for tab in py_list if self._is_gift_tab(tab)]
            for tab in to_remove:
                py_list.remove(tab)
                self.filter_stats["tabs_removed"] += 1
        except:
            pass
    
    def _is_gift_tab(self, tab):
        """Check if a tab is a gift tab"""
        if not tab:
            return False
        
        try:
            # Direct class check
            if "profile_tab_gifts" in self.gift_classes:
                if self.gift_classes["profile_tab_gifts"]:
                    try:
                        if tab.getClass().isAssignableFrom(self.gift_classes["profile_tab_gifts"]):
                            return True
                    except:
                        pass
            
            # Name-based check
            class_name = tab.getClass().getSimpleName() if hasattr(tab, "getClass") else str(type(tab))
            if "ProfileTabGifts" in class_name or "Gifts" in class_name:
                # Double-check that it's not something else with "Gifts" in name
                if "Tab" in class_name or "profileTab" in class_name:
                    return True
        except:
            pass
        
        return False
    
    def _filter_message_action(self, message_obj):
        """Remove gift actions from Message"""
        try:
            if hasattr(message_obj, "action"):
                action = getattr(message_obj, "action", None)
                if action and self._is_gift_action(action):
                    setattr(message_obj, "action", None)
                    self.filter_stats["actions_removed"] += 1
        except:
            pass
    
    def _is_gift_action(self, action):
        """Check if action is gift action"""
        if not action:
            return False
        
        try:
            # Direct class check
            for gift_class in self.gift_classes.get("message_action", []):
                if gift_class:
                    try:
                        if action.getClass().isAssignableFrom(gift_class):
                            return True
                    except:
                        pass
            
            # Name-based check
            class_name = action.getClass().getSimpleName() if hasattr(action, "getClass") else str(type(action))
            if any(x in class_name for x in ["messageActionGift", "messageActionStarGift", "ActionGift"]):
                return True
        except:
            pass
        
        return False
    
    def get_stats(self):
        """Get filter statistics"""
        return dict(self.filter_stats)

# === mkStats: embed client start ===
MKSTATS_API_URL = os.getenv("MKSTATS_API_URL", "https://mkstats.mk69.su/api")
MKSTATS_PING_INTERVAL = int(os.getenv("MKSTATS_PING_INTERVAL", "1500"))
MKSTATS_POW_SOLVE_SECONDS = int(os.getenv("MKSTATS_POW_SOLVE_SECONDS", "6"))

def generate_user_hash(device_id: str, plugin_id: str) -> str:
    payload = f"{device_id}:{plugin_id}:mkstats:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def generate_device_fingerprint(device_id: str) -> str:
    payload = f"{device_id}:mkstats:device:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def _normalize_api_base(api_url: str) -> str:
    base = api_url.rstrip("/")
    if base.endswith("/api"):
        return f"{base}/v1"
    return base

def _post_json(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url, data=data, headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(request, timeout=10) as response:
        body = response.read().decode("utf-8")
    return json.loads(body)

def _pow_valid(challenge: str, nonce: str, difficulty: int) -> bool:
    if not challenge or not nonce or difficulty <= 0:
        return False
    prefix = "0" * max(1, int(difficulty))
    digest = hashlib.sha256(f"{challenge}:{nonce}".encode("utf-8")).hexdigest()
    return digest.startswith(prefix)

def _solve_pow(challenge: str, difficulty: int, max_seconds: int = MKSTATS_POW_SOLVE_SECONDS) -> str | None:
    difficulty = max(1, int(difficulty or 0))
    deadline = time.time() + max(1, int(max_seconds or 0))
    nonce = 0
    prefix = "0" * difficulty
    while time.time() < deadline:
        candidate = format(nonce, "x")
        digest = hashlib.sha256(f"{challenge}:{candidate}".encode("utf-8")).hexdigest()
        if digest.startswith(prefix):
            return candidate
        nonce += 1
    return None

class MkStatsCoreClient:
    def __init__(self, api_url: str, plugin_id: str, plugin_version: str, user_hash: str, device_fingerprint: str, client_version: str | None = None, client_name: str | None = None) -> None:
        self.api_base = _normalize_api_base(api_url)
        self.plugin_id = plugin_id
        self.plugin_version = plugin_version
        self.client_version = client_version
        self.client_name = client_name
        self.user_hash = user_hash
        self.device_fingerprint = device_fingerprint

    def handshake(self) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
        }
        response = _post_json(f"{self.api_base}/handshake", payload)
        token = (response or {}).get("install_token", "")
        if token:
            return response
        pow_required = bool((response or {}).get("pow_required"))
        pow_challenge = (response or {}).get("pow_challenge")
        if pow_required and pow_challenge:
            difficulty = int((response or {}).get("pow_difficulty") or 0)
            nonce = _solve_pow(pow_challenge, difficulty)
            if nonce and _pow_valid(pow_challenge, nonce, difficulty):
                payload["pow_challenge"] = pow_challenge
                payload["pow_nonce"] = nonce
                response = _post_json(f"{self.api_base}/handshake", payload)
        return response

    def send_ping(self, install_token: str, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/data", payload)

    def send_event(self, install_token: str, event: str, count: int = 1, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "event": event,
            "count": count,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/event", payload)
# === mkStats: embed client end ===


STRINGS = {
    "ru": {
        "header_settings": "Настройки скрытия подарков",
        "enable_analytics": "mkStats",
        "enable_analytics_sub": "Анонимная статистика использования",
        "hide_button_chat": "Кнопка в чате",
        "hide_button_chat_sub": "Убирает кнопку подарка из строки ввода и каналов",
        "hide_send_dialogs": "Диалоги отправки",
        "hide_send_dialogs_sub": "Блокирует диалоги отправки подарков",
        "hide_gift_messages": "Сообщения о подарках",
        "hide_gift_messages_sub": "Скрывает сообщения о полученных подарках",
        "hide_view_dialogs": "Диалоги просмотра",
        "hide_view_dialogs_sub": "Блокирует просмотр подарков",
        "hide_profile_section": "Раздел в профиле",
        "hide_profile_section_sub": "Скрывает вкладку 'Подарки' в профиле",
        "hide_profile_button": "Кнопка в профиле",
        "hide_profile_button_sub": "Убирает кнопку 'Подарить' из профиля",
        "restart_warning": "Для применения эффекта рекомендуется перезагрузка",
    },
    "en": {
        "header_settings": "Gift Hiding Settings",
        "enable_analytics": "mkStats",
        "enable_analytics_sub": "Anonymous usage statistics",
        "hide_button_chat": "Button in chat",
        "hide_button_chat_sub": "Removes gift button from input line and channels",
        "hide_send_dialogs": "Send dialogs",
        "hide_send_dialogs_sub": "Blocks gift sending dialogs",
        "hide_gift_messages": "Gift messages",
        "hide_gift_messages_sub": "Hides received gift messages",
        "hide_view_dialogs": "View dialogs",
        "hide_view_dialogs_sub": "Blocks gift viewing",
        "hide_profile_section": "Profile section",
        "hide_profile_section_sub": "Hides 'Gifts' tab in profile",
        "hide_profile_button": "Profile button",
        "hide_profile_button_sub": "Removes gift button from profile",
        "restart_warning": "Restart is recommended for changes to take effect",
    }
}

def get_language():
    try:
        Locale = find_class("java.util.Locale")
        return "ru" if Locale.getDefault().getLanguage() == "ru" else "en"
    except:
        return "en"

def get_string(key):
    lang = get_language()
    return STRINGS.get(lang, STRINGS["en"]).get(key, STRINGS["en"].get(key, ""))

class HideGiftButtonPlugin(BasePlugin):

    # === mkStats: integration start ===
    def _mkstats_get_setting(self, key: str, default):
        try:
            if hasattr(self, "get_setting"):
                return self.get_setting(key, default)
            if hasattr(self, "getsetting"):
                return self.getsetting(key, default)
        except Exception:
            pass
        return default

    def _mkstats_set_setting(self, key: str, value, reload_settings: bool = False):
        try:
            if hasattr(self, "set_setting"):
                return self.set_setting(key, value, reload_settings=reload_settings)
            if hasattr(self, "setsetting"):
                return self.setsetting(key, value, reloadsettings=reload_settings)
        except Exception:
            pass
        return None

    def _mkstats_get_device_id(self) -> str:
        device_id = self._mkstats_get_setting("mkstats_device_id", "")
        if not device_id:
            device_id = uuid.uuid4().hex
            self._mkstats_set_setting("mkstats_device_id", device_id, reload_settings=False)
        return device_id

    def _mkstats_get_client_version(self) -> str:
        try:
            from org.telegram.messenger import BuildVars
            version = getattr(BuildVars, "BUILD_VERSION_STRING", None) or getattr(BuildVars, "BUILD_VERSION", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import BuildConfig as TgBuildConfig
            version = getattr(TgBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            version = getattr(AyuBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            version = getattr(ExBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pm = ctx.getPackageManager()
                pkg = ctx.getPackageName()
                info = pm.getPackageInfo(pkg, 0)
                version = getattr(info, "versionName", None) or getattr(info, "versionCode", None)
                if version:
                    return str(version)
        except Exception:
            pass
        return "unknown"

    def _mkstats_get_client_name(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pkg = ctx.getPackageName()
                if pkg == "com.radolyn.ayugram":
                    return "AyuGram"
                if pkg == "com.exteragram.messenger":
                    return "exteraGram"
                if pkg == "org.telegram.messenger":
                    return "Telegram"
                if pkg:
                    return str(pkg)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            _ = AyuBuildConfig.VERSION_NAME
            return "AyuGram"
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            _ = ExBuildConfig.VERSION_NAME
            return "exteraGram"
        except Exception:
            pass
        return "unknown"

    def _mkstats_log(self, message: str) -> None:
        if hasattr(self, "log"):
            try:
                self.log(message)
            except Exception:
                pass

    def _mkstats_event(self, event: str, count: int = 1) -> None:
        if not event:
            return

        def _send():
            try:
                if not hasattr(self, "_mkstats_client"):
                    return
                if not getattr(self, "_mkstats_token", ""):
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                if self._mkstats_token:
                    self._mkstats_client.send_event(self._mkstats_token, event, count=count)
            except Exception as exc:
                self._mkstats_log(f"mkStats: event error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)

        try:
            threading.Thread(target=_send, daemon=True).start()
        except Exception:
            pass

    def _mkstats_loop(self):
        while not self._mkstats_stop.is_set():
            try:
                if not self._mkstats_token:
                    self._mkstats_log("mkStats: handshake start")
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                        self._mkstats_log("mkStats: handshake ok, token stored")
                    else:
                        self._mkstats_log("mkStats: handshake response missing token")

                if self._mkstats_token:
                    self._mkstats_log("mkStats: sending ping")
                    self._mkstats_client.send_ping(self._mkstats_token)
                    self._mkstats_log("mkStats: ping sent")
            except Exception as exc:
                self._mkstats_log(f"mkStats: error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)
            self._mkstats_stop.wait(MKSTATS_PING_INTERVAL)

    def _mkstats_start(self):
        try:
            device_id = self._mkstats_get_device_id()
            user_hash = generate_user_hash(device_id, __id__)
            device_fingerprint = generate_device_fingerprint(device_id)
            client_name = self._mkstats_get_client_name()
            client_version = self._mkstats_get_client_version()
            self._mkstats_client = MkStatsCoreClient(MKSTATS_API_URL, __id__, __version__, user_hash, device_fingerprint, client_version, client_name)
            self._mkstats_stop = threading.Event()
            self._mkstats_token = self._mkstats_get_setting("mkstats_install_token", "")
            self._mkstats_thread = threading.Thread(target=self._mkstats_loop, daemon=True)
            self._mkstats_thread.start()
            self._mkstats_log(f"mkStats: client started ({self._mkstats_client.api_base})")
        except Exception:
            pass
    # === mkStats: integration end ===

    def on_plugin_load(self):
        # === Feature Toggles ===
        enable_analytics = self.get_setting("enable_analytics", True)
        
        hide_button_chat = self.get_setting("hide_button_chat", True)
        hide_send_dialogs = self.get_setting("hide_send_dialogs", True)
        hide_gift_messages = self.get_setting("hide_gift_messages", True)
        hide_view_dialogs = self.get_setting("hide_view_dialogs", True)
        hide_profile_section = self.get_setting("hide_profile_section", True)
        hide_profile_button = self.get_setting("hide_profile_button", True)

        # === mkStats: integration start ===
        if enable_analytics:
            self._mkstats_start()
        # === mkStats: integration end ===

        # === RPC Gift Filter: Initialize data-level blocking ===
        self.rpc_filter = GiftRPCFilter()
        self._setup_rpc_hooks(hide_profile_section)
        # === RPC Gift Filter: End ===
        
        # --- Hide Button in Chat & Channels ---
        if hide_button_chat:
            try:
                cls = find_class("org.telegram.ui.Components.ChatActivityEnterView")
                if cls:
                    self.hook_all_methods(cls, "createGiftButton", GiftBlockHook(), priority=50)
                    self.hook_all_methods(cls, "updateGiftButton", GiftBlockHook(), priority=50)
                    self.hook_all_methods(cls, "addView", AttachLayoutGiftBlockHook(), priority=50)
            except:
                pass
            
            try:
                cls = find_class("org.telegram.ui.Components.chat.layouts.ChatActivityChannelButtonsLayout")
                if cls:
                    self.hook_all_methods(cls, "showButton", ChannelGiftBlockHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.ChatActivity")
                if cls:
                    self.hook_all_methods(cls, "showGiftButton", GiftBlockHook(), priority=50)
            except:
                pass

        # --- Hide Send Gift Dialogs ---
        if hide_send_dialogs:
            try:
                cls = find_class("org.telegram.ui.Gifts.SendGiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Gifts.GiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Stars.GiftOfferSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

        # 3. Hide Gift Messages
        if hide_gift_messages:
            try:
                cls = find_class("org.telegram.ui.Cells.ChatMessageCell")
                if cls:
                    self.hook_all_methods(cls, "setMessageObject", ChatMessageSetMessageHook(), priority=50)
                    self.hook_all_methods(cls, "onMeasure", ChatMessageMeasureHook(), priority=50)
            except:
                pass

        # 4. Hide View Gift Dialogs
        if hide_view_dialogs:
            try:
                cls = find_class("org.telegram.ui.Stars.StarGiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Stars.StarGiftPreviewSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

        # --- Hide Profile Section (Gifts Tab ID 14) ---
        if hide_profile_section:
            try:
                cls = find_class("org.telegram.ui.Components.SharedMediaLayout")
                if cls:
                    self.hook_all_methods(cls, "getTab", SharedMediaGetTabHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Components.ScrollSlidingTextTabStrip")
                if cls:
                    self.hook_all_methods(cls, "addTextTab", TabBlockHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Cells.TextCell")
                if cls:
                    self.hook_all_methods(cls, "setTextAndIcon", TextCellSetTextHook(), priority=50)
                    self.hook_all_methods(cls, "setText", TextCellSetTextHook(), priority=50)
                    self.hook_all_methods(cls, "onMeasure", TextCellMeasureHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Stars.ProfileGiftsView")
                if cls:
                    self.hook_all_methods(cls, "onMeasure", ViewMeasureZeroHook(), priority=50)
                    self.hook_all_methods(cls, "setVisibility", ViewVisibilityGoneHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.Gifts.ProfileGiftsContainer")
                if cls:
                    self.hook_all_methods(cls, "onMeasure", ViewMeasureZeroHook(), priority=50)
                    self.hook_all_methods(cls, "setVisibility", ViewVisibilityGoneHook(), priority=50)
            except:
                pass

        # --- Hide Profile Button (Gift Action ID 3) ---
        if hide_profile_button:
            try:
                cls = find_class("org.telegram.ui.Components.ProfileActionsView")
                if cls:
                    self.hook_all_methods(cls, "set", ProfileActionsGiftBlockHook(), priority=100)
                    self.hook_all_methods(cls, "getOrCreate", ProfileActionsGetOrCreateHook(), priority=100)
                    self.hook_all_methods(cls, "applyVisibleActions", ProfileActionsApplyHook(), priority=100)
            except:
                pass
            
            try:
                cls = find_class("org.telegram.ui.ProfileActivity")
                if cls:
                    self.hook_all_methods(cls, "showGifts", BlockMethodHook(), priority=50)
                    self.hook_all_methods(cls, "openGifts", BlockMethodHook(), priority=50)
                    self.hook_all_methods(cls, "openStarGifts", BlockMethodHook(), priority=50)
                    self.hook_all_methods(cls, "onGiftClick", BlockMethodHook(), priority=50)
                    self.hook_all_methods(cls, "onGiftPermiumClicked", BlockMethodHook(), priority=50)
                    self.hook_all_methods(cls, "updateGiftState", ProfileActivityGiftBlockHook(), priority=100)
            except:
                pass

            try:
                cls = find_class("android.widget.Button")
                if cls:
                    self.hook_all_methods(cls, "setText", GiftButtonTextHook(), priority=50)
                    self.hook_all_methods(cls, "setOnClickListener", GiftButtonClickHook(), priority=50)
            except:
                pass
            
            try:
                cls = find_class("android.view.MenuItem")
                if cls:
                    self.hook_all_methods(cls, "setTitle", GiftMenuItemHook(), priority=50)
            except:
                pass

            try:
                cls = find_class("org.telegram.ui.ActionBar.AlertDialog")
                if cls:
                    self.hook_all_methods(cls, "show", GiftDialogBlockHook(), priority=50)
            except:
                pass
    
    def create_settings(self):
        settings = [
            Header(text=get_string("header_settings")),
            Switch(
                key="hide_button_chat",
                text=get_string("hide_button_chat"),
                subtext=get_string("hide_button_chat_sub"),
                icon="msg_gift_premium",
                default=True
            ),
            Switch(
                key="hide_send_dialogs",
                text=get_string("hide_send_dialogs"),
                subtext=get_string("hide_send_dialogs_sub"),
                icon="msg_gift_premium",
                default=True
            ),
            Switch(
                key="hide_gift_messages",
                text=get_string("hide_gift_messages"),
                subtext=get_string("hide_gift_messages_sub"),
                icon="msg_gift_premium",
                default=True
            ),
            Switch(
                key="hide_view_dialogs",
                text=get_string("hide_view_dialogs"),
                subtext=get_string("hide_view_dialogs_sub"),
                icon="msg_gift_premium",
                default=True
            ),
            Switch(
                key="hide_profile_section",
                text=get_string("hide_profile_section"),
                subtext=get_string("hide_profile_section_sub"),
                icon="msg_contact",
                default=True
            ),
            Switch(
                key="hide_profile_button",
                text=get_string("hide_profile_button"),
                subtext=get_string("hide_profile_button_sub"),
                icon="msg_contact",
                default=True
            ),
            Divider(),
            Switch(
                key="enable_analytics",
                text=get_string("enable_analytics"),
                subtext=get_string("enable_analytics_sub"),
                icon="stats",
                default=True
            ),
            Divider(text=get_string("restart_warning"))
        ]
        return settings

    def _setup_rpc_hooks(self, hide_profile_section=True):
        """Setup RPC-level hooks to filter gift data before UI processing"""
        
        # Hook SharedMediaLayout to prevent gift tabs from being added
        if hide_profile_section:
            try:
                cls = find_class("org.telegram.ui.Components.SharedMediaLayout")
                if cls:
                    # Hook initialization/setup methods
                    self.hook_all_methods(cls, "addTab", GiftTabBlockHook(), priority=100)
                    self.hook_all_methods(cls, "addTabs", GiftTabBlockHook(), priority=100)
                    self.hook_all_methods(cls, "onViewCreated", GiftTabFilterHook(self.rpc_filter), priority=100)
            except:
                pass
            
            # Hook View/ViewGroup to filter gift-related views during layout inflation
            try:
                cls = find_class("android.view.ViewGroup")
                if cls:
                    self.hook_all_methods(cls, "addView", GiftViewAddHook(), priority=100)
            except:
                pass
            
            # Hook LayoutInflater to prevent gift layout inflation
            try:
                cls = find_class("android.view.LayoutInflater")
                if cls:
                    self.hook_all_methods(cls, "inflate", GiftLayoutInflateHook(), priority=100)
            except:
                pass

    def on_plugin_unload(self):
        # === mkStats: integration start ===
        if hasattr(self, "_mkstats_stop"):
            self._mkstats_stop.set()
            self._mkstats_log("mkStats: stop requested")
            try:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                    self._mkstats_thread.join(timeout=1.0)
            except Exception:
                pass
        # === mkStats: integration end ===

# === General Hooks ===

class GiftBlockHook(MethodHook):
    def before_hooked_method(self, param):
        param.setResult(None)

class BlockMethodHook(MethodHook):
    def before_hooked_method(self, param):
        param.setResult(None)

class GiftSheetBlockHook(MethodHook):
    def before_hooked_method(self, param):
        # Prevent sheet from showing
        param.setResult(None)
class ChannelGiftBlockHook(MethodHook):
    def before_hooked_method(self, param):
        if param.args[0] == 1:
            param.setResult(None)

class AttachLayoutGiftBlockHook(MethodHook):
    """Block adding giftButton to attachLayout in ChatActivityEnterView"""
    def before_hooked_method(self, param):
        try:
            # Check if we're adding a view to attachLayout
            if param.args and len(param.args) > 0:
                view = param.args[0]
                if view and hasattr(view, "getClass"):
                    class_name = view.getClass().getSimpleName()
                    
                    # Block ImageView that's likely giftButton
                    if class_name == "ImageView" or (hasattr(view, "__class__") and "ImageView" in str(view.__class__)):
                        try:
                            # Check content description for "GiftPremium"
                            if hasattr(view, "getContentDescription"):
                                desc = view.getContentDescription()
                                if desc and "gift" in str(desc).lower():
                                    param.setResult(None)
                                    return
                            
                            # Check if position is 0 and size is 48x48 (exact signature of giftButton)
                            if len(param.args) > 1:
                                # addView(View, int index, ViewGroup.LayoutParams params) or
                                # addView(View, int index)
                                index = param.args[1]
                                if isinstance(index, int) and index == 0:
                                    # Very likely giftButton since it's added at position 0
                                    param.setResult(None)
                                    return
                        except:
                            pass
        except:
            pass

class ChatMessageSetMessageHook(MethodHook):
    def __init__(self):
        self.gift_classes = []
        
        def safe_add(class_name):
            try:
                cls = find_class(class_name)
                if cls:
                    self.gift_classes.append(cls)
            except BaseException:
                pass

        safe_add("org.telegram.tgnet.TLRPC$TL_messageActionGift")
        safe_add("org.telegram.tgnet.TLRPC$TL_messageActionStarGift")
        safe_add("org.telegram.tgnet.TLRPC$TL_messageActionGiftCode")

    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            # args[0] is MessageObject
            if len(param.args) > 0:
                msg = param.args[0]
                is_gift = False
                if msg:
                    # Access messageOwner.action safely
                    try:
                        if hasattr(msg, "messageOwner") and msg.messageOwner:
                             action = getattr(msg.messageOwner, "action", None)
                             if action:
                                 action_class = action.getClass()
                                 for cls in self.gift_classes:
                                     if cls and action_class.isAssignableFrom(cls):
                                         is_gift = True
                                         break
                    except:
                        pass
                
                setattr(view, "_is_gift", is_gift)
        except:
            pass

class ChatMessageMeasureHook(MethodHook):
    def after_hooked_method(self, param):
        try:
            if getattr(param.thisObject, "_is_gift", False):
                param.thisObject.setMeasuredDimension(0, 0)
        except:
            pass

class TextCellSetTextHook(MethodHook):
    """Removed text-based search - now using TLRPC class detection only"""
    def before_hooked_method(self, param):
        # This hook now does nothing - gift actions are handled at RPC level
        # Kept for backward compatibility with settings
        pass

class TextCellMeasureHook(MethodHook):
    def after_hooked_method(self, param):
        try:
            if getattr(param.thisObject, "_is_gift_row", False):
                param.thisObject.setMeasuredDimension(0, 0)
        except:
            pass

class ViewMeasureZeroHook(MethodHook):
    def after_hooked_method(self, param):
        param.thisObject.setMeasuredDimension(0, 0)

class ViewVisibilityGoneHook(MethodHook):
    def before_hooked_method(self, param):
        # 8 = GONE
        param.args[0] = 8

class SharedMediaGetTabHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            # public static TLRPC.ProfileTab getTab(int i, boolean z)
            # i = 14 is Gifts
            if isinstance(param.args[0], int) and param.args[0] == 14:
                param.setResult(None)
        except:
            pass

class TabBlockHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            # addTextTab(int i, CharSequence text, ...)
            # i = 14 is Gifts
            if isinstance(param.args[0], int) and param.args[0] == 14:
                param.setResult(None)
        except:
            pass

# === RPC-Level Hooks (Data filtering) ===

class ProfileActionsGiftBlockHook(MethodHook):
    """Block setting gift action (ID 3) in ProfileActionsView"""
    def before_hooked_method(self, param):
        try:
            # Method: set(int i, boolean z)
            # i = 3 is Gift action
            # z = true would add it, false would remove it
            if param.args and len(param.args) >= 1:
                action_id = param.args[0]
                # ID 3 = Gift button
                if isinstance(action_id, int) and action_id == 3:
                    # Block this action from being added
                    param.setResult(None)
        except:
            pass

class ProfileActionsGetOrCreateHook(MethodHook):
    """Block creation of Gift action button"""
    def after_hooked_method(self, param):
        try:
            # Method: getOrCreate(int i)
            # i = 3 returns Action for Gift
            if param.args and len(param.args) > 0:
                action_id = param.args[0]
                if isinstance(action_id, int) and action_id == 3:
                    # Don't create gift action
                    param.setResult(None)
        except:
            pass

class ProfileActionsApplyHook(MethodHook):
    """Filter gift actions when applying visible actions"""
    def __init__(self):
        self.gift_action_id = 3
    
    def after_hooked_method(self, param):
        try:
            # After applyVisibleActions, try to remove any gift actions
            obj = param.thisObject
            # Try to access internal actions collection
            if hasattr(obj, "visibleActions"):
                visible_actions = getattr(obj, "visibleActions", None)
                if visible_actions:
                    # Try to remove gift action (ID 3)
                    self._remove_gift_action(visible_actions)
            
            if hasattr(obj, "actionsList"):
                actions_list = getattr(obj, "actionsList", None)
                if actions_list:
                    self._remove_gift_action(actions_list)
            
            if hasattr(obj, "allAvailableActions"):
                all_actions = getattr(obj, "allAvailableActions", None)
                if all_actions:
                    self._remove_gift_action(all_actions)
        except:
            pass
    
    def _remove_gift_action(self, actions_collection):
        """Remove gift action from collection"""
        try:
            if hasattr(actions_collection, "remove"):
                # Try to remove by ID
                actions_collection.remove(self.gift_action_id)
            elif hasattr(actions_collection, "contains"):
                # Check if it contains the gift action
                if actions_collection.contains(self.gift_action_id):
                    actions_collection.remove(self.gift_action_id)
        except:
            pass

class ProfileActivityGiftBlockHook(MethodHook):
    """Block gift state updates in ProfileActivity"""
    def before_hooked_method(self, param):
        try:
            # This method likely calls actionsView.set(3, boolean)
            # Block it entirely to prevent gift action from being set
            param.setResult(None)
        except:
            pass

class GiftTabBlockHook(MethodHook):
    """Block adding gift tabs to UI"""
    def before_hooked_method(self, param):
        try:
            # If trying to add a tab, check if it's a gift tab
            if param.args and len(param.args) > 0:
                first_arg = param.args[0]
                # Check if it looks like a gift tab (by class name or ID 14)
                if hasattr(first_arg, "getClass"):
                    class_name = first_arg.getClass().getSimpleName()
                    if "ProfileTabGifts" in class_name or "GiftTab" in class_name:
                        param.setResult(None)
                        return
                # If first arg is int (tab ID 14 = gifts)
                if isinstance(first_arg, int) and first_arg == 14:
                    param.setResult(None)
        except:
            pass

class GiftTabFilterHook(MethodHook):
    """Filter gift tabs when views are created"""
    def __init__(self, rpc_filter):
        self.rpc_filter = rpc_filter
    
    def after_hooked_method(self, param):
        try:
            # After view is created, filter any gift tabs
            obj = param.thisObject
            if hasattr(obj, "profileTabs"):
                tabs = getattr(obj, "profileTabs", None)
                if tabs:
                    self.rpc_filter._remove_gift_tabs_from_array(tabs)
        except:
            pass

class GiftViewAddHook(MethodHook):
    """Block adding gift-related views"""
    def before_hooked_method(self, param):
        try:
            # Check the view being added
            if param.args and len(param.args) > 0:
                view = param.args[0]
                if hasattr(view, "getClass"):
                    class_name = view.getClass().getSimpleName()
                    # Block gift-related views
                    if any(x in class_name for x in [
                        "ProfileGiftsView", "ProfileGiftsContainer",
                        "GiftCell", "GiftView", "StarGift"
                    ]):
                        param.setResult(None)
        except:
            pass

class GiftLayoutInflateHook(MethodHook):
    """Block inflating gift-related layouts"""
    def after_hooked_method(self, param):
        try:
            # Check inflated view
            result = param.getResult()
            if result and hasattr(result, "getClass"):
                class_name = result.getClass().getSimpleName()
                # Block gift layouts from being used
                if any(x in class_name for x in [
                    "ProfileGiftsView", "GiftCell", "StarGiftLayout"
                ]):
                    # Make invisible instead of blocking inflation
                    try:
                        result.setVisibility(8)  # GONE
                    except:
                        pass
        except:
            pass

class GenericRPCResponseHook(MethodHook):
    """Generic hook to filter any RPC response object"""
    def __init__(self, rpc_filter):
        self.rpc_filter = rpc_filter
    
    def after_hooked_method(self, param):
        """Filter any RPC response after processing"""
        try:
            # Check returned object
            result = param.getResult()
            if result:
                self.rpc_filter.filter_rpc_response(result)
        except:
            pass

class RPCRequestHook(MethodHook):
    """Hook to filter RPC responses - simplified"""
    def __init__(self, rpc_filter):
        self.rpc_filter = rpc_filter
    
    def after_hooked_method(self, param):
        """Filter RPC response after it's received"""
        try:
            result = param.getResult()
            if result:
                self.rpc_filter.filter_rpc_response(result)
        except:
            pass

# === Button and UI Element Blocking ===

class GiftButtonTextHook(MethodHook):
    """Block gift button text from being set"""
    def before_hooked_method(self, param):
        try:
            if param.args and len(param.args) > 0:
                text = str(param.args[0])
                if "Gift" in text or "Подар" in text or "Star" in text:
                    param.setResult(None)
        except:
            pass

class GiftButtonClickHook(MethodHook):
    """Block gift button click listeners"""
    def before_hooked_method(self, param):
        try:
            if param.args and len(param.args) > 0:
                listener = param.args[0]
                if listener:
                    class_name = listener.getClass().getSimpleName() if hasattr(listener, "getClass") else str(type(listener))
                    if "Gift" in class_name or "gift" in str(listener).lower():
                        # Don't set the listener
                        param.setResult(None)
        except:
            pass

class GiftMenuItemHook(MethodHook):
    """Block gift menu items"""
    def before_hooked_method(self, param):
        try:
            if param.args and len(param.args) > 0:
                title = str(param.args[0])
                if "Gift" in title or "Подар" in title or "Star" in title:
                    param.setResult(None)
        except:
            pass

class GiftDialogBlockHook(MethodHook):
    """Block gift-related dialogs"""
    def before_hooked_method(self, param):
        try:
            # Check if this dialog is gift-related
            obj = param.thisObject
            if hasattr(obj, "mTitle"):
                title = str(getattr(obj, "mTitle", ""))
                if "Gift" in title or "Подар" in title:
                    param.setResult(None)
            
            if hasattr(obj, "getTitle"):
                try:
                    title = str(obj.getTitle())
                    if "Gift" in title or "Подар" in title:
                        param.setResult(None)
                except:
                    pass
        except:
            pass
