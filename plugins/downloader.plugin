import os
import uuid
import time
import requests
import traceback
import threading
import socket
from contextlib import contextmanager
from java.util import Locale
from ui.settings import Header, Input, Divider, Text, Switch, Selector
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from android_utils import log, run_on_ui_thread
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from java.io import File
from client_utils import get_account_instance, get_media_data_controller, get_last_fragment, get_messages_controller
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import ApplicationLoader, SendMessagesHelper
from java.util import ArrayList
from android.content import ClipData, Context, Intent
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from android.net import Uri

DEFAULT_COBALT_API = "https://cobalt.meowing.de"
COBALT_API = [DEFAULT_COBALT_API, "https://cobalt.canine.tools", "https://cobalt.kwiatekmiki.com","https://cobalt.clxxped.lol","https://cobalt.blackcat.sweeux.org","https://co.eepy.today", "https://co.otomir23.me"]
TEMP_DIR_NAME = "DownloaderTemp"
VIDEO_QUALITY_OPTIONS = ["144","240","360","480","720","1080","1440","2160","4320","max"]
DOWNLOAD_MODE_OPTIONS = ["auto","audio","mute"]
AUDIO_BITRATE_OPTIONS = ["8", "64", "96", "128", "256", "320"]
YOUTUBE_VIDEO_CODEC_OPTIONS = ["h264","av1","vp9"]
IMAGE_EXTS = [".jpg", ".jpeg", ".png"]
AUDIO_EXTS = [".mp3", ".wav", ".ogg", ".opus", ".m4a"]
GIF_EXT = ".gif"
FREE_LIMIT = 2 * 1024 * 1024 * 1024 
PREMIUM_LIMIT = 4 * 1024 * 1024 * 1024
AUTO_SERVICE_GROUPS = [
    ("tiktok", ("TikTok", "TikTok"), ["tiktok.com", "vt.tiktok.com", "vm.tiktok.com"]),
    ("youtube", ("YouTube", "YouTube"), ["youtube.com", "youtu.be"]),
    ("facebook", ("Facebook", "Facebook"), ["facebook.com", "fb.watch"]),
    ("instagram", ("Instagram", "Instagram"), ["instagram.com", "instagr.am", "ddinstagram.com"]),
    ("twitter", ("Twitter/X", "Twitter/X"), ["twitter.com", "x.com", "vxtwitter.com", "fixvx.com"]),
    ("reddit", ("Reddit", "Reddit"), ["reddit.com"]),
    ("soundcloud", ("SoundCloud", "SoundCloud"), ["soundcloud.com"]),
    ("pinterest", ("Pinterest", "Pinterest"), ["pinterest.com", "pin.it"]),
    ("bilibili", ("BiliBili", "BiliBili"), ["bilibili.com"]),
    ("bsky", ("Bluesky", "Bluesky"), ["bsky.app"]),
    ("vk", ("VK", "VK"), ["vk.com", "vk.ru", "vkvideo.ru"]),
    ("rutube", ("Rutube", "Rutube"), ["rutube.ru"]),
    ("dailymotion", ("Dailymotion", "Dailymotion"), ["dailymotion.com"]),
    ("vimeo", ("Vimeo", "Vimeo"), ["vimeo.com"]),
    ("streamable", ("Streamable", "Streamable"), ["streamable.com"]),
    ("loom", ("Loom", "Loom"), ["loom.com"]),
    ("newgrounds", ("Newgrounds", "Newgrounds"), ["newgrounds.com"]),
    ("tumblr", ("Tumblr", "Tumblr"), ["tumblr.com"]),
    ("twitch", ("Twitch", "Twitch"), ["twitch.tv", "clips.twitch.tv"]),
    ("snapchat", ("Snapchat", "Snapchat"), ["snapchat.com"]),
    ("ok", ("OK.ru", "OK.ru"), ["ok.ru"]),
    ("xiaohongshu", ("Xiaohongshu", "Xiaohongshu"), ["xiaohongshu.com", "xhslink.com"]),
]
AUTO_GROUP_LABELS = {key: labels for key, labels, _ in AUTO_SERVICE_GROUPS}
BASE_TO_GROUP = {}
for g_key, _, bases in AUTO_SERVICE_GROUPS:
    for b in bases:
        BASE_TO_GROUP[b] = g_key

__name__ = "Media Downloader"
__description__ = "Download and send a media (photo, video, audio, gif) from supported services (check in auto-download settings)"
__icon__ = "exteraPluginsSup/0"
__version__ = "1.9.2"
__id__ = "downloader"
__author__ = "@itsv1eds"
__min_version__ = "11.12.1"

progress_dialog = None

TRANSLATIONS = {
    "api_title": ("Настройки API", "API Settings"),
    "api_url": ("Cobalt API URL", "Cobalt API URL"),
    "api_key": ("API ключ", "API Key"),
    "api_help": ("Справка", "Help"),
    "api_desc": ("Укажите URL и API (если требуется) вашего Cobalt инстанса. Узнать больше: github.com/imputnet/cobalt", "Enter URL and API (if needed) for your Cobalt instance. Learn more: github.com/imputnet/cobalt"),
    "custom_api": ("Свой API", "Custom API"),
    "custom_api_url": ("Свой URL API", "Custom API URL"),
    "auto_fallback": ("Автопереключение API", "Auto API Fallback"),
    "auto_fallback_desc": ("Автоматически переключаться на другой API при ошибке", "Automatically switch to another API on error"),
    "auto_link": ("Автозагрузка", "Auto download"),
    "auto_link_desc": ("Автоматически скачивать при отправке ссылки поддерживаемого сервиса (Отправляет только при наличии https:// в начале)", "Download automatically when sending link supported services (Sends only if https:// is at the start of the link)"),
    "proxy_title": ("Настройки прокси", "Proxy Settings"),
    "proxy_type": ("Тип прокси", "Proxy Type"),
    "proxy_type_items": (["Нет", "HTTP", "HTTPS", "SOCKS", "MTProto"], ["None", "HTTP", "HTTPS", "SOCKS", "MTProto"]),
    "proxy_url": ("URL прокси", "Proxy URL"),
    "proxy_url_desc": ("Введите прокси host:port", "Enter proxy host:port"),
    "proxy_user": ("Логин прокси", "Proxy Username"),
    "proxy_password": ("Пароль прокси", "Proxy Password"),
    "proxy_secret": ("MTProto Secret", "MTProto Secret"),
    "proxy_secret_desc": ("Секретный ключ MTProto прокси", "MTProto proxy secret key"),
    "settings_title": ("Настройки загрузки", "Download Settings"),
    "show_settings_buttons": ("Кнопка настроек в меню", "Settings button in menu"),
    "show_settings_buttons_desc": ("Добавляет кнопку открытия настроек плагина в меню", "Adds plugin settings button to menu"),
    "include_source": ("Включить ссылку источника", "Include source link"),
    "include_source_desc": ("Добавить ссылку источника в подпись сообщения", "Add source link to message caption"),
    "advanced_settings": ("Дополнительные настройки", "Advanced Settings"),
    "advanced_settings_desc": ("Показать качество видео и битрейт аудио", "Show video quality and audio bitrate"),
    "video_quality": ("Качество видео", "Video Quality"),
    "audio_bitrate": ("Битрейт аудио", "Audio Bitrate"),
    "services": ("Поддерживаемые сервисы", "Supported services"),
    "usage_cmd": (".down/.dl [URL] - Скачивает и отправляет медиа\n.down/.dl [URL] audio - Скачивает и отправляет аудио (даже с видео)\nПример: .dl youtu.be/watch?v=dQw4w9WgXcQ", ".down/.dl [URL] - Download and send media\n.down/.dl [URL] audio - Download and send audio (even from video)\nExample: .dl youtu.be/watch?v=dQw4w9WgXcQ"),
    "donate_title": ("Поддержать разработку", "Support development"),
    "donate_info": ("Другая информация и реквизиты", "Other info and requisites"),
    "test_proxy": ("Тест подключения", "Test Connection"),
    "test_proxy_desc": ("Проверить доступность прокси", "Test proxy availability"),
    "downloading": ("Загрузка...", "Downloading..."),
    "cancel": ("Отмена", "Cancel"),
    "auto_link_services": ("Сервисы автозагрузки", "Auto-download services"),
    "auto_link_services_title": ("Выберите сервисы для автозагрузки", "Choose services for auto-download"),
    "auto_link_desc_short": ("Автоматически скачивать поддерживаемые ссылки", "Auto-download supported links"),
    "auto_link_toggle": ("Автозагрузка", "Auto download"),
    "auto_link_off": ("Автозагрузка выключена", "Auto download is off"),
    "auto_link_all": ("Включить все", "Enable all"),
    "auto_link_none": ("Выключить все", "Disable all"),
    "done": ("Готово", "Done"),
}

def Z(key):
    lang = Locale.getDefault().getLanguage()
    idx = 0 if lang.startswith('ru') else 1
    return TRANSLATIONS.get(key, (None, None))[idx]


def _is_premium_user():
    try:
        ai = get_account_instance()
        if ai is None:
            return False
        uc = ai.getUserConfig()
        return bool(uc.isPremium()) if uc else False
    except Exception:
        return False

class VideoDownloaderPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self._cancel_requested = False
        self._drawer_settings_item = None
        self._chat_settings_item = None
        self._task_in_progress = threading.Lock()
        self._current_proxies = None
        self._current_patch_type = None

    @contextmanager
    def _proxy_connection_patch(self, patch_type: str):
        """Temporarily patch urllib3 socket creator for SOCKS/MTProto."""
        import requests.packages.urllib3.util.connection as uc
        original = uc.create_connection
        try:
            if patch_type == "socks":
                uc.create_connection = lambda addr, timeout=None, **kw: self._socks_create_connection(addr[0], addr[1])
            elif patch_type == "mtproto":
                uc.create_connection = lambda addr, timeout=None, **kw: self._mtproto_create_connection(addr[0], addr[1])
            yield
        finally:
            uc.create_connection = original

    def _set_progress(self, value: int):
        """Safely update progress dialog from any thread."""
        def action():
            global progress_dialog
            dlg = None
            try:
                dlg = progress_dialog.get_dialog() if hasattr(progress_dialog, 'get_dialog') else progress_dialog
            except Exception:
                dlg = progress_dialog
            if dlg and hasattr(dlg, "isShowing") and dlg.isShowing():
                try:
                    progress_dialog.set_progress(value)
                except Exception:
                    pass
        run_on_ui_thread(action)

    def _get_auto_link_services(self):
        saved = self.get_setting("auto_link_services_set", None)
        default_set = set(AUTO_GROUP_LABELS.keys())
        if not saved:
            return default_set
        try:
            return set(saved)
        except Exception:
            return default_set

    def _set_auto_link_services(self, services_set):
        try:
            self.set_setting("auto_link_services_set", list(services_set))
        except Exception:
            pass

    def _toggle_auto_service(self, base, enabled):
        current = self._get_auto_link_services()
        if enabled:
            current.add(base)
        else:
            current.discard(base)
        self._set_auto_link_services(current)

    def _auto_link_summary(self):
        global_enabled = self.get_setting("auto_link_set", False)
        if not global_enabled:
            return "Выкл" if Locale.getDefault().getLanguage().startswith('ru') else "Off"
        enabled = self._get_auto_link_services()
        total = len(AUTO_GROUP_LABELS)
        count = len(enabled)
        if count == total:
            return "Все сервисы" if Locale.getDefault().getLanguage().startswith('ru') else "All services"
        if count == 0:
            return "Все отключены" if Locale.getDefault().getLanguage().startswith('ru') else "All disabled"
        labels = []
        for key, labels_pair in AUTO_GROUP_LABELS.items():
            if key in enabled:
                lbl = labels_pair[0 if Locale.getDefault().getLanguage().startswith('ru') else 1]
                labels.append(lbl)
            if len(labels) >= 3:
                break
        suffix = "" if count <= 3 else f"+{count-3}"
        return ", ".join(labels) + (f" {suffix}" if suffix else "")

    def _service_setting_key(self, base: str):
        return "auto_service_" + base.replace(".", "_").replace("-", "_").replace("/", "_")

    def _prepare_sending_media_safe(self, account_instance, media_list, dialog_id, reply_to_msg, reply_to_top_msg, notify, schedule_date):
        """Call prepareSendingMedia with compatibility for old exteraGram builds."""
        try:
            SendMessagesHelper.prepareSendingMedia(
                account_instance,
                media_list,
                dialog_id,
                reply_to_msg,
                reply_to_top_msg,
                None,   # storyItem
                None,   # quote
                False,  # forceDocument
                True,   # groupMedia
                None,   # editingMessageObject
                notify,
                schedule_date,
                0,      # mode
                False,  # updateStickersOrder
                None,   # inputContent
                None,   # quickReplyShortcut
                0,      # quickReplyShortcutId
                0,      # effectId
                False,  # invertMedia
                0,      # payStars
                0,      # monoForumPeerId
                None    # suggestionParams
            )
        except TypeError:
            # Older builds expect an extra trailing boolean (isGroupStory) or older param set.
            try:
                SendMessagesHelper.prepareSendingMedia(
                    account_instance,
                    media_list,
                    dialog_id,
                    reply_to_msg,
                    reply_to_top_msg,
                    None, None,
                    False, True,
                    None,
                    notify,
                    schedule_date,
                    0, False,
                    None, None, 0, 0, False, 0, 0, None, False
                )
            except Exception as e:
                log(f"[downloader] prepareSendingMedia fallback failed: {e}")
                raise

    def _prepare_sending_video_safe(self, account_instance, video_path, dialog_id, reply_to_msg, reply_to_top_msg, entities, notify, schedule_date, force_document, has_media_spoilers, caption, quick_reply_shortcut, quick_reply_shortcut_id, effect_id, stars):
        """Call prepareSendingVideo with compatibility for old exteraGram builds."""
        try:
            SendMessagesHelper.prepareSendingVideo(
                account_instance,
                video_path,
                None,                # VideoEditedInfo
                None,                # cover_path
                None,                # TLRPC.Photo cover
                dialog_id,
                reply_to_msg,
                reply_to_top_msg,
                None,                # storyItem
                None,                # quote
                entities,
                0,                   # ttl
                None,                # editingMessageObject
                notify,
                schedule_date,
                0,                   # mode
                force_document,
                has_media_spoilers,
                caption,
                quick_reply_shortcut,
                quick_reply_shortcut_id,
                effect_id,
                stars
            )
        except TypeError:
            try:
                SendMessagesHelper.prepareSendingVideo(
                    account_instance,
                    video_path,
                    None,
                    None,
                    None,
                    dialog_id,
                    reply_to_msg,
                    reply_to_top_msg,
                    None,
                    None,
                    entities,
                    0,
                    None,
                    notify,
                    schedule_date,
                    force_document,
                    has_media_spoilers,
                    caption,
                    quick_reply_shortcut,
                    quick_reply_shortcut_id,
                    effect_id,
                    stars
                )
            except Exception as e:
                log(f"[downloader] prepareSendingVideo fallback failed: {e}")
                raise

    def _api_settings_section(self, api_idx: int, proxy_type_val: int, locale_idx: int):
        proxy_icon = "msg2_proxy_off" if proxy_type_val == 0 else "msg2_proxy_on"
        settings = [
            Header(text=Z("api_title")),
            Selector(
                key="api_url_choice_set",
                text=Z("api_url"),
                icon="msg2_devices",
                default=api_idx,
                items=COBALT_API + [Z("custom_api")]
            ),
        ]
        if api_idx == len(COBALT_API):
            settings.extend([
                Input(key="api_url_set", text=Z("custom_api_url"), icon="msg_instant_link", default=self.get_setting("api_url_set", "")),
                Input(key="api_key_set", text=Z("api_key"), icon="msg_pin_code", default=self.get_setting("api_key_set", "")),
                Text(text=Z("api_help"), icon="msg_psa", accent=True, on_click=lambda view: self.show_my_info_alert(title=Z("api_title"), message=Z("api_desc"), neutral_button="GitHub", neutral_link="https://github.com/imputnet/cobalt", neutral_type="link")),
            ])
        settings.append(Switch(key="auto_fallback_set", text=Z("auto_fallback"), icon="media_flip", default=self.get_setting("auto_fallback_set", True), subtext=Z("auto_fallback_desc")))
        settings.append(Selector(key="proxy_type_set", text=Z("proxy_type"), icon=proxy_icon, default=proxy_type_val, items=TRANSLATIONS["proxy_type_items"][locale_idx]))
        if proxy_type_val != 0:
            if proxy_type_val == 4:
                settings.extend([
                    Input(key="proxy_url_set", text=Z("proxy_url"), icon="msg_link", default=self.get_setting("proxy_url_set", ""), subtext=Z("proxy_url_desc")),
                    Input(key="proxy_username_set", text=Z("proxy_secret"), icon="msg_pin_code", default=self.get_setting("proxy_username_set", ""), subtext=Z("proxy_secret_desc")),
                ])
            else:
                settings.extend([
                    Input(key="proxy_url_set", text=Z("proxy_url"), icon="msg_link", default=self.get_setting("proxy_url_set", ""), subtext=Z("proxy_url_desc")),
                    Input(key="proxy_username_set", text=Z("proxy_user"), icon="msg_contacts", default=self.get_setting("proxy_username_set", "")),
                    Input(key="proxy_password_set", text=Z("proxy_password"), icon="msg_pin_code", default=self.get_setting("proxy_password_set", "")),
                ])
            settings.append(Text(text=Z("test_proxy"), icon="msg_message", accent=True, on_click=lambda view: self._test_current_proxy()))
        return settings

    def _download_settings_section(self):
        section = [
            Header(text=Z("settings_title")),
            Text(text=Z("auto_link_toggle"), icon="msg_link", accent=True, create_sub_fragment=self._auto_link_settings_section, link_alias="auto_link_toggle"),
            Switch(key="include_source_set", text=Z("include_source"), icon="msg_link", default=self.get_setting("include_source_set", True), subtext=Z("include_source_desc"), link_alias="include_source_set"),
            Switch(key="show_settings_buttons_set", text=Z("show_settings_buttons"), icon="msg_reorder", default=self.get_setting("show_settings_buttons_set", True), subtext=Z("show_settings_buttons_desc"), on_change=self._on_show_settings_buttons_change, link_alias="show_settings_buttons_set"),
        ]
        section.append(Switch(key="show_advanced_set", text=Z("advanced_settings"), icon="msg_settings_14", default=self.get_setting("show_advanced_set", False)))
        if self.get_setting("show_advanced_set", False):
            section.extend([
                Selector(key="video_quality_set", text=Z("video_quality"), icon="msg_video", default=self.get_setting("video_quality_set", 5), items=VIDEO_QUALITY_OPTIONS),
                Selector(key="audio_bitrate_set", text=Z("audio_bitrate"), icon="input_mic", default=self.get_setting("audio_bitrate_set", 5), items=AUDIO_BITRATE_OPTIONS),
            ])
        return section

    def _auto_link_settings_section(self):
        settings = [
            Switch(key="auto_link_set", text=Z("auto_link_toggle"), icon="msg_link", default=self.get_setting("auto_link_set", False), link_alias="auto_link_set"),
            Divider(text=""),
        ]
        if not self.get_setting("auto_link_set", False):
            return settings
        settings.append(Header(text=Z("auto_link_services_title")))
        enabled = self._get_auto_link_services()
        for key, labels_pair, _ in AUTO_SERVICE_GROUPS:
            label = labels_pair[0 if Locale.getDefault().getLanguage().startswith('ru') else 1]
            is_on = key in enabled
            settings.append(Switch(
                key=self._service_setting_key(key),
                text=label,
                icon="msg_filter",
                default=is_on,
                on_change=lambda val, k=key: self._toggle_auto_service(k, val)
            ))
        return settings

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        idx = 0 if lang.startswith('ru') else 1
        api_idx = self.get_setting("api_url_choice_set", 0)
        proxy_type_val = self.get_setting("proxy_type_set", 0)
        settings = []
        settings.extend(self._download_settings_section())
        settings.append(Divider(text=""))
        settings.extend(self._api_settings_section(api_idx, proxy_type_val, idx))
        settings.extend([
            Divider(text=""),
            Header(text="Поддержать разработку" if lang.startswith('ru') else "Support development"),
            Text(text="TON", icon="msg_ton", on_click=lambda v: run_on_ui_thread(lambda: self._copy_to_clipboard("TON", "exteralover.ton"))),
            Text(text="Реквизиты" if lang.startswith('ru') else "Requisites", icon="msg_reactions", accent=True, on_click=lambda v: self._open_tg_link("exteraPluginsSup/302")),
        ])
        return settings

    def _open_plugin_settings(self, java_plugin):
        try:
            get_last_fragment().presentFragment(PluginSettingsActivity(java_plugin))
        except Exception as e:
            log(f"[{__id__}] Error opening plugin settings: {e}")

    def _add_settings_menu_items(self):
        try:
            self._drawer_settings_item = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.DRAWER_MENU,
                text=Z("settings_title"),
                icon="msg_settings_14",
                priority=5,
                on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))
            ))
            self._chat_settings_item = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text=Z("settings_title"),
                icon="msg_settings_14",
                priority=5,
                on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))
            ))
        except Exception as e:
            log(f"[{__id__}] Failed to add settings menu items: {e}")

    def _socks_create_connection(self, dest_host, dest_port):
        sock = None
        try:
            url_setting = self.get_setting('proxy_url_set','').strip()
            if not url_setting or ':' not in url_setting:
                return socket.create_connection((dest_host, dest_port))
            
            if '://' in url_setting:
                url_setting = url_setting.split('://', 1)[1]
            
            user = self.get_setting('proxy_username_set','').strip()
            pwd = self.get_setting('proxy_password_set','').strip()
            
            if ':' not in url_setting:
                log(f"[{__id__}] Invalid proxy URL format: {url_setting}")
                return socket.create_connection((dest_host, dest_port))
                
            host, port_str = url_setting.split(':', 1)
            try:
                port = int(port_str)
            except ValueError:
                log(f"[{__id__}] Invalid proxy port: {port_str}")
                return socket.create_connection((dest_host, dest_port))
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(15)
            sock.connect((host, port))
            
            methods = b'\x02' if user and pwd else b'\x00'
            sock.send(b'\x05\x01' + methods)
            response = sock.recv(2)
            if len(response) < 2:
                raise Exception("Invalid SOCKS5 response")
            
            version, method = response
            if version != 5:
                raise Exception(f"Unsupported SOCKS version: {version}")
            
            if method == 2:
                if not user or not pwd:
                    raise Exception("Username/password required but not provided")
                
                auth_request = b'\x01' + bytes([len(user)]) + user.encode() + bytes([len(pwd)]) + pwd.encode()
                sock.send(auth_request)
                auth_response = sock.recv(2)
                if len(auth_response) < 2 or auth_response[1] != 0:
                    raise Exception("SOCKS5 authentication failed")
            
            try:
                dest_ip = socket.inet_aton(dest_host)
                addr_type = b'\x01'
                addr_data = dest_ip
            except socket.error:
                addr_type = b'\x03'
                addr_data = bytes([len(dest_host)]) + dest_host.encode()
            
            connect_request = b'\x05\x01\x00' + addr_type + addr_data + int(dest_port).to_bytes(2, 'big')
            sock.send(connect_request)
            
            connect_response = sock.recv(10)
            if len(connect_response) < 4:
                raise Exception("Invalid SOCKS5 connect response")
            
            if connect_response[1] != 0:
                raise Exception(f"SOCKS5 connect failed with code: {connect_response[1]}")
            
            return sock
            
        except Exception as e:
            log(f"[{__id__}] SOCKS proxy error: {e}")
            if sock:
                try:
                    sock.close()
                except:
                    pass
            return socket.create_connection((dest_host, dest_port))

    def _mtproto_create_connection(self, dest_host, dest_port):
        sock = None
        try:
            url_setting = self.get_setting('proxy_url_set','').strip()
            if not url_setting or ':' not in url_setting:
                return socket.create_connection((dest_host, dest_port))
            
            if '://' in url_setting:
                url_setting = url_setting.split('://', 1)[1]
            
            secret = self.get_setting('proxy_username_set','').strip()
            pwd = self.get_setting('proxy_password_set','').strip()
            
            if ':' not in url_setting:
                log(f"[{__id__}] Invalid MTProto proxy URL format: {url_setting}")
                return socket.create_connection((dest_host, dest_port))
                
            host, port_str = url_setting.split(':', 1)
            try:
                port = int(port_str)
            except ValueError:
                log(f"[{__id__}] Invalid MTProto proxy port: {port_str}")
                return socket.create_connection((dest_host, dest_port))
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(15)
            sock.connect((host, port))
            
            if secret:
                secret_bytes = secret.encode('utf-8')
                header = b'\xef\xef\xef\xef' + bytes([len(secret_bytes)]) + secret_bytes
                sock.send(header)
                
                response = sock.recv(1)
                if response != b'\xef':
                    log(f"[{__id__}] MTProto secret authentication failed")
                    sock.close()
                    return socket.create_connection((dest_host, dest_port))
            
            dest_info = f"{dest_host}:{dest_port}".encode('utf-8')
            connect_packet = b'\xdd\xdd\xdd\xdd' + bytes([len(dest_info)]) + dest_info
            sock.send(connect_packet)
            
            response = sock.recv(1)
            if response != b'\xdd':
                log(f"[{__id__}] MTProto connection setup failed")
                sock.close()
                return socket.create_connection((dest_host, dest_port))
            
            log(f"[{__id__}] MTProto proxy connection established to {dest_host}:{dest_port}")
            return sock
            
        except Exception as e:
            log(f"[{__id__}] MTProto proxy error: {e}")
            if sock:
                try:
                    sock.close()
                except:
                    pass
            return socket.create_connection((dest_host, dest_port))

    def _test_proxy_connection(self, proxies):
        try:
            if not proxies:
                return True
                
            proxy_type = self.get_setting("proxy_type_set", 0)
            
            if proxy_type == 4:
                return self._test_mtproto_connection()
            
            test_url = "http://httpbin.org/ip"
            log(f"[{__id__}] Testing proxy connection to {test_url}")
            
            response = requests.get(test_url, proxies=proxies, timeout=10)
            if response.status_code == 200:
                log(f"[{__id__}] Proxy test successful: {response.json()}")
                return True
            else:
                log(f"[{__id__}] Proxy test failed with status: {response.status_code}")
                return False
                
        except Exception as e:
            log(f"[{__id__}] Proxy test failed: {e}")
            return False

    def _tcp_ping(self, host: str, port: int, timeout: int = 10) -> bool:
        """Simple TCP ping helper shared by proxy test methods."""
        try:
            sock = socket.create_connection((host, port), timeout)
            sock.close()
            return True
        except Exception as e:
            log(f"[{__id__}] TCP ping to {host}:{port} failed: {e}")
            return False

    def _parse_host_port(self, url_setting: str):
        """Extract host and port from a host:port or scheme://host:port string."""
        if not url_setting or ':' not in url_setting:
            return None, None
        if '://' in url_setting:
            url_setting = url_setting.split('://', 1)[1]
        host, port_str = url_setting.split(':', 1)
        try:
            return host, int(port_str)
        except ValueError:
            return None, None

    def _test_mtproto_connection(self):
        host, port = self._parse_host_port(self.get_setting('proxy_url_set','').strip())
        if not host:
            return False
        success = self._tcp_ping(host, port)
        if success:
            log(f"[{__id__}] MTProto proxy connection test successful")
        return success

    def _get_proxies(self):
        try:
            proxy_type = self.get_setting("proxy_type_set", 0)
            url = self.get_setting("proxy_url_set", "").strip()
            user = self.get_setting("proxy_username_set", "").strip()
            pwd = self.get_setting("proxy_password_set", "").strip()
            
            if not url or proxy_type == 0:
                return None, None
                
            proxies = None
            patch_type = None
            
            if proxy_type == 3:
                try:
                    import requests_html
                    hostport = url.split('://', 1)[-1] if '://' in url else url
                    if user and pwd:
                        scheme = f"socks5://{user}:{pwd}@{hostport}"
                    else:
                        scheme = f"socks5://{hostport}"
                    proxies = {"http": scheme, "https": scheme}
                    log(f"[{__id__}] SOCKS5 proxy configured: {scheme}")
                except ImportError:
                    log(f"[{__id__}] requests-html not available, using custom SOCKS implementation")
                    patch_type = "socks"
                        
            elif proxy_type in (1, 2):
                scheme = "http" if proxy_type == 1 else "https"
                
                clean_url = url
                if "://" in clean_url:
                    clean_url = clean_url.split("://", 1)[1]
                
                if user and pwd:
                    proxy_url = f"{scheme}://{user}:{pwd}@{clean_url}"
                else:
                    proxy_url = f"{scheme}://{clean_url}"
                
                proxies = {"http": proxy_url, "https": proxy_url}
                log(f"[{__id__}] HTTP/HTTPS proxy configured: {proxy_url}")
            
            elif proxy_type == 4:
                log(f"[{__id__}] MTProto proxy configured: {url}")
                patch_type = "mtproto"
            
            return proxies, patch_type
            
        except Exception as e:
            log(f"[{__id__}] Error configuring proxy: {e}")
            return None, None

    def on_plugin_load(self):
        hook_priority = self.get_setting("hook_priority_set", 1)
        try:
            priority = int(hook_priority)
        except:
            priority = 1
        self.add_on_send_message_hook(priority)
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            log(f"[downloader] VideoDownloaderPlugin loaded")
            self._cleanup_old_files()
            try:
                if self.get_setting("show_settings_buttons_set", True):
                    self._add_settings_menu_items()
            except Exception as e:
                log(f"[{__id__}] Failed to add settings menu items: {e}")
        else:
            log("[downloader] Failed to initialize temp directory")

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error creating temp dir: {e}")
            return None

    def _cleanup_old_files(self, max_age_hours=12):
        try:
            now = time.time()
            max_age_seconds = max_age_hours * 3600
            for file in self._temp_dir.listFiles():
                if file.isFile() and now - file.lastModified() / 1000 > max_age_seconds:
                    file.delete()
        except Exception as e:
            log(f"Cleanup error: {e}")

    def _http_post(self, url, proxies=None, patch_type=None, **kwargs):
        headers = kwargs.pop("headers", {}) or {}
        headers.setdefault("User-Agent", "Mozilla/5.0 (compatible; ExteraDownloader/1.0)")
        if patch_type:
            with self._proxy_connection_patch(patch_type):
                return requests.post(url, headers=headers, proxies=proxies, **kwargs)
        return requests.post(url, headers=headers, proxies=proxies, **kwargs)

    def _http_get(self, url, proxies=None, patch_type=None, **kwargs):
        headers = kwargs.pop("headers", {}) or {}
        headers.setdefault("User-Agent", "Mozilla/5.0 (compatible; ExteraDownloader/1.0)")
        if patch_type:
            with self._proxy_connection_patch(patch_type):
                return requests.get(url, headers=headers, proxies=proxies, **kwargs)
        return requests.get(url, headers=headers, proxies=proxies, **kwargs)

    def _show_premium_limit_dialog(self):
        msg = "Чтобы отправлять файлы больше 2 ГБ, подпишитесь на Telegram Premium." if Locale.getDefault().getLanguage().startswith('ru') else "Subscribe to Telegram Premium to send files larger than 2 GB."
        self.show_my_info_alert(title="Telegram Premium", message=msg, neutral_button="Premium", neutral_link="https://t.me/premium", neutral_type="link")
    def _try_download_with_api(self, api_url, video_url, payload, headers, proxies, patch_type):
        try:
            resp = self._http_post(f"{api_url}/", json=payload, headers=headers, timeout=30, proxies=proxies, patch_type=patch_type)
            resp.raise_for_status()
            data = resp.json()
            status = data.get("status")
            
            if status == "error":
                code = data.get("error", {}).get("code", "Unknown error")
                return None, f"API error: {code}"
            
            if status == "picker":
                items = data.get("picker", [])
                if not items:
                    return None, "No items to download"
                item = items[0]
                direct_url = item.get("url")
                filename = item.get("filename")
                item_type = item.get("type")
            else:
                direct_url = data.get("url")
                filename = data.get("filename")
                item_type = data.get("type")

            if not direct_url:
                return None, "Invalid API response"
                
            if not filename and item_type == "photo":
                filename = f"photo_{uuid.uuid4()}.jpg"
            return {"url": direct_url, "filename": filename, "type": item_type, "picker": items if status=="picker" else None}, None
            
        except Exception as e:
            return None, f"Request failed: {e}"

    def _download_video(self, video_url, mode_override=None):
        try:
            api_key = self.get_setting("api_key_set", "").strip()
            proxies, patch_type = self._get_proxies()
            if patch_type == "mtproto":
                if not self._test_mtproto_connection():
                    patch_type = None
            elif patch_type == "socks":
                if not self._test_socks_connection():
                    patch_type = None
            elif proxies:
                if not self._test_proxy_connection(proxies):
                    proxies = None
            self._current_proxies = proxies
            self._current_patch_type = patch_type
            
            quality_setting = self.get_setting("video_quality_set", 4)
            if isinstance(quality_setting, int) and 0 <= quality_setting < len(VIDEO_QUALITY_OPTIONS):
                video_quality = VIDEO_QUALITY_OPTIONS[quality_setting]
            else:
                video_quality = str(quality_setting)
            if 'youtube.com' in video_url.lower() or 'youtu.be' in video_url.lower():
                video_quality = VIDEO_QUALITY_OPTIONS[-1]
            
            payload = {
                "url": video_url,
                "videoQuality": video_quality
            }
            
            bitrate_idx = self.get_setting("audio_bitrate_set", 5)
            if isinstance(bitrate_idx, int) and 0 <= bitrate_idx < len(AUDIO_BITRATE_OPTIONS):
                audio_bitrate = AUDIO_BITRATE_OPTIONS[bitrate_idx]
            else:
                audio_bitrate = "128"
            if audio_bitrate not in AUDIO_BITRATE_OPTIONS:
                audio_bitrate = "128"
            if 'youtube.com' in video_url.lower() or 'youtu.be' in video_url.lower():
                audio_bitrate = AUDIO_BITRATE_OPTIONS[-1]
            payload["audioBitrate"] = audio_bitrate
            payload["convertGif"] = True
            
            if mode_override:
                payload["downloadMode"] = mode_override
            else:
                payload["downloadMode"] = "auto"

            headers = {"Accept": "application/json", "Content-Type": "application/json"}
            if api_key:
                headers["Authorization"] = f"Api-Key {api_key}"

            api_list = []
            
            api_idx = self.get_setting("api_url_choice_set", 0)
            custom = self.get_setting("api_url_set", "")
            
            if api_idx < len(COBALT_API):
                api_list.append(COBALT_API[api_idx].rstrip('/'))
            else:
                if custom:
                    api_list.append(custom.rstrip('/'))
            
            if self.get_setting("auto_fallback_set", True):
                for i, api in enumerate(COBALT_API):
                    if i != api_idx:
                        api_list.append(api.rstrip('/'))
                if api_idx >= len(COBALT_API) and custom:
                    pass
                elif api_idx < len(COBALT_API) and custom:
                    api_list.append(custom.rstrip('/'))
            
            last_error = None
            for i, api_url in enumerate(api_list):
                try:
                    result, error = self._try_download_with_api(api_url, video_url, payload, headers, proxies, patch_type)
                    if result:
                        direct_url = result["url"]
                        filename = result.get("filename")
                        item_type = result.get("type")
                        self._last_item_type = item_type
                        self._picker_items = result.get("picker")
                        break
                    else:
                        last_error = error
                        continue
                except Exception as e:
                    last_error = f"API {api_url} failed: {e}"
                    continue
            else:
                if len(api_list) > 1:
                    BulletinHelper.show_error(f"All {len(api_list)} APIs failed. Last error: {last_error}")
                else:
                    BulletinHelper.show_error(f"API failed: {last_error}")
                return None
            if not filename:
                if self._last_item_type == "photo":
                    filename = f"photo_{uuid.uuid4()}.jpg"
                else:
                    filename = f"video_{uuid.uuid4()}.mp4"
            file_path = File(self._temp_dir, filename).getAbsolutePath()

            try:
                self._set_progress(1)
                video_resp = self._http_get(direct_url, stream=True, timeout=60, proxies=proxies, patch_type=patch_type)
                video_resp.raise_for_status()
            except Exception as e:
                raise
                
            content_length = video_resp.headers.get("content-length")
            total_length = int(content_length) if content_length else 0
            limit_bytes = PREMIUM_LIMIT if _is_premium_user() else FREE_LIMIT
            if total_length and total_length > limit_bytes:
                if not _is_premium_user():
                    self._show_premium_limit_dialog()
                else:
                    BulletinHelper.show_error("File too large (>4 GB)")
                return None
            downloaded = 0

            with open(file_path, "wb") as f:
                for chunk in video_resp.iter_content(chunk_size=8192):
                    if self._cancel_requested:
                        try:
                            os.remove(file_path)
                        except Exception:
                            pass
                        return None
                    f.write(chunk)
                    if total_length:
                        downloaded += len(chunk)
                        percent = int(downloaded * 100 / total_length)
                        self._set_progress(percent)

            return file_path
            
        except Exception as e:
            self._dismiss_dialog()
            log(f"[downloader] Download error: {e}\n{traceback.format_exc()}")
            BulletinHelper.show_error(f"Download error: {e}")
            return None

    def send_video(self, video_path: str, dialog_id: int, caption: str = None, notify: bool = True, schedule_date: int = 0, reply_to_msg=None, reply_to_top_msg=None, entities=None):
        ttl = 0
        force_document = False
        has_media_spoilers = False
        cover_path = None
        quick_reply_shortcut = None
        quick_reply_shortcut_id = 0
        effect_id = 0
        stars = 0
        log(f"[downloader] VideoDownloaderPlugin: send_video entry for path: {video_path}, dialog: {dialog_id} (from background thread)")
        ext = os.path.splitext(video_path)[1].lower()
        if ext in [".mp3", ".wav", ".ogg", ".opus", ".m4a"]:
            return self.send_audio(video_path, dialog_id, caption, notify, schedule_date, reply_to_msg, reply_to_top_msg)
        try:
            account_instance = get_account_instance()
            if account_instance is None:
                log("[downloader] Error: Could not get AccountInstance.")
                return
            if caption and entities is None:
                mdc = get_media_data_controller()
                if mdc:
                    entities = mdc.getEntities([caption], True)

            self._prepare_sending_video_safe(
                account_instance,
                video_path,
                dialog_id,
                reply_to_msg,
                reply_to_top_msg,
                entities,
                notify,
                schedule_date,
                force_document,
                has_media_spoilers,
                caption,
                quick_reply_shortcut,
                quick_reply_shortcut_id,
                effect_id,
                stars
            )
            log(f"[downloader] Video sending initiated for path: {video_path} to dialog: {dialog_id} (from background thread)")

        except Exception as e:
            log(f"[downloader] Error preparing video for sending in background thread: {e}\n{traceback.format_exc()}")
            BulletinHelper.show_error(f"Error sending video: {e}")

    def send_audio(self, audio_path: str, dialog_id: int, caption: str = None, notify: bool = True, schedule_date: int = 0, reply_to_msg=None, reply_to_top_msg=None):
        log(f"[downloader] VideoDownloaderPlugin: send_audio entry for path: {audio_path}, dialog: {dialog_id}")
        try:
            account_instance = get_account_instance()
            if account_instance is None:
                log("[downloader] Error: Could not get AccountInstance.")
                return
            import mimetypes
            mime, _ = mimetypes.guess_type(audio_path)
            if mime is None:
                ext = os.path.splitext(audio_path)[1].lower()
                if ext == ".mp3":
                    mime = "audio/mpeg"
                elif ext == ".wav":
                    mime = "audio/wav"
                elif ext in [".ogg", ".opus", ".m4a"]:
                    mime = "audio/ogg"
                else:
                    mime = "application/octet-stream"
            ext_cache_root = ApplicationLoader.applicationContext.getExternalCacheDir()
            plugin_ext_dir = File(ext_cache_root, TEMP_DIR_NAME)
            if not plugin_ext_dir.exists() and not plugin_ext_dir.mkdirs():
                log("[downloader] Failed to create external temp dir")
            external_path = File(plugin_ext_dir, File(audio_path).getName()).getAbsolutePath()
            with open(audio_path, 'rb') as f_in, open(external_path, 'wb') as f_out:
                while True:
                    chunk = f_in.read(8192)
                    if not chunk:
                        break
                    f_out.write(chunk)
            audio_path = external_path
            SendMessagesHelper.prepareSendingDocument(
                account_instance,
                audio_path,
                audio_path,
                None,
                caption,
                mime,
                dialog_id,
                reply_to_msg, reply_to_top_msg, None, None, None,
                notify, schedule_date, None, None, 0, False
            )
        except Exception as e:
            log(f"[downloader] Error preparing audio for sending: {e}, type: {type(e)}")
            log(f"[downloader] {traceback.format_exc()}")
            BulletinHelper.show_error(f"Error sending audio: {e}")

    def _delete_file_delayed(self, path, delay=60):
        def action():
            try:
                time.sleep(delay)
                if os.path.exists(path):
                    os.remove(path)
                    log(f"[downloader] Deleted temp file: {path}")
            except Exception as e:
                log(f"[downloader] Delayed delete error: {e}")

        threading.Thread(target=action, daemon=True).start()

    def _process_download_and_send(self, url, dialog_id, notify, schedule_date, mode_override=None, reply_to_msg=None, reply_to_top_msg=None):
        if not self._task_in_progress.acquire(blocking=False):
            BulletinHelper.show_error("Another download is already running")
            return
        try:
            video_path = self._download_video(url, mode_override)
            if video_path:
                if os.path.exists(video_path):
                    log(f"[downloader] File exists, proceeding to send: {video_path}")
                    ext = os.path.splitext(video_path)[1].lower()
                    if self._last_item_type == "photo":
                        ext = ".jpg"
                    include_source = self.get_setting("include_source_set", True)
                    caption_text = url if include_source else None
                    account_instance = get_account_instance()
                    if self._last_item_type == "photo" and self._picker_items and len(self._picker_items) > 1:
                        photo_paths = []
                        total_photos = len(self._picker_items)
                        self._set_progress(1)
                        try:
                            for idx, it in enumerate(self._picker_items):
                                if self._cancel_requested:
                                    break
                                p_url = it.get("url")
                                if not p_url:
                                    continue
                                p_filename = it.get("filename") or f"photo_{uuid.uuid4()}.jpg"
                                p_path = File(self._temp_dir, p_filename).getAbsolutePath()
                                resp = self._http_get(p_url, stream=True, timeout=30, proxies=self._current_proxies, patch_type=self._current_patch_type)
                                resp.raise_for_status()
                                with open(p_path, "wb") as pf:
                                    for chunk in resp.iter_content(chunk_size=8192):
                                        if self._cancel_requested:
                                            break
                                        pf.write(chunk)
                                if self._cancel_requested:
                                    break
                                photo_paths.append(p_path)
                                percent_album = int((len(photo_paths) * 100) / total_photos)
                                self._set_progress(percent_album)
                        except Exception as e:
                            log(f"[downloader] Album download error: {e}")
                        if self._cancel_requested:
                            for p_path in photo_paths:
                                self._delete_file_delayed(p_path, delay=1)
                            self._dismiss_dialog()
                            return
                        if photo_paths:
                            self._set_progress(99)
                            media_list = ArrayList()
                            for idx, p_path in enumerate(photo_paths):
                                info = SendMessagesHelper.SendingMediaInfo()
                                info.path = p_path
                                if caption_text and idx == 0:
                                    info.caption = caption_text
                                media_list.add(info)
                            self._prepare_sending_media_safe(
                                account_instance,
                                media_list,
                                dialog_id,
                                reply_to_msg,
                                reply_to_top_msg,
                                notify,
                                schedule_date
                            )
                            for p_path in photo_paths:
                                self._delete_file_delayed(p_path)
                            self._dismiss_dialog()
                            return

                    if ext == ".gif":
                        self._send_gif_as_document(video_path, dialog_id, caption_text, notify, schedule_date, reply_to_msg, reply_to_top_msg)
                        self._delete_file_delayed(video_path)
                        self._dismiss_dialog()
                        return
                    
                    if ext in IMAGE_EXTS:
                        if include_source:
                            entities = ArrayList()
                            ent = TLRPC.TL_messageEntityTextUrl()
                            ent.offset = 0
                            ent.length = 6
                            ent.url = url
                            entities.add(ent)
                            SendMessagesHelper.prepareSendingPhoto(
                                account_instance, 
                                video_path, 
                                None, 
                                dialog_id,
                                reply_to_msg, 
                                reply_to_top_msg, 
                                None, 
                                "Source", 
                                entities,
                                None, 
                                None, 
                                0, 
                                None, 
                                notify, 
                                schedule_date,
                                0, 
                                None, 
                                0
                            )
                        else:
                            SendMessagesHelper.prepareSendingPhoto(
                                account_instance, 
                                video_path, 
                                None, 
                                dialog_id,
                                reply_to_msg, 
                                reply_to_top_msg, 
                                None, 
                                None, 
                                None,
                                None, 
                                None, 
                                0, 
                                None, 
                                notify, 
                                schedule_date,
                                0, 
                                None, 
                                0
                            )
                    elif ext in AUDIO_EXTS:
                        self.send_audio(video_path, dialog_id, caption_text, notify, schedule_date, reply_to_msg, reply_to_top_msg)
                    else:
                        if include_source:
                            entities = ArrayList()
                            ent = TLRPC.TL_messageEntityTextUrl()
                            ent.offset = 0
                            ent.length = 6
                            ent.url = url
                            entities.add(ent)
                            self.send_video(video_path, dialog_id, "Source", notify, schedule_date, reply_to_msg, reply_to_top_msg, entities)
                        else:
                            self.send_video(video_path, dialog_id, None, notify, schedule_date, reply_to_msg, reply_to_top_msg)
                    self._delete_file_delayed(video_path)
                    self._dismiss_dialog()
                else:
                    log(f"[downloader] Downloaded file not found after download: {video_path}")
                    BulletinHelper.show_error(f"Internal error: File not found after download")
                    self._dismiss_dialog()
                    return
            else:
                log(f"[downloader] Failed to download video for url: {url}")
                self._dismiss_dialog()
                return

        except Exception as e:
            self._dismiss_dialog()
            log(f"[downloader] Error in _process_download_and_send: {e}\n{traceback.format_exc()}")
            BulletinHelper.show_error(f"An unexpected error occurred: {e}")
        finally:
            self._task_in_progress.release()

    def _dismiss_dialog(self):
        global progress_dialog
        def action():
            global progress_dialog
            if progress_dialog is not None:
                try:
                    dlg = progress_dialog.get_dialog() if hasattr(progress_dialog, 'get_dialog') else progress_dialog
                    if dlg and dlg.isShowing():
                        dlg.dismiss()
                except Exception:
                    pass
                finally:
                    progress_dialog = None
        run_on_ui_thread(action)

    def _show_loading_alert(self):
        global progress_dialog
        self._cancel_requested = False
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
        builder.set_title(Z("downloading"))
        builder.set_negative_button(Z("cancel"), self._on_progress_cancel)
        builder.set_cancelable(False)
        progress_dialog = builder.show()
        progress_dialog.set_progress(0)

    def _on_progress_cancel(self, builder, which):
        self._cancel_requested = True
        self._dismiss_dialog()

    def _copy_to_clipboard(self, label, text):
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
        clip = ClipData.newPlainText(label, text)
        clipboard.setPrimaryClip(clip)
        BulletinHelper.show_info(f"Copied {label} to clipboard")

    def _open_link(self, url):
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
        run_on_ui_thread(lambda: ctx.startActivity(intent))

    def _open_tg_link(self, path: str):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            if "/" in path:
                domain, post = path.split("/", 1)
                intent = Intent(Intent.ACTION_VIEW, Uri.parse(f"tg://resolve?domain={domain}&post={post}"))
                run_on_ui_thread(lambda: ctx.startActivity(intent))
            else:
                mc = get_messages_controller()
                run_on_ui_thread(lambda: mc.openByUserName(path, fragment, 1))
        except Exception as e:
            log(f"[{__id__}] Failed to open tg link: {e}")


    def show_my_info_alert(self, title="TITLE", message="MESSAGE", positive_button="OK", neutral_button=None, neutral_link=None, neutral_type=None):
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda b, w: self._dismiss_dialog(b))
        if neutral_button:
            if neutral_type == "link":
                builder.set_neutral_button(neutral_button, lambda b, w: self._open_link(neutral_link))
            else:
                builder.set_neutral_button(neutral_button, lambda b, w: self._copy_to_clipboard(neutral_button, neutral_link))
        self.alert_builder_instance = builder.show()

    def _on_show_settings_buttons_change(self, enabled: bool):
        def _toggle():
            try:
                if enabled:
                    if not self._drawer_settings_item:
                        self._drawer_settings_item = self.add_menu_item(MenuItemData(
                            menu_type=MenuItemType.DRAWER_MENU,
                            text=Z("settings_title"),
                            icon="msg_settings_14",
                            priority=5,
                            on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))
                        ))
                    if not self._chat_settings_item:
                        self._chat_settings_item = self.add_menu_item(MenuItemData(
                            menu_type=MenuItemType.CHAT_ACTION_MENU,
                            text=Z("settings_title"),
                            icon="msg_settings_14",
                            priority=5,
                            on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))
                        ))
                else:
                    if self._drawer_settings_item:
                        self.remove_menu_item(self._drawer_settings_item)
                        self._drawer_settings_item = None
                    if self._chat_settings_item:
                        self.remove_menu_item(self._chat_settings_item)
                        self._chat_settings_item = None
            except Exception as e:
                log(f"[{__id__}] Failed toggling settings buttons: {e}")
        run_on_ui_thread(_toggle)

    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        msg = params.message.strip()
        if self.get_setting("auto_link_set", False):
            import re, urllib.parse, threading as _t
            if re.fullmatch(r"https?://\S+", msg):
                parsed = urllib.parse.urlparse(msg)
                host_full = (parsed.hostname or "").lower().lstrip("www.")
                parts = host_full.split('.')
                base = '.'.join(parts[-2:]) if len(parts) >= 2 else host_full
                group_key = BASE_TO_GROUP.get(base)
                if group_key and group_key in self._get_auto_link_services():
                        if self._task_in_progress.locked():
                            BulletinHelper.show_error("Another download is already running")
                            return HookResult(strategy=HookStrategy.CANCEL)
                        _t.Thread(target=self._process_download_and_send, args=(msg, params.peer, True, 0, None, getattr(params, 'replyToMsg', None), getattr(params, 'replyToTopMsg', None)), daemon=True).start()
                        run_on_ui_thread(lambda: self._show_loading_alert())
                        return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".down ") or msg.startswith(".up ") or msg.startswith(".dl "):
            parts = msg.split()
            mode_override = None
            if len(parts) > 2:
                mode_override = parts[2].lower()
            if len(parts) < 2 or not parts[1]:
                BulletinHelper.show_error("No URL provided")
                return HookResult(strategy=HookStrategy.CANCEL)

            url = parts[1].strip()
            dialog_id = params.peer
            notify = True
            schedule_date = 0

            log(f"[downloader] Received command: {msg}. Starting background thread for URL: {url}")

            if self._task_in_progress.locked():
                BulletinHelper.show_error("Another download is already running")
                return HookResult(strategy=HookStrategy.CANCEL)
            thread = threading.Thread(
                target=self._process_download_and_send,
                args=(url, dialog_id, notify, schedule_date, mode_override, params.replyToMsg, params.replyToTopMsg),
                daemon=True
            )
            thread.start()

            log("[downloader] Background thread started. Cancelling original message.")
            run_on_ui_thread(lambda: self._show_loading_alert())
            return HookResult(strategy=HookStrategy.CANCEL)

        return HookResult()

    def _download_with_downloadmanager(self, url, filename):
        try:
            download_manager = ApplicationLoader.applicationContext.getSystemService(Context.DOWNLOAD_SERVICE)
            request = DownloadManager.Request(Uri.parse(url))
            request.setTitle("Downloading media")
            request.setDescription("Downloading via DownloadManager")
            request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE)
            
            file_path = File(self._temp_dir, filename).getAbsolutePath()
            request.setDestinationUri(Uri.fromFile(File(file_path)))
            
            download_id = download_manager.enqueue(request)
            
            query = DownloadManager.Query()
            query.setFilterById(download_id)
            
            while True:
                cursor = download_manager.query(query)
                if cursor.moveToFirst():
                    status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS))
                    if status == DownloadManager.STATUS_SUCCESSFUL:
                        return file_path
                    elif status == DownloadManager.STATUS_FAILED:
                        raise Exception("Download failed")
                time.sleep(1)
            
        except Exception as e:
            log(f"[downloader] DownloadManager error: {e}")
            return None

    def _send_gif_as_document(self, gif_path, dialog_id, caption, notify, schedule_date, reply_to_msg=None, reply_to_top_msg=None):
        try:
            account_instance = get_account_instance()
            if account_instance is None:
                log("[downloader] Error: Could not get AccountInstance.")
                return
            
            ext_cache_root = ApplicationLoader.applicationContext.getExternalCacheDir()
            plugin_ext_dir = File(ext_cache_root, TEMP_DIR_NAME)
            if not plugin_ext_dir.exists() and not plugin_ext_dir.mkdirs():
                log("[downloader] Failed to create external temp dir")
            
            external_path = File(plugin_ext_dir, "animation.gif").getAbsolutePath()
            with open(gif_path, 'rb') as f_in, open(external_path, 'wb') as f_out:
                while True:
                    chunk = f_in.read(8192)
                    if not chunk:
                        break
                    f_out.write(chunk)
            
            SendMessagesHelper.prepareSendingDocument(
                account_instance, 
                external_path, 
                external_path, 
                None, 
                caption, 
                "image/gif", 
                dialog_id,
                reply_to_msg, 
                reply_to_top_msg, 
                None, 
                None, 
                None,
                notify, 
                schedule_date, 
                None, 
                None, 
                0, 
                False
            )
            
            log(f"[downloader] GIF sent successfully: {external_path}")
            
        except Exception as e:
            log(f"[downloader] Error sending GIF: {e}\n{traceback.format_exc()}")
            BulletinHelper.show_error(f"Error sending GIF: {e}")

    def _test_current_proxy(self):
        def test_proxy():
            try:
                proxy_type = self.get_setting("proxy_type_set", 0)
                if proxy_type == 0:
                    return
                
                if proxy_type == 4:
                    success = self._test_mtproto_connection()
                elif proxy_type == 3:
                    success = self._test_socks_connection()
                else:
                    proxies, _ = self._get_proxies()
                    success = self._test_proxy_connection(proxies) if proxies else False
                
                if success:
                    BulletinHelper.show_success("Тест подключения прокси успешен!" if Locale.getDefault().getLanguage().startswith('ru') else "Proxy connection test successful!")
                else:
                    BulletinHelper.show_error("Тест подключения прокси не удался" if Locale.getDefault().getLanguage().startswith('ru') else "Proxy connection test failed")
                    
            except Exception as e:
                log(f"[{__id__}] Proxy test error: {e}")
                BulletinHelper.show_error(f"Ошибка теста прокси: {e}" if Locale.getDefault().getLanguage().startswith('ru') else f"Proxy test error: {e}")
        
        threading.Thread(target=test_proxy, daemon=True).start()

    def _test_socks_connection(self):
        host, port = self._parse_host_port(self.get_setting('proxy_url_set','').strip())
        if not host:
            return False
        success = self._tcp_ping(host, port)
        if success:
            log(f"[{__id__}] SOCKS proxy connection test successful")
        return success
