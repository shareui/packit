"""



                            Ð”Ð˜Ð¡ÐšÐ›Ð•Ð™ÐœÐ•Ð 

Ð•ÑÐ»Ð¸ Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ ÑÐ²Ð¾ÐµÐ³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° Ð²Ñ‹ Ñ€ÐµÑˆÐ¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹Ðµ ÐºÐ¾Ð´Ð¾Ð²Ñ‹Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ
Ð½Ð°ÑˆÐµÐ³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° Ñƒ ÑÐµÐ±Ñ, Ñ‚Ð¾ Ð½Ðµ Ð·Ð°Ð±ÑƒÐ´ÑŒÑ‚Ðµ ÑƒÐ¿Ð¾Ð¼ÑÐ½ÑƒÑ‚ÑŒ Ð² Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ð¸ ÑÐ²Ð¾ÐµÐ³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°
ÐºÐ°Ð½Ð°Ð» @MeeowPlugins Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ ÐºÑ€ÐµÐ´Ð¸Ñ‚Ð¾Ð² Ð·Ð° Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒ Ð² Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°. Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾


                  â£¾â¡‡â£¿â£¿â¡‡â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£„â¢»â£¦â¡€â â¢¸â¡Œâ »â£¿â£¿â£¿â¡½â£¿â£¿
                  â¡‡â£¿â ¹â£¿â¡‡â¡Ÿâ ›â£‰â â ‰â ‰â »â¡¿â£¿â£¿â£¿â£¿â£¿â£¦â£„â¡‰â ‚â ˆâ ™â¢¿â£¿â£â£¿
                  â ¤â¢¿â¡„â ¹â£§â£·â£¸â¡‡â „â „â ²â¢°â£Œâ£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¶â£¤â£¤â¡€â „â ˆâ »â¢®
                  â „â¢¸â£§â „â¢˜â¢»â£¿â¡‡â¢€â£€â „â£¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£§â¡€â „â¢€
                  â „â ˆâ£¿â¡†â¢¸â£¿â£¿â£¿â£¬â£­â£´â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¯â â ›â ›â ™â¢¿â¡¿â ƒâ „â¢¸
                  â „â „â¢¿â£¿â¡€â£¿â£¿â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¿â£¿â£¿â£¿â¡¾â â¢ â¡‡â¢€
                  â „â „â¢¸â£¿â¡‡â »â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£â£«â£»â¡Ÿâ¢€â „â£¿â£·â£¾
                  â „â „â¢¸â£¿â¡‡â „â ˆâ ™â ¿â£¿â£¿â£¿â£®â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â¢ â Šâ¢€â¡‡â£¿â£¿
                  â ’â ¤â „â£¿â¡‡â¢€â¡²â „â „â ˆâ ™â »â¢¿â£¿â£¿â ¿â ¿â Ÿâ ›â ‹â â£°â ‡â „â¢¸â£¿â£¿â£¿



                            DISCLAIMER

If, when creating your plugin, you decided to use the ready-made code solutions
of our plugin, then do not forget to mention the @MeeowPlugins channel in the description
of your plugin as credits for help in developing your plugin. Thanks



"""

import colorsys
import datetime
import json
import math
import os
import random
import re
import textwrap
import threading
import time
import requests

from dataclasses import dataclass
from enum import Enum
from secrets import choice
from typing import Optional, Any, Callable, List, Dict
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance

from android.content import Intent # type: ignore
from android.graphics import Color # type: ignore
from android.net import Uri # type: ignore
from android.view import View, Gravity, ViewGroup, MotionEvent # type: ignore
from android.widget import LinearLayout, FrameLayout, ScrollView, TextView # type: ignore

from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Selector, Input, Divider, Header, Switch, Text, EditText

from android_utils import log, run_on_ui_thread
from hook_utils import set_private_field, get_private_field, find_class
from markdown_utils import parse_markdown
from base_plugin import (
    BasePlugin,
    HookResult,
    HookStrategy,
    MenuItemData,
    MenuItemType,
    MethodHook
)
from client_utils import (
    get_last_fragment,
    get_user_config,
    get_send_messages_helper,
    send_message,
    get_messages_controller,
    send_request,
    get_messages_storage,
    get_account_instance
)

from com.exteragram.messenger.plugins import PluginsController # type: ignore
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity # type: ignore
from com.exteragram.messenger.utils import AppUtils # type: ignore

from java import dynamic_proxy # type: ignore
from java.io import File # type: ignore
from java.lang import Integer, Math, Class, Boolean, Integer, Float # type: ignore
from java.lang.reflect import Array, Modifier # type: ignore
from java.util import ArrayList, Locale # type: ignore

from org.telegram.messenger import ApplicationLoader, R, AndroidUtilities, SendMessagesHelper, MessageObject, MediaController, ChatObject # type: ignore
from org.telegram.tgnet import TLRPC # type: ignore
from org.telegram.tgnet.tl import TL_account # type: ignore
from org.telegram.ui import ChatActivity # type: ignore
from org.telegram.ui.Stories.recorder import ButtonWithCounterView # type: ignore
from org.telegram.ui.Components import LayoutHelper # type: ignore


# === METADATA ===

__id__ = "reswag"
__name__ = "reSwaga"
__description__ = "ÐŸÐ»Ð°Ð³Ð¸Ð½ Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸/Ð°ÑƒÐ´Ð¸Ð¾ Ñ„Ð°Ð¹Ð»Ð° Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ñ‚Ñ€ÐµÐºÐ° Ð´Ð»Ñ Ð¼ÑƒÐ·Ñ‹ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐµÑ€Ð²Ð¸ÑÐ¾Ð²."
__icon__ = "remusic/5"
__version__ = "1.4.2"
__author__ = "@meeowPlugins"
__min_version__ = "12.0.1"

# === METADATA ===


TEMP_DIR_NAME: str = 'swaga_temp'
RESOURCE_DIR_NAME: str = "resources"
RESOURCES: List[str] = [
    "Onest-Regular.ttf",
    "Onest-Bold.ttf",
    "Onest.ttf",
    "NotoSansJP-Regular.ttf",
    "NotoSansJP-Bold.ttf",
    "Circular-Regular.ttf",
    "Circular-Bold.ttf",
    "YSMusic-Bold.ttf",
    "YSMusic-Regular.ttf",
    "YSText-Bold.ttf",
    "YSText-Regular.ttf",
]

DOWNLOAD_URL: str = "https://raw.githubusercontent.com/cherryymerryy/reSwaga/main/"

EMPTY_TRACK_COVER: str = DOWNLOAD_URL + 'resources/img/empty_cover.png'

PLATFORMS_COUNT: int = 7

DEFAULT_LASTFM_API_URL: str = "19e0b83fb81f7043c02e4f070848a57a"
DEFAULT_COBALT_API_URL: str = 'https://cobalt.255x.ru'
DEFAULT_API_URL: str = "https://your.api.url"
DEFAULT_STREAM_STRING: str = "ðŸŽµ | {title} â€” {artists}"
DEFAULT_VALUE: str = "platform value"
DEFAULT_STREAM_TEXT: str = "ðŸ¤™"
DEFAULT_INSTANT_SUBTEXT: str = "Powered by"
DEFAULT_INSTANT_MAIN_TEXT: str = __name__

RESWAGA_TAB_INDEX = 3
VIEW_TAG = "RESWAGA_CUSTOM_TAB_VIEW_TAG"

FONTS: Dict[int, str] = {
    0: "Onest",
    1: "Circular",
    2: "NotoSansJP",
    3: "YSMusic",
    4: "YSText"
}
DEFAULT_COLOR: Dict[str, str] = {
    "background_color": "#000000",
    "title_text_color": "#FFFFFF",
    "subtext_color": "#A0A0A0"
}
COBALT_API_URLS = [
    'Custom',
    DEFAULT_COBALT_API_URL,
    "https://co.eepy.today",
    "https://co.otomir23.me",
]

MIN_LIGHTNESS_FOR_TEXT = 0.725
MAX_LIGHTNESS_FOR_TEXT = 0.25
LIGHTNESS_THRESHOLD = 0.5


def logcat(message: Any): log(f"[{__id__}] {message}")


def to_json(obj: Any): return AppUtils.getGson().toJson(obj)


def show_error(message: str, on_click: Optional[Callable] = None, button_text: str = ""):
    if on_click is None:
        BulletinHelper.show_error(f"[{__name__}] {message}")
    elif on_click is not None and button_text != "":
        BulletinHelper.show_with_button(f"[{__name__}] {message}", R.raw.error, button_text, lambda: on_click())
    else:
        BulletinHelper.show_error(f"[{__name__}] {message}")


def show_info(message: str, on_click: Optional[Callable] = None, button_text: str = ""):
    if on_click is None:
        BulletinHelper.show_info(f"[{__name__}] {message}")
    elif on_click is not None and button_text != "":
        BulletinHelper.show_with_button(f"[{__name__}] {message}", R.raw.info, button_text, lambda: on_click())
    else:
        BulletinHelper.show_error(f"[{__name__}] {message}")


def show_success(message: str, on_click: Optional[Callable] = None, button_text: str = ""):
    if on_click is None:
        BulletinHelper.show_success(f"[{__name__}] {message}")
    elif on_click is not None and button_text != "":
        BulletinHelper.show_with_button(f"[{__name__}] {message}", R.raw.success, button_text, lambda: on_click())
    else:
        BulletinHelper.show_success(f"[{__name__}] {message}")


def get_temp_dir() -> Optional[File]:
    try:
        base_dir = ApplicationLoader.getFilesDirFixed()
        if not base_dir:
            return None
        temp_dir = File(base_dir.getAbsolutePath(), f"plugins/{RESOURCE_DIR_NAME}")
        if not temp_dir.exists() and not temp_dir.mkdirs():
            return None
        return temp_dir
    except Exception as e:
        logcat(f"Error getting/creating temp directory: {e}")
        return None


def download_file(url: str, file_path: str):
    if url is None or url == "":
        logcat("No URL provided to download.")
        return

    if file_path is None or file_path == "":
        logcat("No file_path provided to download.")
        return

    name = url.split("/").pop()

    try:
        logcat(f"Downloading {name}...")

        response = requests.get(url, timeout=15)
        response.raise_for_status()
        content = response.content

        if content:
            with open(file_path, "wb") as f:
                f.write(content)
            logcat(f"Successfully downloaded {name}.")
        else:
            logcat(f"Downloaded empty file for {name}.")

    except requests.exceptions.HTTPError as e:
        show_error(f"Failed to download {name}. Server returned error: {e}")
        logcat(f"Failed to download {name}. Server returned error: {e}")
    except requests.exceptions.RequestException as e:
        show_error(f"Failed to download {name} due to a network error: {e}")
        logcat(f"Failed to download {name} due to a network error: {e}")
    except IOError as e:
        show_error(f"Failed to save {name}. Permission or disk error: {e}")
        logcat(f"Failed to save {name}. Permission or disk error: {e}")
    except Exception as e:
        show_error(f"An unexpected error occurred while downloading {name}: {e}")
        logcat(f"An unexpected error occurred while downloading {name}: {e}")


def open_plugin_settings():
    try:
        java_plugin = PluginsController.getInstance().plugins.get(__id__)
        if java_plugin:
            run_on_ui_thread(lambda: get_last_fragment().presentFragment(PluginSettingsActivity(java_plugin)))
    except Exception as e:
        logcat(f"Error opening plugin settings: {e}")


def open_link(url: str):
    fragment = get_last_fragment()
    ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
    intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
    run_on_ui_thread(lambda: ctx.startActivity(intent))


def open_tg_link(path: str):
    try:
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        if "/" in path:
            domain, post = path.split("/", 1)
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(f"tg://resolve?domain={domain}&post={post}"))
            run_on_ui_thread(lambda: ctx.startActivity(intent))
        else:
            mc = get_messages_controller()
            run_on_ui_thread(lambda: mc.openByUserName(path, fragment, 1))
    except Exception as e:
        log(f"[{__id__}] Failed to open tg link: {e}")


class LocaleController:
    def __init__(self):
        super().__init__()
        self.language: str = Locale.getDefault().getLanguage()

    def get_controller(self):
        if self.language == "ru":
            return self.LanguageRussian()
        # elif self.language == "pt":
        #     return self.lang_ptbr()
        else:
            return self.LanguageEnglish()

    class LanguageRussian:
        language = "ru"

        Settings_Auth_Header = "Ð¡ÐµÑ€Ð²Ð¸Ñ Ð¸ ÐÐ²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ"
        Settings_Auth_Platform = "Ð¡ÐµÑ€Ð²Ð¸Ñ"
        Settings_Auth_Value_Text = "Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"
        Settings_Auth_Value_NotSelected_Text = "â€”"
        Settings_Auth_Value_Spotify_Text = "Ð®Ð·ÐµÑ€Ð½ÐµÐ¹Ð¼"
        Settings_Auth_Value_YandexMusic_Text = "Ð¢Ð¾ÐºÐµÐ½"
        Settings_Auth_Value_SoundCloud_Text = "Ð¢Ð¾ÐºÐµÐ½"

        Settings_YandexMusic_LoginGuide = "ÐŸÐµÑ€ÐµÐ¹Ð´Ð¸Ñ‚Ðµ Ðº Ð¸Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ð¸ Ð¿Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸ÑŽ Ñ‚Ð¾ÐºÐµÐ½Ð°, Ð²Ð¾Ð¹Ð´Ð¸Ñ‚Ðµ Ð² Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð¯Ð½Ð´ÐµÐºÑÐ° Ð¸ Ð²ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ñ‚Ð¾ÐºÐµÐ½ Ð½Ð¸Ð¶Ðµ."
        Settings_VkMusic_LoginGuide = "ÐŸÐµÑ€ÐµÐ¹Ð´Ð¸Ñ‚Ðµ Ð½Ð° ÑÐ°Ð¹Ñ‚ Ð¸ Ð¸Ð·ÑƒÑ‡Ð¸Ñ‚Ðµ ÐºÐ°Ðº Ð½ÑƒÐ¶Ð½Ð¾ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½, Ð¿Ð¾ÑÐ»Ðµ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ 'vk.com'"

        Settings_CobaltApi_Text = 'Cobalt API'
        Settings_CobaltApi_Subtext = 'ÐŸÑ€Ð¾ÑÐ¸Ð¼ Ð½Ðµ Ð¼ÐµÐ½ÑÑ‚ÑŒ ÑÑ‚Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÐµÑÐ»Ð¸ Ð½Ðµ Ð·Ð½Ð°ÐµÑ‚Ðµ Ð·Ð° Ñ‡Ñ‚Ð¾ Ð¾Ð½Ð¾ Ð¾Ñ‚Ð²ÐµÑ‡Ð°ÐµÑ‚ Ð¸ Ð·Ð°Ñ‡ÐµÐ¼ Ð¾Ð½Ð¾ Ð½ÑƒÐ¶Ð½Ð¾.'
        Settings_CobaltApi_Custom_Text = 'ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ Cobalt API'

        Settings_CardSettings_Header = "Ð’Ð½ÐµÑˆÐ½Ð¸Ð¹ Ð²Ð¸Ð´"

        Settings_CardType_Header = "Ð¡Ñ‚Ð¸Ð»ÑŒ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸"
        Settings_CardType_1 = "Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð°Ñ"
        Settings_CardType_2 = "Ð’ÐµÑ€Ñ‚Ð¸ÐºÐ°Ð»ÑŒÐ½Ð°Ñ "

        Settings_BackgroundMode_Text = "Ð¤Ð¾Ð½"
        Settings_BackgroundMode_Item_1 = "ÐžÐ±Ð»Ð¾Ð¶ÐºÐ° Ñ‚Ñ€ÐµÐºÐ°"
        Settings_BackgroundMode_Item_2 = "Ð¦Ð²ÐµÑ‚ Ð¾Ð±Ð»Ð¾Ð¶ÐºÐ¸"

        Settings_Font_Text = "Ð¨Ñ€Ð¸Ñ„Ñ‚"
        Settings_Font_Item1 = "Onest"
        Settings_Font_Item2 = "Spotify"
        Settings_Font_Item3 = "NotoSansJP"

        Settings_PlatformLink_Text = "Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð° ..."
        Settings_PlatformLink_Item_1 = "â€”"
        Settings_PlatformLink_Item_2 = "Ð¢Ñ€ÐµÐº"
        Settings_PlatformLink_Item_3 = "ÐÐ»ÑŒÐ±Ð¾Ð¼"

        Settings_SongLinkInclude_Text = "Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¿Ð»Ð°Ñ‚Ñ„Ð¾Ñ€Ð¼Ñ‹"
        Settings_SongLinkInclude_Subtext = "Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ Ð¿ÐµÑÐ½Ð¸ Ð½Ð° song.link"
        Settings_FastCardRender_Text = "ÐŸÑ€ÐµÐ´Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐµÐº"
        Settings_FastCardRender_Subtext = "ÐœÐ¾Ð¶ÐµÑ‚ ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ñ‚ÑŒ Ñ€Ð°ÑÑ…Ð¾Ð´ Ð±Ð°Ñ‚Ð°Ñ€ÐµÐ¸"

        Setting_AdvancedMode_Text = "Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ‹Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸"
        Setting_AdvancedMode_Subtext = "Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸"
        Setting_AdvancedMode_Title = "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð²Ð½ÐµÑˆÐ½ÐµÐ³Ð¾ Ð²Ð¸Ð´Ð°"

        Settings_BackgroundColor_Text = "Ð¦Ð²ÐµÑ‚ Ñ„Ð¾Ð½Ð°"
        Settings_BackgroundColor_Subtext = "Ð¦Ð²ÐµÑ‚ Ñ„Ð¾Ð½Ð° Ð¿Ñ€Ð¸ Ð²Ñ‹Ð±Ð¾Ñ€Ðµ 'Ð¦Ð²ÐµÑ‚ Ð¾Ð±Ð»Ð¾Ð¶ÐºÐ¸' Ð² Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ðµ 'Ð¤Ð¾Ð½'"

        Settings_AccentColor_Text = "ÐÐºÑ†ÐµÐ½Ñ‚Ð½Ñ‹Ð¹ Ñ†Ð²ÐµÑ‚"
        Settings_AccentColor_Subtext = "Ð¦Ð²ÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð° Ð² Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ð¸ Ñ‚Ñ€ÐµÐºÐ° Ð¸ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð¼ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ðµ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ°"

        Settings_SecondaryColor_Text = "Ð’Ñ‚Ð¾Ñ€Ð¸Ñ‡Ð½Ñ‹Ð¹ Ñ†Ð²ÐµÑ‚"
        Settings_SecondaryColor_Subtext = "Ð¦Ð²ÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð° Ð´Ð»Ñ ÑÑ‚Ñ€Ð¾ÐºÐ¸ Ñ Ð°Ñ€Ñ‚Ð¸ÑÑ‚Ð¾Ð¼, Ð½ÐµÐ°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ-Ð±Ð°Ñ€Ð° Ð¸ Ñ‚Ð°Ð¹Ð¼ÐµÑ€Ð¾Ð²"

        Settings_InstantCardSubtext_Text = "Ð’Ñ‚Ð¾Ñ€Ð¸Ñ‡Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚"
        Settings_InstantCardSubtext_Subtext = "Ð¢ÐµÐºÑÑ‚ Ð² Ð²ÐµÑ€Ñ…Ð½ÐµÐ¹ Ñ‡Ð°ÑÑ‚Ð¸ Ð½Ð¸Ð¶Ð½ÐµÐ³Ð¾ Ð±Ð»Ð¾ÐºÐ° Ð¿Ñ€ÐµÐ´Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐµÐº"

        Settings_InstantCardMainText_Text = "ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ñ‚ÐµÐºÑÑ‚"
        Settings_InstantCardMainText_Subtext = "Ð¢ÐµÐºÑÑ‚ Ð² Ð½Ð¸Ð¶Ð½ÐµÐ¹ Ñ‡Ð°ÑÑ‚Ð¸ Ð½Ð¸Ð¶Ð½ÐµÐ³Ð¾ Ð±Ð»Ð¾ÐºÐ° Ð¿Ñ€ÐµÐ´Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐµÐº"

        Settings_Vertical_ShowServiceLogo_Text = "ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°Ñ‚ÑŒ Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐµÑ€Ð²Ð¸ÑÐ°."

        Settings_Stream_Header = "ÐŸÐ¾Ñ‚Ð¾Ðº Ð² Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ"

        Setting_Stream_Title = "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ ÑÑ‚Ñ€Ð¸Ð¼Ð°"
        Settings_Stream_Text = "Ð¡Ñ‚Ñ€Ð¸Ð¼ Ñ‚Ñ€ÐµÐºÐ° Ð² Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ"
        Settings_Stream_Subtext = "ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÑ‚ Ð±Ð¸Ð¾/Ð»Ð¾ÐºÐ°Ñ†Ð¸ÑŽ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¼ Ñ‚Ñ€ÐµÐºÐ¾Ð¼"
        Settings_Stream_Alert = "Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼ Ð²Ð°Ð¼ ÑÐ½Ð°Ñ‡Ð°Ð»Ð° Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ñ‚Ñ€Ð°Ð½ÑÐ»ÑÑ†Ð¸ÑŽ Ñ‚Ñ€ÐµÐºÐ°, Ð° ÑƒÐ¶Ðµ Ð¿Ð¾ÑÐ»Ðµ ÑÑ‚Ð¾Ð³Ð¾ Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ."

        Settings_StreamAlert_Title = "âš ï¸âš ï¸Ð’ÐÐ˜ÐœÐÐÐ˜Ð•âš ï¸âš ï¸"
        Settings_StreamAlert_Text = "Ð­Ñ‚Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¼Ð¾Ð¶ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½ÐµÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾ Ð¸Ð·-Ð·Ð° Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ð¹ Telegram Ð½Ð° Ñ‡Ð°ÑÑ‚ÑƒÑŽ ÑÐ¼ÐµÐ½Ñƒ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ñ. Ð’Ð°ÑˆÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¼Ð¾Ð³ÑƒÑ‚ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÑ‚ÑŒÑÑ Ñ Ð·Ð°Ð´ÐµÑ€Ð¶ÐºÐ¾Ð¹. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð½Ð° ÑÐ²Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ñ… Ð¸ Ñ€Ð¸ÑÐº."

        Setting_TrackStream_Text = "Ð¡Ñ‚Ñ€Ð¸Ð¼Ð¸Ñ‚ÑŒ Ð²..."
        Setting_TrackStream_Item1 = "Ð‘Ð¸Ð¾"
        Setting_TrackStream_Item2 = "Ð›Ð¾ÐºÐ°Ñ†Ð¸ÑŽ (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ)"
        Setting_TrackStream_Item3 = "ðŸ†• ÐœÑƒÐ·Ñ‹ÐºÐ° Ð² Ð²Ð°ÑˆÐµÐ¼ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ðµ"

        Settings_InStream_Text = "Ð¢ÐµÐºÑÑ‚ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ"
        Settings_InStream_Subtext = "ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÑ‚ÑÑ, ÐµÑÐ»Ð¸ Ð¿Ð»ÐµÐµÑ€ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ Ð¸Ð»Ð¸ Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÑÑ"

        Settings_FormatInStream_Text = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚"
        Settings_FormatInStream_Subtext = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ°. {title} â€” Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚Ñ€ÐµÐºÐ°, {artists} â€” Ð°Ñ€Ñ‚Ð¸ÑÑ‚(Ñ‹)"

        Settings_Stream_AccountId = "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¹ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð´Ð»Ñ ÑÑ‚Ñ€Ð¸Ð¼Ð¸Ð½Ð³Ð°"
        Settings_Stream_AccountId_Saved = "Ð’Ñ‹Ð±Ñ€Ð°Ð½ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð´Ð»Ñ ÑÑ‚Ñ€Ð¸Ð¼Ð¸Ð½Ð³Ð°"
        Settings_Stream_AccountId_Failed_Save = "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð´Ð»Ñ ÑÑ‚Ñ€Ð¸Ð¼Ð¸Ð½Ð³Ð°"

        Settings_Cache_Header = "ÐšÑÑˆ"
        Setting_Cache_Enable_Text = "ÐšÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸"
        Setting_Cache_DeleteCached = "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸"

        Settings_Other_Header = "ÐŸÑ€Ð¾Ñ‡ÐµÐµ"

        Setting_Other_SourceCheck = "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ†ÐµÐ»Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚Ð¸ Ñ„Ð°Ð¹Ð»Ð¾Ð²"
        Setting_Other_ForceDownload = "Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ Ð²ÑÐµ Ñ€ÐµÑÑƒÑ€ÑÑ‹ Ð·Ð°Ð½Ð¾Ð²Ð¾"
        Setting_Other_Donate = "ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ"

        Settings_YandexMusic_Auth_Guide = "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸"
        Settings_YandexMusic_Auth_Guide_Text = "**Ð¸Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ**"

        Settings_YandexMusic_CustomApi_Enable_Text = "Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ðµ API"
        Settings_YandexMusic_CustomApi_Enable_Subtext = "Ð’Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ! Ð’ÐºÐ»ÑŽÑ‡Ð°Ð¹Ñ‚Ðµ ÑÑ‚Ð¾ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐµÑÐ»Ð¸ Ð²Ñ‹ Ð·Ð½Ð°ÐµÑ‚Ðµ Ñ‡Ñ‚Ð¾ Ð´ÐµÐ»Ð°ÐµÑ‚Ðµ."

        Settings_YandexMusic_CustomApi_Input_Text = "ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ðµ API"

        Alert_HEX_Title = "âš ï¸ ÐžÑˆÐ¸Ð±ÐºÐ° HEX"
        Alert_HEX_Text = "ÐÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ð¹ HEX-ÐºÐ¾Ð´ Ñ†Ð²ÐµÑ‚Ð°"

        Message_CaptionLink_Text = "[{0}]({1})"
        Message_CaptionSongLink_Text = "[song.link]({0})"
        Message_CaptionDivider = " â€¢ "

        Check_Value_NotValid = "Ð£ÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÑÐµÑ€Ð²Ð¸ÑÐ° Ð½Ðµ Ð²Ð°Ð»Ð¸Ð´Ð½Ð¾."
        Check_Value_NotValid_Button = "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ"

        Check_Platform_NotSelected = "Ð’Ñ‹ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ð¹ Ð²Ð°Ð¼Ð¸ ÑÐµÑ€Ð²Ð¸Ñ."
        Check_Platform_NotSelected_Button = "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ"

        Check_Platform_DownloadNotAvailable = "Ð”Ð»Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ ÑÐµÑ€Ð²Ð¸ÑÐ° '.nowt' Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°."

        Check_Resources_NotFound = "ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ñ€ÐµÑÑƒÑ€ÑÑ‹ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹."
        Check_Resources_NotFound_Button = "Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ"

        CachedAuthData_Clear_Success = "ÐšÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ñ‹."
        CachedAuthData_Clear_Error = "ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…."

        SourceSuccess_Title = "Ð£ÑÐ¿ÐµÑˆÐ½Ð¾"
        SourceSuccess_Text = "ÐžÑˆÐ¸Ð±Ð¾Ðº Ð¿Ñ€Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐµ Ñ€ÐµÑÑƒÑ€ÑÐ¾Ð² Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾"

        Track_Not_Active = "ÐŸÐ»ÐµÐµÑ€ Ð½ÐµÐ°ÐºÑ‚Ð¸Ð²ÐµÐ½."

        VkMusic_Id = "ID Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð° VK"
        VkMusic_Id_NotValid = "ID Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð° VK Ð½Ðµ Ð²Ð°Ð»Ð¸Ð´ÐµÐ½."
        VkMusic_Audio_NotFound = "Ð¢Ñ€ÐµÐº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½."
        VkMusic_Warning = "â—â—â—Ð’Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµâ—â—â—\nÐ¡ÐµÑ€Ð²Ð¸Ñ Ð’Ðš ÐœÑƒÐ·Ñ‹ÐºÐ° Ð±ÑƒÐ´ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐµÑÐ»Ð¸ Ñƒ Ð²Ð°Ñ Ð’Ðš Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð° Ñ‚Ñ€Ð°Ð½ÑÐ»ÑÑ†Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ° Ð² Ð²Ð°Ñˆ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ."

        SoundCloud_Warning = "â—â—â—Ð’Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµâ—â—â—\nÐ¡ÐµÑ€Ð²Ð¸Ñ SoundCloud Ð±ÑƒÐ´ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ñ‹Ð¼ Ð’ÐŸÐ (ÐµÑÐ»Ð¸ Ð²Ñ‹ Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÐµÑÑŒ Ð² Ð Ð¾ÑÑÐ¸Ð¸)."

        Action_Fix = "Ð˜ÑÐ¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ"

        Platform_YandexMusic = "Ð¯Ð½Ð´ÐµÐºÑ ÐœÑƒÐ·Ñ‹ÐºÐ°"
        Platform_VkMusic = "Ð’Ðš ÐœÑƒÐ·Ñ‹ÐºÐ°"

        Alert_Donate_Header = "Ð”Ð¾Ð½Ð°Ñ‚"
        Alert_Donate_Title = "ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸"
        Alert_Donate_Text = "ÐÐ¸Ð¶Ðµ Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ TON-Ð°Ð´Ñ€ÐµÑ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¾Ð² reSwaga Ð¸ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚ Ð´Ð¾Ð½Ð°Ñ‚Ð¾Ð¼."
        Alert_Donate_Button = "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ"

        Bulletin_InvalidCobaltResponse = "ÐÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚ Ð¾Ñ‚ Cobalt API"
        Bulletin_NoItemsToDownload = "ÐÐµÑ‚ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸"
        Bulletin_CobaltErrorCode = "ÐžÑˆÐ¸Ð±ÐºÐ° Cobalt, ÐºÐ¾Ð´ â€” {0}"

        MenuItem_Service_Select_Text = "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ {0}"
        MenuItem_Service_Select_Subtext = "Ð¡ÐµÑ€Ð²Ð¸Ñ Ð² reSwaga"
        MenuItem_Service_Success = "Ð¡ÐµÑ€Ð²Ð¸Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½ Ð½Ð° {0}."
        MenuItem_Service_Success_Subtext = "ÐÐ¾ Ð²Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ ÑƒÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸."
        MenuItem_Service_Fail = "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ ÑÐµÑ€Ð²Ð¸Ñ Ð½Ð° {0}."

        Guide_Spotify_Link = 'https://telegra.ph/reSwaga-Gajd-po-avtorizacii-v-Spotify-09-20'
        Guide_Soundcloud_Link = 'https://telegra.ph/reSwaga-Gajd-po-avtorizacii-v-SoundCloud-09-21'

        Action_SendCard_Title = 'ÐšÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ°'
        Action_SendCard_Subtext = 'ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð²Ð¸Ð·ÑƒÐ°Ð»ÑŒÐ½Ð¾Ð¹ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹ Ð¾ Ñ‚Ñ€ÐµÐºÐµ'
        Action_SendAudio_Title = 'ÐÑƒÐ´Ð¸Ð¾'
        Action_SendAudio_Subtext = 'ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð°ÑƒÐ´Ð¸Ð¾ Ñ„Ð°Ð¹Ð»Ð° Ñ‚Ñ€ÐµÐºÐ°'
        Action_SendText_Title = 'Ð¢ÐµÐºÑÑ‚'
        Action_SendText_Subtext = 'ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ñ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹ Ð¾ Ñ‚Ñ€ÐµÐºÐµ'
        Action_Settings_Title = 'ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸'
        Action_Settings_Subtext = f'Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° ÑÐ¾ Ð²ÑÐµÐ¼Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ð¼Ð¸ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° {__name__}'

        StreamPlaceUpdated = 'ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ ÑÑ‚Ñ€Ð¸Ð¼Ð° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹'

    class LanguageEnglish:
        language = "en"

        Settings_Auth_Header = "Service & Authorization"
        Settings_Auth_Platform = "Service"
        Settings_Auth_Value_Text = "Value"
        Settings_Auth_Value_NotSelected_Text = "â€”"
        Settings_Auth_Value_Spotify_Text = "Username"
        Settings_Auth_Value_YandexMusic_Text = "Token"
        Settings_Auth_Value_SoundCloud_Text = "Token"

        Settings_YandexMusic_LoginGuide = "Go to token guide, log in to your Yandex account, and paste your token below."
        Settings_VkMusic_LoginGuide = "Go to the website and learn how to get a token correctly. After studying, select 'vk.com' and log-in in to your VK account."

        Settings_CobaltApi_Text = 'Cobalt API Url'
        Settings_CobaltApi_Subtext = 'Please do not change this value if you do not know what it is responsible for and why it is needed.'
        Settings_CobaltApi_Custom_Text = 'Custom Cobalt API'

        Settings_CardSettings_Header = "Customization"

        Settings_CardType_Header = "Card Style"
        Settings_CardType_1 = "Standard"
        Settings_CardType_2 = "Vertical "

        Settings_BackgroundMode_Text = "Background"
        Settings_BackgroundMode_Item_1 = "Track Cover"
        Settings_BackgroundMode_Item_2 = "Cover Color"

        Settings_Font_Text = "Font"
        Settings_Font_Item1 = "Onest"
        Settings_Font_Item2 = "Spotify"
        Settings_Font_Item3 = "NotoSansJP"

        Settings_PlatformLink_Text = "Insert link to ..."
        Settings_PlatformLink_Item_1 = "â€”"
        Settings_PlatformLink_Item_2 = "Track"
        Settings_PlatformLink_Item_3 = "Album"

        Settings_SongLinkInclude_Text = "Link to other platforms"
        Settings_SongLinkInclude_Subtext = "Adds a link to the song page on song.link"
        Settings_FastCardRender_Text = "Pre-render cards"
        Settings_FastCardRender_Subtext = "May increase battery consumption"

        Setting_AdvancedMode_Text = "Advanced Settings"
        Setting_AdvancedMode_Subtext = "Additional customization settings"
        Setting_AdvancedMode_Title = "Customization"

        Settings_BackgroundColor_Text = "Background Color"
        Settings_BackgroundColor_Subtext = "Background color if 'Cover Color' is selected in 'Background'"

        Settings_AccentColor_Text = "Accent Color"
        Settings_AccentColor_Subtext = "Text color used in track title and active progress bar"

        Settings_SecondaryColor_Text = "Secondary Color"
        Settings_SecondaryColor_Subtext = "Text color used for artist line, inactive progress bar, and timers"

        Settings_InstantCardSubtext_Text = "Secondary Text"
        Settings_InstantCardSubtext_Subtext = "Text displayed at the top of the bottom block of pre-rendered cards"

        Settings_InstantCardMainText_Text = "Main Text"
        Settings_InstantCardMainText_Subtext = "Text displayed at the bottom of the bottom block of pre-rendered cards"

        Settings_Vertical_ShowServiceLogo_Text = "Show service logo"

        Settings_Stream_Header = "Profile Streaming"

        Setting_Stream_Title = "Stream settings"
        Settings_Stream_Text = "Stream track to profile"
        Settings_Stream_Subtext = "Updates your bio/location with the currently playing track"
        Settings_Stream_Alert = "We recommend that you first set up the broadcast of the track, and only after that activate the function."

        Settings_StreamAlert_Title = "âš ï¸âš ï¸WARNINGâš ï¸âš ï¸"
        Settings_StreamAlert_Text = "This feature may work inconsistently due to Telegram's profile change limits. As a result, your profile information may not update immediately. Use at your own risk."

        Setting_TrackStream_Text = "Stream to..."
        Setting_TrackStream_Item1 = "Bio"
        Setting_TrackStream_Item2 = "Location (Recommended)"
        Setting_TrackStream_Item3 = "ðŸ†• Music on Your Profile"

        Settings_InStream_Text = "Default Text"
        Settings_InStream_Subtext = "Text displayed when the player is unavailable or no track is playing"

        Settings_FormatInStream_Text = "Format"
        Settings_FormatInStream_Subtext = "Customize track display. {title} â€” track name, {artists} â€” artist(s)"

        Settings_Stream_AccountId = "Select this account for streaming"
        Settings_Stream_AccountId_Saved = "Selected account for streaming"
        Settings_Stream_AccountId_Failed_Save = "Failed to select account for streaming"

        Settings_Cache_Header = "Cache"
        Setting_Cache_Enable_Text = "Caching of authorization data"
        Setting_Cache_DeleteCached = "Delete cached authentication data"

        Settings_Other_Header = "Other"

        Setting_Other_SourceCheck = "File Integrity Check"
        Setting_Other_ForceDownload = "Download Full Resource Package"
        Setting_Other_Donate = "Support Development"

        Settings_YandexMusic_Auth_Guide = "Authentication Guide"
        Settings_YandexMusic_Auth_Guide_Text = "**guide**"

        Settings_YandexMusic_CustomApi_Enable_Text = "Enable Custom API"
        Settings_YandexMusic_CustomApi_Enable_Subtext = "Warning! Enable this only if you know what you doing."

        Settings_YandexMusic_CustomApi_Input_Text = "Custom API Url"

        Alert_HEX_Title = "âš ï¸ HEX Error"
        Alert_HEX_Text = "Invalid HEX color code"

        Message_CaptionLink_Text = "[{0}]({1})"
        Message_CaptionSongLink_Text = "[song.link]({0})"
        Message_CaptionDivider = " â€¢ "

        Check_Value_NotValid = "Platform value is not valid."
        Check_Value_NotValid_Button = "Change"

        Check_Platform_NotSelected = "You can't use command without selected platform."
        Check_Platform_NotSelected_Button = "Select"

        Check_Platform_DownloadNotAvailable = "For current service '.nowt' not available."

        Check_Resources_NotFound = "Plugin resources not found."
        Check_Resources_NotFound_Button = "Download"

        CachedAuthData_Clear_Success = "Cached authorization data removed."
        CachedAuthData_Clear_Error = "Something went wrong, cached data not removed."

        SourceSuccess_Title = "Success"
        SourceSuccess_Text = "No issues detected during resource check"

        Track_Not_Active = "Player not active."

        VkMusic_Id = "VK account ID"
        VkMusic_Id_NotValid = "VK account ID not valid."
        VkMusic_Audio_NotFound = "Track not found."
        VkMusic_Warning = "â—â—â—Warningâ—â—â—\nService VK Music working only if you enabled stream track in to profile in VK"

        SoundCloud_Warning = "â—â—â—Warningâ—â—â—\nService SoundCloud working only with VPN service (if you in Russia)"

        Action_Fix = "Fix"

        Platform_YandexMusic = "Yandex.Music"
        Platform_VkMusic = "VK Music"

        Alert_Donate_Header = "Donate"
        Alert_Donate_Title = "Support Development"
        Alert_Donate_Text = "Below you can copy the TON address of the reSwaga developers and support the development with your donation."
        Alert_Donate_Button = "Copy"

        Bulletin_InvalidCobaltResponse = "Invalid response from Cobalt API"
        Bulletin_NoItemsToDownload = "No items to download"
        Bulletin_CobaltErrorCode = "Cobalt Error Code â€” {0}"

        MenuItem_Service_Select_Text = "Select {0}"
        MenuItem_Service_Select_Subtext = "Service in reSwaga"
        MenuItem_Service_Success = "Selected {0} as main service."
        MenuItem_Service_Success_Subtext = "But you need set auth data."
        MenuItem_Service_Fail = "Failed to select {0} as main service."

        Guide_Spotify_Link = 'https://telegra.ph/reSwaga-Authorization-guide-for-Spotify-09-21'
        Guide_Soundcloud_Link = 'https://telegra.ph/reSwaga-Authorization-guide-for-SoundCloud-09-21'

        Action_SendCard_Title = 'Card'
        Action_SendCard_Subtext = 'Sends a visual card with information about the track'
        Action_SendAudio_Title = 'Audio'
        Action_SendAudio_Subtext = 'Sends a track audio file'
        Action_SendText_Title = 'Text'
        Action_SendText_Subtext = 'Sends a message with information about the track'
        Action_Settings_Title = 'Settings'
        Action_Settings_Subtext = f'Page with all the {__name__} plugin settings'

        StreamPlaceUpdated = 'Stream settings updated'


locale = LocaleController().get_controller()


@dataclass
class Track:
    active: bool
    id: Any = None
    title: str = None
    artist: list = None
    album: str = None
    thumb: str = None
    duration: int = None
    progress: int = None
    link: str = None
    device: str = None
    download_url: str = None


class Platform(Enum):
    NotSelected = (0, locale.Settings_Auth_Value_NotSelected_Text)
    Spotify = (1, 'Spotify')
    YandexMusic = (2, locale.Platform_YandexMusic)
    SoundCloud = (3, 'SoundCloud')
    VkMusic = (4, locale.Platform_VkMusic)
    TgMusic = (5, 'Telegram')
    LastFm = (6, 'Last.FM')


class BasePlatform:
    def __init__(self, value: str):
        self.now_track: Optional[Track] = None

        if value not in ['', None, DEFAULT_VALUE]:
            self.value: str = value
        else:
            logcat("Value is none.")

        self.memory_id: Any = 0
        self.value_text: Optional[str] = None
        self.pre_auth_settings: Optional[bool] = None
        self.additional_settings: Optional[bool] = None
        self.can_download_track: bool = True
        self.need_special_platform_args_check: bool = False

    def get_track(self) -> Optional[Track]:
        pass

    def special_platform_args_check(self, plugin: BasePlugin) -> bool:
        pass

    def create_pre_auth_settings(self, plugin: BasePlugin) -> List[Any]:
        pass

    def create_additional_settings(self, plugin: BasePlugin) -> List[Any]:
        pass


class Spotify(BasePlatform):
    def __init__(self, value: str):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_Spotify_Text
        username = value.strip() if value else ""
        if '/' in username:
            username = username.split('/')[-1]
        self.username = username
        self.headers = {"User-Agent": "Mozilla/5.0", "Accept": "application/json"}
        self.now_track = Track(active=False)
        self.pre_auth_settings = True

    def get_track(self) -> Optional[Track]:
        data = requests.get(f"https://api.stats.fm/api/v1/users/{self.username}/streams/current", headers=self.headers)

        if data.status_code == 204 or data.status_code != 200:
            self.now_track = Track(active=False)
            return Track(active=False)
        else:
            data = data.json()['item']
            if data:
                track_id = data['track']['externalIds']['spotify']
                track_id = track_id[0] if track_id else 0
                album = self.get_album_link(data['track']['id'])
                track = Track(
                    active=True,
                    id=track_id,
                    title=data['track']['name'],
                    artist=[artist['name'] for artist in data['track']['artists']],
                    album=album,
                    thumb=data['track']['albums'][0]['image'],
                    duration=data['track']['durationMs'] // 1000,
                    progress=data['progressMs'] // 1000,
                    link=f"https://open.spotify.com/track/{track_id}",
                    device=data['deviceName']
                )
            else:
                self.now_track = Track(active=False)
                track = Track(active=False)

            self.now_track = track
            return track

    def get_album_link(self, internal_track_id) -> Optional[str]:
        data = requests.get(f"https://api.stats.fm/api/v1/tracks/{internal_track_id}/albums", headers=self.headers)
        if data.status_code != 200:
            return None
        else:
            data = data.json()['items']
            if data:
                try:
                    if data[0]['externalIds']['spotify'][0]:
                        album_id = data[0]['externalIds']['spotify'][0]
                        return f"https://open.spotify.com/album/{album_id}"

                    elif data[0]['externalIds']['appleMusic'][0]:
                        album_id = data[0]['externalIds']['appleMusic'][0]
                        return f"https://open.spotify.com/album/{album_id}"

                    else:
                        album_id = data[0]['externalIds']['id']
                        return f"https://open.spotify.com/album/{album_id}"
                except Exception as e:
                    logcat("[Spotify] get_album_link: " + str(e))
                    return None
            else:
                return None

    def create_pre_auth_settings(self, plugin: BasePlugin) -> List[Any]:
        return [
            Text(
                text=locale.Settings_YandexMusic_Auth_Guide,
                icon="msg_info",
                on_click=lambda _: open_link(locale.Guide_Spotify_Link)
            )
        ]


class YandexMusic(BasePlatform):
    def __init__(self, value: str, api_url: Optional[str] = None):
        super().__init__(value)
        self.token = value.strip()
        self.value_text = locale.Settings_Auth_Value_YandexMusic_Text
        self.pre_auth_settings = True
        self.additional_settings = True
        self.need_special_platform_args_check = True
        self.api_url: str = api_url if api_url else "https://track.mipoh.ru"
        self.headers = {
            "User-Agent": "Mozilla/5.0",
            "Accept": "application/json",
            "ya-token": self.token
        }

    def get_track(self) -> Optional[Track]:
        if not self.token:
            self.now_track = Track(active=False)
            return Track(active=False)

        try:
            r = requests.get(f"{self.api_url}/get_current_track_beta", headers=self.headers, timeout=10, verify=False)
            logcat(f"[YandexMusic] get_current_track status={r.status_code}")
            data = r.json()

            if r.status_code != 200 or 'track' not in data:
                logcat("[YandexMusic] no 'track' key or bad status")
                self.now_track = Track(active=False)
                return Track(active=False)

            t = data['track']

            raw_artist = t.get('artist', '')
            if isinstance(raw_artist, str):
                artists = [x.strip() for x in raw_artist.split(',') if x.strip()]
            elif isinstance(raw_artist, list):
                artists = raw_artist
            else:
                artists = []

            track = Track(
                active=True,
                id=t.get('track_id'),
                title=t.get('title'),
                artist=artists,
                album=t.get('album'),
                thumb=t.get('img'),
                duration=int(t.get('duration', 0)),
                progress=int(data.get('progress_ms', 0)) // 1000,
                link=f"https://music.yandex.ru/track/{t.get('track_id')}",
                download_url=t.get('download_link')
            )
            self.now_track = track
            logcat(f"[YandexMusic] built track: {track.title} â€” {track.artist}")
            return track
        except Exception as e:
            logcat(f"[YandexMusic] get_current_track exception: {e}")
            self.now_track = Track(active=False)
            return Track(active=False)

    def special_platform_args_check(self, plugin):
        if plugin.get_setting('enable_yandex_custom_api_url', False):
            yandex_custom_api: Optional[str] = plugin.get_setting('yandex_custom_api', None)
            if yandex_custom_api in ["", None]:
                return True
            elif not yandex_custom_api.startswith('https://') and not yandex_custom_api.startswith('http://'):
                return True
            elif len(yandex_custom_api) <= 7:
                return True
            else:
                return True
        else:
            return False

    def create_pre_auth_settings(self, plugin):
        return [
            Text(
                text=locale.Settings_YandexMusic_Auth_Guide,
                icon="msg_info",
                on_click=lambda _: plugin.show_info_alert(
                    title=locale.Settings_YandexMusic_Auth_Guide,
                    message=locale.Settings_YandexMusic_LoginGuide,
                    positive_text="Ok",
                    neutral_text="Guide",
                    neutral_listener=lambda: open_link("https://yandex-music.readthedocs.io/en/main/token.html")
                )
            )
        ]

    def create_additional_settings(self, plugin: BasePlugin):
        custom_api_url = plugin.get_setting("enable_yandex_custom_api_url", False)
        return [
            Switch(
                key="enable_yandex_custom_api_url",
                text=locale.Settings_YandexMusic_CustomApi_Enable_Text,
                subtext=locale.Settings_YandexMusic_CustomApi_Enable_Subtext,
                icon="msg_language",
                default=False,
                on_change=lambda _: plugin.update_platform_object(
                    plugin.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                    True
                )
            ),
            Input(
                key="yandex_custom_api",
                text=locale.Settings_YandexMusic_CustomApi_Input_Text,
                icon="msg_instant_link",
                default=DEFAULT_API_URL,
                on_change=lambda _: plugin.update_platform_object(
                    plugin.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                    True
                )
            ) if custom_api_url else None,
            Text(
                text="Custom API Guide",
                icon="msg_info",
                on_click=lambda _: open_link("https://github.com/MIPOHBOPOHIH/megacurrenttrack-go")
            ) if custom_api_url else None
        ]


class SoundCloud(BasePlatform):
    def __init__(self, value: str):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_SoundCloud_Text

        if not value: return
        self.token: str = value.strip()

        chrome_user_agents = [
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1',
            'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.110 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36',
            'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1',
            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.27 Safari/532.0',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.186 Safari/535.1',
            'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.38 Safari/532.0',
            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.7 Safari/532.2',
            'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.29 Safari/525.13',
            'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13',
        ]

        self.headers: Dict[str, str] = {
            'User-Agent': choice(chrome_user_agents),
            'Authorization': f'OAuth {self.token}',
            'Origin': 'https://soundcloud.com',
            'Referer': 'https://soundcloud.com/',
        }
        self.params: Dict[str, str] = {
            'client_id': '1HxML01xkzWgtHfBreaeZfpANMe3ADjb',
            'app_version': '1739181955',
            'app_locale': 'en',
            'limit': '20',
            'offset': '0',
            'linked_partitioning': '1'
        }
        self.api_url: str = 'https://api-v2.soundcloud.com/'
        # self.can_download_track = False
        self.pre_auth_settings = True

    def get_track(self) -> Optional[Track]:
        if not self.token:
            self.now_track = Track(active=False)
            return Track(active=False)

        try:
            data = requests.get(
                url=f"{self.api_url}me/play-history/tracks",
                params=self.params,
                headers=self.headers
            )

            if data.status_code != 200:
                logcat(f"[Soundcloud] Status code: {data.status_code}")
                self.now_track = Track(active=False)
                return Track(active=False)

            collection = data.json()['collection']

            if not collection or len(collection) <= 0:
                logcat("[Soundcloud] Collection is empty")
                self.now_track = Track(active=False)
                return Track(active=False)

            track_id: int = collection[0].get('track_id', 0)
            t: Dict[str, Any] = collection[0].get('track', None)

            if not t:
                logcat("[Soundcloud] TrackInfo is None")
                self.now_track = Track(active=False)
                return Track(active=False)

            metadata: Optional[Dict[str, Any]] = t.get('publisher_metadata', None)
            track = Track(
                active=True,
                id=track_id,
                title=t.get('title', 'No title provided'),
                artist=[metadata.get('artist', 'Anonymous artist')] if metadata is not None else 'No artist',
                album=metadata.get('album_title', '') if metadata is not None else '',
                thumb=t.get('artwork_url', ''),
                duration=int(t.get('duration', 0)) // 1000,
                link=t.get('permalink_url', '')
            )

            self.now_track = track
            logcat(f"[Soundcloud] built track: {track.title} â€” {track.artist}")
            return track

        except Exception as e:
            import traceback
            logcat(f"[Soundcloud] Exception in get_track: {e}\nFull traceback: {traceback.format_exc()}")
            self.now_track = Track(active=False)
            return Track(active=False)

    def create_pre_auth_settings(self, plugin: BasePlugin) -> List[Any]:
        return [
            Text(
                text=locale.Settings_YandexMusic_Auth_Guide,
                icon="msg_info",
                on_click=lambda _: open_link(locale.Guide_Soundcloud_Link)
            ),
            Divider(
                text=locale.SoundCloud_Warning
            )
        ]


# FROM 'VkNowPlay' PLUGIN
class VkMusic(BasePlatform):
    def __init__(self, value: str):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_YandexMusic_Text
        self.token: str = value.strip()
        self.pre_auth_settings = True
        self.additional_settings = True
        self.can_download_track = False
        self.need_special_platform_args_check = True

    def get_track(self) -> Optional[Track]:
        params: Dict[str, Any] = {
            'fields': 'status',
            'v': 5.199,
            'access_token': self.token
        }

        try:
            response = requests.get('https://api.vk.ru/method/users.get', params=params)
            data = response.json()

            if data.get('response', None) is None:
                logcat('Response not found')
                return Track(active=False)

            response = data['response'][0]

            if response.get('status_audio', None) is None:
                logcat('Audio status not found')
                return Track(active=False)

            t = response.get('status_audio', None)
            if t is None:
                logcat('Audio status not found2')
                return Track(active=False)

            main_artists: list = t.get('main_artists', None)
            if main_artists is None:
                artists_names: List[str] = [t.get('artist', 'Artist w/out name')]
            else:
                artists: list = [ma for ma in main_artists]
                artists_names: List[str] = [a.get('name', 'Artist w/out name') for a in artists]

            thumbnail = EMPTY_TRACK_COVER
            link: str = f"https://vk.ru/audio{t.get('owner_id', 0)}_{t.get('id', 0)}"
            album = t.get('album', None)

            if not album is None:
                album_link: str = f"https://vk.ru/music/album/{album.get('owner_id', 0)}_{album.get('id', 0)}_{album.get('access_key', None)}"
                thumb = album.get('thumb', None)
                if not thumb is None:
                    thumbnail = thumb.get('photo_1200', None)
            else:
                album_link: str = link

            track = Track(
                active=True,
                id=t.get('id', 0),
                title=t.get('title', 'No title provided'),
                artist=artists_names,
                album=album_link,
                thumb=thumbnail,
                link=link
            )

            self.now_track = track
            return track

        except Exception as e:
            import traceback
            logcat(f"Exception occurred while getting VK status: {e}\nFull traceback: {traceback.format_exc()}")
            self.now_track = Track(active=False)
            return Track(active=False)

    def create_pre_auth_settings(self, plugin):
        return [
            Text(
                text=locale.Settings_YandexMusic_Auth_Guide,
                icon="msg_info",
                on_click=lambda _: open_link('https://telegra.ph/reSwaga-Gajd-po-avtorizacii-v-VK-09-21')
            )
        ]

    def create_additional_settings(self, plugin):
        return [
            Divider(
                text=locale.VkMusic_Warning
            )
        ]


class TgMusic(BasePlatform):
    def __init__(self, value):
        super().__init__(value)

    def get_track(self):
        now_playing = MediaController.getInstance().getPlayingMessageObject()
        if now_playing is None or MediaController.getInstance().isMessagePaused():
            self.now_track = Track(active=False)
            return Track(active=False)

        self.can_download_track = now_playing.isMusic()
        owner_id: Optional[int] = now_playing.messageOwner.id
        title: Optional[str] = now_playing.getMusicTitle()
        author: Optional[str] = now_playing.getMusicAuthor()
        thumbnail: str = EMPTY_TRACK_COVER
        album: str = ""
        link: str = ""

        if now_playing.isMusic() and (not now_playing.isVoice() or not now_playing.isRoundVideo()):
            # pizdec govnishe
            artwork = now_playing.getArtworkUrl(False)
            req = requests.get(str(artwork).replace('athumb', 'https')).json()
            results: Optional[List[Dict[str, str]]] = req.get('results', None)

            if results and not results[0] is None:
                owner_id = results[0].get('trackId', now_playing.messageOwner.id)
                album = results[0].get('collectionViewUrl', None)
                link = results[0].get('trackViewUrl', None)
                artwork_url = results[0].get('artworkUrl30', None)
                thumbnail = str(artwork_url).replace('30x30bb', '600x600bb') \
                    if not artwork_url is None \
                    else EMPTY_TRACK_COVER

        duration = now_playing.getDuration()
        progress = now_playing.audioProgressSec

        track = Track(
            active=True,
            id=owner_id,
            title=title,
            artist=[author],
            album=album,
            thumb=thumbnail,
            duration=duration,
            progress=progress,
            link=link
        )
        self.now_track = track
        return track


class LastFm(BasePlatform):
    def __init__(self, value, api_key: str = DEFAULT_LASTFM_API_URL):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_Spotify_Text
        self.api_key: str = api_key
        self.value = value.strip()
        self.pre_auth_settings = False
        self.additional_settings = False
        self.can_download_track = False
        self.need_special_platform_args_check = False

    def get_track(self) -> Optional[Track]:
        url = "http://ws.audioscrobbler.com/2.0/"
        params = {
            'method': 'user.getrecenttracks',
            'user': self.value,
            'api_key': self.api_key,
            'format': 'json',
            'limit': 1
        }

        resp = requests.get(url, params=params, timeout=5)
        if resp.status_code == 200:
            data = resp.json()
            tracks = data.get('recenttracks', {}).get('track', [])
            if tracks and isinstance(tracks, list) and len(tracks) > 0:
                track = tracks[0]
                title = track.get('name', '')
                artist = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                album = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                images = track.get('image', [])
                image_url = EMPTY_TRACK_COVER
                if images:
                    size_priority = ['mega', 'extralarge', 'large']
                    size_map = {img.get('size'): img.get('#text', '') for img in images if img.get('#text')}
                    for s in size_priority:
                        if size_map.get(s):
                            image_url = size_map[s]
                            break
                    if not image_url:
                        for img in reversed(images):
                            if img.get('#text'):
                                image_url = img.get('#text', '')
                                break

                track = Track(
                    active=True,
                    id=str(title).replace(' ', '_').lower(),
                    title=title,
                    artist=[artist],
                    album=album,
                    thumb=image_url,
                    progress=0,
                    duration=0,
                    link=track.get('url', '')
                )
                self.now_track = track
                return track
            else:
                track = Track(active=False)
                self.now_track = track
                return track
        else:
            track = Track(active=False)
            self.now_track = track
            return track


def read(path: str) -> Optional[Any]:
    if not os.path.exists(path):
        return None
    try:
        with open(path, "rb") as file:
            file_content = file.read()
        return json.loads(file_content.decode("utf-8", errors="replace"))
    except Exception:
        import traceback
        logcat(f"Failed to load data from {path}: {traceback.format_exc()}")
        return None


def write(path: str, content: Any):
    try:
        dir_name = os.path.dirname(path)
        if not os.path.exists(dir_name):
            os.makedirs(dir_name, exist_ok=True)

        save_data = json.dumps(content, indent=4).encode("utf-8", errors="replace")
        with open(path, "wb") as file:
            file.write(save_data)
    except PermissionError as e:
        logcat(f"Have no permissions to edit {path}: {e}")
    except Exception as e:
        logcat(f"Failed to write data to {path}: {e}")


def get_platform(platform: int) -> Platform:
    if platform == 0:
        return Platform.NotSelected
    elif platform == 1:
        return Platform.Spotify
    elif platform == 2:
        return Platform.YandexMusic
    elif platform == 3:
        return Platform.SoundCloud
    elif platform == 4:
        return Platform.VkMusic
    elif platform == 5:
        return Platform.TgMusic
    elif platform == 6:
        return Platform.LastFm
    else:
        return Platform.NotSelected


def get_songlink(platform: int) -> str:
    if platform == int(Platform.NotSelected.value[0]):
        return ''
    elif platform == int(Platform.Spotify.value[0]):
        return 's'
    elif platform == int(Platform.YandexMusic.value[0]):
        return 'ya'
    elif platform == int(Platform.SoundCloud.value[0]):
        return 'sc'
    else:
        return ''


def get_download_link(platform: int, track_id: int) -> Optional[str]:
    songlink_codename = get_songlink(platform)
    if songlink_codename == '':
        return None

    songlink = requests.get(f"https://song.link/{songlink_codename}/{track_id}")
    if songlink.status_code == 200:
        youtube_link = re.findall(r"(https://(www\.)?youtube.com/.+?=.+?\")", songlink.text)
        soundcloud_link = re.findall(r"(https://(www\.)?soundcloud\.com/.+?\")", songlink.text)
        if soundcloud_link or youtube_link:
            return soundcloud_link[0][0][:-1] if soundcloud_link else youtube_link[0][0][:-1]
        else:
            return None
    else:
        return None


def copy(to_copy: str) -> bool:
    return AndroidUtilities.addToClipboard(to_copy)


def delete_file_delayed(path: str, delay: int = 60):
    def action():
        try:
            time.sleep(delay)
            if os.path.exists(path):
                os.remove(path)
                logcat(f"Deleted temp file: {path}")
        except Exception as e:
            logcat(f"Delayed delete error: {e}")

    threading.Thread(target=action, daemon=True).start()


def _get_cache_file_path() -> Optional[str]:
    temp_dir_obj = get_temp_dir()
    if not temp_dir_obj:
        logcat("Could not get base temp directory for cache.")
        return None

    swaga_dir_path = os.path.join(temp_dir_obj.getAbsolutePath(), TEMP_DIR_NAME)
    return os.path.join(swaga_dir_path, "cached_values.json")


def initialize_cached_platforms_values() -> List[Optional[str]]:
    empty_values = [DEFAULT_VALUE for _ in range(PLATFORMS_COUNT)]
    path = _get_cache_file_path()
    if path:
        write(path, empty_values)
        logcat("Cached values initialized in file.")
    else:
        logcat("Could not initialize cache file: path is invalid.")
    return empty_values


def is_cached_values_exist() -> bool:
    path = _get_cache_file_path()
    if not path:
        return False

    values_list = read(path)

    return isinstance(values_list, list) and len(values_list) == PLATFORMS_COUNT


def is_cached_value_exist(platform: int) -> bool:
    cached_value = get_cached_values()[platform]
    return cached_value is not None and cached_value != DEFAULT_VALUE


def get_cached_values() -> List[Optional[str]]:
    path = _get_cache_file_path()
    if not path:
        return [DEFAULT_VALUE for _ in range(PLATFORMS_COUNT)]

    exist_values = read(path)

    if not isinstance(exist_values, list) or len(exist_values) != PLATFORMS_COUNT:
        logcat("Cached values are missing or corrupted, re-initializing.")
        return initialize_cached_platforms_values()

    return exist_values


def get_cached_value(platform: int) -> Optional[str]:
    return get_cached_values()[platform]


def save_platform_value(platform: int, value: str):
    path = _get_cache_file_path()
    if not path:
        show_error("Cannot save value: cache storage is unavailable.")
        return

    exist_values = get_cached_values()

    if exist_values[platform] == value:
        logcat(f"Value '{value}' at index {platform} is already set.")
        return

    exist_values[platform] = value
    write(path, exist_values)

    if is_cached_value_exist(platform):
        show_success("New service value cached.")
        logcat(f"Saved value '{value}' at index {platform}.")


def get_cover_accent_color(cover: Image.Image):
    img = cover.resize((16, 16), Image.Resampling.LANCZOS)
    pixels = img.load()
    l_width, l_height = img.size

    for y in range(l_height):
        for x in range(l_width):
            if img.mode == 'L':
                r = pixels[x, y]
                r = math.pow(r / 255.0, 1 / 2.2) * 255.0
                pixels[x, y] = int(r)
            else:
                r, g, b = pixels[x, y][:3]
                r = math.pow(r / 255.0, 1 / 2.2) * 255.0
                g = math.pow(g / 255.0, 1 / 2.2) * 255.0
                b = math.pow(b / 255.0, 1 / 2.2) * 255.0
                if img.mode == 'RGB':
                    pixels[x, y] = (int(r), int(g), int(b))
                elif img.mode == 'RGBA':
                    a = pixels[x, y][3]
                    pixels[x, y] = (int(r), int(g), int(b), a)

    if img.mode == 'L':
        img = img.convert('RGB')
    elif img.mode == 'RGBA':
        rgb_img = Image.new('RGB', img.size)
        rgb_img.paste(img, mask=img.split()[3])
        img = rgb_img

    pixels = list(img.getdata())
    i_width, i_height = img.size

    if img.mode == 'RGB':
        total_r, total_g, total_b = 0, 0, 0
        darkness_index = 2.5
        for r, g, b in pixels:
            total_r += int(r // darkness_index)
            total_g += int(g // darkness_index)
            total_b += int(b // darkness_index)
        count = i_width * i_height
        average = (total_r // count, total_g // count, total_b // count)
    else:
        total = sum(pixels)
        average = (total // (i_width * i_height),) * 3

    return average


def adjust_color_for_readability(rgb_color: tuple) -> tuple:
    r, g, b = [x / 255.0 for x in rgb_color]
    h, l, s = colorsys.rgb_to_hls(r, g, b)

    if l < LIGHTNESS_THRESHOLD:
        new_lightness = MIN_LIGHTNESS_FOR_TEXT
    else:
        new_lightness = MAX_LIGHTNESS_FOR_TEXT

    new_r, new_g, new_b = colorsys.hls_to_rgb(h, new_lightness, s)
    return tuple(int(x * 255) for x in (new_r, new_g, new_b))


def _get_stream_info_file_path() -> Optional[str]:
    temp_dir_obj = get_temp_dir()
    if not temp_dir_obj:
        logcat("Could not get base temp directory for cache.")
        return None

    swaga_dir_path = os.path.join(temp_dir_obj.getAbsolutePath(), TEMP_DIR_NAME)
    return os.path.join(swaga_dir_path, "stream_info.json")


def is_stream_value_exist() -> bool:
    path = _get_stream_info_file_path()
    if not path:
        return False

    value = read(path)

    return isinstance(value, int)


def save_stream_account_id(new_user_id: int):
    path = _get_stream_info_file_path()
    if path is None:
        show_error(locale.Settings_Stream_AccountId_Failed_Save)
        return

    write(path, new_user_id)
    show_success(locale.Settings_Stream_AccountId_Saved)


def get_local_stream_id() -> int:
    path = _get_stream_info_file_path()
    if path is None:
        show_error("Failed to load data")
        return 0

    value = read(path)

    return value if isinstance(value, int) else 0


def set_profile_saved_track(resp):
    def process(response, error):
        delete_last_message(get_user_config().getClientUserId())
        if error or response is None:
            logcat(f'Failed to set profile saved track: {error.code} - {error.text}')

    update = resp.updates.get(1)
    if update is None:
        logcat('update not valid')
        return

    message = update.message
    if message is None:
        logcat('msg not valid')
        return

    media = message.media
    if media is None:
        logcat('media not valid')
        return

    document = media.document
    if document is None:
        logcat('doc not valid')
        return

    file_id = document.id
    access_hash = document.access_hash
    file_reference = document.file_reference

    if file_id is None:
        logcat('update not valid')
        return

    if access_hash is None:
        logcat('update not valid')
        return

    if file_reference is None:
        logcat('update not valid')
        return

    if message.from_id.user_id is None or message.from_id.user_id != get_user_config().getClientUserId():
        logcat('wrong id')
        return

    req = TLRPC.TL_account_saveMusic()

    req.unsave = False
    req.id = TLRPC.TL_inputDocument()
    req.id.id = file_id
    req.id.access_hash = access_hash
    req.id.file_reference = file_reference

    if req.id.file_reference is None:
        logcat('file ref not valid')
        req.id.file_reference = b''

    send_request(req, process)


def delete_last_message(chat_id):
    def process_result(response, error):
        if error or not response:
            logcat(f'{error.code} | {error.text}')
            return

        if not hasattr(response, 'messages'):
            logcat(f'Response is not \'messages_Messages\' and \'TL_messages_messagesSlice\', received {response}')
            return

        msgs = list(ArrayList(response.messages).toArray())
        if not msgs or msgs[0] is None:
            logcat("Empty list")
            return

        ids = ArrayList()
        ids.add(Integer(Math.toIntExact(msgs[0].id)))

        def delete_msg():
            get_messages_controller().deleteMessages(
                ids,
                None,
                None,
                chat_id,
                0,
                True,
                0
            )

        run_on_ui_thread(lambda: delete_msg())

    req = TLRPC.TL_messages_getHistory()
    req.peer = get_messages_controller().getInputPeer(chat_id)
    req.offset_id = 0
    req.limit = 1

    send_request(req, process_result)


def _to_syncsafe(size: int) -> bytes:
    return bytes([
        (size >> 21) & 0x7F,
        (size >> 14) & 0x7F,
        (size >> 7)  & 0x7F,
        (size)       & 0x7F,
    ])


def _frame_bytes(frame_id: str, text: str) -> bytes:
    try:
        body_text = text.encode('latin-1')
        encoding_byte = b'\x00'
    except UnicodeEncodeError:
        body_text = text.encode('utf-16')
        encoding_byte = b'\x01'
    body = encoding_byte + body_text
    size_bytes = len(body).to_bytes(4, 'big')
    header = frame_id.encode('ascii') + size_bytes + b'\x00\x00'
    return header + body


def create_minimal_id3_mp3(
        path: str,
        title: str,
        artist: str,
        duration_seconds: Optional[int] = None,
        target_size_mb: float = 0):
    frames = bytearray()
    frames += _frame_bytes('TIT2', title)
    frames += _frame_bytes('TPE1', artist)

    if duration_seconds is not None:
        ms = str(int(duration_seconds * 1000))
        frames += _frame_bytes('TLEN', ms)

    tag_size = len(frames)
    header = b'ID3' + bytes([3, 0]) + b'\x00' + _to_syncsafe(tag_size)

    with open(path, 'wb') as f:
        f.write(header)
        f.write(frames)
        fake_frame = bytes([0xFF, 0xFB, 0x90, 0x64]) + (b'\x00' * 418)

        if target_size_mb > 0:
            target_bytes = int(target_size_mb * 1024 * 1024)
            while f.tell() < target_bytes:
                f.write(fake_frame)
        else:
            f.write(fake_frame)

    st = os.stat(path)
    return path, st.st_size


class ReSwagaPlugin(BasePlugin):
    def __init__(self):
        super().__init__()

        self.platform: Optional[BasePlatform] = None
        self.poller: Optional[Poller] = None
        self.spinner: Optional[AlertDialogBuilder] = None
        self.info: Optional[AlertDialogBuilder] = None
        self.loading: Optional[AlertDialogBuilder] = None
        self.hooks = []

    def on_plugin_load(self):
        try:
            get_temp_dir()

            threading.Thread(target=self.check_resources, args=(False, False)).start()

            stream_bio_enabled: bool = self.get_setting("stream_bio_enabled", False)
            stream_account_id: int = get_local_stream_id()

            enable = any([
                stream_bio_enabled,
                self.get_setting("fast_card_render", False)
            ])
            self.set_poller_enabled(enable)

            user_id: int = get_user_config().getClientUserId()
            if stream_account_id == 0 and get_local_stream_id() != user_id:
                self.set_new_stream_account()

            current_platform = self.get_setting("selected_platform", 0)
            if current_platform != int(Platform.NotSelected.value[0]):
                self.update_platform_object(current_platform, True)

            if not self.is_poller_enabled() and self.enabled and not self.platform is None:
                self.poller.start_poller()

            if self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT) == DEFAULT_STREAM_TEXT:
                self.save_default_user_bio()

            if self.get_setting("enable_auth_data_cache", False):
                if not is_cached_values_exist():
                    initialize_cached_platforms_values()
                else:
                    if current_platform != int(Platform.NotSelected.value[0]):
                        cached_value = get_cached_value(current_platform)
                        current_value = self.get_setting("value", "")

                        if cached_value != current_value:
                            save_platform_value(current_platform, current_value)

            if self.get_setting("enable_auth_data_cache", False):
                self.set_menu_items(False)

            self.add_on_send_message_hook()
            self.add_hook('TL_messages_sendMedia')
            self._setup_hooks()

            self.update_stream_place()

            logcat(f"Plugin loaded.")
        except Exception as _:
            import traceback
            logcat(traceback.format_exc())

    def on_plugin_unload(self):
        if self.poller is not None:
            self.set_poller_enabled(False)
            self.poller = None

        self.remove_hook('TL_messages_sendMedia')
        for h in self.hooks:
            self.unhook_method(h)
        self.hooks.clear()

        logcat(f"Plugin unloaded.")

    def create_settings(self):
        platforms = [p.value[1] for p in Platform]
        selected_platform = self.get_setting("selected_platform", 0)
        is_value_valid = self.is_platform_value_valid(selected_platform)

        settings = [
            Header(text=locale.Alert_Donate_Header),
            Text(
                text="TON",
                icon="msg_ton",
                accent=True,
                on_click=lambda view: copy("UQBVxjueXqAEpALX_b0yr-ytXN26LOTpSBn26b9VRHKrmm5F")
            ),
            Text(
                text="Card (Alfa-Bank)",
                icon="msg_payment_card",
                accent=True,
                on_click=lambda view: copy("2200154564046463")
            ),
            Divider(),
            Header(text=locale.Settings_Auth_Header),
            Selector(
                key="selected_platform",
                text=locale.Settings_Auth_Platform,
                icon="msg_tone_on",
                items=platforms,
                default=0,
                on_change=lambda new_value: self.update_platform_object(new_value, False)
            )
        ]

        if selected_platform == int(Platform.NotSelected.value[0]):
            return settings

        if selected_platform != int(Platform.TgMusic.value[0]):
            settings += [
                Input(
                    key="value",
                    text=locale.Settings_Auth_Value_Text if self.platform.value_text is None else self.platform.value_text,
                    on_change=lambda _: self.update_platform_object(self.get_setting("selected_platform", 0), True),
                    icon="msg_pin_code"
                ) if selected_platform != int(Platform.NotSelected.value[0]) and selected_platform != int(Platform.TgMusic.value[0]) else None
            ]

        if self.platform.pre_auth_settings:
            pre_auth_settings = self.platform.create_pre_auth_settings(self)
            if len(pre_auth_settings) > 0:
                settings += [
                    Divider(),
                    Header(text=get_platform(selected_platform).value[1])
                ]
                settings += pre_auth_settings

                if self.platform.additional_settings:
                    additional_settings = self.platform.create_additional_settings(self)
                    if len(additional_settings) > 0:
                        settings += additional_settings

        if not is_value_valid and selected_platform != int(Platform.TgMusic.value[0]):
            return settings

        advanced = self.get_setting('advanced_mode', False)

        settings += [
            Divider(),

            Header(text='Cobalt API'),
            Selector(
                key='cobalt_api_url',
                text=locale.Settings_CobaltApi_Text,
                default=1,
                items=COBALT_API_URLS,
                icon='msg_instant_link'
            ),
            Input(
                key='cobalt_api_url_custom',
                text=locale.Settings_CobaltApi_Custom_Text,
                subtext=locale.Settings_CobaltApi_Subtext,
                default=DEFAULT_COBALT_API_URL,
                icon='msg2_devices'
            ) if self.get_setting('cobalt_api_url', 1) == 0 else None,
            Divider(),

            Header(text=locale.Settings_CardSettings_Header),
            Selector(
                key='card_type',
                text=locale.Settings_CardType_Header,
                default=0,
                icon="msg_background",
                items=[
                    locale.Settings_CardType_1,
                    locale.Settings_CardType_2
                ]
            ),
            Selector(
                key="background",
                text=locale.Settings_BackgroundMode_Text,
                default=1,
                items=[
                    locale.Settings_BackgroundMode_Item_1,
                    locale.Settings_BackgroundMode_Item_2
                ],
                icon="msg_photos"
            ),
            Selector(
                key="font",
                text=locale.Settings_Font_Text,
                default=0,
                items=[
                    locale.Settings_Font_Item1,
                    locale.Settings_Font_Item2,
                    locale.Settings_Font_Item3,
                    "Yandex Music",
                    "Yandex Text",
                ],
                icon="msg_photo_text_regular"
            ),
            Selector(
                key="platform_link",
                text=locale.Settings_PlatformLink_Text,
                default=1,
                items=[
                    locale.Settings_PlatformLink_Item_1,
                    locale.Settings_PlatformLink_Item_2,
                    locale.Settings_PlatformLink_Item_3
                ],
                icon="msg_link2"
            ) if selected_platform != int(Platform.TgMusic.value[0]) else None,
            Switch(
                key="songlink_link_include",
                text=locale.Settings_SongLinkInclude_Text,
                default=True,
                subtext=locale.Settings_SongLinkInclude_Subtext,
                icon="msg_language"
            ),
            Switch(
                key="fast_card_render",
                text=locale.Settings_FastCardRender_Text,
                default=False,
                subtext=locale.Settings_FastCardRender_Subtext,
                on_change=lambda new_value: self.set_fast_card_render_enabled(new_value),
                icon="boosts_solar"
            ),

            Switch(
                key="advanced_mode",
                text=locale.Setting_AdvancedMode_Text,
                default=False,
                subtext=locale.Setting_AdvancedMode_Subtext,
                icon="msg_palette"
            ),
            Text(
                text=locale.Setting_AdvancedMode_Title,
                icon="msg_download_settings",
                create_sub_fragment=self.create_customization_settings
            ) if advanced else None,

            Divider(),

            Header(text=locale.Settings_Stream_Header),
            Switch(
                key="stream_bio_enabled",
                text=locale.Settings_Stream_Text,
                default=False,
                subtext=locale.Settings_Stream_Subtext,
                on_change=lambda new_value: self.set_stream_bio_enabled(new_value),
                icon="msg_online"
            ),
            Text(
                text=locale.Settings_Stream_AccountId,
                on_click=lambda _: self.set_new_stream_account(),
                accent=True,
                icon="msg_mention"
            ) if get_user_config().getClientUserId() != get_local_stream_id() else None,
            Text(
                text=locale.Setting_Stream_Title,
                icon="msg_download_settings",
                create_sub_fragment=self.create_stream_settings
            ),
            Divider(text=locale.Settings_Stream_Alert),

            Header(text=locale.Settings_Cache_Header),
            Switch(
                key="enable_auth_data_cache",
                text=locale.Setting_Cache_Enable_Text,
                icon="menu_clear_cache",
                default=True,
                on_change=lambda new_value: self.update_cache(new_value)
            ),
            Text(
                text=locale.Setting_Cache_DeleteCached,
                icon="msg_delete",
                red=True,
                on_click=lambda _: self.clear_cached_platforms_values()
            ) if self.get_setting("enable_auth_data_cache", False) else None,

            Divider(),

            Header(text=locale.Settings_Other_Header),
            Text(
                text=locale.Setting_Other_SourceCheck,
                icon="msg_noise_on",
                on_click=lambda _: self.check_resources(True, True)
            ),
            Text(
                text=locale.Setting_Other_ForceDownload,
                icon="msg_download",
                on_click=lambda _: threading.Thread(target=self.download_resources, args=(True,), daemon=True).start()
            )
        ]

        return settings

    def create_customization_settings(self):
        return [
            Input(
                key="background_color",
                text=locale.Settings_BackgroundColor_Text,
                default=DEFAULT_COLOR["background_color"],
                subtext=locale.Settings_BackgroundColor_Subtext,
                icon="menu_feature_custombg",
                on_change=lambda new_value: self.is_hex_valid(new_value, "background_color")
            ) if self.get_setting("background", 1) == 1 else None,
            Input(
                key="title_text_color",
                text=locale.Settings_AccentColor_Text,
                default=DEFAULT_COLOR["title_text_color"],
                subtext=locale.Settings_AccentColor_Subtext,
                icon="msg_photo_text_framed",
                on_change=lambda new_value: self.is_hex_valid(new_value, "title_text_color")
            ),
            Input(
                key="subtext_color",
                text=locale.Settings_SecondaryColor_Text,
                default=DEFAULT_COLOR["subtext_color"],
                subtext=locale.Settings_SecondaryColor_Subtext,
                icon="msg_photo_text_framed2",
                on_change=lambda new_value: self.is_hex_valid(new_value, "subtext_color")
            ),
            Input(
                key="instant_subtext",
                text=locale.Settings_InstantCardSubtext_Text,
                default=DEFAULT_INSTANT_SUBTEXT,
                subtext=locale.Settings_InstantCardSubtext_Subtext,
                icon="menu_feature_intro"
            ),
            Input(
                key="instant_main_text",
                text=locale.Settings_InstantCardMainText_Text,
                default=DEFAULT_INSTANT_MAIN_TEXT,
                subtext=locale.Settings_InstantCardMainText_Subtext,
                icon="menu_feature_cover"
            ),
            Switch(
                key="show_service_logo",
                text=locale.Settings_Vertical_ShowServiceLogo_Text,
                default=True,
                icon="msg_archive_hide" if not self.get_setting("show_service_logo", True) else "msg_message",
            ) if self.get_setting("card_type", 0) else None
        ]

    def create_stream_settings(self):
        stream_places: List[str] = [locale.Setting_TrackStream_Item1]

        if get_user_config().isPremium():
            stream_places.append(locale.Setting_TrackStream_Item2)

        # stream_places.append(locale.Setting_TrackStream_Item3)

        stream_place = self.get_setting("stream_place", 0)
        is_to_profile_stream = stream_place == 2 or (stream_place == 1 and not get_user_config().isPremium())

        return [
            Selector(
                key="stream_place",
                text=locale.Setting_TrackStream_Text,
                default=0,
                items=stream_places,
                icon="menu_premium_location" if self.get_setting("stream_place", 0) else "msg_openprofile"
            ),
            Input(
                key="default_stream_text",
                text=locale.Settings_InStream_Text,
                default=DEFAULT_STREAM_TEXT,
                subtext=locale.Settings_InStream_Subtext,
                icon="msg_photo_text_framed3"
            ) if not is_to_profile_stream else None,
            Input(
                key="track_display_format",
                text=locale.Settings_FormatInStream_Text,
                default=DEFAULT_STREAM_STRING,
                subtext=locale.Settings_FormatInStream_Subtext,
                icon="msg_view_file"
            ) if not is_to_profile_stream else None
        ]

    def set_menu_items(self, remove: bool):
        def on_menu_item_click(new_platform: int):
            self.set_menu_items(True)
            self.set_setting('selected_platform', new_platform)
            self.create_settings()

            platform: Platform = get_platform(new_platform)

            if self.get_setting('selected_platform', int(Platform.NotSelected.value[0])) == new_platform:
                self.update_platform_object(new_platform, False)
                self.set_menu_items(False)

                success_text = locale.MenuItem_Service_Success.format(platform.value[1])

                if self.get_setting('value', DEFAULT_VALUE) in ['', None, DEFAULT_VALUE] and platform != Platform.TgMusic:
                    show_info(
                        message=f'\n{success_text}\n{locale.MenuItem_Service_Success_Subtext}',
                        on_click=lambda: open_plugin_settings(),
                        button_text=locale.Check_Value_NotValid_Button
                    )
                else:
                    show_success(success_text)
            else:
                show_error(locale.MenuItem_Service_Fail.format(pl.value[1]))

        selected_platform = self.get_setting('selected_platform', int(Platform.NotSelected.value[0]))
        platforms = [p for p in Platform if p.value[0] != selected_platform and p.value[0] != int(Platform.NotSelected.value[0])]

        for pl in platforms:
            cleared_item_name: str = str(pl.value[1]).lower().strip().replace(" ", "").replace(".", "")
            item_id: str = f'{cleared_item_name}-{pl.value[0]}'

            if remove:
                self.remove_menu_item(item_id)
            else:
                self.add_menu_item(
                    menu_item_data=MenuItemData(
                        menu_type=MenuItemType.CHAT_ACTION_MENU,
                        item_id=item_id,
                        icon='msg_tone_on',
                        text=locale.MenuItem_Service_Select_Text.format(pl.value[1]),
                        # subtext=locale.MenuItem_Service_Select_Subtext,
                        on_click=lambda _, p=pl: on_menu_item_click(int(p.value[0]))
                    )
                )

    def on_send_message_hook(self, account: int, params: Any):
        has_caption = hasattr(params, 'caption') and isinstance(params.caption, str)
        has_text = hasattr(params, 'message') and isinstance(params.message, str)

        if has_caption or has_text:
            is_modified = False
            current_text = params.caption if has_caption else params.message

            try:
                metadata_flag = f"{__name__}_flag_metadata"
                markdown_flag = f"{__name__}_flag_markdown"

                if metadata_flag in current_text:

                    if self.is_poller_enabled():
                        track = self.platform.now_track
                    else:
                        track = self.platform.get_track()

                    if has_caption:
                        attributes = params.document.attributes
                        for i in range(attributes.size()):
                            attr = attributes.get(i)
                            if isinstance(attr, TLRPC.TL_documentAttributeAudio):
                                attr.title = track.title if track.active else f"[{__name__}] ERROR"
                                attr.performer = ", ".join(track.artist) if track.active else locale.Track_Not_Active
                                attr.duration = track.duration if track.active else 0

                    current_text = current_text.replace(" " + metadata_flag, "")
                    is_modified = True

                if markdown_flag in current_text:
                    try:
                        current_text = current_text.replace(" " + markdown_flag, "")

                        caption = parse_markdown(current_text)
                        current_text = caption.text

                        new_entities = ArrayList()
                        for i in caption.entities:
                            new_entities.add(i.to_tlrpc_object())
                        params.entities = new_entities

                        is_modified = True
                    except Exception as e:
                        import traceback
                        logcat(traceback.format_exc())

                params.searchLinks = False

                if is_modified:
                    if has_caption:
                        params.caption = current_text
                    elif has_text:
                        params.message = current_text

                    return HookResult(HookStrategy.MODIFY, params=params)
                else:
                    return HookResult(strategy=HookStrategy.DEFAULT)

            except Exception as e:
                import traceback
                logcat(traceback.format_exc())
                return HookResult(strategy=HookStrategy.DEFAULT)

        else:
            return HookResult(strategy=HookStrategy.DEFAULT)

    def post_request_hook(self, request_name: str, account: int, response: Any, error: Any) -> HookResult:
        if not self.get_setting('stream_bio_enabled', False):
            logcat('Streamer disabled')
            return HookResult(strategy=HookStrategy.DEFAULT)

        stream_place = self.get_setting('stream_place', 0)
        if stream_place == 2 or (stream_place == 1 and not get_user_config().isPremium()):
            set_profile_saved_track(response)
            return HookResult(strategy=HookStrategy.DEFAULT)

        logcat('Stream place not valid')
        return HookResult(strategy=HookStrategy.DEFAULT)

    def _setup_hooks(self):
        try:
            emoji_view = get_java_class("org.telegram.ui.Components.EmojiView")
            if not emoji_view: return

            base_fragment = get_java_class("org.telegram.ui.ActionBar.BaseFragment")
            resources_provider = get_java_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            chat_full = get_java_class("org.telegram.tgnet.TLRPC$ChatFull")
            context = get_java_class("android.content.Context")
            view_group = get_java_class("android.view.ViewGroup")

            ctor = find_constructor_exact(
                emoji_view,
                base_fragment, # fragment
                Boolean.TYPE, # needAnimatedEmoji
                Boolean.TYPE, # needStickers
                Boolean.TYPE, # needGif
                context, # context
                Boolean.TYPE, # needSearch
                chat_full, # chatFull
                view_group, # parentView
                Boolean.TYPE, # shouldDrawBackground
                resources_provider, # resourcesProvider
                Boolean.TYPE, # frozenAtStart
                Boolean.TYPE # glassDesign
            )

            if ctor is None:
                ctor = find_constructor_exact(
                    emoji_view,
                    base_fragment,  # fragment
                    Boolean.TYPE,  # needAnimatedEmoji
                    Boolean.TYPE,  # needStickers
                    Boolean.TYPE,  # needGif
                    context,  # context
                    Boolean.TYPE,  # needSearch
                    chat_full,  # chatFull
                    view_group,  # parentView
                    Boolean.TYPE,  # shouldDrawBackground
                    resources_provider,  # resourcesProvider
                    Boolean.TYPE  # frozenAtStart
                )

            if ctor is None:
                logcat("Failed to find EmojiView constructor")
                return

            if ctor: self.hooks.append(self.hook_method(ctor, EmojiViewConstructorHook(self)))

            set_allow = find_method_exact(emoji_view, "setAllow", Boolean.TYPE, Boolean.TYPE, Boolean.TYPE)
            if set_allow: self.hooks.append(self.hook_method(set_allow, SetAllowHook(self)))

            check_grid = find_method_exact(emoji_view, "checkGridVisibility", Integer.TYPE, Float.TYPE)
            if check_grid: self.hooks.append(self.hook_method(check_grid, CheckGridVisibilityHook(self)))

            adapter_class = get_java_class("org.telegram.ui.Components.EmojiView$EmojiPagesAdapter")
            if adapter_class:
                get_icon = find_method_exact(adapter_class, "getPageIconDrawable", Integer.TYPE)
                if get_icon: self.hooks.append(self.hook_method(get_icon, AdapterGetIconHook(self)))

                get_title = find_method_exact(adapter_class, "getPageTitle", Integer.TYPE)
                if get_title: self.hooks.append(self.hook_method(get_title, AdapterGetTitleHook(self)))

        except Exception as e:
            logcat(f"Setup error: {e}")

    def set_new_stream_account(self):
        save_stream_account_id(get_user_config().getClientUserId())
        self.save_default_user_bio()
        self.set_setting("stream_bio_enabled", self.get_setting("stream_bio_enabled", False))

    def is_platform_value_valid(self, platform: int) -> bool:
        value = str(self.get_setting("value", ""))
        if platform == int(Platform.YandexMusic.value[0]):
            return not len(value) <= 4 and not value in ["", None, DEFAULT_VALUE]
        elif platform == int(Platform.TgMusic.value[0]):
            return True
        else:
            return not value in ["", None, DEFAULT_VALUE]

    def update_cache(self, new_value: bool):
        initialize_cached_platforms_values()
        if new_value:
            self.set_menu_items(False)
            save_platform_value(
                self.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                self.get_setting("value", "")
            )
        else:
            self.set_menu_items(True)

    def clear_cached_platforms_values(self):
        initialize_cached_platforms_values()
        cached_values = get_cached_values()
        values = [cl for cl in cached_values if cl == DEFAULT_VALUE]
        if len(values) == PLATFORMS_COUNT:
            save_platform_value(
                self.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                self.get_setting("value", "")
            )
            show_success(locale.CachedAuthData_Clear_Success)
        else:
            show_error(locale.CachedAuthData_Clear_Error)

    def download_track_with_cobalt(self, url: str, track: Track) -> Optional[str]:
        api_url_index: int = self.get_setting('cobalt_api_url', 1)

        if api_url_index == 0:
            api_url = self.get_setting('cobalt_api_url_custom', DEFAULT_COBALT_API_URL)

            if api_url in ['', None]:
                api_url = DEFAULT_COBALT_API_URL
        else:
            api_url: str = COBALT_API_URLS[api_url_index]

        payload: Dict[str, str] = {
            "url": url,
            "downloadMode": "audio",
            "audioBitrate": "320",
            "audioFormat": "best"
        }
        headers: Dict[str, str] = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        try:
            try:
                response = requests.post(f"{api_url}/", json=payload, headers=headers, timeout=30)
                response.raise_for_status()
            except Exception as e:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Bulletin_InvalidCobaltResponse)
                logcat(f"Cobalt Request Error: {e} | data = {payload}")
                return None

            data = response.json()
            logcat(f"Cobalt Response Data: {data}")

            status = data.get("status")

            if status == "error":
                code = data.get("error", {}).get("code", "Unknown error")
                show_error(locale.Bulletin_CobaltErrorCode.format(code))
                return None

            elif status == "picker":
                items = data.get("picker", [])
                if not items:
                    show_error(locale.Bulletin_NoItemsToDownload)
                    return None
                item = items[0]
                direct_url = item.get("url")
                original_filename = item.get("filename")

            elif status in ["stream", "redirect", "success", "tunnel"]:
                direct_url = data.get("url")
                original_filename = data.get("filename")

            else:
                logcat(f"Cobalt Warning: Received an unhandled status: '{status}'")
                show_error(locale.Bulletin_InvalidCobaltResponse)
                return None

            if not direct_url:
                show_error(locale.Bulletin_InvalidCobaltResponse)
                return None

            temp_dir = get_temp_dir()

            file_extension = original_filename.split('.')[-1] if original_filename and '.' in original_filename else 'mp3'
            filename: str = f"{track.title} (via {__name__}).{file_extension}"
            file_path: str = File(temp_dir, filename).getAbsolutePath()

            logcat(f"Downloading audio in background thread: {filename}")

            try:
                track_resp = requests.get(direct_url, stream=True, timeout=60)
                track_resp.raise_for_status()
            except Exception as e:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat(f"Cobalt Download Error: {e}")
                show_error(locale.Bulletin_InvalidCobaltResponse)
                return None

            with open(file_path, "wb") as f:
                for chunk in track_resp.iter_content(chunk_size=8192):
                    f.write(chunk)

            ext_root = ApplicationLoader.applicationContext.getExternalCacheDir()
            plugin_dir = File(ext_root, TEMP_DIR_NAME)
            ext_path = File(plugin_dir, File(file_path).getName()).getAbsolutePath()

            with open(file_path, 'rb') as fin, open(ext_path, 'wb') as fout:
                fout.write(fin.read())

            return file_path
        except Exception as _:
            import traceback
            logcat(traceback.format_exc())

    def send_card_message(self, param):
        try:
            run_on_ui_thread(lambda: self.show_spinner())
            params = {
                "message": None,
                "peer": param.peer
            }

            if self.is_poller_enabled():
                track = self.platform.now_track
            else:
                track = self.platform.get_track()

            if track is None:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat("z1")
                show_error(locale.Track_Not_Active)
                return

            if not track.active:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat("z2")
                show_error(locale.Track_Not_Active)
                return

            temp_dir = get_temp_dir()
            temp_file_path = None

            card_type: int = self.get_setting('card_type', 0)

            if card_type == 0:
                card = self.create_horizontal_card()
            elif card_type == 1:
                card = self.create_vertical_card()
            else:
                card = None

            answer = card if not (self.get_setting("fast_card_render", False)) else True
            if answer:
                temp_file_path = File(temp_dir, f"now_{__name__}.png").getAbsolutePath()

            if temp_file_path in ["", None]:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat("z3")
                show_error(locale.Track_Not_Active)
                return

            generated_photo = get_send_messages_helper().generatePhotoSizes(temp_file_path, None)

            if generated_photo is None:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat("z4")
                show_error(locale.Track_Not_Active)
                return

            params["photo"] = generated_photo
            params["path"] = temp_file_path
            params["replyToMsg"] = param.replyToMsg
            params["replyToTopMsg"] = param.replyToTopMsg

            if not track.active:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat("z5")
                show_error(locale.Track_Not_Active)
                return

            platform = self.get_setting("selected_platform", 0)

            platform_link: int = self.get_setting("platform_link", 1)
            platform_link_added: bool = False

            songlink: bool = self.get_setting("songlink_link_include", True)
            songlink_added: bool = False

            caption: str = ""

            if (platform_link and platform_link != 0) and platform != int(Platform.TgMusic.value[0]):
                link = track.link if (platform_link == 1 or track is None) else track.album
                caption += locale.Message_CaptionLink_Text.format(get_platform(platform).value[1], link)
                platform_link_added = True

            if songlink and songlink != 0:
                if platform_link_added:
                    caption += locale.Message_CaptionDivider

                caption += locale.Message_CaptionSongLink_Text.format(f"https://song.link/{get_songlink(platform)}/{track.id}")
                songlink_added = True

            if any([platform_link_added, songlink_added]):
                emoji: str = random.choice(["[ðŸŽµ](5188621441926438751) | ", "[ðŸŽ¶](5188705588925702510) | "])
                caption = emoji + caption

                parsed_caption = parse_markdown(caption)
                params["caption"] = parsed_caption.text
                params["entities"] = set()

                for i in parsed_caption.entities:
                    params["entities"].add(i.to_tlrpc_object())

            run_on_ui_thread(lambda: send_message(params))
            run_on_ui_thread(lambda: self.dismiss_spinner())
        except Exception as _:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            show_error(locale.Track_Not_Active)
            import traceback
            logcat(f'send_card_message: {traceback.format_exc()}')

    def send_audio_message(self, param, silent: bool = False) -> bool:
        if not silent:
            run_on_ui_thread(lambda: self.show_spinner())

        if self.is_poller_enabled():
            track = self.platform.now_track
        else:
            track = self.platform.get_track()

        if not track.active:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            if not silent:
                show_error(locale.Track_Not_Active)
            return False

        if not self.platform.can_download_track:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            if not silent:
                show_error(locale.Check_Platform_DownloadNotAvailable)
            return False

        url = track.download_url
        temp_dir = get_temp_dir()

        try:
            if not url is None:
                ext = os.path.splitext(url)[1] or ".mp3"
                filename = f"{track.title}{ext}"
                file_path = File(temp_dir, filename).getAbsolutePath()
                resp = requests.get(url, stream=True, timeout=60)
                resp.raise_for_status()

                with open(file_path, 'wb') as f:
                    for chunk in resp.iter_content(8192):
                        f.write(chunk)

                ext_root = ApplicationLoader.applicationContext.getExternalCacheDir()
                plugin_dir = File(ext_root, TEMP_DIR_NAME)

                if not plugin_dir.exists() and not plugin_dir.mkdirs():
                    pass

                ext_path = File(plugin_dir, File(file_path).getName()).getAbsolutePath()

                with open(file_path, 'rb') as fin, open(ext_path, 'wb') as fout:
                    fout.write(fin.read())

                delete_file_delayed(file_path)
            else:
                new_url = get_download_link(
                    platform=self.get_setting('selected_platform', int(Platform.NotSelected.value[0])),
                    track_id=track.id
                )

                if new_url in ['', None]:
                    run_on_ui_thread(lambda: self.dismiss_spinner())
                    return False

                file_path = self.download_track_with_cobalt(new_url, track)
                if file_path in ['', None] or not os.path.exists(file_path):
                    run_on_ui_thread(lambda: self.dismiss_spinner())
                    return False

                ext_root = ApplicationLoader.applicationContext.getExternalCacheDir()
                plugin_dir = File(ext_root, TEMP_DIR_NAME)
                ext_path = File(plugin_dir, File(file_path).getName()).getAbsolutePath()

            account = get_account_instance()

            if ext_path.endswith('.opus'):
                mime = 'audio/opus'
            else:
                mime = 'audio/mpeg'

            platform = self.get_setting("selected_platform", 0)

            platform_link: int = self.get_setting("platform_link", 1)
            platform_link_added: bool = False

            songlink: bool = self.get_setting("songlink_link_include", True)
            songlink_added: bool = False

            caption: str = ""

            if (platform_link and platform_link != 0) and platform != int(Platform.TgMusic.value[0]):
                link = track.link if (platform_link == 1 or track is None) else track.album
                caption += locale.Message_CaptionLink_Text.format(get_platform(platform).value[1], link)
                platform_link_added = True

            if songlink and songlink != 0:
                if platform_link_added:
                    caption += locale.Message_CaptionDivider

                caption += locale.Message_CaptionSongLink_Text.format(f"https://song.link/{get_songlink(platform)}/{track.id}")
                songlink_added = True

            if any([platform_link_added, songlink_added]):
                emoji: str = random.choice(["[ðŸŽµ](5188621441926438751) | ", "[ðŸŽ¶](5188705588925702510) | "])
                caption = emoji + caption

            markdown_need = any([platform_link_added, songlink_added])

            SendMessagesHelper.prepareSendingDocument(
                account,
                ext_path,
                ext_path,
                None,
                f"{caption} {__name__}_flag_metadata{f' {__name__}_flag_markdown' if markdown_need else ''}",
                mime,
                param.peer,
                param.replyToMsg,
                param.replyToTopMsg,
                None, None, None, True, 0, None, None, 0, False
            )

            if not silent:
                run_on_ui_thread(lambda: self.dismiss_spinner())

            delete_file_delayed(ext_path)
            return True
        except Exception as e:
            logcat(str(e))

            if not silent:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Track_Not_Active)

            return False

    def send_text_message(self, param):
        run_on_ui_thread(lambda: self.show_spinner())

        if self.is_poller_enabled():
            track = self.platform.now_track
        else:
            track = self.platform.get_track()

        if not track.active:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            show_error(locale.Track_Not_Active)
            return

        platform = self.get_setting("selected_platform", 0)

        platform_link: int = self.get_setting("platform_link", 1)
        platform_link_added: bool = False

        songlink: bool = self.get_setting("songlink_link_include", True)
        songlink_added: bool = False

        text: str = ""
        track_info: str = f"{track.title} - {','.join(track.artist)}\n"

        if (platform_link and platform_link != 0) and platform != int(Platform.TgMusic.value[0]):
            link = track.link if (platform_link == 1 or track is None) else track.album
            text += locale.Message_CaptionLink_Text.format(get_platform(platform).value[1], link)
            platform_link_added = True

        if songlink and songlink != 0:
            if platform_link_added:
                text += locale.Message_CaptionDivider

            text += locale.Message_CaptionSongLink_Text.format(f"https://song.link/{get_songlink(platform)}/{track.id}")
            songlink_added = True

        if any([platform_link_added, songlink_added]):
            emoji: str = random.choice(["[ðŸŽµ](5188621441926438751) | ", "[ðŸŽ¶](5188705588925702510) | "])
            text = emoji + track_info + text

        markdown_need = any([platform_link_added, songlink_added])
        params = {
            "message": f"{text} {__name__}_flag_metadata{f' {__name__}_flag_markdown' if markdown_need else ''}",
            "peer": param.peer,
            "replyToMsg": param.replyToMsg,
            "replyToTopMsg": param.replyToTopMsg,
        }

        run_on_ui_thread(lambda: send_message(params))
        run_on_ui_thread(lambda: self.dismiss_spinner())

    def update_platform_object(self, new_platform: int, value: bool):
        cache_enabled: bool = self.get_setting("enable_auth_data_cache", False)

        if self.is_poller_enabled():
            self.poller.stop_poller()

        if cache_enabled:
            self.set_menu_items(True)

        if not value:
            if cache_enabled and is_cached_value_exist(new_platform):
                self.set_setting("value", get_cached_value(new_platform))
            else:
                self.set_setting("value", "")

        token = self.get_setting("value", "")
        token_default_values = ["", None, DEFAULT_VALUE]
        new_platform_obj: BasePlatform | None = None

        if cache_enabled and (not new_platform in [int(Platform.NotSelected.value[0]), int(Platform.TgMusic.value[0])]):
            cached_value = get_cached_value(new_platform)
            if token not in token_default_values and token != cached_value:
                save_platform_value(new_platform, token)

        if new_platform == int(Platform.NotSelected.value[0]):
            new_platform_obj = None

        elif new_platform == int(Platform.Spotify.value[0]):
            new_platform_obj = Spotify(token)

        elif new_platform == int(Platform.YandexMusic.value[0]):
            is_custom_api_enabled = self.get_setting("enable_yandex_custom_api", False)
            custom_api = self.get_setting("yandex_custom_api", None)
            custom_api_url: Optional[str] = custom_api if is_custom_api_enabled else None
            new_platform_obj = YandexMusic(token, custom_api_url)

        elif new_platform == int(Platform.SoundCloud.value[0]):
            new_platform_obj = SoundCloud(token)

        elif new_platform == int(Platform.VkMusic.value[0]):
            new_platform_obj = VkMusic(token)

        elif new_platform == int(Platform.TgMusic.value[0]):
            new_platform_obj = TgMusic(token)

        elif new_platform == int(Platform.LastFm.value[0]):
            new_platform_obj = LastFm(token)

        else:
            logcat(f"Unknown platform ({new_platform})")

        self.platform = new_platform_obj

        if self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT) == DEFAULT_STREAM_TEXT:
            self.save_default_user_bio()

        self.set_stream_text(True)

        stream_bio_enabled: bool = self.get_setting('stream_bio_enabled', False)
        fast_card_render: bool = self.get_setting('fast_card_render', False)

        if token not in token_default_values and any([stream_bio_enabled, fast_card_render]):
            self.set_poller_enabled(True)

        if cache_enabled:
            self.set_menu_items(False)

        self.set_setting('value', token, True)

    def is_args_not_valid(self, platform: int) -> bool:
        if platform == int(Platform.NotSelected.value[0]) or self.platform is None:
            show_error(
                message=locale.Check_Platform_NotSelected,
                on_click=lambda: open_plugin_settings(),
                button_text=locale.Check_Platform_NotSelected_Button
            )
            return True

        if self.platform.need_special_platform_args_check and self.platform.special_platform_args_check(self):
            return True

        elif not self.is_platform_value_valid(platform):
            show_error(
                message=locale.Check_Value_NotValid,
                on_click=lambda: open_plugin_settings(),
                button_text=locale.Check_Value_NotValid_Button
            )
            return True

        elif not self.check_resources(True, False):
            show_error(
                message=locale.Check_Resources_NotFound,
                on_click=lambda: self.download_resources(True),
                button_text=locale.Check_Resources_NotFound_Button
            )
            return True

        else:
            return False

    def set_fast_card_render_enabled(self, enable: bool):
        if enable:
            self.poller.start_poller()
        else:
            if not self.get_setting("stream_bio_enabled", False):
                self.poller.stop_poller()

    def save_default_user_bio(self):
        stream_place = self.get_setting("stream_place", 0)
        default_stream_text = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)

        client_user_id = get_user_config().getClientUserId()
        if client_user_id is None or client_user_id == 0:
            logcat("Client userId not found")
            return

        user_full = get_messages_controller().getUserFull(client_user_id)
        if user_full is None:
            logcat("User fullInfo not found")
            return

        if stream_place == 0:  # current bio
            if user_full.about and user_full.about != default_stream_text:
                if not str(user_full.about).startswith("ðŸŽµ | "):
                    self.set_setting("default_stream_text", user_full.about)

        elif stream_place == 1:  # current address
            if user_full.business_location and user_full.business_location.address and user_full.business_location.address != default_stream_text:
                if not str(user_full.business_location.address).startswith("ðŸŽµ | "):
                    self.set_setting("default_stream_text", user_full.business_location.address)

        else:  # Index out of range
            self.set_setting("default_stream_text", DEFAULT_STREAM_TEXT)

    def set_stream_bio_enabled(self, enable: bool):
        if enable:
            self.poller.start_poller()
            self.save_default_user_bio()
            self.set_stream_text(False)
        else:
            self.set_stream_text(True)
            if not self.get_setting("fast_card_render", False):
                self.poller.stop_poller()

    def set_stream_text(self, default: bool):
        if get_local_stream_id() != get_user_config().getClientUserId():
            return

        stream_place = self.get_setting("stream_place", 0)

        client_user_id = get_user_config().getClientUserId()
        if client_user_id is None or client_user_id == 0:
            logcat("Client userId not found")
            return

        user_full = get_messages_controller().getUserFull(client_user_id)
        if user_full is None:
            logcat("User fullInfo not found")
            return

        current_text: str = ""

        if stream_place == 0:  # current bio
            if user_full.about:
                current_text = user_full.about

        elif stream_place == 1 and get_user_config().isPremium():  # current address
            if user_full.business_location and user_full.business_location.address:
                current_text = user_full.business_location.address

        elif stream_place == 2 or (stream_place == 1 and not get_user_config().isPremium()):
            if not user_full.saved_music is None:
                pass

        else:
            logcat("Index out of range. Can't get current bio text.")

        if self.platform is None or self.platform.now_track is None:
            return

        text_to_set: str

        if default:
            text_to_set = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
        else:
            if self.platform and self.platform.now_track and self.platform.now_track.active:
                text_to_set = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                text_to_set = text_to_set.replace("{title}", self.platform.now_track.title)
                text_to_set = text_to_set.replace("{artists}", ", ".join(self.platform.now_track.artist))
            else:
                logcat("Poller check: No active track to display. No changes needed.")
                return

        final_text_to_set = text_to_set
        if stream_place == 0:
            max_len = 140 if get_user_config().isPremium() else 70
            final_text_to_set = text_to_set[:max_len]
        elif stream_place == 1 and get_user_config().isPremium():
            final_text_to_set = text_to_set[:96]

        if final_text_to_set == current_text and (stream_place == 0 or (stream_place == 1 and get_user_config().isPremium())):
            logcat("No need to update bio.")
            return

        if stream_place == 0:  # in bio
            # online update
            request = TL_account.updateProfile()
            request.flags = 4
            request.about = final_text_to_set

            # local update
            user_full.flags = 2
            user_full.about = final_text_to_set

        elif stream_place == 1 and get_user_config().isPremium():  # in business location
            # online update
            request = TL_account.updateBusinessLocation()
            request.flags = 1
            request.address = final_text_to_set

            # local update
            user_full.flags2 = 2
            user_full.business_location = TLRPC.TL_businessLocation()
            user_full.business_location.address = final_text_to_set

        elif stream_place == 2 or (stream_place == 1 and not get_user_config().isPremium()):  # in saved music
            logcat(f'current mem id : {self.platform.memory_id}, new id: {self.platform.now_track.id}')
            if self.platform.memory_id == self.platform.now_track.id:
                return

            self.platform.memory_id = self.platform.now_track.id
            threading.Thread(target=self.download_track_for_stream, daemon=True).start()

            request = None

        else:  # out of range
            logcat("Stream place index out of range.")
            return

        if request:
            try:
                send_request(request, ())
                get_messages_storage().updateUserInfo(user_full, False)
                logcat(f"Updating bio to \"{text_to_set}\"...")
            except Exception as e:
                logcat(f"set_stream_text exception: {e}")

    def download_track_for_stream(self):
        client_user_id = get_user_config().getClientUserId()
        if client_user_id is None or client_user_id == 0:
            return

        if self.platform.can_download_track:
            params = SendMessagesHelper.SendMessageParams()
            params.peer = client_user_id
            result = self.send_audio_message(
                params,
                True
            )

            if result:
                return

        logcat('Failed to download track, creating empty file...')

        track = self.platform.now_track
        temp_dir = get_temp_dir()

        filename: str = f"{track.title} - {','.join(track.artist)}.mp3"
        file_path: str = File(temp_dir, filename).getAbsolutePath()

        create_minimal_id3_mp3(
            file_path,
            track.title,
            ', '.join(track.artist),
            random.randint(30, 240) if track.duration is None else track.duration,
            random.randint(1, 2)
        )

        ext_root = ApplicationLoader.applicationContext.getExternalCacheDir()
        plugin_dir = File(ext_root, TEMP_DIR_NAME)

        if not plugin_dir.exists():
            plugin_dir.mkdirs()

        ext_path = File(plugin_dir, File(file_path).getName()).getAbsolutePath()

        with open(file_path, 'rb') as fin:
            with open(ext_path, 'wb') as fout:
                fout.write(fin.read())

        platform = self.get_setting("selected_platform", 0)

        platform_link: int = self.get_setting("platform_link", 1)
        platform_link_added: bool = False

        songlink: bool = self.get_setting("songlink_link_include", True)
        songlink_added: bool = False

        caption: str = ""

        if (platform_link and platform_link != 0) and platform != int(Platform.TgMusic.value[0]):
            link = track.link if (platform_link == 1 or track is None) else track.album
            caption += locale.Message_CaptionLink_Text.format(get_platform(platform).value[1], link)
            platform_link_added = True

        if songlink and songlink != 0:
            if platform_link_added:
                caption += locale.Message_CaptionDivider

            caption += locale.Message_CaptionSongLink_Text.format(f"https://song.link/{get_songlink(platform)}/{track.id}")
            songlink_added = True

        if any([platform_link_added, songlink_added]):
            emoji: str = random.choice(["[ðŸŽµ](5188621441926438751) | ", "[ðŸŽ¶](5188705588925702510) | "])
            caption = emoji + caption

        markdown_need = any([platform_link_added, songlink_added])

        SendMessagesHelper.prepareSendingDocument(
            get_account_instance(),
            ext_path,
            ext_path,
            None,
            f"{caption} {__name__}_flag_metadata{f' {__name__}_flag_markdown' if markdown_need else ''}" ,
            "audio/mpeg",
            client_user_id,
            None,
            None,
            None, None, None, True, 0, None, None, 0, False
        )

    def create_horizontal_card(self):
        try:
            track = self.platform.now_track
            temp_dir = get_temp_dir()
            font_family = self.get_setting("font", 0)
            font_family = FONTS[font_family]
            width, height = 1440, 600

            advanced_mode = self.get_setting("advanced_mode", False)
            if not advanced_mode:
                background_color = DEFAULT_COLOR["background_color"]
                title_text_color = DEFAULT_COLOR["title_text_color"]
                subtext_color = DEFAULT_COLOR["subtext_color"]
            else:
                background_color = self.get_setting("background_color", DEFAULT_COLOR["background_color"])
                title_text_color = self.get_setting("title_text_color", DEFAULT_COLOR["title_text_color"])
                subtext_color = self.get_setting("subtext_color", DEFAULT_COLOR["subtext_color"])

            if not track.active:
                if locale.language == 'ru' and font_family == "Circular":
                    font_family = "Onest"

                card = Image.new('RGB', (width, height), background_color)
                draw = ImageDraw.Draw(card)

                regular_plugin_font = File(temp_dir, f"{font_family}-Regular.ttf").getAbsolutePath()
                bold_plugin_font = File(temp_dir, f"{font_family}-Bold.ttf").getAbsolutePath()
                plugin_font = ImageFont.truetype(regular_plugin_font, 40)
                not_active_font = ImageFont.truetype(bold_plugin_font, 80)

                draw.text(
                    xy=(width // 2, 45),
                    text=__name__,
                    font=plugin_font,
                    fill=title_text_color,
                    align="center",
                    anchor="mm"
                )

                draw.text(
                    xy=(width // 2, height // 2),
                    text="player_not_active_text",
                    font=not_active_font,
                    fill=title_text_color,
                    align="center",
                    anchor="mm"
                )

                filename = f"now_{__name__}.png"
                temp_photo_path = File(temp_dir, filename).getAbsolutePath()
                card.save(temp_photo_path)
                return temp_photo_path

            background_setting = self.get_setting("background", 1)

            try:
                thumb = requests.get(track.thumb, stream=True).raw
            except:
                thumb = requests.get(EMPTY_TRACK_COVER, stream=True).raw

            background = Image.open(thumb)
            thumbnail = background.copy()

            if background_setting == 0:
                background = (background
                              .resize((width, width))
                              .crop((0, (width - height) // 2, width, width))
                              .filter(ImageFilter.GaussianBlur(radius=14)))
                background = ImageEnhance.Brightness(background).enhance(0.3)

                card = Image.new('RGB', (width, height), background_color)
                card.paste(background, (0, 0))

            elif not advanced_mode:
                card = Image.new('RGB', (width, height), get_cover_accent_color(background))

            else:
                card = Image.new('RGB', (width, height), background_color)

            thumbnail = thumbnail.resize((450, 450))
            mask = Image.new('L', thumbnail.size, 0)
            draw = ImageDraw.Draw(mask)
            draw.rounded_rectangle((0, 0, *thumbnail.size), 30, fill=255)
            thumbnail = thumbnail.copy()
            thumbnail.putalpha(mask)
            card.paste(thumbnail, (75, 75), thumbnail)
            draw = ImageDraw.Draw(card)
            local_font_family = None

            if re.findall(r"[Ð-Ð¯Ð°-ÑÐÑ‘]", track.title) and font_family == "Circular":
                local_font_family = "Onest"

            title_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Bold.ttf")
            title_font = ImageFont.truetype(title_font_file.getAbsolutePath(), 60)

            x, y = 590, 85
            artists_plus_y = 0
            lines = textwrap.wrap(track.title, width=21)

            if len(lines) > 1:
                lines[1] = lines[1] + "..." if len(lines) > 2 else lines[1]
                artists_plus_y = 70
            else:
                pass

            lines = lines[:2]

            for line in lines:
                draw.text((x, y), line, font=title_font, fill=title_text_color)
                y += 70

            local_font_family = None

            if re.findall(r"[Ð-Ð¯Ð°-ÑÐÑ‘]", "".join(track.title)) and font_family == "Circular":
                local_font_family = "Onest"

            artist_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Regular.ttf")
            artist_font = ImageFont.truetype(artist_font_file.getAbsolutePath(), 40)
            artists = textwrap.wrap(" â€¢ ".join(track.artist), width=32)
            if len(artists) > 1:
                if "â€¢" in artists[0][-2:]:
                    artists[0] = artists[0][:artists[0].rfind("â€¢") - 1]
                artists[0] = artists[0]
            artists = artists[0]

            draw.text((590, 170 + artists_plus_y), artists, subtext_color, font=artist_font)
            if not (self.get_setting("fast_card_render", False)) and track.progress:
                progress_bar_empty = Image.new('RGBA', (width - 665, 10), (0, 0, 0, 0))

                progress_draw = ImageDraw.Draw(progress_bar_empty)
                progress_draw.rounded_rectangle(
                    xy=(0, 0, *progress_bar_empty.size),
                    radius=7,
                    fill=subtext_color
                )
                progress_draw.rounded_rectangle(
                    xy=(0, 0, progress_bar_empty.width * (track.progress / track.duration), 10),
                    radius=7,
                    fill=title_text_color
                )
                card.paste(progress_bar_empty, (590, 460), progress_bar_empty)

                timers_font_path = File(temp_dir, f"{font_family}-Regular.ttf").getAbsolutePath()
                timers_font = ImageFont.truetype(timers_font_path, 30)

                draw.text(
                    xy=(590, 490),
                    text=f"{datetime.datetime.fromtimestamp(track.progress).strftime('%M:%S')}",
                    fill=subtext_color,
                    font=timers_font,
                    anchor="la"
                )
                draw.text(
                    xy=(1365, 490),
                    text=f"{datetime.datetime.fromtimestamp(track.duration).strftime('%M:%S')}",
                    fill=subtext_color,
                    font=timers_font,
                    anchor="ra"
                )
            else:
                local_font_family = None

                if advanced_mode:
                    subtext = self.get_setting("instant_subtext", "powered by")
                    maintext = self.get_setting("instant_main_text", __name__)
                else:
                    subtext = "powered by"
                    maintext = __name__

                subtext = subtext[:26] + "..." if len(subtext) > 26 else subtext
                maintext = maintext[:21] + "..." if len(maintext) > 21 else maintext

                ru_flag_subtext = True if re.findall(r"[Ð-Ð¯Ð°-ÑÐÑ‘]", subtext) else False
                ru_flag_maintext = True if re.findall(r"[Ð-Ð¯Ð°-ÑÐÑ‘]", maintext) else False

                if ru_flag_subtext and font_family == "Circular":
                    local_font_family = "Onest"

                info_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Regular.ttf")
                info_font = ImageFont.truetype(info_font_file.getAbsolutePath(), 42)
                local_font_family = None

                if ru_flag_maintext and font_family == "Circular":
                    local_font_family = "Onest"

                device_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Bold.ttf")
                device_font = ImageFont.truetype(device_font_file.getAbsolutePath(), 52)

                draw.text((590, 415), subtext, subtext_color, font=info_font, anchor="ls")
                draw.text((590, 485), maintext, title_text_color, font=device_font, anchor="ls")

            filename = f"now_{__name__}.png"
            temp_photo_path = File(temp_dir, filename).getAbsolutePath()
            card.save(temp_photo_path)

            return temp_photo_path
        except Exception as _:
            import traceback
            logcat(f'Failed generate card: {traceback.format_exc()}')
            return None

    def create_vertical_card(self):
        track = self.platform.now_track
        temp_dir = get_temp_dir()
        font_family = self.get_setting("font", 0)
        font_family = FONTS[font_family]

        cover_as_background = self.get_setting("background", 1)
        show_service_logo = self.get_setting("show_service_logo", True)

        max_title_symbols = 19
        max_subtitle_symbols = 30

        local_font_family = None

        advanced_mode = self.get_setting("advanced_mode", False)
        if not advanced_mode:
            title_text_color = (255, 255, 255)
            subtext_color = None
            background_color = None
        else:
            background_color = self.get_setting("background_color", DEFAULT_COLOR["background_color"])
            title_text_color = self.get_setting("title_text_color", DEFAULT_COLOR["title_text_color"])
            subtext_color = self.get_setting("subtext_color", DEFAULT_COLOR["subtext_color"])

        if re.findall(r"[Ð-Ð¯Ð°-ÑÐÑ‘]", track.title) and font_family == "Circular":
            local_font_family = "Onest"

        title_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Bold.ttf")
        title_font = ImageFont.truetype(title_font_file.getAbsolutePath(), 40)

        artist_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Regular.ttf")
        artist_font = ImageFont.truetype(artist_font_file.getAbsolutePath(), 30)

        duration_font_path = File(temp_dir, f"{font_family}-Regular.ttf").getAbsolutePath()
        duration_font = ImageFont.truetype(duration_font_path, 14)

        artists = ", ".join(track.artist)

        try:
            cover = requests.get(track.thumb, stream=True).raw
        except:
            cover = requests.get(EMPTY_TRACK_COVER, stream=True).raw

        original_cover_img = Image.open(cover)
        center_img = original_cover_img.copy().resize((384, 384), Image.Resampling.LANCZOS)
        background_fill = get_cover_accent_color(center_img)
        second_fill = adjust_color_for_readability(background_fill)

        if cover_as_background == 0:
            card = original_cover_img.resize((600, 660), Image.Resampling.LANCZOS)
            card = card.filter(ImageFilter.GaussianBlur(radius=25))
            overlay = Image.new('RGBA', card.size, (0, 0, 0, 90))
            card = card.convert('RGBA')
            card = Image.alpha_composite(card, overlay)
            card = card.convert('RGB')
        else:
            final_bg_color = background_color if advanced_mode else background_fill
            card = Image.new('RGB', (600, 660), final_bg_color)

        draw = ImageDraw.Draw(card)

        img_alpha = center_img.convert('RGBA')
        mask = Image.new('L', img_alpha.size, 0)
        m_draw = ImageDraw.Draw(mask)
        m_draw.rounded_rectangle((0, 0, *img_alpha.size), 25, fill=255)
        img_alpha.putalpha(mask)

        card.paste(img_alpha, (108, 60), img_alpha)

        if track.duration:
            progress_bar_color = subtext_color if advanced_mode else second_fill

            draw.rounded_rectangle(
                xy=(108, 468, 492, 483),
                radius=25,
                fill=progress_bar_color
            )

            progress = track.progress / track.duration
            draw.rounded_rectangle(
                xy=(112, 472, 112 + max(7, int(376 * progress)), 479),
                radius=25 if progress >= 0.1 else 5,
                fill=(255, 255, 255)
            )

            draw.text(
                xy=(108, 490),
                text=time.strftime("%M:%S", time.gmtime(track.progress)),
                font=duration_font,
                fill=progress_bar_color,
                anchor="la"
            )

            draw.text(
                xy=(492, 490),
                text=time.strftime("%M:%S", time.gmtime(track.duration)),
                font=duration_font,
                fill=progress_bar_color,
                align="center",
                anchor="ra"
            )

        final_title_color = title_text_color if advanced_mode else (255, 255, 255)

        draw.text(
            xy=(15, 550),
            text=track.title if len(track.title) < max_title_symbols else track.title[:max_title_symbols] + '...',
            font=title_font,
            fill=final_title_color,
            align="center",
            anchor="la"
        )

        draw.text(
            xy=(15, 605),
            text=artists if len(artists) < max_subtitle_symbols else artists[:max_subtitle_symbols] + '...',
            font=artist_font,
            fill=subtext_color if advanced_mode else second_fill,
            align="center",
            anchor="la"
        )

        if show_service_logo:
            selected_platform: int = self.get_setting('selected_platform', 0)
            platform_name: str = get_platform(selected_platform).name.lower()
            platform_logo_url: str = f"{DOWNLOAD_URL}/resources/img/{platform_name}.png"
            platform_logo = requests.get(platform_logo_url, stream=True).raw

            logo = Image.open(platform_logo).convert("RGBA")
            card.paste(logo, (490, 555), logo)

        filename = f"now_{__name__}.png"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()
        card.save(temp_photo_path)

        return temp_photo_path

    def is_hex_valid(self, new: str, variable_name: str):
        if not re.match("^#[A-Fa-f0-9]{6}$", new):
            run_on_ui_thread(lambda: self.show_info_alert(title=locale.Alert_HEX_Title, message=locale.Alert_HEX_Text))
            self.set_setting(variable_name, DEFAULT_COLOR[variable_name])

    def check_resources(self, redownload_resources: bool, show_success_alert: bool) -> bool:
        try:
            temp = get_temp_dir()
            if not temp:
                logcat("Temp directory is none.")
                return False

            existing_files = {f.getName() for f in temp.listFiles()}

            all_resources_exist = True
            for resource_name in RESOURCES:
                if resource_name not in existing_files:
                    logcat(f"Resource missing: {resource_name}")
                    all_resources_exist = False
                    break

            if all_resources_exist:
                if show_success_alert:
                    self.show_info_alert(title=locale.SourceSuccess_Title, message=locale.SourceSuccess_Text)
                else:
                    logcat("All resources founded.")

                return True
            else:
                if redownload_resources:
                    logcat("Some resources are missing. Clearing directory and re-downloading.")
                    for f in temp.listFiles():
                        if f.isFile():
                            f.delete()

                    threading.Thread(target=self.download_resources, args=(False,), daemon=True).start()

                return False

        except Exception as e:
            logcat(f"check_resources error: {e}")
            return False

    def download_resources(self, clear: bool):
        run_on_ui_thread(lambda: self.show_loading_alert("Downloading resources..."))

        temp = get_temp_dir()
        if not temp:
            logcat("Temp directory is none.")
            return

        if clear:
            for f in temp.listFiles():
                if f.isFile():
                    f.delete()

        error: bool = False
        total_resources = len(RESOURCES)

        for i, r in enumerate(RESOURCES):
            try:
                progress = (i + 1) * 100 // total_resources
                run_on_ui_thread(lambda: self.update_loading_progress(progress))

                file_path = os.path.join(temp.getAbsolutePath(), r)
                url = DOWNLOAD_URL + f"resources/fonts/" + r

                download_file(url, file_path)

            except Exception as e:
                error = True
                show_error(str(e))
                logcat(f"An unexpected error occurred while downloading {r}: {e}")

        if error:
            show_error("Something went wrong")
        else:
            run_on_ui_thread(lambda: self.update_loading_progress(100))
            show_success("Download completed")

        run_on_ui_thread(lambda: self.dismiss_loading_alert())

    def is_poller_enabled(self) -> bool:
        return self.poller is not None and self.poller.is_looping()

    def set_poller_enabled(self, enable: bool):
        if self.poller is not None:
            if enable: self.poller.start_poller()
            else: self.poller.stop_poller()
        elif self.poller is None and enable:
            self.poller = Poller(self)
            self.poller.start_poller()

    def update_stream_place(self):
        is_premium = get_user_config().isPremium()

        stream_place = self.get_setting('stream_place', 0)
        is_business_stream_np = stream_place == 1 and not is_premium
        is_profile_stream = stream_place == 2

        if is_business_stream_np or is_profile_stream:
            stream_place_to_set = 0

            self.set_setting('stream_place', stream_place_to_set)
            show_info(locale.StreamPlaceUpdated)

    def show_spinner(self):
        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None:
            logcat("Context not found, can't show spinner.")
            return

        self.spinner = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_SPINNER)
        self.spinner.set_cancelable(False)
        self.spinner.set_canceled_on_touch_outside(False)
        self.spinner.set_on_cancel_listener(None)

        if self.spinner.get_dialog() and self.spinner.get_dialog().isShowing():
            java = self.spinner.get_dialog()
            java.setCancelable(False)
            java.setCanceledOnTouchOutside(False)

        self.spinner.create()
        self.spinner.show()

    def dismiss_spinner(self):
        if self.spinner and self.spinner.get_dialog() and self.spinner.get_dialog().isShowing():
            self.spinner.dismiss()

        self.spinner = None

    def show_info_alert(self,
                        title: str,
                        message: str,
                        positive_text: Optional[str] = None,
                        positive_listener: Optional[Callable] = None,
                        neutral_text: Optional[str] = "Ok",
                        neutral_listener: Optional[Callable] = None):
        if title == "" or message == "":
            logcat("Title or message not found, can't show info alert.")
            return

        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None:
            logcat("Context not found, can't show info alert.")
            return

        self.info = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.info.set_title(title)
        self.info.set_message(message)

        if positive_text:
            if positive_listener:
                self.info.set_positive_button(positive_text, lambda alert, i: positive_listener())
            else:
                self.info.set_positive_button(positive_text, lambda alert, i: self.dismiss_info_alert())

        if neutral_text:
            if neutral_listener:
                self.info.set_neutral_button(neutral_text, lambda alert, i: neutral_listener())
            else:
                self.info.set_neutral_button(neutral_text, lambda alert, i: self.dismiss_info_alert())

        self.info.show()

    def dismiss_info_alert(self):
        if self.info and self.info.get_dialog() and self.info.get_dialog().isShowing():
            self.info.dismiss()

        self.info = None

    def show_loading_alert(self, title: str):
        if title is None:
            logcat("Title is empty, can't show loading.")
            return

        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None:
            logcat("Context not found, can't show loading alert.")
            return

        self.loading = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
        self.loading.set_title(title)
        self.loading.set_cancelable(False)
        self.loading.set_canceled_on_touch_outside(False)
        self.loading.set_on_cancel_listener(None)
        self.loading.show()

        if self.loading.get_dialog() and self.loading.get_dialog().isShowing():
            java = self.loading.get_dialog()
            java.setCancelable(False)
            java.setCanceledOnTouchOutside(False)

        self.loading.set_progress(0)

    def update_loading_progress(self, progress: int):
        if self.loading is None or not self.loading.get_dialog().isShowing():
            logcat("Can't update loading alert, because he is None or not showing.")
            return

        self.loading.set_progress(progress)

    def dismiss_loading_alert(self):
        if self.loading and self.loading.get_dialog() and self.loading.get_dialog().isShowing():
            self.loading.dismiss()

        self.loading = None


class Poller:
    def __init__(self, plugin: ReSwagaPlugin):
        self.plugin = plugin
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
        self._lock: threading.Lock = threading.Lock()

    def _loop(self):
        logcat("Poller thread started.")
        while not self._stop_event.is_set():
            stream_bio_enabled = self.plugin.get_setting("stream_bio_enabled", False)
            fast_card_render = self.plugin.get_setting("fast_card_render", False)

            if not any([stream_bio_enabled, fast_card_render]):
                logcat("All polling features disabled. Stopping thread.")
                break

            stream_place = self.plugin.get_setting("stream_place", 0)
            if stream_bio_enabled and stream_place == 0:
                sleep_time = 10
            elif stream_bio_enabled and (stream_place == 1 and get_user_config().isPremium()):
                sleep_time = 5
            else:
                sleep_time = 20

            try:
                platform = self.plugin.platform
                if platform is None:
                    logcat("Platform is None. Waiting...")
                    if self._stop_event.wait(5):
                        break
                    continue

                platform.get_track()

                if stream_bio_enabled:
                    user_id = get_user_config().getClientUserId()
                    selected_user_id = get_local_stream_id()

                    if user_id != 0 and selected_user_id != 0 and user_id == selected_user_id:
                        self.plugin.set_stream_text(False)

                if fast_card_render:
                    if platform.now_track and platform.now_track.active:
                        if platform.memory_id != platform.now_track.id:
                            logcat(f"Track changed ({platform.memory_id} -> {platform.now_track.id}). Rendering card...")
                            platform.memory_id = platform.now_track.id
                            card_type = self.plugin.get_setting('card_type', 0)
                            if card_type == 0:
                                self.plugin.create_horizontal_card()
                            else:
                                self.plugin.create_vertical_card()

            except Exception as e:
                import traceback
                logcat(f"Poller iteration error: {e}")
                logcat(traceback.format_exc())

            if self._stop_event.wait(sleep_time):
                logcat("Stop signal received during sleep.")
                break

        logcat("Poller thread finished.")

    def start_poller(self):
        with self._lock:
            if self._thread is not None and self._thread.is_alive():
                logcat("Poller is already running.")
                return

            logcat("Starting poller...")
            self._stop_event.clear()
            self._thread = threading.Thread(target=self._loop, daemon=True)
            self._thread.start()

    def stop_poller(self):
        with self._lock:
            if self._thread is None:
                return

            logcat("Stopping poller...")
            self._stop_event.set()
            self._thread.join(timeout=2.0)
            self._thread = None

            if self.plugin.get_setting("stream_bio_enabled", False):
                threading.Thread(target=lambda: self.plugin.set_stream_text(True), daemon=True).start()

    def is_looping(self) -> bool:
        return self._thread is not None


# === MEDIA KEYBOARD START ===
def get_java_class(name):
    try:
        return Class.forName(name)
    except:
        return None


def find_constructor_exact(clazz, *params):
    try:
        ctor = clazz.getDeclaredConstructor(*params)
        ctor.setAccessible(True)
        return ctor
    except:
        return None


def find_method_exact(clazz, name, *params):
    try:
        m = clazz.getDeclaredMethod(name, *params)
        m.setAccessible(True)
        return m
    except:
        return None


def create_button(context, text: str, subtext: str = "", enabled: bool = True, listener: View.OnClickListener = None, tonal: bool = True) -> Optional[ButtonWithCounterView]:
    if text == "":
        return None

    button = ButtonWithCounterView(context, tonal, None)
    button.setText(text, False)

    if subtext != "" and len(subtext) > 0:
        button.setSubText(subtext, False)

    button.setEnabled(enabled)
    if button.isEnabled() and not listener is None:
        button.setOnClickListener(listener)

    return button


def create_custom_view(context, plugin: ReSwagaPlugin):
    class SendCardButtonListener(dynamic_proxy(View.OnClickListener)):
        def onClick(self, view):
            fragment2 = get_last_fragment()
            if not isinstance(fragment2, ChatActivity): return
            params = SendMessagesHelper.SendMessageParams()
            params.peer = fragment2.getDialogId()
            params.replyToMsg = fragment2.getReplyMessage()
            params.replyToTopMsg = fragment2.getThreadMessage()
            threading.Thread(target=plugin.send_card_message, args=(params,), daemon=True).start()

    class SendAudioButtonListener(dynamic_proxy(View.OnClickListener)):
        def onClick(self, view):
            fragment2 = get_last_fragment()
            if not isinstance(fragment2, ChatActivity): return
            params = SendMessagesHelper.SendMessageParams()
            params.peer = fragment2.getDialogId()
            params.replyToMsg = fragment2.getReplyMessage()
            params.replyToTopMsg = fragment2.getThreadMessage()
            threading.Thread(target=plugin.send_audio_message, args=(params,), daemon=True).start()

    class SendTextButtonListener(dynamic_proxy(View.OnClickListener)):
        def onClick(self, view):
            fragment2 = get_last_fragment()
            if not isinstance(fragment2, ChatActivity): return
            params = SendMessagesHelper.SendMessageParams()
            params.peer = fragment2.getDialogId()
            params.replyToMsg = fragment2.getReplyMessage()
            params.replyToTopMsg = fragment2.getThreadMessage()
            threading.Thread(target=plugin.send_text_message, args=(params,), daemon=True).start()

    class SettingsButtonListener(dynamic_proxy(View.OnClickListener)):
        def onClick(self, view):
            open_plugin_settings()

    class ChannelButtonListener(dynamic_proxy(View.OnClickListener)):
        def onClick(self, view):
            open_tg_link("meeowPlugins")

    class DonateButtonListener(dynamic_proxy(View.OnClickListener)):
        def onClick(self, view):
            open_tg_link("meeowPlugins/93")

    class ScrollTouchListener(dynamic_proxy(View.OnTouchListener)):
        def onTouch(self, v, event):
            v.onTouchEvent(event)

            action = event.getAction()

            if action == MotionEvent.ACTION_DOWN:
                self.last_y = event.getY()
                v.getParent().requestDisallowInterceptTouchEvent(True)

            elif action == MotionEvent.ACTION_MOVE:
                current_y = event.getY()
                delta_y = current_y - self.last_y


                if delta_y > 0 and not v.canScrollVertically(-1):
                    v.getParent().requestDisallowInterceptTouchEvent(False)

                elif delta_y < 0 and not v.canScrollVertically(1):
                    v.getParent().requestDisallowInterceptTouchEvent(False)

                else:
                    v.getParent().requestDisallowInterceptTouchEvent(True)

            elif action == MotionEvent.ACTION_UP or action == MotionEvent.ACTION_CANCEL:
                v.getParent().requestDisallowInterceptTouchEvent(False)

            return True

    layout_helper = find_class("org.telegram.ui.Components.LayoutHelper")
    try:
        ScrollView = find_class("androidx.core.widget.NestedScrollView")
    except:
        ScrollView = find_class("android.widget.ScrollView")

    fragment = get_last_fragment()
    can_send_photo = True
    can_send_audio = True
    can_send_text = True

    if isinstance(fragment, ChatActivity):
        current_chat = fragment.currentChat
        if current_chat is not None:
            if not ChatObject.hasAdminRights(current_chat):
                can_send_photo = ChatObject.canSendPhoto(current_chat)
                can_send_audio = ChatObject.canSendMusic(current_chat)
                can_send_text = ChatObject.canSendMessages(current_chat)

    if not plugin.platform.can_download_track:
        can_send_audio = False

    scroll_view = ScrollView(context)
    scroll_view.setFillViewport(True)
    scroll_view.setVerticalScrollBarEnabled(False)
    scroll_view.setNestedScrollingEnabled(True)
    scroll_view.setOnTouchListener(ScrollTouchListener())

    vertical_container = LinearLayout(context)
    vertical_container.setOrientation(LinearLayout.VERTICAL)
    vertical_container.setPadding(
        AndroidUtilities.dp(4),
        AndroidUtilities.dp(4),
        AndroidUtilities.dp(4),
        AndroidUtilities.dp(4)
    )

    scroll_view.addView(
        vertical_container,
        layout_helper.createScroll(-1, -2, Gravity.TOP)
    )

    buttons_data: list[tuple[str, str, bool, Any, bool]] = [
        (locale.Action_SendCard_Title, locale.Action_SendCard_Subtext, can_send_photo, SendCardButtonListener(), True),
        (locale.Action_SendAudio_Title, locale.Action_SendAudio_Subtext, can_send_audio, SendAudioButtonListener(), True),
        (locale.Action_SendText_Title, locale.Action_SendText_Subtext, can_send_text, SendTextButtonListener(), True),
        (locale.Action_Settings_Title, locale.Action_Settings_Subtext, True, SettingsButtonListener(), False),
        (locale.Alert_Donate_Header, "<3", True, DonateButtonListener(), False),
        ("@MeeowPlugins", "<3", True, ChannelButtonListener(), False),
        ("z", "v", True, ChannelButtonListener(), False)
    ]

    columns = 1
    row_layout = None

    btn_width = (AndroidUtilities.displaySize.x - AndroidUtilities.dp(24)) // columns
    btn_height = AndroidUtilities.dp(52)
    btn_margin = AndroidUtilities.dp(4)

    for i, (title, subtext, enabled, listener, tonal) in enumerate(buttons_data):
        if i % columns == 0:
            row_layout = LinearLayout(context)
            row_layout.setOrientation(LinearLayout.HORIZONTAL)
            vertical_container.addView(
                row_layout,
                layout_helper.createLinear(-1, -2)
            )

        btn = create_button(context, title, subtext, enabled, listener, tonal)

        lp = LinearLayout.LayoutParams(btn_width, btn_height)
        lp.setMargins(btn_margin, btn_margin, btn_margin, btn_margin)
        btn.setLayoutParams(lp)

        row_layout.addView(btn)

    lp_main = LinearLayout.LayoutParams(
        LinearLayout.LayoutParams.MATCH_PARENT,
        AndroidUtilities.dp(300)
    )

    scroll_view.setTag(VIEW_TAG)
    scroll_view.setVisibility(View.GONE)
    scroll_view.setLayoutParams(lp_main)

    scroll_view.setClickable(True)
    scroll_view.setFocusable(True)

    return scroll_view


def force_update_ui(emoji_view):
    try:
        type_tabs = get_private_field(emoji_view, "typeTabs")
        pager = get_private_field(emoji_view, "pager")

        if pager and pager.getAdapter():
            pager.getAdapter().notifyDataSetChanged()

        if type_tabs and pager:
            methods = type_tabs.getClass().getMethods()
            for m in methods:
                if m.getName() == "setViewPager" and len(m.getParameterTypes()) == 1:
                    m.invoke(type_tabs, pager)
                    logcat("UI Updated")
                    break
    except Exception as e:
        logcat(f"UI update failed: {e}")


# === MEDIA KEYBOARD HOOKS STARTS ===


class EmojiViewConstructorHook(MethodHook):
    def __init__(self, plugin: ReSwagaPlugin):
        super().__init__()
        self.plugin = plugin

    def after_hooked_method(self, param) -> Any:
        emoji_view = param.thisObject
        context = param.args[4]

        all_tabs = get_private_field(emoji_view, "allTabs")
        py_all_tabs = list(ArrayList(all_tabs).toArray())
        if len(py_all_tabs) <= 1:
            return

        try:
            my_view = create_custom_view(context, self.plugin)

            tab_class = get_java_class("org.telegram.ui.Components.EmojiView$Tab")
            tab_ctor = tab_class.getDeclaredConstructors()[0]
            tab_ctor.setAccessible(True)
            new_tab = tab_ctor.newInstance(emoji_view)

            set_private_field(new_tab, "type", RESWAGA_TAB_INDEX)
            set_private_field(new_tab, "view", my_view)

            current_tabs = get_private_field(emoji_view, "currentTabs")
            if all_tabs is not None: all_tabs.add(new_tab)
            if current_tabs is not None: current_tabs.add(new_tab)

            run_on_ui_thread(lambda: force_update_ui(emoji_view))

        except Exception as e:
            logcat(f"Ctor error: {e}")


class SetAllowHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param) -> Any:
        emoji_view = param.thisObject
        all_tabs = get_private_field(emoji_view, "allTabs")
        current_tabs = get_private_field(emoji_view, "currentTabs")
        if not all_tabs or not current_tabs: return

        my_tab = None
        for i in range(all_tabs.size()):
            t = all_tabs.get(i)
            if get_private_field(t, "type") == RESWAGA_TAB_INDEX:
                my_tab = t
                break

        if my_tab and not current_tabs.contains(my_tab):
            current_tabs.add(my_tab)
            run_on_ui_thread(lambda: force_update_ui(emoji_view))


class AdapterGetIconHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param) -> Any:
        position = param.args[0]
        if position == RESWAGA_TAB_INDEX:
            param.setResult(None)


class AdapterGetTitleHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param) -> Any:
        position = param.args[0]
        if position == RESWAGA_TAB_INDEX:
            param.setResult(__name__)


class CheckGridVisibilityHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param) -> Any:
        emoji_view = param.thisObject
        position = param.args[0]
        my_view = emoji_view.findViewWithTag(VIEW_TAG)
        stickers = get_private_field(emoji_view, "stickersTabContainer")
        search = get_private_field(emoji_view, "emojiSearchField")

        if position == RESWAGA_TAB_INDEX:
            if my_view: my_view.setVisibility(View.VISIBLE)
            if stickers: stickers.setVisibility(View.GONE)
            if search: search.setVisibility(View.GONE)
        else:
            if my_view: my_view.setVisibility(View.GONE)


# === MEDIA KEYBOARD HOOKS END ===


# === MEDIA KEYBOARD END ===


"""



                            Ð”Ð˜Ð¡ÐšÐ›Ð•Ð™ÐœÐ•Ð 

Ð•ÑÐ»Ð¸ Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ ÑÐ²Ð¾ÐµÐ³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° Ð²Ñ‹ Ñ€ÐµÑˆÐ¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹Ðµ ÐºÐ¾Ð´Ð¾Ð²Ñ‹Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ
Ð½Ð°ÑˆÐµÐ³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° Ñƒ ÑÐµÐ±Ñ, Ñ‚Ð¾ Ð½Ðµ Ð·Ð°Ð±ÑƒÐ´ÑŒÑ‚Ðµ ÑƒÐ¿Ð¾Ð¼ÑÐ½ÑƒÑ‚ÑŒ Ð² Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ð¸ ÑÐ²Ð¾ÐµÐ³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°
ÐºÐ°Ð½Ð°Ð» @MeeowPlugins Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ ÐºÑ€ÐµÐ´Ð¸Ñ‚Ð¾Ð² Ð·Ð° Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒ Ð² Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°. Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾


                  â£¾â¡‡â£¿â£¿â¡‡â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£„â¢»â£¦â¡€â â¢¸â¡Œâ »â£¿â£¿â£¿â¡½â£¿â£¿
                  â¡‡â£¿â ¹â£¿â¡‡â¡Ÿâ ›â£‰â â ‰â ‰â »â¡¿â£¿â£¿â£¿â£¿â£¿â£¦â£„â¡‰â ‚â ˆâ ™â¢¿â£¿â£â£¿
                  â ¤â¢¿â¡„â ¹â£§â£·â£¸â¡‡â „â „â ²â¢°â£Œâ£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¶â£¤â£¤â¡€â „â ˆâ »â¢®
                  â „â¢¸â£§â „â¢˜â¢»â£¿â¡‡â¢€â£€â „â£¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£§â¡€â „â¢€
                  â „â ˆâ£¿â¡†â¢¸â£¿â£¿â£¿â£¬â£­â£´â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¯â â ›â ›â ™â¢¿â¡¿â ƒâ „â¢¸
                  â „â „â¢¿â£¿â¡€â£¿â£¿â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¿â£¿â£¿â£¿â¡¾â â¢ â¡‡â¢€
                  â „â „â¢¸â£¿â¡‡â »â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£â£«â£»â¡Ÿâ¢€â „â£¿â£·â£¾
                  â „â „â¢¸â£¿â¡‡â „â ˆâ ™â ¿â£¿â£¿â£¿â£®â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â¢ â Šâ¢€â¡‡â£¿â£¿
                  â ’â ¤â „â£¿â¡‡â¢€â¡²â „â „â ˆâ ™â »â¢¿â£¿â£¿â ¿â ¿â Ÿâ ›â ‹â â£°â ‡â „â¢¸â£¿â£¿â£¿



                            DISCLAIMER

If, when creating your plugin, you decided to use the ready-made code solutions
of our plugin, then do not forget to mention the @MeeowPlugins channel in the description
of your plugin as credits for help in developing your plugin. Thanks



"""