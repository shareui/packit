from typing import Any, List, Optional
from base_plugin import BasePlugin, MethodHook, hook_filters, HookFilter
from hook_utils import find_class, get_private_field
from java import jclass, dynamic_proxy
from client_utils import run_on_ui_thread, get_last_fragment
from ui.settings import Switch, Header
from ui.alert import AlertDialogBuilder
from org.telegram.messenger import AndroidUtilities, ImageLocation
from org.telegram.tgnet import TLRPC
from org.telegram.ui.Components import BackupImageView
from android.widget import LinearLayout
from android.view import Gravity

__id__ = "confirmation_settings"
__name__ = "Confirm Before Sending"
__type__ = "plugin"
__description__ = "Show confirmation dialogs for various actions like stickers, voice, commands, etc.."
__version__ = "1.0.0"
__author__ = "@luvztroy"
__min_version__ = "12.2.10"


TL_documentAttributeSticker = find_class("org.telegram.tgnet.TLRPC$TL_documentAttributeSticker")
TL_documentAttributeAudio = find_class("org.telegram.tgnet.TLRPC$TL_documentAttributeAudio")
TL_documentAttributeAnimated = find_class("org.telegram.tgnet.TLRPC$TL_documentAttributeAnimated")
TL_documentAttributeVideo = find_class("org.telegram.tgnet.TLRPC$TL_documentAttributeVideo")


def get_send_messages_helper():
    try:
        from org.telegram.messenger import SendMessagesHelper, UserConfig
        return SendMessagesHelper.getInstance(UserConfig.selectedAccount)
    except:
        return None


class ConfirmationHook(MethodHook):
    def __init__(self, plugin):
        MethodHook.__init__(self)
        self.plugin = plugin
        self.pending_params: List[Any] = [] 
        self.pending_group_id: Optional[str] = None 
        self.is_resending = False
        self.pending_sticker_doc = None

    def _reset_pending(self):
        self.pending_params.clear()
        self.pending_group_id = None
        self.pending_sticker_doc = None

    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param: Any):
        if self.is_resending:
            return

        try:
            send_params = param.args[0]
            if not send_params:
                return

            params_map = getattr(send_params, 'params', None)
            group_id = None
            is_group_final = False
            if params_map is not None:
                group_id = params_map.get("groupId")
                is_group_final = params_map.get("final") == "1"

            msg_text = getattr(send_params, 'message', None)
            is_command = isinstance(msg_text, str) and msg_text.strip().startswith('/')

            is_photo = getattr(send_params, 'photo', None) is not None
            doc = getattr(send_params, 'document', None)

            is_sticker = False
            is_voice = False
            is_round_video = False
            is_video_file = False
            is_gif = False
            is_generic_document = False

            if doc and hasattr(doc, 'attributes'):
                attributes_list = doc.attributes
                has_animated_attr = False
                has_video_attr = False
                has_sticker_attr = False
                
                for i in range(attributes_list.size()):
                    attr = attributes_list.get(i)
                    if isinstance(attr, TL_documentAttributeSticker):
                        has_sticker_attr = True
                    elif isinstance(attr, TL_documentAttributeAudio) and attr.voice:
                        is_voice = True
                    elif isinstance(attr, TL_documentAttributeAnimated):
                        has_animated_attr = True
                    elif isinstance(attr, TL_documentAttributeVideo):
                        has_video_attr = True
                        if attr.round_message:
                            is_round_video = True
                        else:
                            is_video_file = True
                
                if has_sticker_attr:
                    is_round_video = False
                    is_video_file = False
                    is_sticker = True
                elif has_animated_attr:
                    is_gif = True
                    is_video_file = False
                elif has_video_attr and not is_round_video:
                    is_video_file = True

                if not (is_sticker or is_voice or is_round_video or is_video_file or is_gif):
                    is_generic_document = True

            should_confirm = False
            message_type = ""

            if is_command and self.plugin.get_setting("confirm_commands", False):
                if self.plugin.command_from_message_click:
                    should_confirm = True
                    message_type = "command"
            elif is_photo and self.plugin.get_setting("confirm_photo", False):
                should_confirm = True
                message_type = "photo"
            elif is_sticker and self.plugin.get_setting("confirm_stickers", False):
                should_confirm = True
                message_type = "sticker"
                self.pending_sticker_doc = doc
            elif is_voice and self.plugin.get_setting("confirm_voice", False):
                should_confirm = True
                message_type = "voice message"
            elif is_round_video and self.plugin.get_setting("confirm_round_video", False):
                should_confirm = True
                message_type = "round video message"
            elif is_video_file and self.plugin.get_setting("confirm_video_file", False):
                should_confirm = True
                message_type = "video file"
            elif is_gif and self.plugin.get_setting("confirm_gif", False):
                should_confirm = True
                message_type = "GIF"
            elif is_generic_document and self.plugin.get_setting("confirm_document", False):
                should_confirm = True
                message_type = "file"

            if not should_confirm:
                if is_command:
                    self.plugin.command_from_message_click = False
                return 

            if is_command:
                self.pending_params.append(param)
                param.setResult(None)
                run_on_ui_thread(lambda: self.show_confirmation_dialog(msg_text.strip()))
                self.plugin.command_from_message_click = False
                return

            if group_id and group_id != "0":
                if self.pending_group_id is None:
                    self.pending_group_id = group_id
                if group_id != self.pending_group_id:
                    return

                self.pending_params.append(param)
                param.setResult(None)

                if is_group_final:
                    count = len(self.pending_params)
                    if count > 1:
                        if is_photo:
                            message_type = "photos"
                        elif is_video_file:
                            message_type = "video files"
                        elif is_round_video:
                            message_type = "round video messages"
                        elif is_generic_document:
                            message_type = "files"
                    
                    run_on_ui_thread(lambda: self.show_confirmation_dialog(f"{count} {message_type}"))
                return
            else:
                self.pending_params.append(param)
                param.setResult(None)
                run_on_ui_thread(lambda: self.show_confirmation_dialog(message_type, is_sticker, doc if is_sticker else None))

        except Exception:
            pass

    def show_confirmation_dialog(self, message_type: str, is_sticker: bool = False, sticker_doc = None):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None

        if not activity:
            self.proceed_sending(None, 0)
            return

        dialog_ref = None
        
        def cleanup():
            nonlocal dialog_ref
            dialog_ref = None

        builder = AlertDialogBuilder(activity)
        builder.set_title("Confirm Send")
        
        confirmation_text = "Do you really want to send this {message_type}?".format(message_type=message_type)

        if is_sticker and sticker_doc:
            try:
                container = LinearLayout(activity)
                container.setOrientation(LinearLayout.VERTICAL)
                container.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(16))

                sticker_view = BackupImageView(activity)
                sticker_view.setRoundRadius(0)
                sticker_size = AndroidUtilities.dp(120)
                sticker_params = LinearLayout.LayoutParams(sticker_size, sticker_size)
                sticker_params.gravity = Gravity.CENTER_HORIZONTAL
                sticker_params.bottomMargin = AndroidUtilities.dp(16)
                sticker_view.setLayoutParams(sticker_params)

                thumb_drawable = None
                if sticker_doc.thumbs and sticker_doc.thumbs.size() > 0:
                    from org.telegram.messenger import ImageLoader
                    for i in range(sticker_doc.thumbs.size()):
                        t = sticker_doc.thumbs.get(i)
                        if hasattr(t, 'bytes') and t.bytes:
                            thumb_drawable = ImageLoader.getStrippedPhotoBitmap(t.bytes, "b")
                            break

                image_location = ImageLocation.getForDocument(sticker_doc)
                if image_location:
                    sticker_view.setImage(image_location, "120_120", thumb_drawable, sticker_doc)

                container.addView(sticker_view)
                builder.set_view(container)
            except Exception:
                builder.set_message(confirmation_text)
        else:
            builder.set_message(confirmation_text)
        
        builder.set_positive_button("Send", self.proceed_sending)
        builder.set_negative_button("Cancel", lambda dialog, which: cleanup())
        builder.set_on_cancel_listener(lambda b: (self.cancel_sending(b, 0), cleanup()))
        dialog_ref = builder.show()
        builder.set_canceled_on_touch_outside(False)

    def proceed_sending(self, builder, which: int):
        if builder:
            builder.dismiss()

        if not self.pending_params:
            return

        try:
            for stored_param in self.pending_params:
                original_method = stored_param.method
                arguments = stored_param.args
                instance = stored_param.thisObject
                self.is_resending = True
                original_method.invoke(instance, *arguments)
            
        except Exception:
            pass
        finally:
            self.is_resending = False
            self._reset_pending()

    def cancel_sending(self, builder, which: int):
        if builder:
            builder.dismiss()
        self._reset_pending()


class SetCommandHook(MethodHook):
    def __init__(self, plugin):
        MethodHook.__init__(self)
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            self.plugin.command_from_message_click = True
        except Exception:
            pass


class ProcessExternalUrlHook(MethodHook):
    def __init__(self, plugin):
        MethodHook.__init__(self)
        self.plugin = plugin

    @hook_filters(HookFilter.ArgumentNotNull(1))
    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("confirm_external_links", False):
                return
            url = param.args[1]
            if url and self.is_external(url):
                param.args[4] = True
        except Exception:
            pass

    def is_external(self, url):
        try:
            from android.net import Uri
            uri = Uri.parse(url)
            host = uri.getHost()
            if not host:
                return False
            host = host.lower()
            return not any(host == domain or host.endswith("." + domain) 
                          for domain in ["t.me", "telegram.me", "telegram.dog", "telegram.org", "telegram.com"])
        except Exception:
            return True


class ForwardConfirmationHook(MethodHook):
    def __init__(self, plugin, reflected_method):
        MethodHook.__init__(self)
        self.plugin = plugin
        self._suppress_next = False
        self.reflected_method = reflected_method

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            if self._suppress_next:
                self._suppress_next = False
                return
            if not self.plugin.get_setting("confirm_forward", False):
                return
            args = list(param.args) if param.args else []
            def on_confirm():
                try:
                    self._suppress_next = True
                    self.reflected_method.setAccessible(True)
                    coerced = list(args)
                    if len(coerced) >= 6:
                        try:
                            coerced[4] = jclass("java.lang.Integer")(int(coerced[4]))
                        except Exception:
                            pass
                        try:
                            coerced[5] = jclass("java.lang.Long")(int(coerced[5]))
                        except Exception:
                            pass
                    self.reflected_method.invoke(chat_activity, *coerced)
                except Exception:
                    pass
  
            ctx = None
            try:
                fragment = get_last_fragment()
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            except Exception:
                ctx = None
            if ctx:
                def _show():
                    try:
                        builder = AlertDialogBuilder(ctx)
                        builder.set_title("Confirm Forwarding Messages")
                        builder.set_message("Are you sure you want to forward this message?")
                        builder.set_positive_button("OK", lambda dialog, which: on_confirm())
                        builder.set_negative_button("Cancel", None)
                        builder.show()
                        builder.set_canceled_on_touch_outside(False)
                    except Exception:
                        pass
                run_on_ui_thread(_show)
                param.setResult(None)
        except Exception:
            pass


class JoinConfirmationHook(MethodHook):
    def __init__(self, plugin):
        MethodHook.__init__(self)
        self.plugin = plugin

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("confirm_join_chat", False):
                return
                
            chat_activity = param.thisObject
            if not chat_activity:
                return

            chat_activity_class = find_class("org.telegram.ui.ChatActivity")
            overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
            overlay_field.setAccessible(True)
            overlay_text_view = overlay_field.get(chat_activity)
            
            if not overlay_text_view:
                return

            view_class = find_class("android.view.View")
            listener_info_method = view_class.getClass().getDeclaredMethod("getListenerInfo")
            listener_info_method.setAccessible(True)
            listener_info = listener_info_method.invoke(overlay_text_view)
            
            if not listener_info:
                return

            click_listener_field = listener_info.getClass().getDeclaredField("mOnClickListener")
            click_listener_field.setAccessible(True)
            original_listener = click_listener_field.get(listener_info)
            
            if original_listener and not hasattr(original_listener, '_is_confirmation_listener'):
                custom_listener = JoinConfirmationClickListener(original_listener, self.plugin)
                overlay_text_view.setOnClickListener(custom_listener)
                
        except Exception:
            pass


class JoinConfirmationClickListener(dynamic_proxy(find_class("android.view.View$OnClickListener"))):
    _is_confirmation_listener = True
    
    def __init__(self, original_listener, plugin):
        super().__init__()
        self.original_listener = original_listener
        self.plugin = plugin

    def onClick(self, view):
        if not self._is_join_action():
            self.original_listener.onClick(view)
            return
            
        def show_confirmation():
            try:
                builder = AlertDialogBuilder(view.getContext())
                chat_name = self._get_chat_name()
                
                builder.set_title("Join Confirmation")
                message = "Are you sure you want to join **{chat_name}**?".format(chat_name=chat_name)
                builder.set_message(AndroidUtilities.replaceTags(message))
                
                def on_confirm(dialog, which):
                    dialog.dismiss()
                    self.original_listener.onClick(view)
                
                def on_cancel(dialog, which):
                    dialog.dismiss()
                
                builder.set_positive_button("Join", on_confirm)
                builder.set_negative_button("Cancel", on_cancel)
                builder.show()
                builder.set_canceled_on_touch_outside(False)
                
            except Exception:
                self.original_listener.onClick(view)

        run_on_ui_thread(show_confirmation)

    def _is_join_action(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return False
            
            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                try:
                    chat_object_class = find_class("org.telegram.messenger.ChatObject")
                    if chat_object_class:
                        is_not_in_chat_method = chat_object_class.getClass().getDeclaredMethod("isNotInChat", find_class("org.telegram.tgnet.TLRPC$Chat"))
                        is_not_in_chat = is_not_in_chat_method.invoke(None, fragment.currentChat)
                        return is_not_in_chat
                except Exception:
                    pass
            return False
        except Exception:
            return False

    def _get_chat_name(self):
        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, 'currentChat') and fragment.currentChat and hasattr(fragment.currentChat, 'title'):
                return fragment.currentChat.title
            return "this chat"
        except:
            return "this chat"


class ConfirmationSettingsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._class_cache = {}
        self.hook_handler = None
        self.unhook_send_message = None
        self.unhook_set_command = None
        self.hook_process_external_url_ref = None
        self.hook_forward_confirmation_ref = None
        self.hook_join_confirmation_ref = None
        self.command_from_message_click = False
    
    def _get_class(self, class_name):
        if class_name not in self._class_cache:
            self._class_cache[class_name] = find_class(class_name)
        return self._class_cache[class_name]
    
    def create_settings(self):
        return [
            Header(text="Send Confirmations"),
            Switch(key="confirm_stickers", text="Stickers", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_voice", text="Voice Messages", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_commands", text="Bot Commands", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_round_video", text="Video Messages", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_video_file", text="Video Files", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_photo", text="Photos", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_document", text="Documents", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_gif", text="GIFs", default=False, on_change=lambda v: self._apply_hooks()),
            Header(text="Action Confirmations"),
            Switch(key="confirm_forward", text="Forward", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_join_chat", text="Join Chat", default=False, on_change=lambda v: self._apply_hooks()),
            Switch(key="confirm_external_links", text="External Links", default=False, on_change=lambda v: self._apply_hooks()),
        ]
    
    def on_plugin_load(self):
        self._apply_hooks()
    
    def on_plugin_unload(self):
        if self.unhook_send_message:
            try:
                self.unhook_method(self.unhook_send_message)
            except:
                pass
            self.unhook_send_message = None
        if self.unhook_set_command:
            try:
                self.unhook_method(self.unhook_set_command)
            except:
                pass
            self.unhook_set_command = None
        if self.hook_process_external_url_ref:
            try:
                self.unhook_method(self.hook_process_external_url_ref)
            except:
                pass
            self.hook_process_external_url_ref = None
        if self.hook_forward_confirmation_ref:
            try:
                self.unhook_method(self.hook_forward_confirmation_ref)
            except:
                pass
            self.hook_forward_confirmation_ref = None
        if self.hook_join_confirmation_ref:
            try:
                self.unhook_method(self.hook_join_confirmation_ref)
            except:
                pass
            self.hook_join_confirmation_ref = None
    
    def _apply_hooks(self):
        self._setup_confirmation_hooks()
        if self.get_setting("confirm_external_links", False):
            self._hook_process_external_url()
        if self.get_setting("confirm_forward", False):
            self._hook_forward_confirmation()
        if self.get_setting("confirm_join_chat", False):
            self._hook_join_confirmation()
    
    def _setup_confirmation_hooks(self):
        try:
            if self.unhook_send_message:
                return
            send_helper_instance = get_send_messages_helper()
            if not send_helper_instance:
                return
            send_helper_class = send_helper_instance.getClass()

            send_params_class = jclass("org.telegram.messenger.SendMessagesHelper$SendMessageParams")

            send_message_method = send_helper_class.getDeclaredMethod("sendMessage", send_params_class)
            send_message_method.setAccessible(True)

            self.hook_handler = ConfirmationHook(self)
            self.unhook_send_message = self.hook_method(send_message_method, self.hook_handler)
            
            chat_enter_view_class = self._get_class("org.telegram.ui.Components.ChatActivityEnterView")
            set_command_method = chat_enter_view_class.getClass().getDeclaredMethod("setCommand", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("java.lang.String").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE)
            set_command_method.setAccessible(True)
            
            self.unhook_set_command = self.hook_method(set_command_method, SetCommandHook(self))
            
        except Exception:
            pass
    
    def _hook_process_external_url(self):
        try:
            if self.hook_process_external_url_ref:
                return
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            method = ChatActivityClass.getClass().getDeclaredMethod(
                "processExternalUrl", 
                self._get_class("java.lang.Integer").TYPE,
                self._get_class("java.lang.String").getClass(),
                self._get_class("android.text.style.CharacterStyle").getClass(),
                self._get_class("org.telegram.ui.Cells.ChatMessageCell").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_process_external_url_ref = self.hook_method(method, ProcessExternalUrlHook(self))
        except Exception:
            pass
    
    def _hook_forward_confirmation(self):
        try:
            if self.hook_forward_confirmation_ref:
                return
            chat_cls = self._get_class("org.telegram.ui.ChatActivity")
            method = chat_cls.getClass().getDeclaredMethod(
                "forwardMessages",
                self._get_class("java.util.ArrayList").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Integer").TYPE,
                self._get_class("java.lang.Long").TYPE
            )
            method.setAccessible(True)
            self.hook_forward_confirmation_ref = self.hook_method(method, ForwardConfirmationHook(self, method))
        except Exception:
            pass
    
    def _hook_join_confirmation(self):
        try:
            if self.hook_join_confirmation_ref:
                return
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            context_class = self._get_class("android.content.Context")
            
            if not chat_activity_class or not context_class:
                return

            create_view_method = chat_activity_class.getClass().getDeclaredMethod("createView", context_class)
            self.hook_join_confirmation_ref = self.hook_method(create_view_method, JoinConfirmationHook(self))
            
        except Exception:
            pass
