import json
import time
import threading
import urllib.request
import urllib.parse
import xml.etree.ElementTree as ET
import re
from typing import Any, Dict, List, Optional, Tuple

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.settings import Header, Divider, Switch, Text

from android_utils import log, run_on_ui_thread, OnClickListener
from client_utils import get_last_fragment

from org.telegram.messenger import AndroidUtilities

from android.graphics import Color
from android.graphics import BitmapFactory
from android.graphics import Typeface
try:
    from android.graphics import Bitmap
except Exception:
    Bitmap = None
from android.graphics.drawable import GradientDrawable
from android.view import Gravity, View, ViewGroup, ViewOutlineProvider
from android.view import HapticFeedbackConstants
from android.view.animation import DecelerateInterpolator

from android.widget import FrameLayout, LinearLayout, ScrollView, TextView, ImageView, EditText, SeekBar
from android.content import Intent
from android.net import Uri

from datetime import datetime, timezone

from java import dynamic_proxy
from java.lang import Runnable
from android.view import MotionEvent, KeyEvent
from android.widget import ProgressBar

try:
    from android_utils import OnTouchListener as _OnTouchListener
except ImportError:
    class _OnTouchListener(dynamic_proxy(View.OnTouchListener)):
        def __init__(self, fn):
            super().__init__()
            self._fn = fn

        def onTouch(self, v, ev):
            return bool(self._fn(v, ev))

try:
    from android_utils import OnKeyListener as _OnKeyListener
except ImportError:
    class _OnKeyListener(dynamic_proxy(View.OnKeyListener)):
        def __init__(self, fn):
            super().__init__()
            self._fn = fn

        def onKey(self, v, key_code, event):
            return bool(self._fn(v, key_code, event))

try:
    from android_utils import OnSeekBarChangeListener as _OnSeekBarChangeListener
except ImportError:
    try:
        class _OnSeekBarChangeListener(dynamic_proxy(SeekBar.OnSeekBarChangeListener)):
            def __init__(self, on_change=None, on_start=None, on_stop=None):
                super().__init__()
                self._on_change = on_change
                self._on_start = on_start
                self._on_stop = on_stop

            def onProgressChanged(self, seek_bar, progress, from_user):
                try:
                    if self._on_change is not None:
                        self._on_change(seek_bar, int(progress), bool(from_user))
                except Exception:
                    pass

            def onStartTrackingTouch(self, seek_bar):
                try:
                    if self._on_start is not None:
                        self._on_start(seek_bar)
                except Exception:
                    pass

            def onStopTrackingTouch(self, seek_bar):
                try:
                    if self._on_stop is not None:
                        self._on_stop(seek_bar)
                except Exception:
                    pass
    except Exception:
        class _OnSeekBarChangeListener:
            def __init__(self, on_change=None, on_start=None, on_stop=None):
                self._on_change = on_change
                self._on_start = on_start
                self._on_stop = on_stop


__id__ = "ExteraRSS"
__name__ = "ExteraRSS"
__description__ = "RSS + Telegram в одной ленте."
__author__ = "@RoflPlugins"
__version__ = "1.0"
__icon__ = "RoflPlugins/15"
__min_version__ = "11.12.0"

# ---- UI tuning ----
CORNER_RADIUS_DP = 8
_UI_SCALE_MIN = 0.80
_UI_SCALE_MAX = 1.35
_UI_SCALE = 1.00


def _clamp_ui_scale(v: Any) -> float:
    try:
        x = float(v)
    except Exception:
        x = 1.00
    if x < _UI_SCALE_MIN:
        x = _UI_SCALE_MIN
    if x > _UI_SCALE_MAX:
        x = _UI_SCALE_MAX
    return x


# ---------------- safe color ----------------
def _c(hex_color: str, fallback: str = "#FFFFFFFF") -> int:
    """
    Safe Color.parseColor:
    - trims
    - ensures startswith '#'
    - accepts only 7 or 9 length: #RRGGBB or #AARRGGBB
    - returns fallback if invalid
    """
    try:
        s = (hex_color or "").strip()
        if not s:
            return Color.parseColor(fallback)
        if not s.startswith("#"):
            s = "#" + s
        if len(s) not in (7, 9):
            return Color.parseColor(fallback)
        return Color.parseColor(s)
    except Exception:
        try:
            return Color.parseColor(fallback)
        except Exception:
            return 0xFFFFFFFF


# ---------------- utils ----------------
def _clean_reply_for_ui(reply_raw: str, it: Dict[str, Any]) -> str:
    txt = (reply_raw or "").strip()
    if not txt:
        return ""

    # 1) если формат "Name — Text"
    txt = _reply_text_only(txt)

    # 2) убрать лидирующее "@user:"
    txt = _strip_leading_handle_line(txt)

    # 3) если начинается с названия/хэндла источника — срезаем
    src_title = str(it.get("source_title") or "").strip()
    src_handle = str(it.get("source_handle") or "").strip()
    src_title_plain = src_title.lstrip("@").strip()
    src_handle_plain = src_handle.lstrip("@").strip()

    low = txt.lower().strip()

    def _cut_prefix(prefix: str):
        nonlocal txt, low
        p = (prefix or "").strip()
        if not p:
            return
        plow = p.lower()
        for sep in (" ", ":", " —", " -", " — ", " - "):
            pref = (plow + sep).strip()
            if low.startswith(pref):
                txt = txt[len(p):].lstrip(" \t\r\n:-—|")
                low = txt.lower().strip()
                return

    _cut_prefix(src_title_plain)
    _cut_prefix(src_handle_plain)

# 3.5) вырезаем "оригинальное имя канала" (source_title), если оно попало в reply как префикс
    try:
        # иногда reply начинается с "Имя Канала:" или "Имя Канала —"
        real_title = str(it.get("source_title") or "").strip()
        if real_title:
            real_title_plain = real_title.strip()
            # пробуем несколько нормализованных вариантов
            cand = _norm_name_for_compare(real_title_plain)
            txt_low = _norm_name_for_compare(txt)

            for sep in (":", "—", "-", "|"):
                pref = (cand + " " + sep).strip()
                if txt_low.startswith(pref):
                    # режем по длине оригинального title (не normalized), чтобы не ломать регистр
                    txt = txt[len(real_title_plain):].lstrip(" \t\r\n:-—|•·")
                    break

            # ещё вариант: "Имя Канала " + текст (без разделителя)
            txt_low = _norm_name_for_compare(txt)
            if txt_low.startswith(cand + " "):
                # режем только если дальше явно "контент", иначе можно случайно съесть фразу
                rest = txt[len(real_title_plain):].lstrip()
                if rest and (rest[0].isalnum() or rest[0] in "@#("):
                    txt = rest
    except Exception:
        pass

    # 4) ✅ TG reply без "—": "Rofl Plugins spoiler_random (2).plugin"
    # Считаем, что первые 1-3 слова — "автор", если они "похожи на имя",
    # а следующий токен уже "похож на содержимое" (файл/ссылка/подчёркивания/скобки/точка).
    if " — " not in (reply_raw or ""):
        try:
            parts = txt.split()
            if len(parts) >= 3:
                def is_name_word(w: str) -> bool:
                    # только буквы (лат/кирилл), без цифр/._()/-
                    if not w:
                        return False
                    for ch in w:
                        if not (ch.isalpha() or ch in "’'"):
                            return False
                    return True

                def looks_like_content(w: str) -> bool:
                    if not w:
                        return False
                    # файлы/никнеймы/ссылки/скобки/точки/подчёркивания/цифры
                    if any(x in w for x in (".", "_", "(", ")", "/", "://", "@")):
                        return True
                    if any(ch.isdigit() for ch in w):
                        return True
                    return False

                # пробуем 2 слова имени
                if is_name_word(parts[0]) and is_name_word(parts[1]) and looks_like_content(parts[2]):
                    txt = " ".join(parts[2:]).strip()
                # пробуем 1 слово имени
                elif is_name_word(parts[0]) and looks_like_content(parts[1]):
                    txt = " ".join(parts[1:]).strip()
                # пробуем 3 слова имени
                elif len(parts) >= 4 and is_name_word(parts[0]) and is_name_word(parts[1]) and is_name_word(parts[2]) and looks_like_content(parts[3]):
                    txt = " ".join(parts[3:]).strip()
        except Exception:
            pass

    return txt.strip()

def _reply_text_only(reply_raw: str) -> str:
    s = (reply_raw or "").strip()
    if not s:
        return ""
    # чаще всего "Name — Text"
    if " — " in s:
        parts = s.split(" — ", 1)
        tail = (parts[1] or "").strip()
        return tail if tail else s
    return s

def _ensure_at(src: str) -> str:
    s = (src or "").strip()
    if not s:
        return ""
    if s.startswith("@"):
        return s
    # если это tguser source, оно уже "@username", но на всякий случай:
    return "@" + s

def _format_source_line(it: Dict[str, Any]) -> str:
    h = (it.get("source_handle") or "").strip()
    t = (it.get("source_title") or "").strip()

    if h and not h.startswith("@"):
        h = "@" + h

    if h and t:
        # чтобы не было "@rofl – @rofl"
        if t != h:
            return f"{h} – {t}"
        return h

    # fallback старое поведение
    s = (it.get("source") or "").strip()
    if s and not s.startswith("@") and h:
        return h
    return s or h

def _preview_text(text: str, max_len: int = 170, title: str = "") -> str:
    t = (text or "").strip()
    if not t:
        return ""
    # если title совпадает с первой строкой — убираем её из превью
    if title:
        first = t.split("\n", 1)[0].strip()
        if first and title.strip() == first:
            t = t.split("\n", 1)[1].strip() if "\n" in t else ""
    if not t:
        return ""
    t = re.sub(r"\s+", " ", t).strip()
    if len(t) <= max_len:
        return t
    return t[:max_len - 1].rstrip() + "…"

def _dp(x: float) -> int:
    return AndroidUtilities.dp(float(x) * float(_UI_SCALE))


def _safe_json_load(s: Any, default):
    try:
        if isinstance(s, str) and s.strip():
            return json.loads(s)
    except Exception:
        pass
    return default


def _now_ts() -> int:
    return int(time.time())


def _strip_ns(tag: str) -> str:
    if "}" in tag:
        return tag.split("}", 1)[1]
    return tag


def _text(node) -> str:
    if node is None:
        return ""
    return (node.text or "").strip()


def _join_text(node) -> str:
    if node is None:
        return ""
    parts = []
    try:
        for t in node.itertext():
            if t:
                parts.append(t)
    except Exception:
        pass
    return (" ".join(parts)).strip()


def _uniq_keep_order(lst: List[str]) -> List[str]:
    seen = set()
    out = []
    for x in lst:
        if x in seen:
            continue
        seen.add(x)
        out.append(x)
    return out


def _statusbar_pad() -> int:
    try:
        sb = int(getattr(AndroidUtilities, "statusBarHeight", 0))
        if sb > 0:
            return sb
    except Exception:
        pass
    return _dp(24)


# ---------- normalize subscription ----------
def _norm_sub(line: str) -> Optional[str]:
    """
    Valid:
    - tguser:username  (already normalized)
    - @username        -> tguser:username
    - t.me/s/username  -> tguser:username
    - https://...      -> https://...
    """
    if not isinstance(line, str):
        return None
    s = line.strip()
    if not s:
        return None

    if s.startswith("tguser:"):
        u = s.split(":", 1)[1].strip()
        return ("tguser:" + u) if u else None

    if s.startswith("@"):
        u = s[1:].strip()
        return ("tguser:" + u) if u else None

    if s.startswith("t.me/s/") or s.startswith("telegram.me/s/"):
        u = s.split("/s/", 1)[1].strip("/ ")
        return ("tguser:" + u) if u else None

    if s.startswith("http://") or s.startswith("https://"):
        low = s.lower()
        if "t.me/s/" in low:
            try:
                u = s.split("t.me/s/", 1)[1].strip("/ ")
                return ("tguser:" + u) if u else None
            except Exception:
                pass
        return s

    return None


def _norm_category(raw: Any) -> str:
    s = str(raw or "").strip()
    if not s:
        return ""
    s = re.sub(r"\s+", " ", s).strip()
    return s[:42]

def _norm_image_url(raw: Any) -> str:
    u = str(raw or "").strip()
    if not u:
        return ""
    if u.startswith("//"):
        u = "https:" + u
    return u

def _upgrade_image_url(raw: Any) -> str:
    u = _norm_image_url(raw)
    if not u:
        return ""
    try:
        p = urllib.parse.urlsplit(u)
        if not p.query:
            return u
        q = urllib.parse.parse_qsl(p.query, keep_blank_values=True)
        out_q = []
        for k, v in q:
            lk = str(k or "").lower()
            lv = str(v or "").lower()
            if lk in ("w", "h", "width", "height", "size"):
                continue
            if lk == "name" and lv in ("small", "medium"):
                out_q.append((k, "orig"))
                continue
            out_q.append((k, v))
        new_q = urllib.parse.urlencode(out_q, doseq=True)
        return urllib.parse.urlunsplit((p.scheme, p.netloc, p.path, new_q, p.fragment))
    except Exception:
        return u

def _norm_images_list(raw: Any) -> List[str]:
    arr = raw if isinstance(raw, list) else [raw]
    out: List[str] = []
    seen = set()
    for x in arr:
        u = _upgrade_image_url(x)
        if not u or u in seen:
            continue
        seen.add(u)
        out.append(u)
    return out


# ---------- HTML cleaning ----------
def _html_unescape_basic(s: str) -> str:
    if not s:
        return ""

    # named entities
    s = s.replace("&nbsp;", " ")
    s = s.replace("&quot;", "\"")
    s = s.replace("&apos;", "'")
    s = s.replace("&lt;", "<")
    s = s.replace("&gt;", ">")
    s = s.replace("&amp;", "&")

    # numeric entities: &#33; and &#x21;
    def _rep_num(m):
        try:
            code = int(m.group(1))
            if 0 <= code <= 0x10FFFF:
                return chr(code)
        except Exception:
            pass
        return m.group(0)

    def _rep_hex(m):
        try:
            code = int(m.group(1), 16)
            if 0 <= code <= 0x10FFFF:
                return chr(code)
        except Exception:
            pass
        return m.group(0)

    s = re.sub(r"&#(\d+);", _rep_num, s)
    s = re.sub(r"&#x([0-9a-fA-F]+);", _rep_hex, s)

    return s


def _strip_tags_and_format(s: str) -> str:
    if not s:
        return ""

    x = s
    x = x.replace("<br/>", "\n").replace("<br />", "\n").replace("<br>", "\n")
    x = x.replace("</p>", "\n").replace("<p>", "")
    x = x.replace("</div>", "\n").replace("<div>", "")
    x = x.replace("</li>", "\n").replace("<li>", "• ")
    x = x.replace("</ul>", "\n").replace("<ul>", "")
    x = x.replace("</ol>", "\n").replace("<ol>", "")

    out = []
    in_tag = False
    for ch in x:
        if ch == "<":
            in_tag = True
            continue
        if ch == ">":
            in_tag = False
            continue
        if not in_tag:
            out.append(ch)
    x = "".join(out)

    x = _html_unescape_basic(x)
    x = x.replace("\r\n", "\n").replace("\r", "\n")

    lines = [ln.strip() for ln in x.split("\n")]
    cleaned = []
    empty_run = 0
    for ln in lines:
        if not ln:
            empty_run += 1
            if empty_run <= 1:
                cleaned.append("")
        else:
            empty_run = 0
            cleaned.append(ln)

    return "\n".join(cleaned).strip()


# ---------- date parsing / formatting ----------
_RSS_MONTHS = {
    "jan": 1, "feb": 2, "mar": 3, "apr": 4, "may": 5, "jun": 6,
    "jul": 7, "aug": 8, "sep": 9, "oct": 10, "nov": 11, "dec": 12
}


def _parse_rfc822_dt(s: str) -> Optional[datetime]:
    if not s:
        return None
    x = s.strip()

    if "," in x:
        parts = x.split(",", 1)
        if len(parts) == 2 and len(parts[0].strip()) <= 4:
            x = parts[1].strip()

    x = x.replace(" GMT", " +0000").replace(" UT", " +0000").replace(" UTC", " +0000")
    toks = x.split()
    if len(toks) < 4:
        return None
    try:
        day = int(toks[0])
        mon = _RSS_MONTHS.get(toks[1].lower(), 0)
        if mon <= 0:
            return None
        year = int(toks[2])

        hh, mm, ss = 0, 0, 0
        tt = toks[3].split(":")
        if len(tt) >= 2:
            hh = int(tt[0])
            mm = int(tt[1])
        if len(tt) >= 3:
            ss = int(tt[2])

        tz = None
        if len(toks) >= 5:
            z = toks[4].strip().replace(":", "")
            if z and (z[0] in "+-" and len(z) == 5):
                sign = 1 if z[0] == "+" else -1
                zh = int(z[1:3])
                zm = int(z[3:5])
                tz = timezone(sign * (zh * 3600 + zm * 60))
        if tz is None:
            tz = timezone.utc
        return datetime(year, mon, day, hh, mm, ss, tzinfo=tz)
    except Exception:
        return None


def _parse_iso8601_dt(s: str) -> Optional[datetime]:
    if not s:
        return None
    x = s.strip()
    try:
        if x.endswith("Z"):
            x = x[:-1] + "+00:00"
        return datetime.fromisoformat(x)
    except Exception:
        try:
            base = x[:19]
            dt = datetime.strptime(base, "%Y-%m-%dT%H:%M:%S")
            return dt.replace(tzinfo=timezone.utc)
        except Exception:
            return None


def _parse_published_to_ts(published: str) -> int:
    if not published:
        return 0
    dt = _parse_rfc822_dt(published) or _parse_iso8601_dt(published)
    if dt is None:
        return 0
    try:
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return int(dt.timestamp())
    except Exception:
        return 0


def _format_ru_datetime(ts: int) -> str:
    if not ts:
        return ""
    try:
        lt = time.localtime(int(ts))
        return time.strftime("%d.%m.%Y %H:%M", lt)
    except Exception:
        return ""


# ---------------- HTTP ----------------
def _http_get(url: str, timeout_sec: int = 12) -> bytes:
    req = urllib.request.Request(url, headers={"User-Agent": "Exteragram-RSS-Plugin/1.4.4"})
    with urllib.request.urlopen(req, timeout=timeout_sec) as resp:
        return resp.read()


# ---------------- RSS/Atom parsing ----------------
def _best_image_from_rss_item(it: ET.Element) -> str:
    arr = _all_images_from_rss_item(it)
    return arr[0] if arr else ""

def _all_images_from_rss_item(it: ET.Element) -> List[str]:
    out: List[str] = []
    try:
        for enc in it.findall("enclosure"):
            url = (enc.attrib.get("url") or "").strip()
            typ = (enc.attrib.get("type") or "").strip().lower()
            if url and (typ.startswith("image/") or url.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                out.append(url)
    except Exception:
        pass

    try:
        for el in it.iter():
            name = _strip_ns(el.tag).lower()
            if name in ("thumbnail", "content"):
                url = (el.attrib.get("url") or el.attrib.get("src") or "").strip()
                typ = (el.attrib.get("type") or "").strip().lower()
                if url and (typ.startswith("image/") or url.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                    out.append(url)
    except Exception:
        pass

    return _norm_images_list(out)

_RE_LEADING_HANDLE = re.compile(r"^\s*@[\w\d_]{3,32}\s*:\s*", re.I)

def _norm_name_for_compare(s: str) -> str:
    # упрощаем для сравнения (без эмодзи/символов)
    x = (s or "").strip().lower()
    x = re.sub(r"\s+", " ", x).strip()
    # убираем “мусорные” разделители в конце имени
    x = x.strip(":-—|•·")
    return x

def _strip_leading_handle_line(s: str) -> str:
    if not s:
        return ""
    lines = s.split("\n")
    if not lines:
        return s
    # если первая строка выглядит как "@name:" — убираем её
    if _RE_LEADING_HANDLE.match(lines[0].strip()):
        return "\n".join(lines[1:]).lstrip()
    return s

def _best_image_from_atom_entry(e: ET.Element) -> str:
    arr = _all_images_from_atom_entry(e)
    return arr[0] if arr else ""

def _all_images_from_atom_entry(e: ET.Element) -> List[str]:
    out: List[str] = []
    try:
        for l in e.iter():
            if _strip_ns(l.tag).lower() != "link":
                continue
            href = (l.attrib.get("href") or "").strip()
            rel = (l.attrib.get("rel") or "").strip().lower()
            typ = (l.attrib.get("type") or "").strip().lower()
            if href and rel == "enclosure" and (typ.startswith("image/") or href.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                out.append(href)
    except Exception:
        pass

    try:
        for el in e.iter():
            name = _strip_ns(el.tag).lower()
            if name in ("thumbnail", "content"):
                url = (el.attrib.get("url") or el.attrib.get("src") or "").strip()
                typ = (el.attrib.get("type") or "").strip().lower()
                if url and (typ.startswith("image/") or url.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                    out.append(url)
    except Exception:
        pass

    return _norm_images_list(out)


def parse_feed(xml_bytes: bytes, source_url: str) -> Tuple[str, List[Dict[str, Any]]]:
    items: List[Dict[str, Any]] = []
    try:
        root = ET.fromstring(xml_bytes)
    except Exception:
        return (source_url, items)

    root_name = _strip_ns(root.tag).lower()

    if root_name == "rss":
        channel = root.find("channel")
        if channel is None:
            return (source_url, items)

        src_title = _text(channel.find("title")) or source_url

        for it in channel.findall("item"):
            title = _text(it.find("title"))
            link = _text(it.find("link"))

            pub_raw = _text(it.find("pubDate")) or _text(it.find("date"))
            if not pub_raw:
                try:
                    for el in it.iter():
                        n = _strip_ns(el.tag).lower()
                        if n in ("date", "pubdate", "updated", "published"):
                            v = _join_text(el)
                            if v:
                                pub_raw = v.strip()
                                break
                except Exception:
                    pass

            if not link:
                guid = _text(it.find("guid"))
                if guid.startswith("http://") or guid.startswith("https://"):
                    link = guid

            desc = _join_text(it.find("description"))
            if not desc:
                try:
                    for el in it.iter():
                        if _strip_ns(el.tag).lower() in ("encoded", "content"):
                            txt = _join_text(el)
                            if txt:
                                desc = txt
                                break
                except Exception:
                    pass

            images = _all_images_from_rss_item(it)
            img = images[0] if images else ""
            ts = _parse_published_to_ts(pub_raw)

            if link:
                items.append({
                    "title": title,
                    "link": link,
                    "published_raw": pub_raw,
                    "ts": ts,
                    "source": src_title,
                    "text": desc,
                    "image": img,
                    "images": images,
                })

        return (src_title, items)

    if root_name == "feed":
        ns = ""
        if root.tag.startswith("{") and "}" in root.tag:
            ns = root.tag.split("}", 1)[0].strip("{")

        def q(name: str) -> str:
            return f"{{{ns}}}{name}" if ns else name

        src_title = _text(root.find(q("title"))) or source_url

        for e in root.findall(q("entry")):
            title = _text(e.find(q("title")))
            pub_raw = _text(e.find(q("updated"))) or _text(e.find(q("published")))

            link = ""
            for l in e.findall(q("link")):
                href = l.attrib.get("href", "")
                rel = l.attrib.get("rel", "")
                if href and (rel == "" or rel == "alternate"):
                    link = href
                    break

            desc = _join_text(e.find(q("summary"))) or _join_text(e.find(q("content")))
            images = _all_images_from_atom_entry(e)
            img = images[0] if images else ""
            ts = _parse_published_to_ts(pub_raw)

            if link:
                items.append({
                    "title": title,
                    "link": link,
                    "published_raw": pub_raw,
                    "ts": ts,
                    "source": src_title,
                    "text": desc,
                    "image": img,
                    "images": images,
                })

        return (src_title, items)

    return (source_url, items)


# ---------------- Telegram local (t.me/s/<username>) ----------------
# ---------------- Telegram local (t.me/s/<username>) ----------------

# wrap
_RE_TG_WRAP = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_wrap\b[^'\"]*['\"][^>]*>(.*?)</div>\s*</div>\s*</div>",
    re.S | re.I
)

# time
_RE_TG_TIME = re.compile(r"<time[^>]+datetime=['\"]([^'\"]+)['\"]", re.S | re.I)

# text / caption (важно: допускаем ' и ")
_RE_TG_TEXT = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_text\b[^'\"]*['\"][^>]*>(.*?)</div>",
    re.S | re.I
)

_RE_TG_CAPTION = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_caption\b[^'\"]*['\"][^>]*>(.*?)</div>",
    re.S | re.I
)

# media urls (style может быть в ' или ", и url('')/url("")
_RE_TG_PHOTO_STYLE = re.compile(
    r"tgme_widget_message_photo_wrap[^>]*style=['\"][^'\"]*url\((?:'|\")?([^'\")]+)",
    re.S | re.I
)

_RE_TG_VIDEO_STYLE = re.compile(
    r"tgme_widget_message_video_thumb[^>]*style=['\"][^'\"]*url\((?:'|\")?([^'\")]+)",
    re.S | re.I
)

# sticker (src может быть в ' или ")
_RE_TG_STICKER_IMG = re.compile(
    r"tgme_widget_message_sticker[^>]*src=['\"]([^'\"]+)['\"]",
    re.S | re.I
)

# message id
_RE_TG_MSG_ID = re.compile(r"data-post=['\"]([^'\"]+)['\"]", re.S | re.I)

# document filename
_RE_TG_DOC_NAME = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_document_name\b[^'\"]*['\"][^>]*>(.*?)</div>",
    re.S | re.I
)
_RE_TG_VOICE_DURATION = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_(?:voice|audio)_duration\b[^'\"]*['\"][^>]*>(.*?)</div>",
    re.S | re.I
)
_RE_TG_VOICE_TITLE = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_(?:voice|audio)_title\b[^'\"]*['\"][^>]*>(.*?)</div>",
    re.S | re.I
)
_RE_TG_VOICE_LABEL = re.compile(
    r"aria-label=['\"]([^'\"]*(?:voice|audio|голос|подкаст)[^'\"]*)['\"]",
    re.S | re.I
)
_RE_TG_DATE_HREF = re.compile(
    r'<a[^>]+class="[^"]*\btgme_widget_message_date\b[^"]*"[^>]+href="([^"]+)"',
    re.S | re.I
)

_RE_TG_TEXT_JS = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\bjs-message_text\b[^'\"]*['\"][^>]*>(.*?)</div>",
    re.S | re.I
)

_RE_TG_BUBBLE = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_bubble\b[^'\"]*['\"][^>]*>(.*?)<div[^>]+class=['\"][^'\"]*\btgme_widget_message_footer\b",
    re.S | re.I
)

_RE_TG_FOOTER = re.compile(
    r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_footer\b[^'\"]*['\"][^>]*>.*?</div>",
    re.S | re.I
)

# было: _RE_TG_REPLY_NAME = re.compile(r"<div ...reply_name...>(.*?)</div>", ...)
# стало:
_RE_TG_REPLY_NAME = re.compile(
    r"<(?P<tag>\w+)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply_name\b[^'\"]*['\"][^>]*>(?P<inner>.*?)</(?P=tag)>",
    re.S | re.I
)

_RE_TG_REPLY_TEXT = re.compile(
    r"<(?P<tag>\w+)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply_text\b[^'\"]*['\"][^>]*>(?P<inner>.*?)</(?P=tag)>",
    re.S | re.I
)

_RE_TG_REPLY_AUTHOR_ALT = re.compile(
    r"<(?P<tag>\w+)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply_author\b[^'\"]*['\"][^>]*>(?P<inner>.*?)</(?P=tag)>",
    re.S | re.I
)

_RE_TG_REPLY_TEXT_ALT = re.compile(
    r"<(?P<tag>\w+)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply_snippet\b[^'\"]*['\"][^>]*>(?P<inner>.*?)</(?P=tag)>",
    re.S | re.I
)

_RE_TG_REPLY_BLOCK = re.compile(
    r"<(?P<tag>a|div|span)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply\b[^'\"]*['\"][^>]*>[\s\S]*?</(?P=tag)>",
    re.S | re.I
)

_RE_TG_REPLY_BLOCK_INNER = re.compile(
    r"<(?P<tag>a|div|span)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply\b[^'\"]*['\"][^>]*>(?P<inner>[\s\S]*?)</(?P=tag)>",
    re.S | re.I
)

_RE_TG_PAGE_TITLE = re.compile(
    r'<div[^>]+class=["\']tgme_page_title["\'][^>]*>\s*(?:<span[^>]*>)?\s*(.*?)\s*(?:</span>)?\s*</div>',
    re.S | re.I
)
_RE_OG_TITLE = re.compile(
    r'<meta[^>]+property=["\']og:title["\'][^>]+content=["\']([^"\']+)["\']',
    re.S | re.I
)

def _extract_tg_channel_title(html: str, username: str) -> str:
    if not html:
        return f"@{username}"
    try:
        m = _RE_TG_PAGE_TITLE.search(html)
        if m:
            t = _strip_tags_and_format(m.group(1) or "").strip()
            if t:
                return t
    except Exception:
        pass

    try:
        m = _RE_OG_TITLE.search(html)
        if m:
            t = _strip_tags_and_format(m.group(1) or "").strip()
            # часто og:title = "ChannelName — Telegram"
            t = t.replace("— Telegram", "").replace("- Telegram", "").strip()
            if t:
                return t
    except Exception:
        pass

    return f"@{username}"


def _extract_tg_reply(block_html: str) -> str:
    if not block_html:
        return ""
    if "tgme_widget_message_reply" not in block_html:
        return ""

    try:
        text = ""

        # основной вариант
        mt = _RE_TG_REPLY_TEXT.search(block_html)
        if mt:
            text = _strip_tags_and_format(mt.group("inner") or "").strip()

        # альтернативный вариант
        if not text:
            mt2 = _RE_TG_REPLY_TEXT_ALT.search(block_html)
            if mt2:
                text = _strip_tags_and_format(mt2.group("inner") or "").strip()

        # если текста нет — берём сырой текст из reply блока и чистим
        if not text:
            m = _RE_TG_REPLY_BLOCK_INNER.search(block_html)
            if m:
                raw = _strip_tags_and_format(m.group("inner") or "").strip()
                raw = re.sub(r"\s+", " ", raw).strip()
                text = raw

        text = (text or "").strip()
        if not text:
            return ""

        # точечный анти-мусор
        if text.lower() in ("test", "тест"):
            return ""

        return text[:180]
    except Exception:
        return ""

def _extract_tg_doc_name(block_html: str) -> str:
    m = _RE_TG_DOC_NAME.search(block_html)
    if not m:
        return ""
    return _strip_tags_and_format(m.group(1) or "").strip()

def _extract_tg_voice_label(block_html: str) -> str:
    if not block_html:
        return ""
    has_audio_tag = ("<audio" in block_html.lower())
    try:
        if ("voice" not in block_html.lower()) and ("audio" not in block_html.lower()) and ("голос" not in block_html.lower()):
            return ""
    except Exception:
        pass

    title = ""
    dur = ""
    try:
        m_t = _RE_TG_VOICE_TITLE.search(block_html)
        if m_t:
            title = _strip_tags_and_format(m_t.group(1) or "").strip()
    except Exception:
        pass
    try:
        m_d = _RE_TG_VOICE_DURATION.search(block_html)
        if m_d:
            dur = _strip_tags_and_format(m_d.group(1) or "").strip()
    except Exception:
        pass

    if title and dur:
        return f"{title} ({dur})"
    if title:
        return title
    if dur:
        return f"Голосовое сообщение ({dur})"

    try:
        m_l = _RE_TG_VOICE_LABEL.search(block_html)
        if m_l:
            raw = _strip_tags_and_format(m_l.group(1) or "").strip()
            if raw:
                return raw[:120]
    except Exception:
        pass

    if has_audio_tag:
        return "Аудио-сообщение"

    return ""

def _all_tg_media_urls(block_html: str) -> List[str]:
    urls: List[str] = []
    try:
        for m in _RE_TG_PHOTO_STYLE.finditer(block_html or ""):
            urls.append((m.group(1) or "").strip())
    except Exception:
        pass
    try:
        for m in _RE_TG_VIDEO_STYLE.finditer(block_html or ""):
            urls.append((m.group(1) or "").strip())
    except Exception:
        pass
    try:
        for m in _RE_TG_STICKER_IMG.finditer(block_html or ""):
            urls.append((m.group(1) or "").strip())
    except Exception:
        pass
    return _norm_images_list(urls)

def _best_tg_media_url(block_html: str) -> str:
    arr = _all_tg_media_urls(block_html)
    return arr[0] if arr else ""


def _extract_tg_text(block_html: str) -> str:
    if not block_html:
        return ""

    # 1) Берём только внутренность bubble (там и reply, и сам текст)
    m_b = _RE_TG_BUBBLE.search(block_html)
    scope = m_b.group(1) if m_b else block_html

    # 2) Удаляем reply-preview и footer, чтобы reply_text (цитата) не мешала
    scope = _RE_TG_REPLY_BLOCK.sub("", scope)
    scope = _RE_TG_FOOTER.sub("", scope)

    # 3) Ищем возможные контейнеры текста.
    # Важно: если почему-то нашлось несколько — берём ПОСЛЕДНИЙ (обычно это именно текст ответа)
    candidates = []

    try:
        candidates += [m.group(1) for m in _RE_TG_TEXT.finditer(scope) if m and m.group(1)]
    except Exception:
        pass

    if not candidates:
        try:
            candidates += [m.group(1) for m in _RE_TG_TEXT_JS.finditer(scope) if m and m.group(1)]
        except Exception:
            pass

    if not candidates:
        try:
            candidates += [m.group(1) for m in _RE_TG_CAPTION.finditer(scope) if m and m.group(1)]
        except Exception:
            pass

    if not candidates:
        return ""

    text_html = candidates[-1]  # ✅ последний блок текста
    return _strip_tags_and_format(text_html)

def _parse_tg_preview_page(html: str, username: str, channel_title: str) -> Tuple[str, List[Dict[str, Any]]]:
    src_handle = f"@{username}"
    src_title = (channel_title or src_handle).strip()

    items: List[Dict[str, Any]] = []

    blocks = _split_tg_blocks(html)
    if not blocks:
        blocks = _RE_TG_WRAP.findall(html)

    for b in blocks[:160]:
        try:
            log(f"[TGDBG] block_len={len(b)} has_text={('tgme_widget_message_text' in b)} has_reply={('tgme_widget_message_reply' in b)}")
            dt_iso = _extract_tg_time_iso(b)
            ts = _parse_published_to_ts(dt_iso)

            post_link = f"https://t.me/s/{username}"
            tg_post_id = ""

            m2 = _RE_TG_MSG_ID.search(b)
            if m2:
                mid = (m2.group(1) or "").strip()
                if mid:
                    tg_post_id = mid
                    if "/" in mid:
                        post_link = f"https://t.me/{mid}"

            text = _extract_tg_text(b)
            text = _strip_leading_handle_line(text)
            reply = _extract_tg_reply(b)
            if reply:
                log(f"[TGDBG2] reply='{reply[:60]}' text_head='{(text.splitlines()[0] if text else '')[:60]}'")

            doc_name = _extract_tg_doc_name(b)
            voice_label = _extract_tg_voice_label(b)

            if text:
                first = text.split("\n", 1)[0].strip()
                first = _RE_LEADING_HANDLE.sub("", first).strip()
                title = first[:120] if first else ""
            elif reply:
                title = reply[:120]
            elif doc_name:
                title = doc_name[:120]
            elif voice_label:
                title = voice_label[:120]
            else:
                title = ""

            images = _all_tg_media_urls(b)
            img = images[0] if images else ""

            items.append({
                "source": src_title,          # что показываем в ленте
                "source_handle": src_handle,  # @username
                "source_title": src_title,    # title (пока = @username)
                "title": title,
                "link": post_link,
                "tg_post_id": tg_post_id,
                "published_raw": dt_iso,
                "ts": ts,
                "text": text,
                "image": img,
                "images": images,
                "reply": reply,
                "doc": doc_name,
                "voice": voice_label,
            })
        except Exception as e:
            log(f"[TG] parse block error: {e}")
            continue

    # важно: возвращаем то же, что раньше ждёт _refresh_now
    return (src_title, items)

_DIVTAG = re.compile(r"</div\s*>|<div\b", re.I)

def _split_tg_blocks(html: str) -> List[str]:
    if not html:
        return []

    marks = [m.start() for m in re.finditer(r"tgme_widget_message_wrap", html)]
    if not marks:
        return []

    out: List[str] = []
    n = len(html)

    for pos in marks[:220]:
        start = html.rfind("<div", 0, pos)
        if start < 0:
            continue

        depth = 0
        i = start
        end = -1

        while i < n:
            m = _DIVTAG.search(html, i)
            if not m:
                break

            tok = m.group(0).lower()
            if tok.startswith("<div"):
                depth += 1
            else:
                depth -= 1
                if depth == 0:
                    end = m.end()
                    break

            i = m.end()

        if end > start:
            out.append(html[start:end])

    return out

def _extract_tg_time_iso(block_html: str) -> str:
    m = _RE_TG_TIME.search(block_html)
    if m:
        return (m.group(1) or "").strip()

    m2 = re.search(r"datetime=['\"]([^'\"]+)['\"]", block_html, re.S | re.I)
    if m2:
        return (m2.group(1) or "").strip()

    return ""


def _fetch_tg_user_feed(username: str) -> Tuple[str, List[Dict[str, Any]]]:
    url = f"https://t.me/s/{username}"
    data = _http_get(url, timeout_sec=14)
    try:
        html = data.decode("utf-8", errors="ignore")
    except Exception:
        html = str(data)

    ch_title = _extract_tg_channel_title(html, username)  # ✅ настоящее имя
    return _parse_tg_preview_page(html, username, ch_title)

# ---------------- Plugin ----------------
class Plugin(BasePlugin):
    def __init__(self):
        super().__init__()

        # main
        self._overlay: Optional[FrameLayout] = None
        self._content: Optional[LinearLayout] = None
        self._list_container: Optional[LinearLayout] = None

        # add/import
        self._add_overlay: Optional[FrameLayout] = None
        self._add_content: Optional[LinearLayout] = None
        self._cat_overlay: Optional[FrameLayout] = None
        self._cat_content: Optional[LinearLayout] = None
        self._src_overlay: Optional[FrameLayout] = None
        self._src_content: Optional[LinearLayout] = None

        # post
        self._post_overlay: Optional[FrameLayout] = None
        self._post_content: Optional[LinearLayout] = None

        # image
        self._img_overlay: Optional[FrameLayout] = None
        self._img_content: Optional[LinearLayout] = None

        self._mode: str = "feed"
        self._refresh_lock = threading.Lock()

        self._img_cache: Dict[str, Any] = {}
        self._img_cache_lock = threading.Lock()

        self._refreshing = False
        self._pull_armed = False
        self._pull_start_y = 0.0

        self._main_scroll: Optional[ScrollView] = None
        self._refresh_bar: Optional[View] = None
        self._main_touch_listener = None
        self._main_back_listener = None
        self._add_back_listener = None
        self._cat_back_listener = None
        self._src_back_listener = None
        self._post_back_listener = None
        self._img_back_listener = None

        self._source_filter: str = ""
        self._category_filter: str = ""
        self._source_btn: Optional[TextView] = None
        self._nav_feed_btn: Optional[TextView] = None
        self._nav_subs_btn: Optional[TextView] = None
        self._nav_cats_btn: Optional[TextView] = None
        self._nav_settings_btn: Optional[TextView] = None
        self._bottom_nav_row: Optional[LinearLayout] = None
        self._bottom_nav_indicator: Optional[View] = None

        self._gesture_start_x = 0.0
        self._gesture_start_y = 0.0
        self._gesture_switched = False
        self._gesture_dragging = False
        self._animate_list_once = False
        self._feed_item_touch_listener = None

        self._ui_scale = _clamp_ui_scale(self.get_setting("ui_scale", "1.00"))
        global _UI_SCALE
        _UI_SCALE = float(self._ui_scale)
        self._ui_seek_listener = None
        self._suppress_open_refresh_once = False

    # ---- UI rounding ----
    def _corner_radius_px(self) -> int:
        return _dp(float(CORNER_RADIUS_DP))

    def _bg_rounded(self, fill_hex: str, stroke_hex: str = "#00000000", stroke_dp: float = 0.0):
        bg = GradientDrawable()
        bg.setColor(_c(fill_hex, "#FF1E1E24"))
        bg.setCornerRadius(float(self._corner_radius_px()))
        if stroke_dp and stroke_dp > 0:
            bg.setStroke(_dp(stroke_dp), _c(stroke_hex, "#00000000"))
        return bg

    def _bg_important_gradient(self):
        try:
            bg = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                [_c("#FF1E1E24"), _c("#6EFFFFFF")]
            )
            bg.setCornerRadius(float(self._corner_radius_px()))
            bg.setStroke(_dp(0), _c("#22FFFFFF"))
            return bg
        except Exception:
            return self._bg_rounded("#FF1E1E24", "#22FFFFFF", 0.0)

    def _bg_pill(self, fill_hex: str, stroke_hex: str = "#00000000", stroke_dp: float = 0.0):
        bg = GradientDrawable()
        bg.setColor(_c(fill_hex, "#FF1E1E24"))
        bg.setCornerRadius(float(_dp(18)))
        if stroke_dp and stroke_dp > 0:
            bg.setStroke(_dp(stroke_dp), _c(stroke_hex, "#00000000"))
        return bg

    def _apply_rounded_clip(self, v: View):
        try:
            v.setClipToOutline(True)
            v.setOutlineProvider(ViewOutlineProvider.BACKGROUND)
        except Exception:
            pass

    def _focus_view_safe(self, v: Optional[View]):
        if v is None:
            return
        try:
            v.setFocusable(True)
        except Exception:
            pass
        try:
            v.setFocusableInTouchMode(True)
        except Exception:
            pass
        try:
            v.requestFocus()
        except Exception:
            pass
        try:
            v.requestFocusFromTouch()
        except Exception:
            pass

    def _set_ui_scale(self, value: Any, persist: bool = True):
        val = _clamp_ui_scale(value)
        self._ui_scale = val
        global _UI_SCALE
        _UI_SCALE = float(val)
        if persist:
            try:
                self.set_setting("ui_scale", f"{val:.2f}")
            except Exception:
                pass

    def _ui_scale_percent(self) -> int:
        try:
            return int(round(float(self._ui_scale) * 100.0))
        except Exception:
            return 100

    def _ui_scale_to_progress(self, value: float) -> int:
        return int(round((_clamp_ui_scale(value) - _UI_SCALE_MIN) * 100.0))

    def _progress_to_ui_scale(self, progress: int) -> float:
        return _clamp_ui_scale(_UI_SCALE_MIN + float(progress) / 100.0)

    def _apply_ui_scale_and_reopen(self, value: float):
        old = float(self._ui_scale)
        new = _clamp_ui_scale(value)
        if abs(new - old) < 0.004:
            return
        self._set_ui_scale(new, persist=True)
        if self._overlay is None:
            return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed":
                self._set_mode(mode_now)

    # ---------- lifecycle ----------
    def on_plugin_load(self):
        self._install_drawer_item()


    def on_plugin_unload(self):
        run_on_ui_thread(lambda: self._close(animated=False))
        run_on_ui_thread(lambda: self._close_add_feed_screen(animated=False))
        run_on_ui_thread(lambda: self._close_category_screen(animated=False))
        run_on_ui_thread(lambda: self._close_source_picker_screen(animated=False))
        run_on_ui_thread(lambda: self._close_post_screen(animated=False))
        run_on_ui_thread(lambda: self._close_image_screen(animated=False))

    # ---------- settings ----------
    def _clear_cache(self):
        try:
            self.set_setting("rss_cache", "[]")
            self.set_setting("rss_cache_ts", "0")
        except Exception as e:
            log(f"[RSS] clear cache error: {e}")
        # если лента открыта — перерисуем
        try:
            run_on_ui_thread(self._render)
        except Exception:
            pass
    def create_settings(self):
        return [
            Header(text="RSS Моя лента"),
            Text(
                text="Открыть ленту",
                icon="msg_list",
                accent=True,
                on_click=lambda v: self._open(get_last_fragment()),
            ),
            Text(
                text="Очистить кэш",
                icon="msg_delete",
                accent=False,
                on_click=lambda v: self._clear_cache(),
            ),
            Divider(),
            Switch(
                key="auto_refresh",
                text="Автообновление при открытии",
                default=True,
                icon="msg_autodelete",
            ),
        ]

    # ---------- drawer ----------
    def _install_drawer_item(self):
        try:
            item = MenuItemData(
                menu_type=MenuItemType.DRAWER_MENU,
                text="Моя лента",
                on_click=lambda ctx: self._open(ctx.get("fragment") or get_last_fragment()),
                icon="msg_list",
                item_id="rss_my_feed_drawer",
                subtext="RSS/Atom + Telegram",
                priority=980,
            )
            self.add_menu_item(item)
        except Exception as e:
            log(f"[RSS] Drawer item error: {e}")

    # ---------- storage ----------
    def _get_sub_entries(self) -> List[Dict[str, str]]:
        raw = self.get_setting("rss_subs", "[]")
        subs = _safe_json_load(raw, [])
        if not isinstance(subs, list):
            return []
        out: List[Dict[str, str]] = []
        seen = {}
        for it in subs:
            sub = ""
            cat = ""
            if isinstance(it, dict):
                sub = _norm_sub(str(it.get("sub") or it.get("url") or it.get("source") or ""))
                cat = _norm_category(it.get("category") or it.get("cat") or "")
            else:
                sub = _norm_sub(str(it))
            if not sub:
                continue
            if sub in seen:
                idx = seen[sub]
                if cat and not out[idx].get("category"):
                    out[idx]["category"] = cat
                continue
            seen[sub] = len(out)
            out.append({"sub": sub, "category": cat})
        return out

    def _set_sub_entries(self, entries: List[Dict[str, Any]]):
        try:
            out: List[Dict[str, str]] = []
            seen = set()
            for it in entries:
                if not isinstance(it, dict):
                    continue
                sub = _norm_sub(str(it.get("sub") or ""))
                if not sub or sub in seen:
                    continue
                seen.add(sub)
                out.append({
                    "sub": sub,
                    "category": _norm_category(it.get("category") or ""),
                })
            self.set_setting("rss_subs", json.dumps(out, ensure_ascii=False))
        except Exception as e:
            log(f"[RSS] _set_sub_entries error: {e}")

    def _get_subs(self) -> List[str]:
        return [x.get("sub", "") for x in self._get_sub_entries() if x.get("sub")]

    def _set_subs(self, subs: List[str]):
        old = self._get_sub_entries()
        old_cat = {str(x.get("sub")): _norm_category(x.get("category")) for x in old}
        merged = []
        for u in subs:
            nu = _norm_sub(str(u))
            if not nu:
                continue
            merged.append({"sub": nu, "category": old_cat.get(nu, "")})
        self._set_sub_entries(merged)

    def _get_cache(self) -> List[Dict[str, Any]]:
        raw = self.get_setting("rss_cache", "[]")
        arr = _safe_json_load(raw, [])
        if not isinstance(arr, list):
            return []
        out: List[Dict[str, Any]] = []
        for it in arr:
            if not isinstance(it, dict):
                continue
            link = str(it.get("link", "") or "")
            # ✅ title теперь может быть пустым (для TG-only-media)
            title = str(it.get("title", "") or "")
            if link:
                images = _norm_images_list(it.get("images", []))
                if not images:
                    one = _upgrade_image_url(it.get("image", ""))
                    if one:
                        images = [one]
                out.append({
                    "source_handle": str(it.get("source_handle", "") or ""),
                    "source_title": str(it.get("source_title", "") or ""),
                    "title": title,
                    "link": link,
                    "published_raw": str(it.get("published_raw", "") or ""),
                    "ts": int(it.get("ts", 0) or 0),
                    "fetched_ts": int(it.get("fetched_ts", 0) or 0),
                    "sort_ts": int(it.get("sort_ts", 0) or 0),
                    "source": str(it.get("source", "") or ""),
                    "text": str(it.get("text", "") or ""),
                    "image": (images[0] if images else ""),
                    "images": images,
                    "reply": str(it.get("reply", "") or ""),
                    "doc": str(it.get("doc", "") or ""),
                    "voice": str(it.get("voice", "") or ""),
                    "tg_post_id": str(it.get("tg_post_id", "") or ""),
                    "category": _norm_category(it.get("category", "")),
                })
        return out

    def _set_cache(self, items: List[Dict[str, Any]]):
        try:
            self.set_setting("rss_cache", json.dumps(items, ensure_ascii=False))
            self.set_setting("rss_cache_ts", str(_now_ts()))
        except Exception as e:
            log(f"[RSS] _set_cache error: {e}")

    # ---------- refresh ----------
    def _bind_back_handler(self, overlay: View, close_cb, store_attr: str):
        try:
            self._focus_view_safe(overlay)

            def on_key(_v, key_code, event):
                try:
                    if int(key_code) != int(KeyEvent.KEYCODE_BACK):
                        return False
                    act = int(event.getAction())
                    # ACTION_DOWN catches both button back and gesture back reliably.
                    if act == int(KeyEvent.ACTION_DOWN):
                        close_cb()
                        return True
                    if act == int(KeyEvent.ACTION_UP):
                        return True
                    return False
                except Exception:
                    return False

            listener = None
            try:
                listener = _OnKeyListener(on_key)
            except Exception:
                listener = None

            if listener is None:
                class _LocalOnKeyListener(dynamic_proxy(View.OnKeyListener)):
                    def __init__(self, fn):
                        super().__init__()
                        self._fn = fn
                    def onKey(self, v, key_code, event):
                        return bool(self._fn(v, key_code, event))
                listener = _LocalOnKeyListener(on_key)

            def attach_to_tree(v: View):
                try:
                    v.setOnKeyListener(listener)
                except Exception:
                    pass
                if isinstance(v, ViewGroup):
                    try:
                        cnt = int(v.getChildCount() or 0)
                    except Exception:
                        cnt = 0
                    for i in range(cnt):
                        try:
                            ch = v.getChildAt(i)
                        except Exception:
                            ch = None
                        if ch is not None:
                            attach_to_tree(ch)

            attach_to_tree(overlay)
            self._focus_view_safe(overlay)

            def late_bind():
                try:
                    attach_to_tree(overlay)
                    self._focus_view_safe(overlay)
                except Exception:
                    pass

            def focus_guard():
                try:
                    parent = overlay.getParent()
                    if parent is None:
                        return
                except Exception:
                    return
                try:
                    attach_to_tree(overlay)
                    self._focus_view_safe(overlay)
                except Exception:
                    pass
                try:
                    AndroidUtilities.runOnUIThread(Runnable(focus_guard), 420)
                except Exception:
                    pass
            try:
                AndroidUtilities.runOnUIThread(Runnable(late_bind), 80)
                AndroidUtilities.runOnUIThread(Runnable(late_bind), 220)
                AndroidUtilities.runOnUIThread(Runnable(focus_guard), 420)
            except Exception:
                pass
            setattr(self, store_attr, listener)
        except Exception as e:
            log(f"[RSS] back handler bind error: {e}")

    def _set_refreshing_ui(self, val: bool):
        self._refreshing = bool(val)
        try:
            if self._refresh_bar is not None:
                self._refresh_bar.setVisibility(View.VISIBLE if self._refreshing else View.GONE)
        except Exception:
            pass

    def _source_filter_label(self) -> str:
        if not self._source_filter:
            return "Выбрать источник ▾"
        name = self._source_filter
        if len(name) > 22:
            name = name[:21].rstrip() + "…"
        return f"Источник: {name} ▾"

    def _category_filter_label(self) -> str:
        if not self._category_filter:
            return "Выбрать категорию ▾"
        name = self._category_filter
        if len(name) > 22:
            name = name[:21].rstrip() + "…"
        return f"Категория: {name} ▾"

    def _top_filter_label(self) -> str:
        if self._mode == "settings":
            return "Настройки"
        return self._category_filter_label() if self._mode == "cats" else self._source_filter_label()

    def _update_source_button(self):
        try:
            if self._source_btn is not None:
                self._source_btn.setText(self._top_filter_label())
                self._source_btn.setAlpha(0.58 if self._mode == "settings" else 1.0)
        except Exception:
            pass

    def _available_sources(self) -> List[str]:
        vals = []
        for it in self._get_cache():
            s = _format_source_line(it).strip()
            if not s:
                s = str(it.get("source", "") or "").strip()
            if s:
                vals.append(s)
        return _uniq_keep_order(vals)

    def _source_filter_options(self) -> List[str]:
        return [""] + self._available_sources()

    def _available_categories(self) -> List[str]:
        vals = []
        for it in self._get_cache():
            c = _norm_category(it.get("category", ""))
            if c:
                vals.append(c)
        for it in self._get_sub_entries():
            c = _norm_category(it.get("category", ""))
            if c:
                vals.append(c)
        return _uniq_keep_order(vals)

    def _category_filter_options(self) -> List[str]:
        return [""] + self._available_categories()

    def _set_source_filter(self, source_value: str):
        val = str(source_value or "")
        opts = self._source_filter_options()
        self._source_filter = val if val in opts else ""
        self._update_source_button()
        self._animate_list_once = True
        self._render()

    def _set_category_filter(self, category_value: str):
        val = _norm_category(category_value)
        opts = self._category_filter_options()
        self._category_filter = val if val in opts else ""
        self._update_source_button()
        self._animate_list_once = True
        self._render()

    def _open_top_filter_picker(self):
        if self._mode == "settings":
            return
        if self._mode == "cats":
            self._open_category_picker_screen()
        else:
            self._open_source_picker_screen()

    def _open_picker_screen(self, picker_title: str, options: List[Tuple[str, str]], current_value: str, on_select):
        if self._src_overlay is not None:
            return
        fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup):
            return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        overlay.setBackgroundColor(_c("#A6000000"))
        overlay.setClickable(True)
        overlay.setFocusable(True)
        overlay.setOnClickListener(OnClickListener(lambda _v: self._close_source_picker_screen(animated=True)))

        card = LinearLayout(activity)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(_dp(12), _dp(12), _dp(12), _dp(12))
        card.setBackground(self._bg_rounded("#FF171A24", "#22FFFFFF", 0.0))
        card.setClickable(True)
        lp_card = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
        lp_card.leftMargin = _dp(16)
        lp_card.rightMargin = _dp(16)
        lp_card.topMargin = _statusbar_pad() + _dp(14)
        overlay.addView(card, lp_card)

        title_tv = TextView(activity)
        title_tv.setText(picker_title)
        title_tv.setTextSize(27)
        title_tv.setTextColor(_c("#FFFFFFFF"))
        title_tv.setPadding(_dp(2), _dp(2), _dp(2), _dp(10))
        card.addView(title_tv)

        sv = ScrollView(activity)
        sv.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        ))
        card.addView(sv)

        col = LinearLayout(activity)
        col.setOrientation(LinearLayout.VERTICAL)
        sv.addView(col)

        current = str(current_value or "")
        for value, label in options:
            btn = TextView(activity)
            btn.setText(label)
            btn.setTextSize(14)
            btn.setTextColor(_c("#FFFFFFFF"))
            btn.setPadding(_dp(12), _dp(10), _dp(12), _dp(10))
            btn.setClickable(True)
            selected = (value == current)
            btn.setAlpha(1.0 if selected else 0.9)
            btn.setBackground(self._bg_rounded("#33FFFFFF" if selected else "#121AFFFFFF"))
            btn.setOnClickListener(OnClickListener(
                lambda _v, val=value: (on_select(val), self._close_source_picker_screen(animated=True))
            ))
            lp_btn = LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            )
            lp_btn.bottomMargin = _dp(8)
            col.addView(btn, lp_btn)

        close_btn = self._top_button(activity, " Свернуть ", lambda: self._close_source_picker_screen(animated=True))
        lp_close = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
        lp_close.topMargin = _dp(6)
        card.addView(close_btn, lp_close)

        self._src_overlay = overlay
        self._src_content = card
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._close_source_picker_screen(animated=True), "_src_back_listener")

        try:
            overlay.setAlpha(0.0)
            card.setTranslationY(float(_dp(-10)))
            overlay.animate().alpha(1.0).setDuration(120).start()
            anim = card.animate().translationY(0.0).setDuration(160)
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            pass

    def _open_source_picker_screen(self):
        vals = self._source_filter_options()
        options = [("", "Все источники")] + [(x, x) for x in vals if x]
        cur = self._source_filter if self._source_filter in vals else ""
        self._open_picker_screen("Выбор источника", options, cur, self._set_source_filter)

    def _open_category_picker_screen(self):
        vals = self._category_filter_options()
        options = [("", "Все категории")] + [(x, x) for x in vals if x]
        cur = self._category_filter if self._category_filter in vals else ""
        self._open_picker_screen("Выбор категории", options, cur, self._set_category_filter)

    def _close_source_picker_screen(self, animated: bool):
        overlay = self._src_overlay
        content = self._src_content
        if overlay is None:
            return

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup):
                    parent.removeView(overlay)
            except Exception:
                pass
            self._src_overlay = None
            self._src_content = None
            self._src_back_listener = None

        if not animated or content is None:
            detach()
            return

        try:
            overlay.animate().alpha(0.0).setDuration(110).start()
            content.animate().translationY(float(_dp(-10))).setDuration(120).start()
        except Exception:
            pass
        try:
            AndroidUtilities.runOnUIThread(Runnable(detach), 150)
        except Exception:
            run_on_ui_thread(detach)

    def _refresh_now(self):
        sub_entries = self._get_sub_entries()
        old = self._get_cache()

        old_by_key = {}
        for x in old:
            if not isinstance(x, dict):
                continue
            key = str(x.get("tg_post_id") or x.get("link") or "")
            if key:
                old_by_key[key] = x

        fetched_now = _now_ts()
        all_items: List[Dict[str, Any]] = []

        for sub_item in sub_entries:
            sub = str(sub_item.get("sub") or "")
            sub_cat = _norm_category(sub_item.get("category") or "")
            if not sub:
                continue
            try:
                if sub.startswith("tguser:"):
                    username = sub.split(":", 1)[1].strip()
                    if not username:
                        continue
                    src_title, items = _fetch_tg_user_feed(username)
                else:
                    xml = _http_get(sub, timeout_sec=12)
                    src_title, items = parse_feed(xml, sub)

                for it in items[:250]:
                    key = str(it.get("tg_post_id") or it.get("link") or "")
                    it["source"] = it.get("source") or src_title or sub
                    it["fetched_ts"] = fetched_now

                    # ✅ гарантируем, что поля существуют (иначе в кэш могут не попасть)
                    it["source_handle"] = str(it.get("source_handle", "") or "")
                    it["source_title"]  = str(it.get("source_title", "") or it.get("source", "") or "")
                    it["reply"] = str(it.get("reply", "") or "")
                    it["doc"] = str(it.get("doc", "") or "")
                    it["voice"] = str(it.get("voice", "") or "")
                    it["tg_post_id"] = str(it.get("tg_post_id", "") or "")
                    imgs = _norm_images_list(it.get("images", []))
                    one_img = _upgrade_image_url(it.get("image", ""))
                    if one_img and one_img not in imgs:
                        imgs.insert(0, one_img)
                    it["images"] = imgs
                    it["image"] = imgs[0] if imgs else one_img
                    prev = old_by_key.get(key) if key else None
                    prev_cat = _norm_category((prev or {}).get("category") or "")
                    it["category"] = sub_cat if sub_cat else prev_cat

                    ts = int(it.get("ts", 0) or 0)
                    if ts > 0:
                        it["sort_ts"] = ts
                    else:
                        prev_sort = int((prev or {}).get("sort_ts", 0) or 0)
                        it["sort_ts"] = prev_sort if prev_sort > 0 else fetched_now

                all_items.extend(items[:250])
            except Exception as e:
                log(f"[RSS] fetch error {sub}: {e}")

        # dedup by link
        seen = set()
        uniq = []
        for it in all_items:
            key = str(it.get("tg_post_id") or it.get("link") or "")
            if not key or key in seen:
                continue
            seen.add(key)
            uniq.append(it)

        uniq.sort(key=lambda x: int(x.get("sort_ts", x.get("ts", 0) or 0) or 0), reverse=True)
        self._set_cache(uniq[:900])

    def _refresh_async(self):
        def bg():
            try:
                with self._refresh_lock:
                    self._refresh_now()
            finally:
                def ui():
                    # ✅ всегда сбрасываем индикатор
                    self._set_refreshing_ui(False)
                    self._render()
                    self._update_source_button()
                run_on_ui_thread(ui)

        threading.Thread(target=bg, daemon=True).start()

    # ---------- UI helpers ----------
    def _reply_bubble(self, ctx, reply_text: str) -> View:
        row = LinearLayout(ctx)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setPadding(_dp(10), _dp(8), _dp(10), _dp(8))
        # Reply bubble is intentionally darker than the card itself.
        row.setBackground(self._bg_rounded("#32000000", "#28FFFFFF", 0.0))

        bar = View(ctx)

        gd = GradientDrawable()
        gd.setColor(_c("#FFFFF0FF"))
        gd.setCornerRadii([_dp(99),_dp(99), 0,0, 0,0, _dp(99),_dp(99)])  # TL,TR, BR,BL (парами)
        bar.setBackground(gd)

        lp_bar = LinearLayout.LayoutParams(_dp(3.5), ViewGroup.LayoutParams.MATCH_PARENT)
        row.addView(bar, lp_bar)
        tv = TextView(ctx)
        tv.setText(reply_text)
        tv.setTextSize(13)
        tv.setTextColor(_c("#FFFFFFFF"))
        tv.setAlpha(0.64)
        tv.setSingleLine(False)

        lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp.leftMargin = _dp(8)
        row.addView(tv, lp)

        return row

    def _top_button(self, ctx, text: str, cb):
        b = TextView(ctx)
        b.setText(text)
        b.setTextSize(11)
        b.setTextColor(_c("#FFFFFFFF"))
        b.setTypeface(None, Typeface.BOLD)
        b.setPadding(_dp(12), _dp(8), _dp(12), _dp(8))
        b.setClickable(True)
        b.setBackground(self._bg_rounded("#1AFFFFFF"))

        def on_click(v):
            try:
                v.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
            except Exception:
                pass
            try:
                cb()
            except Exception as e:
                log(f"[RSS] top button error: {e}")

        b.setOnClickListener(OnClickListener(on_click))
        return b

    def _primary_button(self, ctx, text: str, cb):
        b = TextView(ctx)
        b.setText(text)
        b.setTextSize(11)
        b.setGravity(Gravity.CENTER)
        b.setTextColor(_c("#FFFFFFFF"))
        b.setTypeface(None, Typeface.BOLD)
        b.setPadding(_dp(12), _dp(12), _dp(12), _dp(12))
        b.setClickable(True)
        b.setBackground(self._bg_rounded("#22FFFFFF"))

        def on_click(v):
            try:
                v.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
            except Exception:
                pass
            try:
                cb()
            except Exception as e:
                log(f"[RSS] primary button error: {e}")

        b.setOnClickListener(OnClickListener(on_click))
        return b

    def _spacer_h(self, ctx, wdp: int) -> View:
        v = View(ctx)
        v.setLayoutParams(LinearLayout.LayoutParams(_dp(wdp), 1))
        return v

    def _bottom_nav_button(self, ctx, text: str, cb):
        b = TextView(ctx)
        b.setText(text)
        b.setTextSize(11)
        b.setGravity(Gravity.CENTER)
        b.setTextColor(_c("#FFFFFFFF"))
        b.setPadding(_dp(10), _dp(10), _dp(10), _dp(10))
        b.setClickable(True)
        b.setBackground(self._bg_pill("#00000000"))

        def on_click(v):
            try:
                v.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
            except Exception:
                pass
            try:
                v.animate().cancel()
                a = v.animate().scaleX(0.96).scaleY(0.96).setDuration(70)
                try:
                    a.withEndAction(Runnable(lambda: v.animate().scaleX(1.0).scaleY(1.0).setDuration(120).start()))
                except Exception:
                    pass
                a.start()
            except Exception:
                pass
            try:
                cb()
            except Exception as e:
                log(f"[RSS] bottom nav button error: {e}")

        b.setOnClickListener(OnClickListener(on_click))
        return b

    def _mode_order(self) -> List[str]:
        return ["feed", "cats", "subs", "settings"]

    def _mode_index(self, mode: str) -> int:
        order = self._mode_order()
        try:
            return order.index(mode)
        except Exception:
            return 0

    def _switch_mode_by_swipe(self, dx: float):
        order = self._mode_order()
        cur = self._mode_index(self._mode)
        step = 1 if float(dx) < 0 else -1
        nxt = max(0, min(len(order) - 1, cur + step))
        if nxt == cur:
            return
        try:
            if self._main_scroll is not None:
                self._main_scroll.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
        except Exception:
            pass
        self._set_mode(order[nxt])

    def _preview_page_swipe(self, dx: float):
        try:
            cont = self._list_container
            if cont is not None:
                shift = max(-float(_dp(90)), min(float(_dp(90)), float(dx) * 0.55))
                cont.setTranslationX(shift)
        except Exception:
            pass
        try:
            row = self._bottom_nav_row
            ind = self._bottom_nav_indicator
            if row is None or ind is None:
                return
            w = int(row.getWidth() or 0)
            total = len(self._mode_order())
            if w <= 0 or total <= 0:
                return
            seg = float(w) / float(total)
            base = float(self._mode_index(self._mode)) * seg
            target = max(0.0, min(seg * float(total - 1), base + float(-dx) * 0.35))
            ind.setTranslationX(target)
        except Exception:
            pass

    def _finish_page_swipe_preview(self):
        try:
            if self._list_container is not None:
                self._list_container.animate().translationX(0.0).setDuration(140).start()
        except Exception:
            pass
        try:
            self._update_bottom_nav_indicator(animated=True)
        except Exception:
            pass

    def _update_bottom_nav_indicator(self, animated: bool):
        row = self._bottom_nav_row
        ind = self._bottom_nav_indicator
        if row is None or ind is None:
            return
        idx = self._mode_index(self._mode)
        total = len(self._mode_order())

        def apply():
            try:
                w = int(row.getWidth() or 0)
                if w <= 0 or total <= 0:
                    return
                seg = max(1, int(w / total))
                lp = ind.getLayoutParams()
                if lp is not None:
                    try:
                        if int(lp.width or 0) != seg:
                            lp.width = seg
                            ind.setLayoutParams(lp)
                    except Exception:
                        pass
                tx = float(seg * idx)
                if animated:
                    ind.animate().translationX(tx).setDuration(170).start()
                else:
                    ind.setTranslationX(tx)
            except Exception:
                pass

        try:
            row.post(Runnable(apply))
        except Exception:
            try:
                AndroidUtilities.runOnUIThread(Runnable(apply), 0)
            except Exception:
                pass

    def _handle_item_swipe_touch(self, ev) -> bool:
        try:
            try:
                act = int(ev.getActionMasked())
            except Exception:
                act = int(ev.getAction())

            if act == MotionEvent.ACTION_DOWN:
                self._gesture_start_x = float(ev.getX())
                self._gesture_start_y = float(ev.getY())
                self._gesture_switched = False
                self._focus_view_safe(self._overlay)
                return False

            if act == MotionEvent.ACTION_MOVE:
                dx = float(ev.getX()) - float(self._gesture_start_x)
                dy = float(ev.getY()) - float(self._gesture_start_y)
                if (not self._gesture_switched) and (abs(dx) > float(_dp(72))) and (abs(dx) > abs(dy) * 1.2):
                    self._gesture_switched = True
                    self._switch_mode_by_swipe(dx)
                    return True
                return bool(self._gesture_switched)

            if act in (MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL):
                consumed = bool(self._gesture_switched)
                self._gesture_switched = False
                return consumed
        except Exception:
            return False
        return False

    def _update_bottom_nav_state(self):
        try:
            if self._nav_feed_btn is None or self._nav_subs_btn is None or self._nav_cats_btn is None or self._nav_settings_btn is None:
                return
            is_feed = (self._mode == "feed")
            is_subs = (self._mode == "subs")
            is_cats = (self._mode == "cats")
            is_settings = (self._mode == "settings")

            self._nav_feed_btn.setBackground(self._bg_pill("#00000000"))
            self._nav_subs_btn.setBackground(self._bg_pill("#00000000"))
            self._nav_cats_btn.setBackground(self._bg_pill("#00000000"))
            self._nav_settings_btn.setBackground(self._bg_pill("#00000000"))

            self._nav_feed_btn.setAlpha(1.0 if is_feed else 0.78)
            self._nav_subs_btn.setAlpha(1.0 if is_subs else 0.78)
            self._nav_cats_btn.setAlpha(1.0 if is_cats else 0.78)
            self._nav_settings_btn.setAlpha(1.0 if is_settings else 0.78)
            self._nav_feed_btn.setBackground(self._bg_pill("#2AFFFFFF" if is_feed else "#00000000"))
            self._nav_subs_btn.setBackground(self._bg_pill("#2AFFFFFF" if is_subs else "#00000000"))
            self._nav_cats_btn.setBackground(self._bg_pill("#2AFFFFFF" if is_cats else "#00000000"))
            self._nav_settings_btn.setBackground(self._bg_pill("#2AFFFFFF" if is_settings else "#00000000"))
        except Exception:
            pass

    def _animate_entry(self, v: View, idx: int = 0):
        try:
            delay = int(min(max(idx, 0), 10) * 22)
            v.setAlpha(1.0)
            v.setTranslationY(float(_dp(6)))
            anim = v.animate().translationY(0.0).setDuration(160)
            try:
                anim.setStartDelay(delay)
            except Exception:
                pass
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            try:
                v.setAlpha(1.0)
                v.setTranslationY(0.0)
            except Exception:
                pass

    # ---------- MAIN SCREEN ----------
    def _open(self, fragment):
        log("[RSS] _open: start")
        if self._overlay is not None:
            log("[RSS] _open: already opened")
            return
        if not fragment:
            fragment = get_last_fragment()
        if not fragment:
            log("[RSS] _open: no fragment")
            return
        activity = fragment.getParentActivity()
        if not activity:
            log("[RSS] _open: no activity")
            return

        # ✅ сначала создаём overlay
        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        overlay.setBackgroundColor(_c("#FF0F0F12"))
        overlay.setClickable(True)
        overlay.setFocusable(True)

        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup):
            log("[RSS] _open: decor is not ViewGroup")
            return

        try:
            decor.addView(overlay)
            log("[RSS] _open: overlay added")
        except Exception as e:
            log(f"[RSS] _open: decor.addView failed: {e}")
            return
        self._bind_back_handler(overlay, lambda: self._close(animated=True), "_main_back_listener")

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        title = TextView(activity)
        title.setText("Моя лента")
        title.setTextSize(20)
        title.setTextColor(_c("#FFFFFFFF"))
        top.addView(title, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        source_btn = self._top_button(activity, self._top_filter_label(), lambda: self._open_top_filter_picker())
        self._source_btn = source_btn
        top.addView(source_btn)
        top.addView(self._spacer_h(activity, 8))
        top.addView(self._top_button(activity, " X ", lambda: self._close(animated=True)))

        hint = TextView(activity)
        hint.setText("ExteraRSS By @RoflPlugins")
        hint.setTextSize(12)
        hint.setTextColor(_c("#FFFFFFFF"))
        hint.setAlpha(0.45)
        hint.setPadding(0, _dp(6), 0, _dp(10))
        content.addView(hint)

        # --- refresh bar (показывается во время обновления) ---
        refresh_bar = LinearLayout(activity)
        refresh_bar.setOrientation(LinearLayout.HORIZONTAL)
        refresh_bar.setGravity(Gravity.CENTER_VERTICAL)
        refresh_bar.setPadding(_dp(12), _dp(8), _dp(12), _dp(8))
        refresh_bar.setBackground(self._bg_rounded("#1AFFFFFF"))
        refresh_bar.setVisibility(View.GONE)

        pb = ProgressBar(activity)
        try:
            pb.setIndeterminate(True)
        except Exception:
            pass
        refresh_bar.addView(pb, LinearLayout.LayoutParams(_dp(18), _dp(18)))

        txt = TextView(activity)
        txt.setText("Обновление… ")
        txt.setTextSize(13)
        txt.setTypeface(None, Typeface.BOLD)
        txt.setTextColor(_c("#FFFFFFFF"))
        txt.setAlpha(0.85)
        lp_txt = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_txt.leftMargin = _dp(10)
        refresh_bar.addView(txt, lp_txt)

        lp_rb = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_rb.bottomMargin = _dp(10)
        content.addView(refresh_bar, lp_rb)

        self._refresh_bar = refresh_bar

        sv = ScrollView(activity)
        sv.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            0,
            1.0
        ))
        try:
            sv.setFillViewport(True)
        except Exception:
            pass
        content.addView(sv)

        list_container = LinearLayout(activity)
        list_container.setOrientation(LinearLayout.VERTICAL)
        try:
            lp_lc = ScrollView.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            )
            list_container.setLayoutParams(lp_lc)
        except Exception:
            pass

        sv.addView(list_container)

        bottom_nav = LinearLayout(activity)
        bottom_nav.setOrientation(LinearLayout.HORIZONTAL)
        bottom_nav.setGravity(Gravity.CENTER_VERTICAL)
        bottom_nav.setPadding(_dp(4), _dp(4), _dp(4), _dp(4))
        bottom_nav.setBackground(self._bg_pill("#1C1AFFFFFF", "#24FFFFFF", 0.0))
        lp_nav = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_nav.topMargin = _dp(10)
        content.addView(bottom_nav, lp_nav)

        nav_feed = self._bottom_nav_button(activity, "Лента", lambda: self._set_mode("feed"))
        nav_cats = self._bottom_nav_button(activity, "Категории", lambda: self._set_mode("cats"))
        nav_subs = self._bottom_nav_button(activity, "Подписки", lambda: self._set_mode("subs"))
        nav_settings = self._bottom_nav_button(activity, "Настройки", lambda: self._set_mode("settings"))
        self._nav_feed_btn = nav_feed
        self._nav_cats_btn = nav_cats
        self._nav_subs_btn = nav_subs
        self._nav_settings_btn = nav_settings

        lp_feed = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp_cats = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp_cats.leftMargin = _dp(6)
        lp_subs = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp_subs.leftMargin = _dp(6)
        lp_settings = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp_settings.leftMargin = _dp(6)

        bottom_nav.addView(nav_feed, lp_feed)
        bottom_nav.addView(nav_cats, lp_cats)
        bottom_nav.addView(nav_subs, lp_subs)
        bottom_nav.addView(nav_settings, lp_settings)
        try:
            bottom_nav.setAlpha(1.0)
            bottom_nav.setTranslationY(float(_dp(14)))
            nav_anim = bottom_nav.animate().translationY(0.0).setDuration(180)
            try:
                nav_anim.setStartDelay(80)
            except Exception:
                pass
            nav_anim.start()
        except Exception:
            try:
                bottom_nav.setAlpha(1.0)
                bottom_nav.setTranslationY(0.0)
            except Exception:
                pass

        self._main_scroll = sv
        self._overlay = overlay
        self._content = content
        self._list_container = list_container
        self._mode = "feed"
        self._update_bottom_nav_state()

        # --- pull-to-refresh без androidx ---
        def start_refresh_from_pull():
            if self._refreshing:
                return
            log("[RSS] pull refresh triggered")
            self._set_refreshing_ui(True)
            self._refresh_async()

        def on_touch(_v, ev):
            try:
                try:
                    act = int(ev.getActionMasked())
                except Exception:
                    act = int(ev.getAction())

                if act == MotionEvent.ACTION_DOWN:
                    self._gesture_start_x = float(ev.getX())
                    self._gesture_start_y = float(ev.getY())
                    self._gesture_switched = False
                    self._focus_view_safe(self._overlay)
                    self._pull_start_y = float(ev.getY())
                    try:
                        at_top = (not bool(sv.canScrollVertically(-1)))
                    except Exception:
                        at_top = (sv.getScrollY() <= 0)
                    self._pull_armed = (self._mode in ("feed", "cats") and (not self._refreshing) and at_top)
                    return False

                if act == MotionEvent.ACTION_MOVE:
                    dx = float(ev.getX()) - float(self._gesture_start_x)
                    dy_total = float(ev.getY()) - float(self._gesture_start_y)

                    # свайп влево/вправо по ленте -> переключение нижних вкладок
                    if (not self._gesture_switched) and (abs(dx) > float(_dp(72))) and (abs(dx) > abs(dy_total) * 1.2):
                        self._gesture_switched = True
                        self._pull_armed = False
                        self._switch_mode_by_swipe(dx)
                        return True

                    if self._mode not in ("feed", "cats"):
                        return False

                    # не триггерим pull-to-refresh во время обновления
                    if self._refreshing:
                        return False

                    if not self._pull_armed:
                        return False

                    # важно: pull только в самом верху
                    try:
                        at_top = (not bool(sv.canScrollVertically(-1)))
                    except Exception:
                        at_top = (sv.getScrollY() <= 0)
                    if not at_top:
                        self._pull_armed = False
                        return False

                    dy = float(ev.getY()) - float(self._pull_start_y)
                    if abs(dx) > abs(dy):
                        return False

                    # порог "как в браузере": потянул заметно вниз
                    if dy > float(_dp(64)):
                        # чтобы не срабатывало 10 раз подряд
                        self._pull_armed = False
                        try:
                            sv.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
                        except Exception:
                            pass
                        start_refresh_from_pull()
                        return False

                    return False

                if act in (MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL):
                    self._pull_armed = False
                    self._gesture_switched = False
                    return False

            except Exception:
                return False

            return False

        try:
            listener = _OnTouchListener(on_touch)
            self._main_touch_listener = listener
            sv.setOnTouchListener(listener)
            log("[RSS] pull-to-refresh enabled")
        except Exception as e:
            self._main_touch_listener = None
            log(f"[RSS] pull-to-refresh disabled: {e}")

        self._render()
        self._focus_view_safe(overlay)

        

        try:
            overlay.setAlpha(0.0)
            content.setTranslationY(float(_dp(16)))
            overlay.animate().alpha(1.0).setDuration(160).start()
            anim = content.animate().translationY(0.0).setDuration(220)
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            pass


        if self._suppress_open_refresh_once:
            self._suppress_open_refresh_once = False
        elif self.get_setting("auto_refresh", True):
            self._set_refreshing_ui(True)
            self._refresh_async()

    def _close(self, animated: bool):
        overlay = self._overlay
        content = self._content
        if overlay is None:
            return
        self._close_source_picker_screen(animated=False)

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup):
                    parent.removeView(overlay)
            except Exception as e:
                log(f"[RSS] close detach error: {e}")
            self._overlay = None
            self._content = None
            self._list_container = None
            self._main_touch_listener = None
            self._main_back_listener = None
            self._source_btn = None
            self._nav_feed_btn = None
            self._nav_cats_btn = None
            self._nav_subs_btn = None
            self._nav_settings_btn = None
            self._gesture_switched = False
            self._gesture_dragging = False
            self._bottom_nav_row = None
            self._bottom_nav_indicator = None
            self._feed_item_touch_listener = None
            self._ui_seek_listener = None

        if not animated or content is None:
            detach()
            return

        try:
            overlay.animate().alpha(0.0).setDuration(140).start()
            content.animate().translationY(float(_dp(16))).setDuration(160).start()
        except Exception:
            pass
        try:
            AndroidUtilities.runOnUIThread(Runnable(detach), 180)
        except Exception:
            run_on_ui_thread(detach)

    def _set_mode(self, mode: str):
        if mode == self._mode:
            return
        self._close_source_picker_screen(animated=False)
        prev_idx = self._mode_index(self._mode)
        self._mode = mode
        new_idx = self._mode_index(mode)
        self._animate_list_once = True
        self._update_source_button()
        self._update_bottom_nav_state()
        container = self._list_container
        if container is None:
            self._render()
            return
        try:
            container.animate().cancel()
        except Exception:
            pass
        self._render()
        self._update_bottom_nav_state()
        try:
            container.setAlpha(1.0)
            direction = 1 if new_idx > prev_idx else -1
            container.setTranslationX(float(direction * _dp(22)))
            container.setTranslationY(0.0)
            anim_in = container.animate().translationX(0.0).setDuration(190)
            try:
                anim_in.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim_in.start()
        except Exception:
            pass

    # ---------- Add feed screen ----------
    def _open_add_feed_screen(self, fragment):
        log("[RSS] _open: start")
        if self._add_overlay is not None:
            return
        if not fragment:
            fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup):
            return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        overlay.setBackgroundColor(_c("#FF0F0F12"))
        overlay.setClickable(True)
        overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = TextView(activity)
        back.setText("←")
        back.setTextSize(20)
        back.setTypeface(None, Typeface.BOLD)
        back.setTextColor(_c("#FFFFFFFF"))
        back.setPadding(_dp(6), _dp(6), _dp(12), _dp(6))
        back.setClickable(True)
        back.setOnClickListener(OnClickListener(lambda v: self._close_add_feed_screen(animated=True)))
        top.addView(back)

        title = TextView(activity)
        title.setText("Добавить RSS-ленту")
        title.setTextSize(20)
        title.setTypeface(None, Typeface.BOLD)
        title.setTextColor(_c("#FFFFFFFF"))
        top.addView(title, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        sp = View(activity)
        sp.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(18)))
        content.addView(sp)

        h = TextView(activity)
        h.setText("Добавить RSS-ленту")
        h.setTextSize(24)
        h.setTextColor(_c("#FFFFFFFF"))
        h.setPadding(0, 0, 0, _dp(18))
        content.addView(h)

        lbl = TextView(activity)
        lbl.setText("Адрес RSS (или @username для Telegram)")
        lbl.setTextSize(13)
        lbl.setTextColor(_c("#FFFFFFFF"))
        lbl.setAlpha(0.85)
        content.addView(lbl)

        url_input = EditText(activity)
        url_input.setHint("https://site.com/rss  или  @channel")
        url_input.setSingleLine(True)
        url_input.setPadding(_dp(12), _dp(12), _dp(12), _dp(12))
        url_input.setTextColor(_c("#FFFFFFFF"))
        try:
            url_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception:
            pass
        url_input.setBackground(self._bg_rounded("#1AFFFFFF"))
        lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp.topMargin = _dp(10)
        content.addView(url_input, lp)

        lbl_cat = TextView(activity)
        lbl_cat.setText("Категория (любая, необязательно)")
        lbl_cat.setTextSize(13)
        lbl_cat.setTextColor(_c("#FFFFFFFF"))
        lbl_cat.setAlpha(0.85)
        lp_lbl_cat = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_lbl_cat.topMargin = _dp(12)
        content.addView(lbl_cat, lp_lbl_cat)

        category_input = EditText(activity)
        category_input.setHint("например: Новости, Мемы, Работа")
        category_input.setSingleLine(True)
        category_input.setPadding(_dp(12), _dp(12), _dp(12), _dp(12))
        category_input.setTextColor(_c("#FFFFFFFF"))
        try:
            category_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception:
            pass
        category_input.setBackground(self._bg_rounded("#1AFFFFFF"))
        lp_cat = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_cat.topMargin = _dp(10)
        content.addView(category_input, lp_cat)

        push = View(activity)
        push.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0))
        content.addView(push)

        add_btn = self._primary_button(activity, "Добавить", lambda: self._add_sub_from_input(url_input, category_input))
        content.addView(add_btn, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ))

        self._add_overlay = overlay
        self._add_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._close_add_feed_screen(animated=True), "_add_back_listener")

        try:
            overlay.setAlpha(0.0)
            content.setTranslationY(float(_dp(16)))
            overlay.animate().alpha(1.0).setDuration(160).start()
            anim = content.animate().translationY(0.0).setDuration(220)
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            pass

    def _add_sub_from_input(self, url_input: EditText, category_input: EditText):
        raw = str(url_input.getText().toString()).strip()
        sub = _norm_sub(raw)
        if not sub:
            try:
                url_input.setBackground(self._bg_rounded("#33FF0000"))
            except Exception:
                pass
            return

        category = _norm_category(str(category_input.getText().toString()))
        entries = self._get_sub_entries()
        updated = False
        for it in entries:
            if str(it.get("sub") or "") == sub:
                it["category"] = category
                updated = True
                break
        if not updated:
            entries.append({"sub": sub, "category": category})
        self._set_sub_entries(entries)

        if self._overlay is not None:
            self._set_refreshing_ui(True)
        self._refresh_async()
        self._close_add_feed_screen(animated=True)

        if self._overlay is not None:
            self._mode = "subs"
            self._render()

    def _close_add_feed_screen(self, animated: bool):
        overlay = self._add_overlay
        content = self._add_content
        if overlay is None:
            return

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup):
                    parent.removeView(overlay)
            except Exception:
                pass
            self._add_overlay = None
            self._add_content = None
            self._add_back_listener = None

        if not animated or content is None:
            detach()
            return

        try:
            overlay.animate().alpha(0.0).setDuration(140).start()
            content.animate().translationY(float(_dp(16))).setDuration(160).start()
        except Exception:
            pass
        try:
            AndroidUtilities.runOnUIThread(Runnable(detach), 180)
        except Exception:
            run_on_ui_thread(detach)

    def _open_category_screen(self, sub_key: str):
        if self._cat_overlay is not None:
            return
        if not sub_key:
            return
        fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup):
            return

        target = None
        for it in self._get_sub_entries():
            if str(it.get("sub") or "") == sub_key:
                target = it
                break
        if target is None:
            return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        overlay.setBackgroundColor(_c("#FF0F0F12"))
        overlay.setClickable(True)
        overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = TextView(activity)
        back.setText("←")
        back.setTextSize(20)
        back.setTextColor(_c("#FFFFFFFF"))
        back.setPadding(_dp(6), _dp(6), _dp(12), _dp(6))
        back.setClickable(True)
        back.setOnClickListener(OnClickListener(lambda v: self._close_category_screen(animated=True)))
        top.addView(back)

        title = TextView(activity)
        title.setText("Категория подписки")
        title.setTextSize(20)
        title.setTextColor(_c("#FFFFFFFF"))
        top.addView(title, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        show = ("@" + sub_key.split(":", 1)[1]) if sub_key.startswith("tguser:") else sub_key
        source_tv = TextView(activity)
        source_tv.setText(show)
        source_tv.setTextSize(13)
        source_tv.setTextColor(_c("#FFFFFFFF"))
        source_tv.setAlpha(0.8)
        source_tv.setPadding(0, _dp(16), 0, _dp(10))
        content.addView(source_tv)

        category_input = EditText(activity)
        category_input.setHint("Любая категория")
        category_input.setSingleLine(True)
        category_input.setText(_norm_category(target.get("category", "")))
        category_input.setPadding(_dp(12), _dp(12), _dp(12), _dp(12))
        category_input.setTextColor(_c("#FFFFFFFF"))
        try:
            category_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception:
            pass
        category_input.setBackground(self._bg_rounded("#1AFFFFFF"))
        content.addView(category_input, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ))

        push = View(activity)
        push.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0))
        content.addView(push)

        save_btn = self._primary_button(activity, "Сохранить", lambda: self._save_sub_category(sub_key, category_input))
        content.addView(save_btn, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ))

        self._cat_overlay = overlay
        self._cat_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._close_category_screen(animated=True), "_cat_back_listener")

        try:
            overlay.setAlpha(0.0)
            content.setTranslationY(float(_dp(16)))
            overlay.animate().alpha(1.0).setDuration(160).start()
            anim = content.animate().translationY(0.0).setDuration(220)
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            pass

    def _save_sub_category(self, sub_key: str, category_input: EditText):
        cat = _norm_category(str(category_input.getText().toString()))
        entries = self._get_sub_entries()
        changed = False
        for it in entries:
            if str(it.get("sub") or "") == sub_key:
                it["category"] = cat
                changed = True
                break
        if not changed:
            return
        self._set_sub_entries(entries)
        self._close_category_screen(animated=True)
        if self._overlay is not None:
            self._render()
            self._set_refreshing_ui(True)
        self._refresh_async()

    def _close_category_screen(self, animated: bool):
        overlay = self._cat_overlay
        content = self._cat_content
        if overlay is None:
            return

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup):
                    parent.removeView(overlay)
            except Exception:
                pass
            self._cat_overlay = None
            self._cat_content = None
            self._cat_back_listener = None

        if not animated or content is None:
            detach()
            return

        try:
            overlay.animate().alpha(0.0).setDuration(140).start()
            content.animate().translationY(float(_dp(16))).setDuration(160).start()
        except Exception:
            pass
        try:
            AndroidUtilities.runOnUIThread(Runnable(detach), 180)
        except Exception:
            run_on_ui_thread(detach)

    # ---------- Post screen ----------
    def _open_post_screen(self, fragment, item: Dict[str, Any]):
        if self._post_overlay is not None:
            return
        if not fragment:
            fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup):
            return

        title_raw = item.get("title", "") or ""
        if not str(title_raw).strip():
            title_raw = item.get("voice", "") or item.get("doc", "") or ""
        link = item.get("link", "")
        src = _format_source_line(item)
        cat = _norm_category(item.get("category", ""))
        sort_ts = int(item.get("sort_ts", 0) or 0)
        body_raw = item.get("text", "") or ""
        images = _norm_images_list(item.get("images", []))
        if not images:
            one = _upgrade_image_url(item.get("image", ""))
            if one:
                images = [one]

        title = _strip_tags_and_format(title_raw)
        body = _strip_tags_and_format(body_raw)

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        overlay.setBackgroundColor(_c("#FF0F0F12"))
        overlay.setClickable(True)
        overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = TextView(activity)
        back.setText("←")
        back.setTextSize(20)
        back.setTextColor(_c("#FFFFFFFF"))
        back.setPadding(_dp(6), _dp(6), _dp(12), _dp(6))
        back.setClickable(True)
        back.setOnClickListener(OnClickListener(lambda v: self._close_post_screen(animated=True)))
        top.addView(back)

        t = TextView(activity)
        t.setText("Пост")
        t.setTextSize(20)
        t.setTextColor(_c("#FFFFFFFF"))
        top.addView(t, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        go_btn = self._top_button(activity, "Перейти", lambda: self._open_link(get_last_fragment(), link))
        top.addView(go_btn)

        sv = ScrollView(activity)
        sv.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        

        col = LinearLayout(activity)
        col.setOrientation(LinearLayout.VERTICAL)
        sv.addView(col)
        
        # ✅ если title пустой — не показываем
        if title:
            tv_title = TextView(activity)
            tv_title.setText(title)
            tv_title.setTextSize(22)
            tv_title.setTypeface(None, Typeface.BOLD)
            tv_title.setTextColor(_c("#FFFFFFFF"))
            tv_title.setPadding(0, _dp(10), 0, _dp(10))
            col.addView(tv_title)
        else:
            spacer = View(activity)
            spacer.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(8)))
            col.addView(spacer)

        meta = []
        if src:
            meta.append(src)
        if cat:
            meta.append(f"#{cat}")
        dt = _format_ru_datetime(sort_ts)
        if dt:
            meta.append(dt)
        meta_line = " • ".join(meta).strip()
        if meta_line:
            tv_meta = TextView(activity)
            tv_meta.setText(meta_line)
            tv_meta.setTextSize(12)
            tv_meta.setTextColor(_c("#FFFFFFFF"))
            tv_meta.setAlpha(0.65)
            tv_meta.setPadding(0, 0, 0, _dp(12))
            col.addView(tv_meta)

        reply_raw = str(item.get("reply", "") or "").strip()
        reply = _clean_reply_for_ui(reply_raw, item)
        if reply:
            src_line = _format_source_line(item)
            shown = f"{src_line}:\n↩ " + reply if src_line else f"↩ {reply}"

            chip = self._reply_bubble(activity, shown)  # ✅ создаём bubble

            lp = LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            )
            lp.bottomMargin = _dp(12)
            col.addView(chip, lp)

        for img_idx, img_url in enumerate(images):
            iv = ImageView(activity)
            iv.setVisibility(View.GONE)
            iv.setAdjustViewBounds(True)
            try:
                iv.setScaleType(ImageView.ScaleType.FIT_CENTER)
            except Exception:
                pass
            iv.setBackground(self._bg_rounded("#00000000"))
            self._apply_rounded_clip(iv)

            iv.setClickable(True)
            u = img_url
            iv.setOnClickListener(OnClickListener(lambda _v, uu=u: self._open_image_screen(get_last_fragment(), uu)))

            ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(520))
            ilp.bottomMargin = _dp(8 if img_idx < len(images) - 1 else 12)
            col.addView(iv, ilp)
            self._load_image_into(img_url, iv)

        if body:
            tv_body = TextView(activity)
            tv_body.setText(body)
            tv_body.setTextSize(15)
            tv_body.setTextColor(_c("#FFFFFFFF"))
            tv_body.setAlpha(0.88)
            tv_body.setPadding(0, 0, 0, _dp(16))
            col.addView(tv_body)

        bottom_go = self._primary_button(activity, "Перейти", lambda: self._open_link(get_last_fragment(), link))
        col.addView(bottom_go, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ))

        self._post_overlay = overlay
        self._post_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._close_post_screen(animated=True), "_post_back_listener")
        content.addView(sv)

        try:
            overlay.setAlpha(0.0)
            content.setTranslationY(float(_dp(16)))
            overlay.animate().alpha(1.0).setDuration(160).start()
            anim = content.animate().translationY(0.0).setDuration(220)
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            pass

    def _close_post_screen(self, animated: bool):
        overlay = self._post_overlay
        content = self._post_content
        if overlay is None:
            return

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup):
                    parent.removeView(overlay)
            except Exception:
                pass
            self._post_overlay = None
            self._post_content = None
            self._post_back_listener = None

        if not animated or content is None:
            detach()
            return

        try:
            overlay.animate().alpha(0.0).setDuration(140).start()
            content.animate().translationY(float(_dp(16))).setDuration(160).start()
        except Exception:
            pass
        try:
            AndroidUtilities.runOnUIThread(Runnable(detach), 180)
        except Exception:
            run_on_ui_thread(detach)

    # ---------- Image fullscreen screen ----------
    def _open_image_screen(self, fragment, url: str):
        if not url:
            return
        if self._img_overlay is not None:
            return
        if not fragment:
            fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup):
            return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        overlay.setBackgroundColor(_c("#FF0F0F12"))
        overlay.setClickable(True)
        overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = TextView(activity)
        back.setText("←")
        back.setTextSize(20)
        back.setTextColor(_c("#FFFFFFFF"))
        back.setPadding(_dp(6), _dp(6), _dp(12), _dp(6))
        back.setClickable(True)
        back.setOnClickListener(OnClickListener(lambda v: self._close_image_screen(animated=True)))
        top.addView(back)

        t = TextView(activity)
        t.setText("Изображение")
        t.setTextSize(20)
        t.setTextColor(_c("#FFFFFFFF"))
        top.addView(t, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        open_btn = self._top_button(activity, "Открыть", lambda: self._open_link(get_last_fragment(), url))
        top.addView(open_btn)

        sv = ScrollView(activity)
        sv.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        ))
        content.addView(sv)

        col = LinearLayout(activity)
        col.setOrientation(LinearLayout.VERTICAL)
        sv.addView(col)

        iv = ImageView(activity)
        iv.setVisibility(View.GONE)
        iv.setAdjustViewBounds(True)
        try:
            iv.setScaleType(ImageView.ScaleType.FIT_CENTER)
        except Exception:
            pass
        iv.setBackground(self._bg_rounded("#00000000"))
        self._apply_rounded_clip(iv)

        ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        ilp.topMargin = _dp(12)
        col.addView(iv, ilp)

        self._load_image_into(url, iv)

        self._img_overlay = overlay
        self._img_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._close_image_screen(animated=True), "_img_back_listener")

        try:
            overlay.setAlpha(0.0)
            content.setTranslationY(float(_dp(16)))
            overlay.animate().alpha(1.0).setDuration(160).start()
            anim = content.animate().translationY(0.0).setDuration(220)
            try:
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            pass

    def _close_image_screen(self, animated: bool):
        overlay = self._img_overlay
        content = self._img_content
        if overlay is None:
            return

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup):
                    parent.removeView(overlay)
            except Exception:
                pass
            self._img_overlay = None
            self._img_content = None
            self._img_back_listener = None

        if not animated or content is None:
            detach()
            return

        try:
            overlay.animate().alpha(0.0).setDuration(140).start()
            content.animate().translationY(float(_dp(16))).setDuration(160).start()
        except Exception:
            pass
        try:
            AndroidUtilities.runOnUIThread(Runnable(detach), 180)
        except Exception:
            run_on_ui_thread(detach)

    # ---------- image loading ----------
    def _load_image_into(self, url: str, iv: ImageView):
        url = _upgrade_image_url(url)
        if not url:
            return

        with self._img_cache_lock:
            bmp = self._img_cache.get(url)

        if bmp is not None:
            try:
                iv.setImageBitmap(bmp)
                iv.setVisibility(View.VISIBLE)
            except Exception:
                pass
            return

        def bg():
            try:
                req = urllib.request.Request(url, headers={"User-Agent": "Exteragram-RSS-Plugin/1.4.4"})
                with urllib.request.urlopen(req, timeout=14) as resp:
                    data = resp.read()
                bmp2 = None
                try:
                    if Bitmap is not None:
                        opts = BitmapFactory.Options()
                        opts.inPreferredConfig = Bitmap.Config.ARGB_8888
                        opts.inScaled = False
                        bmp2 = BitmapFactory.decodeByteArray(data, 0, len(data), opts)
                except Exception:
                    bmp2 = None
                if bmp2 is None:
                    bmp2 = BitmapFactory.decodeByteArray(data, 0, len(data))
                if bmp2 is None:
                    return

                with self._img_cache_lock:
                    if len(self._img_cache) > 80:
                        self._img_cache.clear()
                    self._img_cache[url] = bmp2

                def ui():
                    try:
                        iv.setImageBitmap(bmp2)
                        iv.setVisibility(View.VISIBLE)
                    except Exception:
                        pass
                run_on_ui_thread(ui)
            except Exception:
                pass

        threading.Thread(target=bg, daemon=True).start()

    # ---------- render ----------
    def _render(self):
        if not self._list_container:
            return
        ctx = self._list_container.getContext()
        self._update_source_button()
        self._update_bottom_nav_state()
        try:
            self._list_container.removeAllViews()
        except Exception:
            pass
        

        try:
            if self._mode == "subs":
                self._render_subs(ctx)
            elif self._mode == "settings":
                self._render_settings(ctx)
            elif self._mode == "cats":
                self._render_feed(ctx, by_category=True)
            else:
                self._render_feed(ctx, by_category=False)
        except Exception as e:
            log(f"[RSS] render error: {e}")
            t = TextView(ctx)
            t.setText("Ошибка отображения ленты (см. log).")
            t.setTextSize(14)
            t.setTextColor(_c("#FFFFFFFF"))
            t.setAlpha(0.75)
            self._list_container.addView(t)
        self._animate_list_once = False

    def _render_feed(self, ctx, by_category: bool = False):
        all_items = self._get_cache()
        log(f"[RSS] render_feed cache_items={len(all_items)} mode={self._mode} by_category={by_category}")

        if not all_items:
            t = TextView(ctx)
            t.setText("Лента пустая.\nОткрой «Подписки» и нажми «+», затем потяни ленту вниз для обновления.")
            t.setTextSize(14)
            t.setTextColor(_c("#FFFFFFFF"))
            t.setAlpha(0.75)
            self._list_container.addView(t)
            return

        items = all_items
        if by_category:
            if self._category_filter:
                filt = self._category_filter
                items = []
                for it in all_items:
                    if _norm_category(it.get("category", "")) == filt:
                        items.append(it)
        else:
            if self._source_filter:
                filt = self._source_filter
                items = []
                for it in all_items:
                    src_val = _format_source_line(it).strip()
                    if not src_val:
                        src_val = str(it.get("source", "") or "").strip()
                    if src_val == filt:
                        items.append(it)

        if not items:
            t = TextView(ctx)
            if by_category:
                t.setText("По выбранной категории пока ничего нет.\nНажми «Категория», чтобы выбрать другую или «все».")
            else:
                t.setText("По выбранному источнику пока ничего нет.\nНажми кнопку «Источник», чтобы переключить фильтр на «все».")
            t.setTextSize(14)
            t.setTextColor(_c("#FFFFFFFF"))
            t.setAlpha(0.75)
            self._list_container.addView(t)
            return

        if by_category:
            info = TextView(ctx)
            info.setText(
                f"Категории: {self._category_filter}" if self._category_filter
                else "Категории: все"
            )
            info.setTextSize(13)
            info.setTextColor(_c("#FFFFFFFF"))
            info.setAlpha(0.72)
            info.setPadding(0, 0, 0, _dp(10))
            self._list_container.addView(info)

        items.sort(key=lambda x: int(x.get("sort_ts", x.get("ts", 0) or 0) or 0), reverse=True)
        try:
            self._feed_item_touch_listener = _OnTouchListener(lambda _v, ev: self._handle_item_swipe_touch(ev))
        except Exception:
            self._feed_item_touch_listener = None

        for idx, it in enumerate(items[:320]):
            title = _strip_tags_and_format(str(it.get("title", "") or ""))
            if not title:
                title = _strip_tags_and_format(str(it.get("voice", "") or ""))[:120]
            if not title:
                title = _strip_tags_and_format(str(it.get("doc", "") or ""))[:120]
            src = _format_source_line(it)
            cat = _norm_category(it.get("category", ""))
            sort_ts = int(it.get("sort_ts", 0) or 0)
            images = _norm_images_list(it.get("images", []))
            if not images:
                one = _upgrade_image_url(it.get("image", ""))
                if one:
                    images = [one]
            img = images[0] if images else ""
            text = str(it.get("text", "") or "")
            important = ("(!)" in title) or ("(!)" in text)
            veryimportant = ("(!!)" in title) or ("(!!)" in text)

            block = LinearLayout(ctx)
            block.setOrientation(LinearLayout.VERTICAL)
            block.setPadding(_dp(10), _dp(10), _dp(10), _dp(10))
            block.setClickable(True)
            block.setOnClickListener(OnClickListener(lambda _v, item=it: self._open_post_screen(get_last_fragment(), item)))
            try:
                if self._feed_item_touch_listener is not None:
                    block.setOnTouchListener(self._feed_item_touch_listener)
            except Exception:
                pass

            if important or veryimportant:
                block.setBackground(self._bg_important_gradient())
            else:
                block.setBackground(self._bg_rounded("#141AFFFFFF"))
            lp_block = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp_block.bottomMargin = _dp(10)
            self._list_container.addView(block, lp_block)
            if self._animate_list_once and idx < 12:
                self._animate_entry(block, idx)

            # ✅ если title пустой — не показываем его вообще
            if title:
                tv_title = TextView(ctx)
                tv_title.setText(title)
                tv_title.setTextSize(32 if veryimportant else (22 if important else 16))
                tv_title.setTextColor(_c("#FFFF0000" if veryimportant else ("#FFFFFFFF" if important else "#EFEFEFEF")))
                tv_title.setTypeface(None, Typeface.BOLD)
                tv_title.invalidate()
                tv_title.setAlpha(0.98)
                tv_title.setPadding(0, 0, 0, _dp(6))
                block.addView(tv_title)

            meta = []
            if src:
                meta.append(src)
            if cat:
                meta.append(f"#{cat}")
            dt = _format_ru_datetime(sort_ts)
            if dt:
                meta.append(dt)
            meta_line = " • ".join(meta).strip()
            if meta_line:
                tv_meta = TextView(ctx)
                tv_meta.setText(meta_line)
                tv_meta.setTextSize(12)
                tv_meta.setTextColor(_c("#FFFFFFFF"))
                tv_meta.setAlpha(0.65)
                tv_meta.setPadding(0, 0, 0, _dp(10))
                block.addView(tv_meta)

            reply_raw = str(it.get("reply", "") or "").strip()
            reply_text = _clean_reply_for_ui(reply_raw, it)  # теперь это почти no-op, но ок
            if reply_text:
                src_line = _format_source_line(it)
                shown = f"{src_line}:\n↩ " + reply_text if src_line else f"↩ {reply_text}"

                bubble = self._reply_bubble(ctx, shown)
                lp = LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT
                )
                lp.bottomMargin = _dp(8)
                block.addView(bubble, lp)

            prev = _preview_text(text, 170, title)
            if prev:
                tv_prev = TextView(ctx)
                tv_prev.setText(prev)
                tv_prev.setTextSize(13)
                tv_prev.setTextColor(_c("#FFFFFFFF"))
                tv_prev.setAlpha(0.78)
                tv_prev.setPadding(0, 0, 0, _dp(10))
                block.addView(tv_prev)

            if img:
                iv = ImageView(ctx)
                iv.setVisibility(View.GONE)
                iv.setAdjustViewBounds(True)
                try:
                    iv.setScaleType(ImageView.ScaleType.CENTER_CROP)
                except Exception:
                    pass

                iv.setBackground(self._bg_rounded("#00000000"))
                self._apply_rounded_clip(iv)

                ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(250))
                ilp.bottomMargin = _dp(2)
                block.addView(iv, ilp)

                self._load_image_into(img, iv)
                if len(images) > 1:
                    tv_more = TextView(ctx)
                    tv_more.setText(f"Ещё изображений: {len(images) - 1}")
                    tv_more.setTextSize(11)
                    tv_more.setTextColor(_c("#FFFFFFFF"))
                    tv_more.setAlpha(0.62)
                    tv_more.setPadding(0, _dp(4), 0, 0)
                    block.addView(tv_more)

    def _render_settings(self, ctx):
        h = TextView(ctx)
        h.setText("Настройки")
        h.setTextSize(18)
        h.setTypeface(None, Typeface.BOLD)
        h.setTextColor(_c("#FFFFFFFF"))
        h.setPadding(0, _dp(6), 0, _dp(10))
        self._list_container.addView(h)

        hint = TextView(ctx)
        hint.setText("Масштаб интерфейса (DPI)")
        hint.setTextSize(13)
        hint.setTextColor(_c("#FFFFFFFF"))
        hint.setAlpha(0.75)
        hint.setPadding(0, 0, 0, _dp(10))
        self._list_container.addView(hint)

        card = LinearLayout(ctx)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(_dp(12), _dp(12), _dp(12), _dp(12))
        card.setBackground(self._bg_rounded("#1E1AFFFFFF", "#24FFFFFF", 0.0))
        lp_card = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_card.bottomMargin = _dp(12)
        self._list_container.addView(card, lp_card)

        val_tv = TextView(ctx)
        val_tv.setText(f"Текущий масштаб: {self._ui_scale_percent()}%")
        val_tv.setTextSize(14)
        val_tv.setTextColor(_c("#FFFFFFFF"))
        val_tv.setTypeface(None, Typeface.BOLD)
        val_tv.setPadding(0, 0, 0, _dp(8))
        card.addView(val_tv)

        sb = SeekBar(ctx)
        max_progress = max(1, self._ui_scale_to_progress(_UI_SCALE_MAX))
        cur_progress = self._ui_scale_to_progress(self._ui_scale)
        try:
            sb.setMax(max_progress)
            sb.setProgress(max(0, min(max_progress, cur_progress)))
        except Exception:
            pass
        card.addView(sb, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ))

        scale_range = TextView(ctx)
        scale_range.setText(f"Диапазон: {int(_UI_SCALE_MIN * 100)}% - {int(_UI_SCALE_MAX * 100)}%")
        scale_range.setTextSize(12)
        scale_range.setTextColor(_c("#FFFFFFFF"))
        scale_range.setAlpha(0.62)
        scale_range.setPadding(0, _dp(6), 0, 0)
        card.addView(scale_range)

        def on_progress(_sb, progress, from_user):
            try:
                if not from_user:
                    return
                val = self._progress_to_ui_scale(int(progress))
                val_tv.setText(f"Текущий масштаб: {int(round(val * 100))}%")
            except Exception:
                pass

        def on_stop(_sb):
            try:
                val = self._progress_to_ui_scale(int(_sb.getProgress() or 0))
                self._apply_ui_scale_and_reopen(val)
            except Exception:
                pass

        try:
            self._ui_seek_listener = _OnSeekBarChangeListener(on_progress, None, on_stop)
            sb.setOnSeekBarChangeListener(self._ui_seek_listener)
        except Exception as e:
            log(f"[RSS] settings seekbar bind error: {e}")

        reset_btn = self._primary_button(ctx, "Сбросить: 100%", lambda: self._apply_ui_scale_and_reopen(1.0))
        self._list_container.addView(reset_btn, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ))

    def _render_subs(self, ctx):
        entries = self._get_sub_entries()

        h = TextView(ctx)
        h.setText("Подписки")
        h.setTextSize(18)
        h.setTextColor(_c("#FFFFFFFF"))
        h.setPadding(0, _dp(6), 0, _dp(12))
        self._list_container.addView(h)

        if not entries:
            t = TextView(ctx)
            t.setText("Подписок нет.\nНажми «+» и вставь RSS или @username.")
            t.setTextSize(14)
            t.setTextColor(_c("#FFFFFFFF"))
            t.setAlpha(0.75)
            self._list_container.addView(t)
        else:
            for idx, it in enumerate(entries):
                sub = str(it.get("sub") or "")
                cat = _norm_category(it.get("category", ""))
                row = LinearLayout(ctx)
                row.setOrientation(LinearLayout.HORIZONTAL)
                row.setGravity(Gravity.CENTER_VERTICAL)
                row.setPadding(0, _dp(10), 0, _dp(10))
                self._list_container.addView(row)
                row.setBackground(self._bg_rounded("#201AFFFFFF"))  # было #141AFFFFFF
                if self._animate_list_once and idx < 12:
                    self._animate_entry(row, idx)

                show = ("@" + sub.split(":", 1)[1]) if sub.startswith("tguser:") else sub

                txt_col = LinearLayout(ctx)
                txt_col.setOrientation(LinearLayout.VERTICAL)
                row.addView(txt_col, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

                tv = TextView(ctx)
                tv.setText(show)
                tv.setTextSize(14)
                tv.setTextColor(_c("#FFFFFFFF"))
                tv.setAlpha(0.92)
                txt_col.addView(tv)

                if cat:
                    tv_cat = TextView(ctx)
                    tv_cat.setText(f"Категория: {cat}")
                    tv_cat.setTextSize(12)
                    tv_cat.setTextColor(_c("#FFFFFFFF"))
                    tv_cat.setAlpha(0.62)
                    tv_cat.setPadding(0, _dp(3), 0, 0)
                    txt_col.addView(tv_cat)

                cat_btn = self._top_button(ctx, "Кат.", lambda key=sub: self._open_category_screen(key))
                delb = self._top_button(ctx, "—", lambda key=sub: self._remove_sub(key))
                row.addView(cat_btn)
                row.addView(self._spacer_h(ctx, 8))
                row.addView(delb)

                div = View(ctx)
                div.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(1)))
                div.setBackgroundColor(_c("#22FFFFFF", "#22000000"))
                self._list_container.addView(div)

        plus_btn = self._primary_button(ctx, "+", lambda: self._open_add_feed_screen(get_last_fragment()))
        lp_plus = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_plus.topMargin = _dp(14)
        lp_plus.bottomMargin = _dp(4)
        self._list_container.addView(plus_btn, lp_plus)
        if self._animate_list_once:
            self._animate_entry(plus_btn, 2)

    def _remove_sub(self, sub_key: str):
        if not sub_key:
            return
        entries = [x for x in self._get_sub_entries() if str(x.get("sub") or "") != sub_key]
        self._set_sub_entries(entries)
        self._render()
        if self._overlay is not None:
            self._set_refreshing_ui(True)
        self._refresh_async()

    # ---------- open link ----------
    def _open_link(self, fragment, link: str):
        if not link:
            return
        if not fragment:
            fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return
        try:
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(link))
            activity.startActivity(intent)
        except Exception as e:
            log(f"[RSS] open link error: {e}")
