__id__ = "shazam_by_audio_pg"
__name__ = "Shazam (Ð¿Ð¾ Ð°ÑƒÐ´Ð¸Ð¾)"
__description__ = "ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÑ‚ Ð¼ÑƒÐ·Ñ‹ÐºÑƒ Ð¿Ð¾ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ñƒ Ð¸Ð»Ð¸ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð¾Ð¼Ñƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑŽ (.shazam Ð² Ð¾Ñ‚Ð²ÐµÑ‚). Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð² Ð´Ð¸Ð°Ð»Ð¾Ð³Ðµ Ñ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹ Ð¸ ÑÑÑ‹Ð»ÐºÐ°Ð¼Ð¸. Ð¢Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒ Ð·Ð°Ð²Ð¸ÑÐ¸Ñ‚ Ð¾Ñ‚ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð° Ð°ÑƒÐ´Ð¸Ð¾ (Ð´Ð»Ñ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð½Ð¸Ð¶Ðµ)."
__version__ = "1.0.9"
__author__ = "@galaxy_conqueror"
__min_version__ = "11.12.0"

import os
import uuid
import time
import threading
import traceback
import json
import requests
import shutil
from typing import Any, Optional
from java.io import File

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import send_message, get_last_fragment, run_on_queue
from android_utils import log, run_on_ui_thread
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Input, Divider, Text
from org.telegram.messenger import ApplicationLoader, MessageObject, FileLoader, UserConfig, AndroidUtilities, R as R_tg
from org.telegram.tgnet import TLRPC
from android.graphics import Color

class ShazamPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.pg_temp_dir = None
        self.pg_processing = False
        self.pg_loading_dialog: Optional[AlertDialogBuilder] = None
        self.last_shazam_request_time = 0 # Ð”Ð»Ñ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ñ‹ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²
        self.shazam_cooldown_seconds = 10 # Ð’Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¼ÐµÐ¶Ð´Ñƒ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°Ð¼Ð¸ Ð² ÑÐµÐºÑƒÐ½Ð´Ð°Ñ…

    def on_plugin_load(self):
        self.pg_temp_dir = self._prepare_temp_dir()
        if not self.pg_temp_dir:
            run_on_ui_thread(lambda: BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ Ð´Ð»Ñ Shazam Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°."))
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ°: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ.")
            return

        self.add_on_send_message_hook()
        log(f"[{__id__}] ÐŸÐ»Ð°Ð³Ð¸Ð½ 'Shazam (Ð¿Ð¾ Ð°ÑƒÐ´Ð¸Ð¾)' Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½.")
        self._cleanup_old_files()

    def on_plugin_unload(self):
        if self.pg_temp_dir and self.pg_temp_dir.exists():
            try:
                for file_obj in self.pg_temp_dir.listFiles():
                    if file_obj.isFile():
                        file_obj.delete()
                log(f"[{__id__}] Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ ÑƒÐ´Ð°Ð»ÐµÐ½Ñ‹ Ð¸Ð· {self.pg_temp_dir.getAbsolutePath()}.")
            except Exception as e:
                log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸: {e}")
        self._dismiss_loading_dialog()
        log(f"[{__id__}] ÐŸÐ»Ð°Ð³Ð¸Ð½ 'Shazam (Ð¿Ð¾ Ð°ÑƒÐ´Ð¸Ð¾)' Ð²Ñ‹Ð³Ñ€ÑƒÐ¶ÐµÐ½.")

    def create_settings(self):
        return [
            Header(text="ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Shazam"),
            Input(
                key="shazam_command",
                text="ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° Ð°ÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ð¸",
                default=".shazam",
                subtext="ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ ÑÑ‚Ñƒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ Ð² Ð¾Ñ‚Ð²ÐµÑ‚ Ð½Ð° Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð».",
                icon="input_bot1_solar"
            ),
            Input(
                key="auddio_api_token",
                text="Audd.io API Ð¢Ð¾ÐºÐµÐ½",
                default="",
                subtext="ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ Ð½Ð° https://audd.io/develop. ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÐµÐ½ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹!",
                icon="menu_feature_code_solar"
            ),
            Divider(text="ÐšÐ°Ðº Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒÑÑ:"),
            Text(text="1. ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ API-Ñ‚Ð¾ÐºÐµÐ½ Ð½Ð° Audd.io (https://audd.io/develop)."),
            Text(text="2. Ð’ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ ÐµÐ³Ð¾ Ð² Ð¿Ð¾Ð»Ðµ Ð²Ñ‹ÑˆÐµ."),
            Text(text="3. Ð’ Ñ‡Ð°Ñ‚Ðµ Ð¾Ñ‚Ð²ÐµÑ‚ÑŒÑ‚Ðµ Ð½Ð° Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð¸Ð»Ð¸ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹, ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ Ð² 'ÐšÐ¾Ð¼Ð°Ð½Ð´Ðµ Ð°ÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ð¸' (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ .shazam)."),
            Divider(text="Ð’Ð°Ð¶Ð½Ð¾: ÐŸÐ»Ð°Ð³Ð¸Ð½ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÑ‚ÑŒ Ð¼ÑƒÐ·Ñ‹ÐºÑƒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ð°Ð¼. ÐÐµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ð·Ð°Ð¿Ð¸ÑÑŒ Ñ Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ð°. Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð±ÑƒÐ´ÐµÑ‚ Ð¿Ð¾ÐºÐ°Ð·Ð°Ð½ Ð² Ð²ÑÐ¿Ð»Ñ‹Ð²Ð°ÑŽÑ‰ÐµÐ¼ Ð¾ÐºÐ½Ðµ Ñ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹. Ð¢Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð·Ð°Ð²Ð¸ÑÐ¸Ñ‚ Ð¾Ñ‚ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð° Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð°ÑƒÐ´Ð¸Ð¾. Ð”Ð»Ñ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð½Ð¸Ð¶Ðµ.")
        ]

    def _prepare_temp_dir(self) -> Optional[File]:
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, "ShazamAudioTemp")
            if not temp_dir.exists():
                if not temp_dir.mkdirs():
                    log(f"[{__id__}] ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ: {temp_dir.getAbsolutePath()}")
                    return None
            return temp_dir
        except Exception as e:
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸: {e}\n{traceback.format_exc()}")
            return None

    def _cleanup_old_files(self, max_age_hours=1):
        if not self.pg_temp_dir:
            return
        try:
            now = time.time()
            max_age_seconds = max_age_hours * 3600
            for file_obj in self.pg_temp_dir.listFiles():
                if file_obj.isFile() and now - (file_obj.lastModified() / 1000) > max_age_seconds:
                    file_obj.delete()
                    log(f"[{__id__}] Ð£Ð´Ð°Ð»ÐµÐ½ ÑÑ‚Ð°Ñ€Ñ‹Ð¹ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»: {file_obj.getName()}")
        except Exception as e:
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐµ ÑÑ‚Ð°Ñ€Ñ‹Ñ… Ñ„Ð°Ð¹Ð»Ð¾Ð²: {e}\n{traceback.format_exc()}")

    def _download_audio_sync(self, message_obj: MessageObject, document_to_download: TLRPC.Document) -> Optional[str]:
        """
        Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÑ‚ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð¸Ð· MessageObject Ð²Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°.
        ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð¸ Ð²Ð°Ð»Ð¸Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ TLRPC.Document.
        Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¿ÑƒÑ‚ÑŒ Ðº Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ð¾Ð¼Ñƒ Ñ„Ð°Ð¹Ð»Ñƒ Ð¸Ð»Ð¸ None Ð² ÑÐ»ÑƒÑ‡Ð°Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸.
        """
        if not self.pg_temp_dir:
            log(f"[{__id__}] _download_audio_sync: Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ñ Ð½Ðµ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°.")
            return None

        try:
            mime_type = getattr(document_to_download, 'mime_type', 'audio/ogg')
            file_extension = ".ogg"
            if "mp3" in mime_type: file_extension = ".mp3"
            elif "wav" in mime_type: file_extension = ".wav"
            elif "flac" in mime_type: file_extension = ".flac"
            elif "m4a" in mime_type: file_extension = ".m4a"
            elif "opus" in mime_type: file_extension = ".ogg" # Voice messages often use opus codec in ogg container

            final_temp_file_path_str = File(self.pg_temp_dir, f"audio_{uuid.uuid4().hex}{file_extension}").getAbsolutePath()
            
            file_loader = FileLoader.getInstance(UserConfig.selectedAccount)
            
            # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¿ÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ Ð² ÐºÑÑˆÐµ Telegram Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ MessageOwner
            telegram_cache_file_path_obj = file_loader.getPathToMessage(message_obj.messageOwner)
            telegram_cache_file_path_str = telegram_cache_file_path_obj.getAbsolutePath() if telegram_cache_file_path_obj else None

            downloaded_telegram_cache_path = None

            # 1. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ Ñ„Ð°Ð¹Ð» ÑƒÐ¶Ðµ Ð² ÐºÑÑˆÐµ Telegram
            if telegram_cache_file_path_str and os.path.exists(telegram_cache_file_path_str) and os.path.getsize(telegram_cache_file_path_str) > 0:
                downloaded_telegram_cache_path = telegram_cache_file_path_str
                log(f"[{__id__}] ÐÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» ÑƒÐ¶Ðµ Ð² ÐºÑÑˆÐµ Telegram: {telegram_cache_file_path_str}")
            else:
                # 2. Ð•ÑÐ»Ð¸ Ñ„Ð°Ð¹Ð»Ð° Ð½ÐµÑ‚ Ð² ÐºÑÑˆÐµ, Ð¸Ð½Ð¸Ñ†Ð¸Ð¸Ñ€ÑƒÐµÐ¼ ÐµÐ³Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ Ð² ÐºÑÑˆ Telegram
                # FileLoader.loadFile Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ TLRPC.Document Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°.
                file_loader.loadFile(document_to_download, message_obj, mime_type.split('/')[0], FileLoader.PRIORITY_HIGH, 0)
                
                pg_timeout = 60 # Ð–Ð´ÐµÐ¼ Ð´Ð¾ 60 ÑÐµÐºÑƒÐ½Ð´ Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð² ÐºÑÑˆ Telegram
                for _pg_iterator_index in range(pg_timeout):
                    if telegram_cache_file_path_str and os.path.exists(telegram_cache_file_path_str) and os.path.getsize(telegram_cache_file_path_str) > 0:
                        downloaded_telegram_cache_path = telegram_cache_file_path_str
                        log(f"[{__id__}] ÐÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½ Ð² ÐºÑÑˆ Telegram Ð¿Ð¾ÑÐ»Ðµ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ: {telegram_cache_file_path_str}")
                        break
                    time.sleep(1) # Ð–Ð´ÐµÐ¼ 1 ÑÐµÐºÑƒÐ½Ð´Ñƒ
            
            if not downloaded_telegram_cache_path:
                log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ°: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð² ÐºÑÑˆ Telegram Ð¿Ð¾ÑÐ»Ðµ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ.")
                return None

            # 3. ÐšÐ¾Ð¿Ð¸Ñ€ÑƒÐµÐ¼ Ñ„Ð°Ð¹Ð» Ð¸Ð· ÐºÑÑˆÐ° Telegram Ð² Ð½Ð°ÑˆÑƒ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ
            shutil.copyfile(downloaded_telegram_cache_path, final_temp_file_path_str)
            log(f"[{__id__}] ÐÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð¸Ð· ÐºÑÑˆÐ° Telegram Ð²Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°: {final_temp_file_path_str}")
            return final_temp_file_path_str

        except Exception as e:
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐµ/ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ð¸ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ð°: {e}\n{traceback.format_exc()}")
            return None

    def _identify_music(self, audio_path: str) -> Optional[dict]:
        api_token = self.get_setting("auddio_api_token", "").strip()
        if not api_token:
            run_on_ui_thread(lambda: BulletinHelper.show_error("ÐžÑˆÐ¸Ð±ÐºÐ°: Audd.io API Ð¢Ð¾ÐºÐµÐ½ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ… Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°."))
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ°: Audd.io API Ð¢Ð¾ÐºÐµÐ½ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚.")
            return None

        url = "https://api.audd.io/"
        params = {
            "api_token": api_token,
            "return": "lyrics,artist,title,album,label,song_link,release_date,genres,spotify,youtube,deezer,apple_music"
        }

        try:
            with open(audio_path, 'rb') as f:
                content_type = 'audio/mpeg' if '.mp3' in audio_path.lower() else 'audio/ogg'
                files = {'file': (os.path.basename(audio_path), f, content_type)}
                response = requests.post(url, data=params, files=files, timeout=30)
            response.raise_for_status()

            result = response.json()
            if result.get("status") == "success" and result.get("result"):
                return result["result"]
            else:
                error_message = result.get("error", {}).get("error_message", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Audd.io.")
                log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚ Audd.io: {error_message} (ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚: {result})")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¼ÑƒÐ·Ñ‹ÐºÑƒ: {error_message}"))
                return None
        except requests.exceptions.Timeout:
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ°: Ð’Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ðº Audd.io Ð¸ÑÑ‚ÐµÐºÐ»Ð¾.")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ð’Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ðº Audd.io Ð¸ÑÑ‚ÐµÐºÐ»Ð¾."))
            return None
        except requests.exceptions.RequestException as e:
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ðº Audd.io: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ‚Ð¸ Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ Ðº Audd.io: {e}"))
            return None
        except json.JSONDecodeError as e:
            log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð° JSON Ð¾Ñ‚ Audd.io: {e}\nÐžÑ‚Ð²ÐµÑ‚: {response.text}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ Audd.io: {e}"))
            return None
        except Exception as e:
            log(f"[{__id__}] ÐÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸ Ð¼ÑƒÐ·Ñ‹ÐºÐ¸: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"ÐÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: {e}"))
            return None

    def _show_loading_dialog(self):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None

        if not activity:
            log(f"[{__id__}] ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð´Ð»Ñ AlertDialog Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸.")
            return

        def _action():
            try:
                builder = AlertDialogBuilder(activity)
                builder.set_title("ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¼ÑƒÐ·Ñ‹ÐºÐ¸...")
                builder.set_top_animation(R_tg.raw.dots_loading, AndroidUtilities.dp(60), True, Color.TRANSPARENT, None)
                builder.set_cancelable(False)
                builder.set_canceled_on_touch_outside(False)
                self.pg_loading_dialog = builder.show()
            except Exception as e:
                log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð¸Ð»Ð¸ Ð¿Ð¾ÐºÐ°Ð·Ðµ AlertDialog Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸: {e}\n{traceback.format_exc()}")
                BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° UI Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸: {e}")

        run_on_ui_thread(_action)

    def _dismiss_loading_dialog(self):
        def _action():
            if self.pg_loading_dialog:
                try:
                    self.pg_loading_dialog.dismiss() 
                except Exception as e:
                    log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐºÑ€Ñ‹Ñ‚Ð¸Ð¸ AlertDialog Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸: {e}")
                finally:
                    self.pg_loading_dialog = None
        run_on_ui_thread(_action)

    def _show_result_dialog(self, title: str, message: str, copy_text: Optional[str] = None):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None

        if not activity:
            log(f"[{__id__}] ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð´Ð»Ñ AlertDialog.")
            run_on_ui_thread(lambda: BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð·Ð¸Ñ‚ÑŒ Ð´Ð¸Ð°Ð»Ð¾Ð³ (Ð½ÐµÑ‚ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°)."))
            return

        def _action():
            try:
                builder = AlertDialogBuilder(activity)
                builder.set_title(title)
                builder.set_message(message)
                
                builder.set_top_animation(R_tg.raw.sound_on, AndroidUtilities.dp(40), False, Color.TRANSPARENT, None)
                
                if copy_text:
                    def copy_action(bld, which):
                        if AndroidUtilities.addToClipboard(copy_text):
                            BulletinHelper.show_copied_to_clipboard()
                        bld.dismiss()
                    builder.set_positive_button("ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", copy_action)
                    builder.set_negative_button("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ", lambda bld, which: bld.dismiss())
                else:
                    builder.set_positive_button("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ", lambda bld, which: bld.dismiss())

                builder.set_cancelable(True)
                builder.set_canceled_on_touch_outside(True)
                builder.show()
            except Exception as e:
                log(f"[{__id__}] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð¸Ð»Ð¸ Ð¿Ð¾ÐºÐ°Ð·Ðµ AlertDialog: {e}\n{traceback.format_exc()}")
                BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° UI: {e}")

        run_on_ui_thread(_action)

    def _process_shazam_request(self, original_params: Any, reply_msg: MessageObject, document_to_process: TLRPC.Document):
        """
        ÐžÑÐ½Ð¾Ð²Ð½Ð°Ñ Ð»Ð¾Ð³Ð¸ÐºÐ° Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð¼ÑƒÐ·Ñ‹ÐºÐ¸, Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ Ð² Ñ„Ð¾Ð½Ð¾Ð²Ð¾Ð¼ Ð¿Ð¾Ñ‚Ð¾ÐºÐµ.
        ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð¸ Ð²Ð°Ð»Ð¸Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ TLRPC.Document.
        """
        if self.pg_processing:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ð£Ð¶Ðµ Ð¸Ð´ÐµÑ‚ Ð¿Ñ€Ð¾Ñ†ÐµÑÑ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð¼ÑƒÐ·Ñ‹ÐºÐ¸. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ."))
            return

        self.pg_processing = True
        audio_path = None
        
        self._show_loading_dialog()
        
        try:
            # ÐŸÐµÑ€ÐµÐ´Ð°ÐµÐ¼ reply_msg Ð¸ document_to_process Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸
            audio_path = self._download_audio_sync(reply_msg, document_to_process)
            if not audio_path:
                self._show_result_dialog("ÐžÑˆÐ¸Ð±ÐºÐ°", "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð´Ð»Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ.")
                return

            result = self._identify_music(audio_path)
            
            if result:
                title = result.get("title", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾")
                artist = result.get("artist", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾")
                album = result.get("album", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾")
                label = result.get("label", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾")
                release_date = result.get("release_date")
                genres = result.get("genres")
                
                song_link = result.get("song_link")
                spotify_link = result.get("spotify", {}).get("link")
                youtube_link = result.get("youtube", {}).get("link")
                apple_music_link = result.get("apple_music", {}).get("link")
                deezer_link = result.get("deezer", {}).get("link")

                output_message_parts = [
                    f"ðŸŽ¤ *Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ:* {artist}",
                    f"ðŸŽµ *ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ:* {title}",
                    f"ðŸ’¿ *ÐÐ»ÑŒÐ±Ð¾Ð¼:* {album}",
                    f"ðŸ·ï¸ *Ð›ÐµÐ¹Ð±Ð»:* {label}"
                ]
                
                if release_date:
                    year = release_date.split('-')[0] if '-' in release_date else release_date
                    output_message_parts.append(f"ðŸ—“ï¸ *Ð“Ð¾Ð´ Ð²Ñ‹Ð¿ÑƒÑÐºÐ°:* {year}")
                
                genre_names = []
                if genres:
                    genre_names = [g.get("name", "") for g in genres if g.get("name")]
                    if genre_names:
                        output_message_parts.append(f"ðŸŽ¶ *Ð–Ð°Ð½Ñ€(Ñ‹):* {', '.join(genre_names)}")
                
                output_message_links = []
                if song_link:
                    output_message_links.append(f"ðŸ”— [Audd.io]({song_link})")
                if spotify_link:
                    output_message_links.append(f"ðŸ”— [Spotify]({spotify_link})")
                if youtube_link:
                    output_message_links.append(f"ðŸ”— [YouTube]({youtube_link})")
                
                output_message = "\n".join(output_message_parts)
                if output_message_links:
                    output_message += "\n\n*Ð¡ÑÑ‹Ð»ÐºÐ¸:*\n" + "\n".join(output_message_links)

                copy_content_parts = [
                    f"Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ: {artist}",
                    f"ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ: {title}",
                    f"ÐÐ»ÑŒÐ±Ð¾Ð¼: {album}",
                    f"Ð›ÐµÐ¹Ð±Ð»: {label}"
                ]
                if release_date:
                    copy_content_parts.append(f"Ð“Ð¾Ð´ Ð²Ñ‹Ð¿ÑƒÑÐºÐ°: {year}")
                if genre_names:
                    copy_content_parts.append(f"Ð–Ð°Ð½Ñ€(Ñ‹): {', '.join(genre_names)}")
                
                copy_content_links = []
                if song_link: copy_content_links.append(f"Audd.io: {song_link}")
                if spotify_link: copy_content_links.append(f"Spotify: {spotify_link}")
                if youtube_link: copy_content_links.append(f"YouTube: {youtube_link}")
                if apple_music_link: copy_content_links.append(f"Apple Music: {apple_music_link}")
                if deezer_link: copy_content_links.append(f"Deezer: {deezer_link}")

                if copy_content_links:
                    copy_content = "\n".join(copy_content_parts) + "\n\nÐ¡ÑÑ‹Ð»ÐºÐ¸:\n" + "\n".join(copy_content_links)
                else:
                    copy_content = "\n".join(copy_content_parts)

                self._show_result_dialog("ÐœÑƒÐ·Ñ‹ÐºÐ° Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð°!", output_message, copy_content)
                run_on_ui_thread(lambda: BulletinHelper.show_success("ÐœÑƒÐ·Ñ‹ÐºÐ° ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð°!", get_last_fragment()))
            else:
                self._show_result_dialog("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¼ÑƒÐ·Ñ‹ÐºÑƒ", "ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð· Ñ Ð±Ð¾Ð»ÐµÐµ Ñ‡Ð¸ÑÑ‚Ñ‹Ð¼ Ð°ÑƒÐ´Ð¸Ð¾.")

        except Exception as e:
            error_details = traceback.format_exc()
            log(f"[{__id__}] ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð² _process_shazam_request: {e}\n{error_details}")
            self._show_result_dialog("ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°", f"ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð½ÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: {e}\n\nÐŸÐ¾Ð´Ñ€Ð¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð² Ð»Ð¾Ð³Ð°Ñ….")
        finally:
            self._dismiss_loading_dialog()
            if audio_path and os.path.exists(audio_path):
                run_on_queue(lambda: os.remove(audio_path), delay=500)
                log(f"[{__id__}] Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» ÑƒÐ´Ð°Ð»ÐµÐ½: {audio_path}")
            self.pg_processing = False

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        command_prefix = self.get_setting("shazam_command", ".shazam").strip()
        if not params.message.lower().startswith(command_prefix):
            return HookResult()
        
        current_time = time.time()
        if current_time - self.last_shazam_request_time < self.shazam_cooldown_seconds:
            remaining_time = int(self.shazam_cooldown_seconds - (current_time - self.last_shazam_request_time))
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"ÐŸÐ¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ {remaining_time} ÑÐµÐº. Ð¿ÐµÑ€ÐµÐ´ Ð½Ð¾Ð²Ñ‹Ð¼ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð¼ Shazam.", get_last_fragment()))
            return HookResult(strategy=HookStrategy.CANCEL)

        if not hasattr(params, "replyToMsg") or not params.replyToMsg:
            run_on_ui_thread(lambda: BulletinHelper.show_error("ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¾Ñ‚Ð²ÐµÑ‚ÑŒÑ‚Ðµ Ð½Ð° Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð¸Ð»Ð¸ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ .shazam", get_last_fragment()))
            return HookResult(strategy=HookStrategy.CANCEL)

        reply_msg = params.replyToMsg
        
        document_to_process = MessageObject.getDocument(reply_msg)

        if not document_to_process:
            run_on_ui_thread(lambda: BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¼ÐµÐ´Ð¸Ð°-Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· Ð¾Ñ‚Ð²ÐµÑ‚Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ. Ð£Ð±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ ÑÑ‚Ð¾ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð» Ð¸Ð»Ð¸ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ.", get_last_fragment()))
            return HookResult(strategy=HookStrategy.CANCEL)

        if not hasattr(document_to_process, 'mime_type') or not document_to_process.mime_type.startswith("audio"):
            run_on_ui_thread(lambda: BulletinHelper.show_error("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±Ñ‹Ñ‚ÑŒ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ð¾Ð¼ Ð¸Ð»Ð¸ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ñ‹Ð¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÐµÐ¼.", get_last_fragment()))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        self.last_shazam_request_time = current_time

        threading.Thread(target=self._process_shazam_request, args=(params, reply_msg, document_to_process), daemon=True).start()
        
        return HookResult(strategy=HookStrategy.CANCEL)