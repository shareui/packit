import io
import requests
import os
import uuid
import time
import math
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance
from java.io import File
from java.util import Locale
from org.telegram.messenger import ApplicationLoader
from org.telegram.messenger import R as R_tg
from org.telegram.tgnet.tl import TL_account
from ui.settings import Header, Input, Switch, Divider, Selector, Text
from client_utils import send_message, get_send_messages_helper, get_last_fragment, get_messages_controller, get_user_config, send_request
from base_plugin import BasePlugin, HookResult, HookStrategy
from org.telegram.ui.ActionBar import AlertDialog
from android_utils import log
import threading
from typing import Optional, Any
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from markdown_utils import parse_markdown

__id__ = "lastfm"
__name__ = "LastFM"
__version__ = "1.7.0 [Release]"
__description__ = "Shows the current song from LastFM. [.np]"
__author__ = "@ArThirtyFour | @KangelPlugins"
__min_version__ = "11.9.0"
__icon__ = "OMGKAWAIIANGELGOD/0"

GENIUS_API_TOKEN = "9JiBRxKAEgfssIWg3Yw8uxKyDO0HZr1IQS5qVYQiKMLwJ4d_9tEMxxYlm3w_mIML"
GENIUS_API_BASE_URL = "https://api.genius.com"

API_KEY = "460cda35be2fbf4f28e8ea7a38580730"
TEMP_DIR_NAME = "temp_lastfm_covers"
DEFAULT_STREAM_STRING = "[ðŸŽ¼](5264918568117487270) | {title} â€” {artist}"
DEFAULT_STREAM_TEXT = "Hi, I use exteraGram"

FONTS = {
    "NotoSansJP": "https://github.com/itsNightly/font_link/raw/refs/heads/main/NotoSansJP-Regular.ttf",
    "Zpix": "https://github.com/Ar4ikTrirtyFour/windose20/raw/refs/heads/main/fonts/zpix.ttf",
    "Impact": "https://github.com/localizator/ukrainian-fonts-pack/raw/refs/heads/master/TimesNRCyrMT-Bold%20-%20Times%20New%20Roman%20Cyr%20-%20Bold.ttf"
}
FONT_DISPLAY_NAMES = {
    "NotoSansJP": "Noto Sans JP",
    "Zpix": "Zpix", 
    "Impact": "Impact"
}

progress_dialog = None

class AlertManager:
    def __init__(self):
        self.alert_builder_instance: Optional[AlertDialogBuilder] = None

    def show_info_alert(self, title: str, message: str, positive_button: str):
        last_fragment = get_last_fragment()
        if not last_fragment or not last_fragment.getParentActivity(): return
        context = last_fragment.getParentActivity()
        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.alert_builder_instance = builder
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda d, w: self.dismiss_dialog())
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def dismiss_dialog(self):
        if self.alert_builder_instance and self.alert_builder_instance.get_dialog() and self.alert_builder_instance.get_dialog().isShowing():
            self.alert_builder_instance.dismiss()
            self.alert_builder_instance = None

class LocalizationManager:
    strings = {
        "ru": {
            "FONT_FAQ_TITLE": "ðŸŽ¨ ÐšÐ°Ðº Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ðµ ÑˆÑ€Ð¸Ñ„Ñ‚Ñ‹",
            "FONT_FAQ_TEXT": (
                "ðŸ“ ÐšÐ°Ðº Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ ÑˆÑ€Ð¸Ñ„Ñ‚?\n\n"
                "1ï¸âƒ£ Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ 'ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ ÑˆÑ€Ð¸Ñ„Ñ‚' Ð² ÑÐµÐ»ÐµÐºÑ‚Ð¾Ñ€Ðµ ÑˆÑ€Ð¸Ñ„Ñ‚Ð¾Ð²\n\n"
                "2ï¸âƒ£ Ð’ Ð¿Ð¾Ð»Ðµ 'Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ ÑˆÑ€Ð¸Ñ„Ñ‚' Ð²ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð¿Ñ€ÑÐ¼ÑƒÑŽ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð° .ttf Ñ„Ð°Ð¹Ð»\n\n"
                "ðŸ”— ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ ÑÑÑ‹Ð»Ð¾Ðº:\n"
                "â€¢ https://example.com/font.ttf\n"
                "â€¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "ðŸ’¡ Ð˜ ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž Ð¢ÐÐœ Ð”ÐžÐ›Ð–Ð•Ð Ð‘Ð«Ð¢Ð¬ Ð’ ÐšÐžÐÐ¦Ð• .ttf\n\n"
                "3ï¸âƒ£ Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÑƒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ .np\n\n"
                "âš¡ ÐŸÐ»Ð°Ð³Ð¸Ð½ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ ÑÐºÐ°Ñ‡Ð°ÐµÑ‚ ÑˆÑ€Ð¸Ñ„Ñ‚ Ð¸ Ð±ÑƒÐ´ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐµÐ³Ð¾!\n\n"
                "ðŸš¨ Ð’ÐÐ–ÐÐž! ÐŸÐ Ð˜ ÐŸÐ•Ð Ð’ÐžÐœ Ð˜Ð¡ÐŸÐžÐ›Ð¬Ð—ÐžÐ’ÐÐÐ˜Ð˜/Ð¡ÐœÐ•ÐÐ• Ð¨Ð Ð˜Ð¤Ð¢Ð Ð‘Ð£Ð”Ð•Ð¢ Ð”ÐžÐ›Ð¬Ð¨Ð• Ð¡ÐžÐ—Ð”ÐÐ’ÐÐ¢Ð¬Ð¡Ð¯ Ð§Ð•Ðœ ÐžÐ‘Ð«Ð§ÐÐž\n\n"
                "ðŸ’» ÐÐ²Ñ‚Ð¾Ñ€ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°Ñ‚ÑŒ ÑˆÑ€Ð¸Ñ„Ñ‚Ñ‹ Ð½Ð° Github\n\n"
                "ðŸŒ Ð¡Ð°Ð¹Ñ‚Ñ‹ Ð³Ð´Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ð°Ð¹Ñ‚Ð¸ ÑˆÑ€Ð¸Ñ„Ñ‚Ñ‹ (Ñ Ð¿Ñ€ÑÐ¼Ñ‹Ð¼Ð¸ ÑÑÑ‹Ð»ÐºÐ°Ð¼Ð¸):\n"
                "â€¢ https://fontsaddict.com\n\n"
                "â€¢ https://en.bestfonts.pro\n\n"
            ),
            "ALERT_CLOSE_BUTTON": "âœ… ÐŸÐ¾Ð½ÑÐ»"
        },
        "en": {
            "FONT_FAQ_TITLE": "ðŸŽ¨ How to use custom fonts",
            "FONT_FAQ_TEXT": (
                "ðŸ“ How to add a custom font?\n\n"
                "1ï¸âƒ£ Select 'Custom font' in the font selector\n\n"
                "2ï¸âƒ£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
                "ðŸ”— Example links:\n"
                "â€¢ https://example.com/font.ttf\n"
                "â€¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "ðŸ’¡ AND THERE MUST BE .ttf AT THE END\n\n"
                "3ï¸âƒ£ Create a card with .np command\n\n"
                "âš¡ The plugin will automatically download the font and use it!\n\n"
                "ðŸš¨ IMPORTANT! ON FIRST USE/FONT CHANGE, IT WILL TAKE LONGER TO CREATE THAN USUAL\n\n"
                "ðŸ’» The author recommends uploading fonts to Github\n\n"
                "ðŸŒ Sites where you can find fonts (with direct links):\n"
                "â€¢ https://fontsaddict.com\n\n"
                "â€¢ https://en.bestfonts.pro\n\n"
            ),
            "ALERT_CLOSE_BUTTON": "âœ… Got it"
        }
    }

    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self.strings else "en"

    def get_string(self, key: str) -> str:
        return self.strings[self.language].get(key, self.strings["en"].get(key, key))

locali = LocalizationManager()


class LastFMPlugin(BasePlugin):

    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self.alert_manager = AlertManager()
        threading.Thread(target=self._streamer, daemon=True).start()

    def _streamer(self):
        log("[LastFM] Streamer started")
        while True:
            try:
                try:
                    update_interval = int(self.get_setting("update_interval", "30"))
                    if update_interval < 5:
                        update_interval = 5
                except:
                    update_interval = 30
                
                if self.get_setting("update_bio", False):
                    log("[LastFM] Update bio is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[LastFM] Failed to get userFull")
                        time.sleep(update_interval)
                        continue

                    stream_place = self.get_setting("stream_place", 1 if get_user_config().isPremium() else 0)
                    max_len = 140 if get_user_config().isPremium() else 70

                    username = self.get_setting("lastfm_username", "")
                    if not username:
                        log("[LastFM] LastFM username is not set")
                        time.sleep(update_interval)
                        continue

                    log(f"[LastFM] Fetching track for user {username}")
                    current_track_url = f'http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&nowplaying=true&user={username}&api_key={API_KEY}&format=json'
                    response = requests.get(current_track_url)
                    
                    if response.status_code == 200:
                        data = response.json()
                        log(f"[LastFM] Got response: {data}")
                        if 'recenttracks' in data and 'track' in data['recenttracks'] and data['recenttracks']['track']:
                            log(f"[LastFM] Found tracks in response: {len(data['recenttracks']['track'])} tracks")
                            nowplaying_track = None
                            for track in data['recenttracks']['track']:
                                if '@attr' in track and 'nowplaying' in track['@attr']:
                                    nowplaying_track = track
                                    log(f"[LastFM] Found now playing track: {track}")
                                    break

                            if nowplaying_track:
                                log(f"[LastFM] Processing now playing track")
                                track_info = {
                                    'name': nowplaying_track.get('name', 'Unknown Track'),
                                    'artist': nowplaying_track.get('artist', {}).get('#text', 'Unknown Artist'),
                                    'album_image': None
                                }

                                log(f"[LastFM] Track info: {track_info}")

                                images = nowplaying_track.get('image', [])
                                log(f"[LastFM] Available images: {images}")
                                for size in ['extralarge', 'large', 'medium', 'small']:
                                    for img in images:
                                        if img.get('size') == size:
                                            track_info['album_image'] = img.get('#text')
                                            if track_info['album_image'] and track_info['album_image'].strip():
                                                log(f"[LastFM] Selected image size {size}: {track_info['album_image']}")
                                                break
                                    if track_info['album_image']:
                                        break

                                log(f"[LastFM] Final track info: {track_info}")
                                
                                try:
                                    
                                    np_format = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                                    bio_text = np_format.replace("{title}", track_info['name']).replace("{artist}", track_info['artist'])
                                    
                                    if stream_place == 0:
                                        if userFull.about != bio_text[:max_len]:
                                            try:
                                                req = TL_account.updateProfile()
                                                req.flags = 4
                                                req.about = bio_text[:max_len]
                                                send_request(req, ())
                                                log(f"[LastFM] Updated bio with: {bio_text[:max_len]}")
                                            except Exception as e:
                                                log(f"[LastFM] Error updating bio: {e}")
                                    else:
                                        if not get_user_config().isPremium():
                                            log("[LastFM] User is not premium, can't update business location")
                                            time.sleep(update_interval)
                                            continue
                                        try:
                                            req = TL_account.updateBusinessLocation()
                                            req.address = bio_text[:96]
                                            req.flags = 1
                                            send_request(req, ())
                                            log(f"[LastFM] Updated business location with: {bio_text[:96]}")
                                        except Exception as e:
                                            log(f"[LastFM] Error updating business location: {e}")
                                            
                                except Exception as e:
                                    log(f"[LastFM] Error in bio update: {e}")
                                    import traceback
                                    log(f"[LastFM] Traceback: {traceback.format_exc()}")

                            else:
                                log("[LastFM] No now playing track found")
                                default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                                if stream_place == 0:
                                    if userFull.about != default_bio[:max_len]:
                                        try:
                                            req = TL_account.updateProfile()
                                            req.flags = 4
                                            req.about = default_bio[:max_len]
                                            send_request(req, ())
                                            log("[LastFM] Set default bio")
                                        except Exception as e:
                                            log(f"[LastFM] Error setting default bio: {e}")
                                else:
                                    if not get_user_config().isPremium():
                                        log("[LastFM] User is not premium, can't update business location")
                                        time.sleep(update_interval)
                                        continue
                                    try:
                                        req = TL_account.updateBusinessLocation()
                                        req.address = default_bio[:96]
                                        req.flags = 1
                                        send_request(req, ())
                                        log("[LastFM] Set default bio in business location")
                                    except Exception as e:
                                        log(f"[LastFM] Error setting default bio in business location: {e}")
                        else:
                            log("[LastFM] No tracks found in response")
                    else:
                        log(f"[LastFM] Bad response from LastFM API: {response.status_code}")
                        default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                        if stream_place == 0:
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                    log("[LastFM] Set default bio after bad response")
                                except Exception as e:
                                    log(f"[LastFM] Error setting default bio after bad response: {e}")
                        else:
                            if not get_user_config().isPremium():
                                log("[LastFM] User is not premium, can't update business location")
                                time.sleep(update_interval)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = default_bio[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[LastFM] Set default bio in business location after bad response")
                            except Exception as e:
                                log(f"[LastFM] Error setting default bio in business location after bad response: {e}")

                time.sleep(update_interval)
            except Exception as e:
                log(f"[LastFM] Streamer error: {e}")
                time.sleep(10)

    def _dismiss_dialog(self):
        global progress_dialog
        try:
            if progress_dialog is not None and progress_dialog.isShowing():
                progress_dialog.dismiss()
        except Exception:
            pass
        finally:
            progress_dialog = None

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            threading.Thread(target=self._download_fonts, daemon=True).start()
            log("LastFM plugin loaded successfully")
        else:
            log("Failed to initialize temp directory for LastFM")

    def on_plugin_unload(self):
        log("LastFM plugin unloaded")
        self.alert_manager.dismiss_dialog()

    def _download_fonts(self):
        try:
            for font_name, font_url in FONTS.items():
                font_path = File(self._temp_dir, f"{font_name}-Regular.ttf").getAbsolutePath()
                if not os.path.exists(font_path):
                    response = requests.get(font_url)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                    log(f"Downloaded font: {font_name}")
        except Exception as e:
            log(f"Error downloading fonts: {e}")

    def _handle_show_faq_alert_click(self, view):
        title = locali.get_string("FONT_FAQ_TITLE")
        text = locali.get_string("FONT_FAQ_TEXT")
        close_button = locali.get_string("ALERT_CLOSE_BUTTON")
        self.alert_manager.show_info_alert(title, text, close_button)

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        update_bio = self.get_setting("update_bio", False)

        if lang.startswith('ru'):
            user_header = "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ LastFM"
            user_input_text = "Ð˜Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ"
            user_input_subtext = "Ð£ÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÐµ Ð¸Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ LastFM."
            photo_header = "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ"
            photo_text = "ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ð¾Ð±Ð»Ð¾Ð¶ÐºÑƒ Ð°Ð»ÑŒÐ±Ð¾Ð¼Ð°"
            photo_subtext = "Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ð¾Ð±Ð»Ð¾Ð¶ÐºÑƒ Ð°Ð»ÑŒÐ±Ð¾Ð¼Ð° Ð²Ð¼ÐµÑÑ‚Ðµ Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹ Ð¾ Ñ‚Ñ€ÐµÐºÐµ."
            np_format_text = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ .np"
            np_format_subtext = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ° Ð² ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ .np. {title} â€” Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚Ñ€ÐµÐºÐ°, {artist} â€” Ð°Ñ€Ñ‚Ð¸ÑÑ‚"
            font_header = "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ ÑˆÑ€Ð¸Ñ„Ñ‚Ð° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸"
            font_text = "Ð¨Ñ€Ð¸Ñ„Ñ‚ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸"
            custom_font_text = "Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ ÑˆÑ€Ð¸Ñ„Ñ‚"
            custom_font_subtext = "Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° .ttf Ñ„Ð°Ð¹Ð» Ð² Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ðµ"
            stream_header = "ÐŸÐ¾Ñ‚Ð¾Ðº Ð² Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ"
            stream_text = "Ð¡Ñ‚Ñ€Ð¸Ð¼ Ñ‚Ñ€ÐµÐºÐ° Ð² Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ"
            stream_subtext = "ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÑ‚ Ð±Ð¸Ð¾/Ð³ÐµÐ¾Ð»Ð¾ÐºÐ°Ñ†Ð¸ÑŽ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¼ Ñ‚Ñ€ÐµÐºÐ¾Ð¼"
            stream_place_text = "Ð¢Ñ€Ð°Ð½ÑÐ»Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð² ..."
            stream_place_item1 = "Ð‘Ð¸Ð¾"
            stream_place_item2 = "Ð“ÐµÐ¾Ð»Ð¾ÐºÐ°Ñ†Ð¸ÑŽ (Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ)"
            stream_format_text = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚"
            stream_format_subtext = "Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ°. {title} â€” Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚Ñ€ÐµÐºÐ°, {artist} â€” Ð°Ñ€Ñ‚Ð¸ÑÑ‚"
            stream_default_text = "Ð¢ÐµÐºÑÑ‚ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ"
            stream_default_subtext = "ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÑ‚ÑÑ, ÐµÑÐ»Ð¸ Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÑÑ"
            update_interval_text = "Ð˜Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ"
            update_interval_subtext = "ÐšÐ°Ðº Ñ‡Ð°ÑÑ‚Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÑ‚ÑŒ Ñ‚ÐµÐºÑÑ‚ Ð² Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ðµ (Ð² ÑÐµÐºÑƒÐ½Ð´Ð°Ñ…)"
        else:
            user_header = "LastFM User"
            user_input_text = "Username"
            user_input_subtext = "Set your LastFM username."
            photo_header = "Display Settings"
            photo_text = "Send album cover"
            photo_subtext = "Enable to send album cover along with track information."
            np_format_text = ".np Format"
            np_format_subtext = "Format for .np command display. {title} â€” track name, {artist} â€” artist"
            font_header = "Card Font Settings"
            font_text = "Card font"
            custom_font_text = "Custom font link"
            custom_font_subtext = "URL to .ttf file on the internet"
            stream_header = "Profile Streaming"
            stream_text = "Stream track to profile"
            stream_subtext = "Updates bio/location with currently playing track"
            stream_place_text = "Stream to..."
            stream_place_item1 = "Bio"
            stream_place_item2 = "Location (Recommended)"
            stream_format_text = "Format"
            stream_format_subtext = "Customize track display. {title} â€” track name, {artist} â€” artist"
            stream_default_text = "Default Text"
            stream_default_subtext = "Displayed when no track is playing"
            update_interval_text = "Update Interval"
            update_interval_subtext = "How often to update profile text (in seconds)"

        font_items = ["Noto Sans JP", "Zpix", "Impact", "ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ ÑˆÑ€Ð¸Ñ„Ñ‚" if lang.startswith('ru') else "Custom font"]

        settings = [
            Header(text=user_header),
            Input(
                key="lastfm_username",
                text=user_input_text,
                default="",
                subtext=user_input_subtext,
                icon="menu_username_change"
            ),
            Header(text=photo_header),
            Switch(
                key="send_album_cover",
                text=photo_text,
                default=True,
                subtext=photo_subtext,
                icon="msg_photos"
            ),
            Input(
                key="np_display_format",
                text=np_format_text,
                default=DEFAULT_STREAM_STRING,
                subtext=np_format_subtext,
                icon="msg_view_file"
            ),
            Divider(),
            Header(text=font_header),
            Selector(
                key="card_font_family",
                text=font_text,
                default=0,
                items=font_items,
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_path",
                text=custom_font_text,
                subtext=custom_font_subtext,
                default="",
                icon="msg_photo_text_regular"
            ),
            Text(
                text="ÐšÐ°Ðº Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ðµ ÑˆÑ€Ð¸Ñ„Ñ‚Ñ‹" if lang.startswith('ru') else "How to use custom fonts",
                icon="msg_info",
                on_click=self._handle_show_faq_alert_click
            ),
            Switch(
                key="show_promo",
                text=("ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑŒ Ð°Ð²Ñ‚Ð¾Ñ€Ð°" if lang.startswith('ru') else "Show promo signature"),
                subtext=("ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ ÑÑ‚Ñ€Ð¾ÐºÑƒ Ñ ÐºÐ°Ð½Ð°Ð»Ð¾Ð¼ Ð²Ð½Ð¸Ð·Ñƒ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸" if lang.startswith('ru') else "Display channel in the bottom of the card"),
                default=True,
                icon="msg_info"
            ),
            Divider(),
            Header(text=stream_header),
            Switch(
                key="update_bio",
                text=stream_text,
                default=False,
                subtext=stream_subtext,
                on_change=lambda new_value: self._show_stream_alert(new_value),
                icon="msg_online"
            ),
            Selector(
                key="stream_place",
                text=stream_place_text,
                default=1 if get_user_config().isPremium() else 0,
                items=[
                    stream_place_item1,
                    stream_place_item2,
                ],
                icon="menu_premium_location" if get_user_config().isPremium() else "msg_openprofile"
            ) if update_bio and get_user_config().isPremium() else None,
            Input(
                key="track_display_format",
                text=stream_format_text,
                default="{title} â€” {artist}",
                subtext=stream_format_subtext,
                icon="msg_view_file"
            ) if update_bio else None,
            Input(
                key="default_stream_text",
                text=stream_default_text,
                default=DEFAULT_STREAM_TEXT,
                subtext=stream_default_subtext,
                icon="msg_photo_text_framed3"
            ) if update_bio else None,
            Input(
                key="update_interval",
                text=update_interval_text,
                default="30",
                subtext=update_interval_subtext,
                icon="menu_premium_clock"
            ) if update_bio else None,
        ]
        return [s for s in settings if s is not None]

    def _show_stream_alert(self, value):
        if value:
            lang = Locale.getDefault().getLanguage()
            if lang.startswith('ru'):
                title = "âš ï¸âš ï¸Ð’ÐÐ˜ÐœÐÐÐ˜Ð•âš ï¸âš ï¸"
                message = "Ð­Ñ‚Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¼Ð¾Ð¶ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½ÐµÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾ Ð¸Ð·-Ð·Ð° Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ð¹ Telegram Ð½Ð° Ñ‡Ð°ÑÑ‚ÑƒÑŽ ÑÐ¼ÐµÐ½Ñƒ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ñ. Ð’Ð°ÑˆÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¼Ð¾Ð³ÑƒÑ‚ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÑ‚ÑŒÑÑ Ñ Ð·Ð°Ð´ÐµÑ€Ð¶ÐºÐ¾Ð¹. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð½Ð° ÑÐ²Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ñ… Ð¸ Ñ€Ð¸ÑÐº."
            else:
                title = "âš ï¸âš ï¸WARNINGâš ï¸âš ï¸"
                message = "This feature may work inconsistently due to Telegram's profile change limits. Your profile information may not update immediately. Use at your own risk."
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            dialog = AlertDialog(ctx, 3)
            dialog.setTitle(title)
            dialog.setMessage(message)
            dialog.setButton("OK", None)
            dialog.show()

    def get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None

    def download_album_image(self, image_url):
        if not image_url:
            return None
        temp_dir = self.get_temp_dir()
        if not temp_dir or not temp_dir.isDirectory():
            return None
        filename = f"album_{uuid.uuid4()}.jpg"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()
        try:
            head = requests.head(image_url, timeout=5)
            content_length = int(head.headers.get('content-length', 0))
            if content_length > 5 * 1024 * 1024:
                return None

            resp = requests.get(image_url, stream=True, timeout=10)
            resp.raise_for_status()
            with open(temp_photo_path, 'wb') as f:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return temp_photo_path
        except Exception as e:
            try:
                if os.path.exists(temp_photo_path):
                    os.remove(temp_photo_path)
            except Exception:
                pass
            return None

    def delete_temp_file_async(self, file_path, delay_seconds=5):
        def _delete():
            try:
                time.sleep(delay_seconds)
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                pass
        threading.Thread(target=_delete, daemon=True).start()

    def _get_genius_lyrics_url(self, title: str, artist: str):
        try:
            if not title and not artist:
                return None
            query = f"{title} {artist}".strip()
            search_url = f"{GENIUS_API_BASE_URL}/search?q={requests.utils.quote(query)}"
            log(f"[LastFM] Searching Genius lyrics URL: {search_url}")
            headers = {"Authorization": f"Bearer {GENIUS_API_TOKEN}"}
            response = requests.get(search_url, headers=headers, timeout=7)
            if response.status_code != 200:
                log(f"[LastFM] Genius API error: HTTP {response.status_code}")
                return None
            data = response.json()
            hits = data.get("response", {}).get("hits", []) if isinstance(data, dict) else []
            if not hits:
                log("[LastFM] Genius: no hits for query")
                return None
            song_url = hits[0].get("result", {}).get("url")
            log(f"[LastFM] Genius song URL: {song_url}")
            return song_url
        except Exception as e:
            log(f"[LastFM] Genius lookup error: {e}")
            return None

    def _show_lyrics_search_bulletin(self):
        try:
            lang = Locale.getDefault().getLanguage()
            is_ru = lang and lang.startswith('ru')
            text = "Ð˜Ñ‰ÐµÐ¼ ÑÐ»Ð¾Ð²Ð° Ð¿ÐµÑÐ½Ð¸.." if is_ru else "Searching lyrics..."
            BulletinHelper.show_info(text)
        except Exception as e:
            log(f"[LastFM] show_with_button failed: {e}")

    def _escape_markdown_text(self, text: str) -> str:
        try:
            if not isinstance(text, str) or not text:
                return ""
            escaped = text.replace("\\", "\\\\")
            for ch in ["*", "_", "~", "|", "`", "[", "]", "(", ")"]:
                escaped = escaped.replace(ch, f"\\{ch}")
            return escaped
        except Exception:
            return text if isinstance(text, str) else ""

    def on_send_message_hook(self, account, params):
        log(f"[LastFM] on_send_message_hook called with message: {getattr(params, 'message', 'None')}")
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            log("[LastFM] No valid message found, returning")
            return HookResult()

        message_text = params.message.strip()
        command_prefix_now = ".np"
        log(f"[LastFM] Message text: '{message_text}', looking for command: '{command_prefix_now}'")

        lastfm_username = self.get_setting("lastfm_username", "")
        log(f"[LastFM] LastFM username from settings: '{lastfm_username}'")

        if message_text == command_prefix_now:
            log("[LastFM] Command .np detected!")
            if not lastfm_username or lastfm_username == "":
                log("[LastFM] No LastFM username set")
                response_text = "âŒ ÐÐ¸Ðº LastFM Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ… Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°."
                params.message = response_text
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            else:
                log(f"[LastFM] Starting search for user: {lastfm_username}")
                def search_and_reply(peer):
                    log(f"[LastFM] search_and_reply started for peer: {peer}")
                    try:
                        current_track_url = f'http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&nowplaying=true&user={lastfm_username}&api_key={API_KEY}&format=json'
                        log(f"[LastFM] Requesting URL: {current_track_url}")
                        response = requests.get(current_track_url)
                        log(f"[LastFM] Response status: {response.status_code}")
                        
                        if response.status_code != 200:
                            log(f"[LastFM] Bad response status: {response.status_code}")
                            send_message({
                                "peer": peer,
                                "message": f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° API LastFM: HTTP {response.status_code}"
                            })
                            return
                            
                        try:
                            data = response.json()
                            log(f"[LastFM] Response data: {data}")
                        except Exception as e:
                            log(f"[LastFM] Error parsing JSON: {e}")
                            send_message({
                                "peer": peer,
                                "message": "âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ LastFM. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ."
                            })
                            return

                        if 'recenttracks' in data and 'track' in data['recenttracks'] and data['recenttracks']['track']:
                            log(f"[LastFM] Found tracks in response: {len(data['recenttracks']['track'])} tracks")
                            nowplaying_track = None
                            for track in data['recenttracks']['track']:
                                if '@attr' in track and 'nowplaying' in track['@attr']:
                                    nowplaying_track = track
                                    log(f"[LastFM] Found now playing track: {track}")
                                    break

                            if nowplaying_track:
                                log(f"[LastFM] Processing now playing track")
                                track_info = {
                                    'name': nowplaying_track.get('name', 'Unknown Track'),
                                    'artist': nowplaying_track.get('artist', {}).get('#text', 'Unknown Artist'),
                                    'album_image': None
                                }

                                log(f"[LastFM] Track info: {track_info}")

                                images = nowplaying_track.get('image', [])
                                log(f"[LastFM] Available images: {images}")
                                for size in ['extralarge', 'large', 'medium', 'small']:
                                    for img in images:
                                        if img.get('size') == size:
                                            track_info['album_image'] = img.get('#text')
                                            if track_info['album_image'] and track_info['album_image'].strip():
                                                log(f"[LastFM] Selected image size {size}: {track_info['album_image']}")
                                                break
                                    if track_info['album_image']:
                                        break

                                log(f"[LastFM] Final track info: {track_info}")
                                log(f"[LastFM] Send album cover setting: {self.get_setting('send_album_cover', True)}")
                                
                                try:
                                    if self.get_setting("send_album_cover", True):
                                        log("[LastFM] Creating card...")
                                        temp_photo_path = self._make_card(track_info)
                                        log(f"[LastFM] Card created at: {temp_photo_path}")
                                        
                                        if temp_photo_path:
                                            log("[LastFM] Getting send messages helper...")
                                            helper = get_send_messages_helper()
                                            log("[LastFM] Generating photo sizes...")
                                            generated_photo = helper.generatePhotoSizes(temp_photo_path, None)
                                            log(f"[LastFM] Generated photo: {generated_photo}")

                                            if generated_photo is not None:
                                                np_format = self.get_setting("np_display_format", DEFAULT_STREAM_STRING)
                                                safe_title = self._escape_markdown_text(track_info['name'])
                                                safe_artist = self._escape_markdown_text(track_info['artist'])
                                                caption = np_format.replace("{title}", safe_title).replace("{artist}", safe_artist)
                                                try:
                                                    self._show_lyrics_search_bulletin()
                                                    lyrics_url = self._get_genius_lyrics_url(track_info['name'], track_info['artist'])
                                                    if lyrics_url:
                                                        caption = f"{caption}\n[ðŸ“](5267392860122006833) | [Lyrics]({lyrics_url})"
                                                except Exception as e:
                                                    log(f"[LastFM] Failed to append lyrics URL: {e}")
                                                log(f"[LastFM] Sending photo with caption: {caption}")
                                                
                                                try:
                                                    parsed_caption = parse_markdown(caption.strip())
                                                    send_message({
                                                        "peer": peer,
                                                        "photo": generated_photo,
                                                        "path": temp_photo_path,
                                                        "caption": parsed_caption.text,
                                                        "entities": [e.to_tlrpc_object() for e in parsed_caption.entities],
                                                        "message": None
                                                    })
                                                except Exception:
                                                    send_message({
                                                        "peer": peer,
                                                        "photo": generated_photo,
                                                        "path": temp_photo_path,
                                                        "caption": self._escape_markdown_text(caption),
                                                        "message": None
                                                    })
                                                log("[LastFM] Photo sent successfully")
                                                self.delete_temp_file_async(temp_photo_path)
                                                return HookResult(strategy=HookStrategy.CANCEL)
                                            else:
                                                log("[LastFM] Failed to generate photo sizes")
                                                self.delete_temp_file_async(temp_photo_path)
                                                try:
                                                    lang = Locale.getDefault().getLanguage()
                                                    is_ru = lang and lang.startswith('ru')
                                                    BulletinHelper.show_error("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ñ„Ð¾Ñ‚Ð¾" if is_ru else "Error generating photo")
                                                except Exception:
                                                    pass
                                                return HookResult(strategy=HookStrategy.CANCEL)
                                        else:
                                            log("[LastFM] Failed to create card")
                                            try:
                                                lang = Locale.getDefault().getLanguage()
                                                is_ru = lang and lang.startswith('ru')
                                                BulletinHelper.show_error("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸" if is_ru else "Error creating the card")
                                            except Exception:
                                                pass
                                            return HookResult(strategy=HookStrategy.CANCEL)
                                    else:
                                        log("[LastFM] Sending text message only...")
                                        np_format = self.get_setting("np_display_format", DEFAULT_STREAM_STRING)
                                        safe_title = self._escape_markdown_text(track_info['name'])
                                        safe_artist = self._escape_markdown_text(track_info['artist'])
                                        message = np_format.replace("{title}", safe_title).replace("{artist}", safe_artist)
                                        try:
                                            self._show_lyrics_search_bulletin()
                                            lyrics_url = self._get_genius_lyrics_url(track_info['name'], track_info['artist'])
                                            if lyrics_url:
                                                message = f"{message}\n\n[ðŸ“](5267392860122006833) [Lyrics]({lyrics_url})"
                                        except Exception as e:
                                            log(f"[LastFM] Failed to append lyrics URL: {e}")
                                        log(f"[LastFM] Sending text: {message}")
                                        try:
                                            parsed_text = parse_markdown(message.strip())
                                            send_message({
                                                "peer": peer,
                                                "message": parsed_text.text,
                                                "entities": [e.to_tlrpc_object() for e in parsed_text.entities]
                                            })
                                        except Exception:
                                            send_message({
                                                "peer": peer,
                                                "message": self._escape_markdown_text(message)
                                            })
                                        log("[LastFM] Text message sent successfully")
                                        return HookResult(strategy=HookStrategy.CANCEL)
                                except Exception as e:
                                    log(f"[LastFM] Error in card creation/sending: {e}")
                                    import traceback
                                    log(f"[LastFM] Traceback: {traceback.format_exc()}")
                                    try:
                                        lang = Locale.getDefault().getLanguage()
                                        is_ru = lang and lang.startswith('ru')
                                        BulletinHelper.show_error((f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸: {e}") if is_ru else (f"Error creating the card: {e}"))
                                    except Exception:
                                        pass
                                    return HookResult(strategy=HookStrategy.CANCEL)

                            else:
                                log("[LastFM] No now playing track found")
                                send_message({
                                    "peer": peer,
                                    "message": "â–¶ï¸ Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð¸Ð³Ñ€Ð°ÐµÑ‚."
                                })
                                return

                        else:
                            log("[LastFM] No tracks found in response")
                            send_message({
                                "peer": peer,
                                "message": "ðŸ¤·â€â™‚ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ñ‚Ñ€ÐµÐºÐµ. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð½Ð¸Ðº LastFM Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ…."
                            })
                            return

                    except requests.exceptions.RequestException as e:
                        log(f"[LastFM] Request exception: {e}")
                        send_message({
                            "peer": peer,
                            "message": f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ Ðº LastFM API: {e}"
                        })
                        return
                    except Exception as e:
                        log(f"[LastFM] Unexpected exception: {e}")
                        import traceback
                        log(f"[LastFM] Traceback: {traceback.format_exc()}")
                        send_message({
                            "peer": peer,
                            "message": f"âŒ ÐÐµÐ¾Ð¶Ð¸Ð´Ð°Ð½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: {e}"
                        })
                        return

                try:
                    log("[LastFM] Showing search bulletin")
                    lang = Locale.getDefault().getLanguage()
                    is_ru = lang and lang.startswith('ru')
                    searching_text = "Ð˜Ñ‰ÐµÐ¼..." if is_ru else "Searching..."
                    BulletinHelper.show_info(searching_text)
                except Exception as e:
                    log(f"[LastFM] ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð°: {e}")

                log(f"[LastFM] Starting search thread for peer: {params.peer}")
                threading.Thread(target=lambda: search_and_reply(params.peer), daemon=True).start()

                lang = Locale.getDefault().getLanguage()
                is_ru = lang and lang.startswith('ru')
                params.message = "Ð˜Ñ‰ÐµÐ¼..." if is_ru else "Searching..."
                return HookResult(strategy=HookStrategy.CANCEL)

        log("[LastFM] Command not detected, returning")
        return HookResult()

    def _make_card(self, track_info):
        log(f"[LastFM] Starting _make_card with track_info: {track_info}")
        width, height = 1440, 600
        background_color = "#000000"
        title_text_color = "#FFFFFF"
        subtext_color = "#FFFFFF"
        default_cover_url = "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fplay-lh.googleusercontent.com%2FVFmAfWqcuV3aReZG8MMQdHRSdKWx85IW22f4RQ5xhR5U-o1_u03P7TVwsnTYa26Q1No&f=1&nofb=1&ipt=4449ba66d57828b42c006e2a6c19d76deae54a97f2485f28b3fbe695883dc7cc"

        log(f"[LastFM] Creating card with dimensions: {width}x{height}")
        
        album_image_url = track_info.get('album_image')
        log(f"[LastFM] Album image URL: {album_image_url}")
        if not album_image_url or not album_image_url.strip():
            album_image_url = default_cover_url
            log(f"[LastFM] Using default cover URL: {album_image_url}")

        original_image = None
        try:
            log(f"[LastFM] Downloading original image for background and thumbnail from: {album_image_url}")
            response = requests.get(album_image_url, timeout=10)
            response.raise_for_status()
            original_image = Image.open(io.BytesIO(response.content)).convert("RGBA")
        except Exception as e:
            log(f"[LastFM] Error downloading original cover image: {e}")
            original_image = Image.new('RGBA', (1, 1), (0, 0, 0, 0))

        full_background = Image.new('RGB', (width, height), background_color)
        if original_image:
            try:
                src_bg = original_image
                src_w, src_h = src_bg.size
                if src_w and src_h:
                    scale = max(width / src_w, height / src_h)
                    new_w, new_h = max(1, int(src_w * scale)), max(1, int(src_h * scale))
                    resized_bg = src_bg.resize((new_w, new_h), Image.LANCZOS)
                    left = max(0, (new_w - width) // 2)
                    top = max(0, (new_h - height) // 2)
                    cropped_bg = resized_bg.crop((left, top, left + width, top + height))
                else:
                    cropped_bg = src_bg.resize((width, height), Image.LANCZOS)

                blurred_background = cropped_bg.filter(ImageFilter.GaussianBlur(30))

                overlay = Image.new("RGBA", (width, height), (0, 0, 0, 150))
                full_background = Image.alpha_composite(blurred_background.convert("RGBA"), overlay).convert("RGB")
                log(f"[LastFM] Full blurred background created (cover fit)")
            except Exception as e:
                log(f"[LastFM] Error processing background cover: {e}")

        card = full_background
        draw = ImageDraw.Draw(card)
        if original_image:
            try:
                src_tw, src_th = original_image.size
                if src_tw > 0 and src_th > 0:
                    min_side = min(src_tw, src_th)
                    left = (src_tw - min_side) // 2
                    top = (src_th - min_side) // 2
                    thumb_square = original_image.crop((left, top, left + min_side, top + min_side))
                else:
                    thumb_square = original_image

                thumbnail = thumb_square.resize((450, 450), Image.LANCZOS)
                log(f"[LastFM] Album image prepared as square 450x450 (cover crop)")
                mask = Image.new('L', thumbnail.size, 0)
                draw_mask = ImageDraw.Draw(mask)
                draw_mask.rounded_rectangle((0, 0, *thumbnail.size), 30, fill=255)
                thumbnail = thumbnail.copy()
                thumbnail.putalpha(mask)
                card.paste(thumbnail, (75, 75), thumbnail)
                log(f"[LastFM] Album image pasted to card")
            except Exception as e:
                log(f"[LastFM] Error processing album cover thumbnail: {e}")

        title = track_info.get('name', 'Unknown Track')
        artist = track_info.get('artist', 'Unknown Artist')
        log(f"[LastFM] Title: {title}, Artist: {artist}")
        
        font_index = self.get_setting("card_font_family", 0)
        log(f"[LastFM] Font index: {font_index}")
        title_font = None
        artist_font = None
        info_font = None
        plugins_font = None
        
        if font_index == 3:
            log("[LastFM] Using custom font")
            custom_font_url = self.get_setting("custom_font_path", "").strip()
            log(f"[LastFM] Custom font URL: {custom_font_url}")
            if custom_font_url and custom_font_url.startswith(('http://', 'https://')):
                try:
                    custom_font_file = File(self._temp_dir, "custom_font.ttf").getAbsolutePath()
                    custom_url_file = File(self._temp_dir, "custom_font_url.txt").getAbsolutePath()
                    log(f"[LastFM] Custom font file path: {custom_font_file}")
                    
                    should_download = True
                    if os.path.exists(custom_font_file) and os.path.exists(custom_url_file):
                        try:
                            with open(custom_url_file, 'r') as f:
                                saved_url = f.read().strip()
                            if saved_url == custom_font_url:
                                should_download = False
                                log(f"[LastFM] Custom font URL unchanged, using cached font")
                        except Exception as e:
                            log(f"[LastFM] Error reading saved URL: {e}")
                    
                    if should_download:
                        log(f"[LastFM] Downloading custom font from: {custom_font_url}")
                        response = requests.get(custom_font_url, verify=False)
                        with open(custom_font_file, 'wb') as f:
                            f.write(response.content)
                        with open(custom_url_file, 'w') as f:
                            f.write(custom_font_url)
                        log(f"[LastFM] Downloaded new custom font from: {custom_font_url}")
                    
                    if os.path.exists(custom_font_file):
                        title_font = ImageFont.truetype(custom_font_file, 50)
                        artist_font = ImageFont.truetype(custom_font_file, 35)
                        info_font = ImageFont.truetype(custom_font_file, 35)
                        plugins_font = ImageFont.truetype(custom_font_file, 30)
                        log(f"[LastFM] Using custom font: {custom_font_file}")
                    else:
                        raise Exception("Custom font file not found")
                except Exception as e:
                    log(f"[LastFM] Failed to load custom font: {e}")
                    font_index = 0
        
        if not title_font:
            log(f"[LastFM] Loading standard font with index: {font_index}")
            font_key = list(FONTS.keys())[font_index] if isinstance(font_index, int) and font_index < len(FONTS) else "NotoSansJP"
            font_file_name = f"{font_key}-Regular.ttf"
            log(f"[LastFM] Font file name: {font_file_name}")
            try:
                font_path = File(self._temp_dir, font_file_name).getAbsolutePath()
                log(f"[LastFM] Font path: {font_path}")
                if os.path.exists(font_path):
                    title_font = ImageFont.truetype(font_path, 50)
                    artist_font = ImageFont.truetype(font_path, 35)
                    info_font = ImageFont.truetype(font_path, 35)
                    plugins_font = ImageFont.truetype(font_path, 30)
                    log(f"[LastFM] Using downloaded font: {font_path}")
                else:
                    raise Exception("Downloaded font not found")
            except Exception as e:
                log(f"[LastFM] Failed to load downloaded font: {e}")
                try:
                    title_font = ImageFont.truetype("/system/fonts/Roboto-Bold.ttf", 50)
                    artist_font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", 35)
                    info_font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", 35)
                    plugins_font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", 30)
                    log('[LastFM] Using system fonts')
                except:
                    log('[LastFM] Using default font')
                    title_font = ImageFont.load_default()
                    artist_font = ImageFont.load_default()
                    info_font = ImageFont.load_default()
                    plugins_font = ImageFont.load_default()
        
        log(f"[LastFM] Fonts loaded - title: {title_font}, artist: {artist_font}")
        
        max_width = width - 665
        title_lines = []
        current_line = []
        
        words = title.split()
        for word in words:
            test_line = ' '.join(current_line + [word])
            bbox = draw.textbbox((0, 0), test_line, font=title_font)
            if bbox[2] - bbox[0] <= max_width:
                current_line.append(word)
            else:
                if current_line:
                    title_lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            title_lines.append(' '.join(current_line))
            
        if len(title_lines) > 2:
            title_lines = title_lines[:2]
            title_lines[1] = title_lines[1][:title_lines[1].rfind(' ')] + '...'
        
        log(f"[LastFM] Title lines: {title_lines}")
        
        y_position = 85
        for line in title_lines:
            draw.text((590, y_position), line, font=title_font, fill=title_text_color)
            y_position += 60
        
        artist_lines = []
        current_line = []
        
        words = artist.split()
        for word in words:
            test_line = ' '.join(current_line + [word])
            bbox = draw.textbbox((0, 0), test_line, font=artist_font)
            if bbox[2] - bbox[0] <= max_width:
                current_line.append(word)
            else:
                if current_line:
                    artist_lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            artist_lines.append(' '.join(current_line))
            
        if len(artist_lines) > 1:
            artist_lines = [artist_lines[0][:artist_lines[0].rfind(' ')] + '...']
        
        log(f"[LastFM] Artist lines: {artist_lines}")
        
        draw.text((590, y_position + 10), artist_lines[0], font=artist_font, fill=subtext_color)

        draw.text((590, 415), "Now Playing", font=info_font, fill=subtext_color)

        try:
            if self.get_setting("show_promo", True):
                draw.text((590, 470), "Plugins by: @KangelPlugins", font=plugins_font, fill=subtext_color)
        except Exception:
            pass

        filename = f"now_lastfm.png"
        temp_photo_path = File(self._temp_dir, filename).getAbsolutePath()
        log(f"[LastFM] Saving card to: {temp_photo_path}")
        card.save(temp_photo_path)
        log(f"[LastFM] Card saved successfully")
        return temp_photo_path

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None 