# pizdec

from typing import Any, List, Dict, Optional, Tuple
import time
import json
import re
import calendar
from datetime import datetime, timedelta

from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from android_utils import log, run_on_ui_thread
from client_utils import send_message, run_on_queue, get_user_config, get_last_fragment
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Divider, Switch, Selector, Text
from ui.alert import AlertDialogBuilder

DEFAULT_PREFIX = ".cal"
DEFAULT_ENABLE_REMINDERS = True
DEFAULT_REMIND_TO_SELF = True
DEFAULT_TIME_STR = "09:00"
DEFAULT_WEEK_START = 0
DEFAULT_BULLETINS = True
DEFAULT_MENU_ON_PREFIX = True
DEFAULT_MENU_CHAT = True
DEFAULT_MENU_DRAWER = False
DEFAULT_CONFIRM_AS_BULLETIN = True

__id__ = "nanoCL"
__name__ = "nanoCL"
__description__ = "–∫–∞–ª–µ–Ω–¥–∞—Ä—å —Å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º–∏ (.cal)"
__author__ = "@nanoPrograms"
__version__ = "1.0.0"
__icon__ = "nanoCL/1"
__min_version__ = "12.1.1"

Event = Dict[str, Any]

class CalendarPlugin(BasePlugin):
    def on_plugin_load(self):
        self.add_on_send_message_hook()
        if self.get_setting("next_id", None) is None:
            self.set_setting("next_id", 1)
        if self.get_setting("events_json", None) is None:
            self._save_events([])
        self._register_menu_items()
        self._ui_state = {"year": datetime.now().year, "month": datetime.now().month}
        log("CalendarPlugin loaded with menu support")

    def create_settings(self):
        def on_prefix_change(new_value: str):
            if new_value and not new_value.startswith("."):
                self.set_setting("prefix", "." + new_value.strip())

        def on_toggle_chat_menu(val: bool):
            self.set_setting("menu_chat", val)
            try:
                self._register_menu_items()
                BulletinHelper.show_success("–ú–µ–Ω—é —á–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ")
            except Exception as e:
                log(f"Menu chat toggle error: {e}")

        def on_toggle_drawer_menu(val: bool):
            self.set_setting("menu_drawer", val)
            try:
                self._register_menu_items()
                BulletinHelper.show_success("–ë–æ–∫–æ–≤–æ–µ –º–µ–Ω—é –æ–±–Ω–æ–≤–ª–µ–Ω–æ")
            except Exception as e:
                log(f"Menu drawer toggle error: {e}")

        return [
            Header(text="–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"),
            Input(
                key="prefix",
                text="–ü—Ä–µ—Ñ–∏–∫—Å –∫–æ–º–∞–Ω–¥—ã",
                default=self.get_setting("prefix", DEFAULT_PREFIX),
                subtext="–ù–∞–ø—Ä–∏–º–µ—Ä: .cal",
                icon="msg_mention",
                on_change=on_prefix_change
            ),
            Switch(
                key="menu_on_prefix",
                text="–û–∫–Ω–æ –ø–æ –∫–æ–º–∞–Ω–¥–µ (.cal)",
                default=self.get_setting("menu_on_prefix", DEFAULT_MENU_ON_PREFIX),
                subtext="–ü—Ä–∏ –≤–≤–æ–¥–µ —Ç–æ–ª—å–∫–æ .cal –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é",
                icon="msg_menu"
            ),
            Switch(
                key="menu_chat",
                text="–ü—É–Ω–∫—Ç ¬´–ö–∞–ª–µ–Ω–¥–∞—Ä—å¬ª –≤ –º–µ–Ω—é —á–∞—Ç–∞",
                default=self.get_setting("menu_chat", DEFAULT_MENU_CHAT),
                subtext="–¢—Ä–∏ —Ç–æ—á–∫–∏ ‚Üí Plugins ‚Üí –ö–∞–ª–µ–Ω–¥–∞—Ä—å",
                icon="msg_calendar",
                on_change=on_toggle_chat_menu
            ),
            Switch(
                key="menu_drawer",
                text="–ü—É–Ω–∫—Ç ¬´–ö–∞–ª–µ–Ω–¥–∞—Ä—å¬ª –≤ –±–æ–∫–æ–≤–æ–º –º–µ–Ω—é",
                default=self.get_setting("menu_drawer", DEFAULT_MENU_DRAWER),
                subtext="–ë–æ–∫–æ–≤–æ–µ –º–µ–Ω—é (–≥–∞–º–±—É—Ä–≥–µ—Ä)",
                icon="msg_list",
                on_change=on_toggle_drawer_menu
            ),
            Switch(
                key="enable_reminders",
                text="–ê–≤—Ç–æ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π",
                default=self.get_setting("enable_reminders", DEFAULT_ENABLE_REMINDERS),
                subtext="–ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
                icon="msg_reminders"
            ),
            Switch(
                key="remind_to_self",
                text="–°–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–µ",
                default=self.get_setting("remind_to_self", DEFAULT_REMIND_TO_SELF),
                subtext="–ò–Ω–∞—á–µ ‚Äî –≤ —Ç–µ–∫—É—â–∏–π —á–∞—Ç",
                icon="msg_saved"
            ),
            Input(
                key="default_time",
                text="–í—Ä–µ–º—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (HH:MM)",
                default=self.get_setting("default_time", DEFAULT_TIME_STR),
                icon="msg_time"
            ),
            Selector(
                key="week_start",
                text="–ù–∞—á–∞–ª–æ –Ω–µ–¥–µ–ª–∏",
                default=self.get_setting("week_start", 0),
                items=["–ü–Ω", "–í—Å"],
                icon="msg_calendar"
            ),
            Switch(
                key="bulletins",
                text="–í—Å–ø–ª—ã–≤–∞—é—â–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏",
                default=self.get_setting("bulletins", DEFAULT_BULLETINS),
                icon="msg_info"
            ),
            Switch(
                key="confirm_as_bulletin",
                text="–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–∞–∫ –º–∏–Ω–∏-–æ–∫–Ω–æ",
                default=self.get_setting("confirm_as_bulletin", DEFAULT_CONFIRM_AS_BULLETIN),
                subtext="–í–Ω–∏–∑—É, —Å –∫–Ω–æ–ø–∫–æ–π OK",
                icon="msg_info"
            ),
            Divider(text="–°–ø—Ä–∞–≤–∫–∞"),
            Text(
                text="–ö–æ–º–∞–Ω–¥—ã: .cal help | add YYYY-MM-DD [HH:MM] –¢–µ–∫—Å—Ç | list [N] | del ID | month [YYYY-MM] | next | clear",
                icon="msg_list"
            )
        ]

    def _register_menu_items(self):
        try:
            if self.get_setting("menu_chat", DEFAULT_MENU_CHAT):
                self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text="–ö–∞–ª–µ–Ω–¥–∞—Ä—å",
                    icon="msg_calendar",
                    on_click=lambda ctx: self._open_root_menu(ctx.get("dialog_id"))
                ))
            if self.get_setting("menu_drawer", DEFAULT_MENU_DRAWER):
                self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text="–ö–∞–ª–µ–Ω–¥–∞—Ä—å",
                    icon="msg_calendar",
                    on_click=lambda ctx: self._open_root_menu(None)
                ))
        except Exception as e:
            log(f"Register menu items error: {e}")

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        msg = params.message if isinstance(params.message, str) else ""
        prefix = self.get_setting("prefix", DEFAULT_PREFIX)
        if not msg.startswith(prefix):
            return HookResult()

        only_prefix = msg.strip() == prefix
        if only_prefix and self.get_setting("menu_on_prefix", DEFAULT_MENU_ON_PREFIX):
            peer = getattr(params, "peer", None)
            run_on_queue(lambda: self._open_root_menu(peer))
            return HookResult(strategy=HookStrategy.CANCEL)

        run_on_queue(lambda: self._process_command_async(msg, params.peer))
        return HookResult(strategy=HookStrategy.CANCEL)

    def _process_command_async(self, msg: str, current_peer: Any):
        prefix = self.get_setting("prefix", DEFAULT_PREFIX)
        args = msg[len(prefix):].strip().split()
        if not args:
            self._reply_or_bulletin("–û—Ç–∫—Ä–æ–π—Ç–µ –º–µ–Ω—é –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ .cal help", kind="info")
            return

        cmd = args[0].lower()
        rest = msg[len(prefix):].strip()[len(cmd):].strip()

        try:
            if cmd == "help":
                self._reply(current_peer, self._help_text())

            elif cmd == "add":
                event, warn = self._cmd_add(rest, current_peer)
                text = "–°–æ–±—ã—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–æ\n" + self._format_single_event(event)
                if warn:
                    text += f"\n{warn}"
                self._reply_or_bulletin(text, kind="success", force_bulletin=True)

            elif cmd == "list":
                count = self._parse_int(args[1]) if len(args) > 1 else 5
                events = self._get_upcoming(count)
                self._reply(current_peer, self._format_events_list(events))

            elif cmd == "del":
                if len(args) < 2:
                    self._reply_or_bulletin("–£–∫–∞–∂–∏—Ç–µ ID: .cal del ID", kind="info")
                    return
                eid = self._parse_int(args[1])
                ok = self._delete_event(eid)
                if ok:
                    self._reply_or_bulletin("–°–æ–±—ã—Ç–∏–µ —É–¥–∞–ª–µ–Ω–æ", kind="delete", force_bulletin=True)
                else:
                    self._reply_or_bulletin("–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", kind="info", force_bulletin=True)

            elif cmd == "clear":
                self._save_events([])
                self._reply_or_bulletin("–í—Å–µ —Å–æ–±—ã—Ç–∏—è –æ—á–∏—â–µ–Ω—ã", kind="delete", force_bulletin=True)

            elif cmd == "month":
                year, month = self._parse_year_month(rest)
                self._reply(current_peer, self._render_month(year, month))

            elif cmd == "next":
                ev = self._next_event()
                self._reply(current_peer, self._format_single_event(ev) if ev else "–ë–ª–∏–∂–∞–π—à–∏—Ö —Å–æ–±—ã—Ç–∏–π –Ω–µ—Ç")

            else:
                self._reply_or_bulletin("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. .cal help", kind="info", force_bulletin=True)
        except Exception as e:
            log(f"Calendar error: {e}")
            self._reply_or_bulletin(f"–û—à–∏–±–∫–∞: {e}", kind="info", force_bulletin=True)

    def _open_root_menu(self, current_peer: Any):
        def show():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                BulletinHelper.show_error("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –æ–∫–Ω–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞ –º–µ–Ω—é")
                return

            activity = fragment.getParentActivity()
            builder = AlertDialogBuilder(activity)
            builder.set_title("–ö–∞–ª–µ–Ω–¥–∞—Ä—å")
            items = ["–ö–∞–ª–µ–Ω–¥–∞—Ä—å –º–µ—Å—è—Ü–∞", "–î–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ", "–°–ø–∏—Å–æ–∫ –±–ª–∏–∂–∞–π—à–∏—Ö", "–ë–ª–∏–∂–∞–π—à–µ–µ —Å–æ–±—ã—Ç–∏–µ", "–°–ø—Ä–∞–≤–∫–∞"]
            def on_click(bld: AlertDialogBuilder, which: int):
                if which == 0:
                    nowy, nowm = self._ui_state.get("year", datetime.now().year), self._ui_state.get("month", datetime.now().month)
                    self._show_month_dialog(nowy, nowm)
                elif which == 1:
                    self._show_add_dialog(current_peer)
                elif which == 2:
                    self._show_list_dialog()
                elif which == 3:
                    self._show_next_dialog()
                elif which == 4:
                    self._show_help_dialog()
                bld.dismiss()
            builder.set_items(items, on_click)
            builder.set_negative_button("–ó–∞–∫—Ä—ã—Ç—å", lambda b, w: b.dismiss())
            builder.show()
        run_on_ui_thread(show)

    def _show_month_dialog(self, year: int, month: int):
        self._ui_state["year"], self._ui_state["month"] = year, month
        def show():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å")
                return
            activity = fragment.getParentActivity()
            builder = AlertDialogBuilder(activity)
            builder.set_title("–ö–∞–ª–µ–Ω–¥–∞—Ä—å –º–µ—Å—è—Ü–∞")
            builder.set_message(self._render_month(year, month))

            def go_prev(bld: AlertDialogBuilder, which: int):
                y, m = self._shift_month(year, month, -1)
                bld.dismiss()
                self._show_month_dialog(y, m)

            def go_next(bld: AlertDialogBuilder, which: int):
                y, m = self._shift_month(year, month, +1)
                bld.dismiss()
                self._show_month_dialog(y, m)

            def go_today(bld: AlertDialogBuilder, which: int):
                today = datetime.today()
                bld.dismiss()
                self._show_month_dialog(today.year, today.month)

            builder.set_negative_button("‚óÄ –ü—Ä–µ–¥", go_prev)
            builder.set_neutral_button("–°–µ–≥–æ–¥–Ω—è", go_today)
            builder.set_positive_button("–°–ª–µ–¥ ‚ñ∂", go_next)
            builder.show()
        run_on_ui_thread(show)

    def _show_add_dialog(self, current_peer: Any):
        from android.widget import LinearLayout, EditText, TextView
        from android.view import ViewGroup
        from org.telegram.messenger import AndroidUtilities

        def show():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–æ—Ä–º—É")
                return
            activity = fragment.getParentActivity()

            ll = LinearLayout(activity)
            ll.setOrientation(1)
            pad = AndroidUtilities.dp(16)
            ll.setPadding(pad, pad, pad, pad)

            def add_field(label: str, hint: str, default_val: str = "") -> EditText:
                tv = TextView(activity)
                tv.setText(label)
                tv.setTextSize(16)
                ll.addView(tv, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
                et = EditText(activity)
                et.setHint(hint)
                if default_val:
                    et.setText(default_val)
                ll.addView(et, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
                return et

            today = datetime.today()
            date_et = add_field("–î–∞—Ç–∞ (YYYY-MM-DD)", "–ù–∞–ø—Ä.: 2025-10-25", today.strftime("%Y-%m-%d"))
            time_et = add_field("–í—Ä–µ–º—è (HH:MM)", "–ù–∞–ø—Ä.: 09:00", self.get_setting("default_time", DEFAULT_TIME_STR))
            title_et = add_field("–¢–µ–∫—Å—Ç —Å–æ–±—ã—Ç–∏—è", "–ù–∞–ø—Ä–∏–º–µ—Ä: –í—Å—Ç—Ä–µ—á–∞ —Å –∫–æ–º–∞–Ω–¥–æ–π", "")

            builder = AlertDialogBuilder(activity)
            builder.set_title("–î–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ")
            builder.set_view(ll)

            def on_ok(bld: AlertDialogBuilder, which: int):
                try:
                    date_str = date_et.getText().toString().strip()
                    time_str = time_et.getText().toString().strip() or self.get_setting("default_time", DEFAULT_TIME_STR)
                    title = title_et.getText().toString().strip()
                    if not title:
                        raise ValueError("–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–±—ã—Ç–∏—è")
                    dt = self._parse_datetime(date_str, time_str)
                    event = self._add_event(dt, title)
                    warn = None
                    if self.get_setting("enable_reminders", DEFAULT_ENABLE_REMINDERS):
                        scheduled = self._schedule_reminder(dt, title, current_peer or self._get_self_peer())
                        if not scheduled:
                            warn = "–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ (–ø—Ä–æ—à–µ–¥—à–µ–µ –≤—Ä–µ–º—è –∏–ª–∏ –æ—à–∏–±–∫–∞)."
                    text = "–°–æ–±—ã—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–æ\n" + self._format_single_event(event)
                    if warn:
                        text += f"\n{warn}"
                    self._reply_or_bulletin(text, kind="success", force_bulletin=True)
                except Exception as e:
                    BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {e}")
                finally:
                    bld.dismiss()

            builder.set_positive_button("–°–æ–∑–¥–∞—Ç—å", on_ok)
            builder.set_negative_button("–û—Ç–º–µ–Ω–∞", lambda b, w: b.dismiss())
            builder.show()

        run_on_ui_thread(show)

    def _show_list_dialog(self):
        def show():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫")
                return
            activity = fragment.getParentActivity()
            events = self._get_upcoming(10)
            builder = AlertDialogBuilder(activity)
            builder.set_title("–ë–ª–∏–∂–∞–π—à–∏–µ —Å–æ–±—ã—Ç–∏—è")
            builder.set_message(self._format_events_list(events))
            builder.set_negative_button("–ó–∞–∫—Ä—ã—Ç—å", lambda b, w: b.dismiss())
            builder.show()
        run_on_ui_thread(show)

    def _show_next_dialog(self):
        def show():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ")
                return
            activity = fragment.getParentActivity()
            ev = self._next_event()
            builder = AlertDialogBuilder(activity)
            builder.set_title("–ë–ª–∏–∂–∞–π—à–µ–µ —Å–æ–±—ã—Ç–∏–µ")
            builder.set_message(self._format_single_event(ev) if ev else "–ë–ª–∏–∂–∞–π—à–∏—Ö —Å–æ–±—ã—Ç–∏–π –Ω–µ—Ç")
            builder.set_negative_button("–ó–∞–∫—Ä—ã—Ç—å", lambda b, w: b.dismiss())
            builder.show()
        run_on_ui_thread(show)

    def _show_help_dialog(self):
        def show():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É")
                return
            activity = fragment.getParentActivity()
            builder = AlertDialogBuilder(activity)
            builder.set_title("–°–ø—Ä–∞–≤–∫–∞")
            builder.set_message(self._help_text())
            builder.set_negative_button("–ó–∞–∫—Ä—ã—Ç—å", lambda b, w: b.dismiss())
            builder.show()
        run_on_ui_thread(show)

    def _load_events(self) -> List[Event]:
        raw = self.get_setting("events_json", "[]")
        try:
            return json.loads(raw)
        except Exception:
            return []

    def _save_events(self, events: List[Event]):
        self.set_setting("events_json", json.dumps(events, ensure_ascii=False))

    def _next_id(self) -> int:
        nid = int(self.get_setting("next_id", 1))
        self.set_setting("next_id", nid + 1)
        return nid

    def _add_event(self, dt: datetime, title: str) -> Event:
        events = self._load_events()
        ev = {
            "id": self._next_id(),
            "ts": int(dt.timestamp()),
            "title": title,
            "created_at": int(time.time())
        }
        events.append(ev)
        events.sort(key=lambda e: e["ts"])
        self._save_events(events)
        return ev

    def _delete_event(self, eid: int) -> bool:
        events = self._load_events()
        new_events = [e for e in events if int(e.get("id")) != eid]
        if len(new_events) == len(events):
            return False
        self._save_events(new_events)
        return True

    def _get_upcoming(self, n: int) -> List[Event]:
        now_ts = int(time.time())
        events = [e for e in self._load_events() if int(e.get("ts", 0)) >= now_ts]
        events.sort(key=lambda e: e["ts"])
        return events[:max(1, n)]

    def _next_event(self) -> Optional[Event]:
        ups = self._get_upcoming(1)
        return ups[0] if ups else None

    def _get_self_peer(self) -> Optional[int]:
        try:
            uc = get_user_config()
            if hasattr(uc, "getClientUserId"):
                return int(uc.getClientUserId())
            user = uc.getCurrentUser()
            return int(user.id) if user else None
        except Exception as e:
            log(f"Self peer error: {e}")
            return None

    def _schedule_reminder(self, dt: datetime, title: str, current_peer: Any) -> bool:
        try:
            ts = int(dt.timestamp())
            if ts <= int(time.time()) + 5:
                return False
            remind_to_self = self.get_setting("remind_to_self", DEFAULT_REMIND_TO_SELF)
            peer = self._get_self_peer() if remind_to_self else current_peer
            if peer is None:
                return False
            params = {
                "peer": peer,
                "message": f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {title}\n–í—Ä–µ–º—è: {dt.strftime('%Y-%m-%d %H:%M')}",
                "scheduleDate": ts
            }
            send_message(params)
            self._reply_or_bulletin("–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ", kind="success", force_bulletin=True)
            return True
        except Exception as e:
            log(f"Schedule error: {e}")
            self._reply_or_bulletin("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ", kind="info", force_bulletin=True)
            return False

    def _format_single_event(self, e: Event) -> str:
        if not e:
            return "–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
        dt = datetime.fromtimestamp(int(e["ts"]))
        return f"#{e['id']} ‚Ä¢ {dt.strftime('%Y-%m-%d %H:%M')} ‚Ä¢ {e['title']}"

    def _format_events_list(self, events: List[Event]) -> str:
        if not events:
            return "–ù–µ—Ç –±–ª–∏–∂–∞–π—à–∏—Ö —Å–æ–±—ã—Ç–∏–π"
        lines = ["–ë–ª–∏–∂–∞–π—à–∏–µ —Å–æ–±—ã—Ç–∏—è:"]
        for e in events:
            lines.append(self._format_single_event(e))
        return "\n".join(lines)

    def _render_month(self, year: int, month: int) -> str:
        firstweekday = 0 if self.get_setting("week_start", 0) == 0 else 6
        cal = calendar.Calendar(firstweekday=firstweekday)
        weeks = cal.monthdayscalendar(year, month)
        header = f"{year}-{str(month).zfill(2)}"
        days_ru = ["–ü–Ω","–í—Ç","–°—Ä","–ß—Ç","–ü—Ç","–°–±","–í—Å"] if firstweekday == 0 else ["–í—Å","–ü–Ω","–í—Ç","–°—Ä","–ß—Ç","–ü—Ç","–°–±"]
        lines = [header, " ".join(f"{d:>2}" for d in days_ru)]
        today = datetime.today()
        for w in weeks:
            row = []
            for d in w:
                if d == 0:
                    row.append("  ")
                else:
                    mark = f"{d:02}"
                    if today.year == year and today.month == month and today.day == d:
                        mark = f"[{mark}]"
                    row.append(mark)
            lines.append(" ".join(f"{c:>2}" for c in row))
        return "\n".join(lines)

    def _parse_int(self, s: str) -> int:
        try:
            return int(s)
        except Exception:
            return 0

    def _parse_year_month(self, s: str) -> Tuple[int, int]:
        s = s.strip()
        if re.match(r"^\d{4}-\d{2}$", s):
            y, m = s.split("-")
            return int(y), int(m)
        now = datetime.now()
        return now.year, now.month

    def _parse_datetime(self, date_str: str, time_str: str) -> datetime:
        if not re.match(r"^\d{4}-\d{2}-\d{2}$", date_str):
            raise ValueError("–î–∞—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD")
        if not re.match(r"^\d{2}:\d{2}$", time_str):
            raise ValueError("–í—Ä–µ–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM")
        y, m, d = [int(x) for x in date_str.split("-")]
        hh, mm = [int(x) for x in time_str.split(":")]
        return datetime(year=y, month=m, day=d, hour=hh, minute=mm)

    def _shift_month(self, year: int, month: int, delta: int) -> Tuple[int, int]:
        m0 = (month - 1) + delta
        y = year + m0 // 12
        m = (m0 % 12) + 1
        return y, m

    def _reply(self, peer: Any, text: str):
        if not peer:
            return
        params = { "peer": peer, "message": text }
        send_message(params)

    def _reply_or_bulletin(self, text: str, kind: str = "info", force_bulletin: bool = False):
        try:
            use_bulletin = self.get_setting("confirm_as_bulletin", DEFAULT_CONFIRM_AS_BULLETIN) or force_bulletin
            if not use_bulletin:
                peer = None
                frag = get_last_fragment()
                if frag and hasattr(frag, "getDialogId"):
                    peer = frag.getDialogId()
                if peer:
                    self._reply(peer, text)
                else:
                    BulletinHelper.show_info(text)
                return

            from org.telegram.messenger import R as R_tg
            icon_map = {
                "success": getattr(R_tg.raw, "success", getattr(R_tg.raw, "check", R_tg.raw.info)),
                "delete": getattr(R_tg.raw, "delete", R_tg.raw.info),
                "info": R_tg.raw.info
            }
            icon_id = icon_map.get(kind, R_tg.raw.info)

            def _noop():
                return

            BulletinHelper.show_with_button(
                text,
                icon_id,
                "OK",
                _noop
            )
        except Exception as e:
            log(f"Bulletin fallback: {e}")
            BulletinHelper.show_info(text)

    def _help_text(self) -> str:
        prefix = self.get_setting("prefix", DEFAULT_PREFIX)
        return (
            "–ö–∞–ª–µ–Ω–¥–∞—Ä—å ‚Äî –æ—Ñ–ª–∞–π–Ω —Å–æ–±—ã—Ç–∏—è –∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è\n"
            f"{prefix} ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ –∫–∞–ª–µ–Ω–¥–∞—Ä—è (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)\n"
            f"{prefix} add YYYY-MM-DD [HH:MM] –¢–µ–∫—Å—Ç ‚Äî –¥–æ–±–∞–≤–∏—Ç—å\n"
            f"{prefix} list [N] ‚Äî —Å–ø–∏—Å–æ–∫ –±–ª–∏–∂–∞–π—à–∏—Ö\n"
            f"{prefix} del ID ‚Äî —É–¥–∞–ª–∏—Ç—å\n"
            f"{prefix} month [YYYY-MM] ‚Äî –∫–∞–ª–µ–Ω–¥–∞—Ä—å –º–µ—Å—è—Ü–∞\n"
            f"{prefix} next ‚Äî –±–ª–∏–∂–∞–π—à–µ–µ —Å–æ–±—ã—Ç–∏–µ\n"
            f"{prefix} clear ‚Äî —É–¥–∞–ª–∏—Ç—å –≤—Å–µ"
        )

    def _cmd_add(self, rest: str, current_peer: Any) -> Tuple[Event, Optional[str]]:
        parts = rest.split()
        if not parts:
            raise ValueError("–§–æ—Ä–º–∞—Ç: .cal add YYYY-MM-DD [HH:MM] –¢–µ–∫—Å—Ç")
        date_str = parts[0]
        time_str = self.get_setting("default_time", DEFAULT_TIME_STR)
        title_start_idx = 1
        if len(parts) > 1 and re.match(r"^\d{2}:\d{2}$", parts[1]):
            time_str = parts[1]
            title_start_idx = 2
        title = " ".join(parts[title_start_idx:]).strip()
        if not title:
            raise ValueError("–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–±—ã—Ç–∏—è")
        dt = self._parse_datetime(date_str, time_str)
        event = self._add_event(dt, title)
        warn = None
        if self.get_setting("enable_reminders", DEFAULT_ENABLE_REMINDERS):
            scheduled = self._schedule_reminder(dt, title, current_peer)
            if not scheduled:
                warn = "–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ (–ø—Ä–æ—à–µ–¥—à–µ–µ –≤—Ä–µ–º—è –∏–ª–∏ –æ—à–∏–±–∫–∞)."
        return event, warn