__id__ = "saved_cleaner_ultimate"
__name__ = "Saved Cleaner"
__description__ = "Удаление дубликатов из Избранного"
__author__ = "@kaufapuk"
__version__ = "1.0.0"
__icon__ = "exteraPlugins/1"
__min_version__ = "12.2.10"

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import send_request
from android_utils import log, run_on_ui_thread, OnClickListener
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder

from org.telegram.tgnet import TLRPC
from org.telegram.messenger import UserConfig, MessagesController, FileLoader, AndroidUtilities
from org.telegram.ui import LaunchActivity, ChatActivity
from android.app import ProgressDialog
from android.widget import ScrollView, TextView, LinearLayout, ImageView, FrameLayout
from android.view import Gravity
from android.graphics import BitmapFactory, Typeface
from android.graphics.drawable import GradientDrawable
from android.os import Bundle

# Java Imports
from java.util import ArrayList
from java.lang import Integer
from java.io import File

import hashlib

class SavedCleanerPlugin(BasePlugin):
    
    def __init__(self):
        self.seen_hashes = {} 
        self.duplicate_msgs = [] 
        self.duplicate_ids = []
        self.is_processing = False
        self.last_msg_id = 0
        self.total_scanned = 0
        self.progress_dialog = None
        self.self_id = 0
        self.dialog_instance = None

    def on_plugin_load(self):
        menu_item = MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU, 
            text="Найти дубликаты",
            icon="ic_delete",
            on_click=self.check_and_start             
        )
        self.add_menu_item(menu_item)

    def show_progress(self):
        def _run():
            try:
                act = LaunchActivity.instance
                if not act: return
                self.progress_dialog = ProgressDialog(act)
                self.progress_dialog.setMessage("Сканирование...")
                self.progress_dialog.setCancelable(False)
                self.progress_dialog.show()
            except: pass
        run_on_ui_thread(_run)

    def update_progress(self, scanned, dups):
        def _run():
            if self.progress_dialog and self.progress_dialog.isShowing():
                self.progress_dialog.setMessage(f"Просканированно: {scanned}\nНайдено дубликатов: {dups}")
        run_on_ui_thread(_run)

    def hide_progress(self):
        def _run():
            if self.progress_dialog:
                self.progress_dialog.dismiss()
                self.progress_dialog = None
        run_on_ui_thread(_run)

    def check_and_start(self, param):
        if self.is_processing:
            BulletinHelper.show_error("Busy!")
            return

        dialog_id = param.get('dialog_id')
        account_id = UserConfig.selectedAccount
        self.self_id = UserConfig.getInstance(account_id).getClientUserId()

        if dialog_id != self.self_id:
            BulletinHelper.show_error("Только для Избранного!")
            return

        self.is_processing = True
        self.seen_hashes = {}
        self.duplicate_msgs = []
        self.duplicate_ids = []
        self.last_msg_id = 0
        self.total_scanned = 0
        
        self.show_progress()
        self.fetch_history_chunk()

    def get_message_hash(self, msg):
        content_str = ""
        if msg.message: content_str += f"TXT:{msg.message}"
        if msg.media:
            if isinstance(msg.media, TLRPC.TL_messageMediaPhoto):
                if hasattr(msg.media, 'photo') and msg.media.photo:
                    content_str += f"IMG:{msg.media.photo.id}"
            elif isinstance(msg.media, TLRPC.TL_messageMediaDocument):
                if hasattr(msg.media, 'document') and msg.media.document:
                    doc = msg.media.document
                    content_str += f"DOC:{doc.id}:{doc.size}"
            elif isinstance(msg.media, TLRPC.TL_messageMediaWebPage):
                if hasattr(msg.media, 'webpage') and hasattr(msg.media.webpage, 'url'):
                    content_str += f"URL:{msg.media.webpage.url}"

        if not content_str: return None
        return hashlib.md5(content_str.encode('utf-8')).hexdigest()

    def fetch_history_chunk(self):
        if not self.is_processing: return

        req = TLRPC.TL_messages_getHistory()
        req.peer = TLRPC.TL_inputPeerSelf()
        req.offset_id = self.last_msg_id
        req.limit = 100
        req.add_offset = 0
        req.min_id = 0
        req.max_id = 0
        req.hash = 0

        send_request(req, self.on_history_response)

    def on_history_response(self, response, error):
        if error:
            self.finish_scan(error=error.text)
            return

        messages = response.messages
        if messages.isEmpty():
            self.finish_scan()
            return

        for i in range(messages.size()):
            msg = messages.get(i)
            self.last_msg_id = msg.id
            if isinstance(msg.action, TLRPC.TL_messageActionHistoryClear): continue
            
            msg_hash = self.get_message_hash(msg)
            if msg_hash:
                if msg_hash in self.seen_hashes:
                    self.duplicate_ids.append(msg.id)
                    if len(self.duplicate_msgs) < 50:
                        self.duplicate_msgs.append(msg)
                else:
                    self.seen_hashes[msg_hash] = msg.id

        self.total_scanned += messages.size()
        self.update_progress(self.total_scanned, len(self.duplicate_ids))

        if messages.size() < 100:
            self.finish_scan()
        else:
            self.fetch_history_chunk()

    def finish_scan(self, error=None):
        self.is_processing = False
        self.hide_progress()
        if error:
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка: {error}"))
            return
        if not self.duplicate_ids:
            run_on_ui_thread(lambda: BulletinHelper.show_info("Чисто! Нет дубликатов"))
            return
        run_on_ui_thread(self.show_result_dialog)

    def to_java_color(self, hex_val):
        return int(hex_val - 0x100000000) if hex_val > 0x7FFFFFFF else hex_val

    def open_message(self, msg_id):
        try:
            if self.dialog_instance:
                self.dialog_instance.dismiss()
            args = Bundle()
            args.putLong("user_id", self.self_id)
            args.putInt("message_id", msg_id)
            LaunchActivity.instance.presentFragment(ChatActivity(args))
        except Exception as e:
            log(f"Nav error: {e}")

    def create_preview_row(self, context, msg):
        row = LinearLayout(context)
        row.setOrientation(0) 
        row.setGravity(Gravity.CENTER_VERTICAL)
        row.setPadding(0, 12, 0, 12)
        row.setOnClickListener(OnClickListener(lambda v: self.open_message(msg.id)))
        
        icon_container = FrameLayout(context)
        params = LinearLayout.LayoutParams(110, 110) 
        params.rightMargin = 25
        icon_container.setLayoutParams(params)
        
        image_view = ImageView(context)
        image_view.setLayoutParams(FrameLayout.LayoutParams(-1, -1))
        image_view.setScaleType(ImageView.ScaleType.CENTER_CROP)
        
        shape = GradientDrawable()
        shape.setCornerRadius(18)
        
        COLOR_BLUE = self.to_java_color(0xFF3b82f6)
        COLOR_RED = self.to_java_color(0xFFef4444)
        COLOR_GREEN = self.to_java_color(0xFF22c55e)
        COLOR_GRAY = self.to_java_color(0xFF333333)
        
        is_image_loaded = False
        file_ext_text = ""

        if msg.media:
            if isinstance(msg.media, TLRPC.TL_messageMediaPhoto):
                try:
                    photo = msg.media.photo
                    thumb_loc = None
                    if photo.sizes.size() > 0:
                        thumb_loc = FileLoader.getInstance(UserConfig.selectedAccount).getPathToAttach(photo.sizes.get(0), True)
                    
                    for i in range(photo.sizes.size()):
                        s = photo.sizes.get(i)
                        if s.type == "m" or s.type == "x":
                            possible_file = FileLoader.getInstance(UserConfig.selectedAccount).getPathToAttach(s, True)
                            if possible_file.exists():
                                thumb_loc = possible_file
                                break
                    
                    if thumb_loc and thumb_loc.exists():
                        bmp = BitmapFactory.decodeFile(thumb_loc.getAbsolutePath())
                        if bmp:
                            image_view.setImageBitmap(bmp)
                            is_image_loaded = True
                    
                    if not is_image_loaded:
                        shape.setColor(COLOR_BLUE)
                        file_ext_text = "IMG"
                except:
                    shape.setColor(COLOR_BLUE)
                    file_ext_text = "ERR"

            elif isinstance(msg.media, TLRPC.TL_messageMediaDocument):
                shape.setColor(COLOR_RED)
                doc = msg.media.document
                attr_name = None
                for i in range(doc.attributes.size()):
                    a = doc.attributes.get(i)
                    if isinstance(a, TLRPC.TL_documentAttributeFilename):
                        attr_name = a
                        break
                
                if attr_name:
                    parts = attr_name.file_name.split('.')
                    file_ext_text = parts[-1].upper()[:4] if len(parts) > 1 else "FILE"
                else:
                    file_ext_text = doc.mime_type.split('/')[-1].upper()[:4]

            elif isinstance(msg.media, TLRPC.TL_messageMediaWebPage):
                shape.setColor(COLOR_BLUE)
                file_ext_text = "LINK"
            else:
                shape.setColor(COLOR_GREEN)
                file_ext_text = "MEDIA"
        else:
            shape.setColor(COLOR_GRAY)
            file_ext_text = "TXT"

        if not is_image_loaded:
            image_view.setBackground(shape)
            ext_tv = TextView(context)
            ext_tv.setText(file_ext_text)
            ext_tv.setTextColor(self.to_java_color(0xFFFFFFFF))
            ext_tv.setTextSize(10.0)
            ext_tv.setTypeface(None, Typeface.BOLD)
            ext_tv.setGravity(Gravity.CENTER)
            icon_container.addView(image_view)
            icon_container.addView(ext_tv)
        else:
            icon_container.addView(image_view)

        row.addView(icon_container)

        text_view = TextView(context)
        preview_text = "Message"
        if msg.message:
            preview_text = msg.message.replace("\n", " ")
        elif msg.media:
            if isinstance(msg.media, TLRPC.TL_messageMediaPhoto): preview_text = "Photo"
            elif isinstance(msg.media, TLRPC.TL_messageMediaDocument): 
                doc = msg.media.document
                attr = None
                for i in range(doc.attributes.size()):
                    a = doc.attributes.get(i)
                    if isinstance(a, TLRPC.TL_documentAttributeFilename):
                        attr = a
                        break
                preview_text = attr.file_name if attr else "Document"
            elif isinstance(msg.media, TLRPC.TL_messageMediaWebPage): 
                preview_text = msg.media.webpage.url if hasattr(msg.media.webpage, 'url') else "Link"
        
        if len(preview_text) > 60: preview_text = preview_text[:60] + "..."
        
        text_view.setText(preview_text)
        text_view.setTextSize(14.0)
        text_view.setTextColor(self.to_java_color(0xFFE0E0E0)) 
        
        row.addView(text_view)
        return row

    def show_result_dialog(self):
        act = LaunchActivity.instance
        if not act: return

        count = len(self.duplicate_ids)
        
        main_layout = LinearLayout(act)
        main_layout.setOrientation(1) 
        
        hint = TextView(act)
        hint.setText("Tap on item to view in chat")
        hint.setTextSize(12.0)
        hint.setTextColor(self.to_java_color(0xFF888888))
        hint.setPadding(40, 20, 40, 0)
        main_layout.addView(hint)

        scroll = ScrollView(act)
        scroll.setPadding(40, 20, 40, 20)
        
        list_layout = LinearLayout(act)
        list_layout.setOrientation(1)
        
        for msg in self.duplicate_msgs:
            row = self.create_preview_row(act, msg)
            list_layout.addView(row)
            
        if count > len(self.duplicate_msgs):
            more_text = TextView(act)
            more_text.setText(f"\n...and {count - len(self.duplicate_msgs)} more.")
            more_text.setTextColor(self.to_java_color(0xFF888888))
            more_text.setGravity(Gravity.CENTER)
            list_layout.addView(more_text)

        scroll.addView(list_layout)
        main_layout.addView(scroll)

        builder = AlertDialogBuilder(act)
        builder.set_title(f"Найдено {count} дубликатов")
        
        builder.set_view(main_layout)
        
        builder.set_positive_button("Удалить всё", self.perform_deletion)
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        
        builder.set_negative_button("Отмена", lambda b, w: b.dismiss())
        
        self.dialog_instance = builder.show().get_dialog()

    def perform_deletion(self, builder, which):
        builder.dismiss()
        if not self.duplicate_ids: return

        try:
            java_ids = ArrayList()
            for mid in self.duplicate_ids:
                java_ids.add(Integer(mid))

            account_id = UserConfig.selectedAccount
            controller = MessagesController.getInstance(account_id)
            
            # (messages, randomIds, encryptedChat, channelId, classGuid, forAll, scheduleDate)
            controller.deleteMessages(java_ids, None, None, 0, 0, False, 0)
            
            BulletinHelper.show_success(f"Deleted {len(self.duplicate_ids)} messages.")
        except Exception as e:
            log(f"Delete error: {e}")
            BulletinHelper.show_error("Deletion failed!")