from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from ui.settings import Input, Header, Selector, Text
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment

__id__ = "fix_endpoint_gooey"
__name__ = "Notch Fix"
__description__ = "изменяет конечную точку аватарки в профиле"
__icon__ = "feature_plugins/0"
__version__ = "3.0"
__min_version__ = "12.1.1"
__author__ = "@feature_plugins"

CONF_MODE = "notch_mode"
CONF_OFFSET_Y = "notch_offset_y"
CONF_RECT_L = "notch_rect_l"
CONF_RECT_T = "notch_rect_t"
CONF_RECT_R = "notch_rect_r"
CONF_RECT_B = "notch_rect_b"

MODE_HIDE = "0"
MODE_OFFSET = "1"
MODE_FORCE = "2"

STRINGS = {
    "ru": {
        "label_mode": "Режим",
        "mode_hide": "Выреза нету",
        "mode_offset": "Смещение",
        "mode_force": "Ручной",
        "label_offset": "Сдвиг (DP)",
        "hint_offset": "Положит. = вниз, Отрицат. = вверх",
        "label_l": "Слева [DP]",
        "label_t": "Сверху [DP]",
        "label_r": "Справа [DP]",
        "label_b": "Снизу [DP]",
        "force_hint": "Если все 0 - используется системное значение",
        "faq_btn": "FAQ / Справка",
        "faq_title": "Справка",
        "faq_content": "Режим 'Выреза нету': Скрывает вырез.\n\nРежим 'Смещение': Поднимает/Опускает.\n\nРежим 'Ручной': Позволяет задать точные координаты RectF.\n\nЕсли не меняется - перезапуск.",
        "btn_ok": "Понятно",
    },
    "en": {
        "label_mode": "Mode",
        "mode_hide": "No notch",
        "mode_offset": "Offset",
        "mode_force": "Manual",
        "label_offset": "Vertical Offset (DP)",
        "hint_offset": "Positive = down, Negative = up",
        "label_l": "Left [DP]",
        "label_t": "Top [DP]",
        "label_r": "Right [DP]",
        "label_b": "Bottom [DP]",
        "force_hint": "If all are 0 - system default is used",
        "faq_btn": "FAQ / Help",
        "faq_title": "Help",
        "faq_content": "Mode 'No notch': Hides the notch.\n\nMode 'Offset': Raises/Lowers.\n\nMode 'Manual': Custom RectF coordinates.\n\nIf it doesn't change, restart.",
        "btn_ok": "Got it",
    }
}

def get_language():
    """Определяет язык системы используя Java Locale API"""
    try:
        Locale = find_class("java.util.Locale")
        return "ru" if Locale.getDefault().getLanguage() == "ru" else "en"
    except:
        return "en"

def get_string(key):
    lang = get_language()
    return STRINGS.get(lang, STRINGS["en"]).get(key, STRINGS["en"].get(key, ""))

class Plugin(BasePlugin):
    def on_plugin_load(self):
        try:
            target = find_class("org.telegram.messenger.NotchInfoUtils")
            m = target.getClass().getDeclaredMethod("getInfo", find_class("android.content.Context"))
            m.setAccessible(True)
            self.hook_method(m, NotchHook(self))
        except Exception as e:
            self.log(f"Hook Error: {e}")

    def create_settings(self):
        current_mode = int(self.get_setting(CONF_MODE, MODE_OFFSET))
        current_offset = self.get_setting(CONF_OFFSET_Y, "0")
        
        # RectF Settings
        current_l = self.get_setting(CONF_RECT_L, "0")
        current_t = self.get_setting(CONF_RECT_T, "0")
        current_r = self.get_setting(CONF_RECT_R, "0")
        current_b = self.get_setting(CONF_RECT_B, "0")
        
        items = [get_string("mode_hide"), get_string("mode_offset"), get_string("mode_force")]
        
        settings = [
            Selector(key=CONF_MODE, text=get_string("label_mode"), default=current_mode, items=items)
        ]
        
        if current_mode == 1:
            settings.extend([
                Input(
                    CONF_OFFSET_Y, 
                    get_string("label_offset"),
                    default=current_offset
                ),
                Header(get_string("hint_offset"))
            ])
        elif current_mode == 2:
            settings.extend([
                Input(CONF_RECT_L, get_string("label_l"), default=current_l),
                Input(CONF_RECT_T, get_string("label_t"), default=current_t),
                Input(CONF_RECT_R, get_string("label_r"), default=current_r),
                Input(CONF_RECT_B, get_string("label_b"), default=current_b),
                Header(get_string("force_hint"))
            ])
        
        # FAQ Button
        settings.append(
            Text(
                text=get_string("faq_btn"),
                on_click=self.show_faq
            )
        )
        
        return settings

    def show_faq(self, view):
        frag = get_last_fragment()
        if not frag:
            return
        act = frag.getParentActivity()
        if not act:
            return
            
        b = AlertDialogBuilder(act)
        b.set_title(get_string("faq_title"))
        b.set_message(get_string("faq_content"))
        b.set_positive_button(get_string("btn_ok"), lambda b, w: b.dismiss())
        b.show()

class NotchHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        # Кэшируем класс при инициализации, чтобы не искать его каждый раз
        self._au_class = None
        self.detected = False

    def _get_au_class(self):
        """Кэшируем AndroidUtilities класс"""
        if self._au_class is None:
            self._au_class = find_class("org.telegram.messenger.AndroidUtilities")
        return self._au_class

    def after_hooked_method(self, param):
        try:
            original = param.getResult()
            mode = int(self.plugin.get_setting(CONF_MODE, MODE_OFFSET))
            
            # Режим 0 - "выреза нету" - возвращаем null
            if mode == 0:
                if original is not None:
                    param.setResult(None)
                return
            
            # Режим 1 - смещения
            if mode == 1:
                if original is None:
                    return
                    
                offset_dp = int(self.plugin.get_setting(CONF_OFFSET_Y, "0"))
                if offset_dp == 0:
                    return
                
                # Используем кэшированный класс
                AU = self._get_au_class()
                offset_px = float(AU.dp(float(offset_dp)))
                
                original.bounds.top += offset_px
                original.bounds.bottom += offset_px
                return

            # Режим 2 - Ручной
            if mode == 2:
                # Читаем настройки
                l_str = self.plugin.get_setting(CONF_RECT_L, "0")
                t_str = self.plugin.get_setting(CONF_RECT_T, "0")
                r_str = self.plugin.get_setting(CONF_RECT_R, "0")
                b_str = self.plugin.get_setting(CONF_RECT_B, "0")
                
                AU = self._get_au_class()

                # Авто-определение (если все настройки по нулям)
                if r_str == "0" and not self.detected and original is not None:
                    density = float(AU.density)
                    real_l = int(original.bounds.left / density)
                    real_t = int(original.bounds.top / density)
                    real_r = int(original.bounds.right / density)
                    real_b = int(original.bounds.bottom / density)
                    
                    self.plugin.set_setting(CONF_RECT_L, str(real_l))
                    self.plugin.set_setting(CONF_RECT_T, str(real_t))
                    self.plugin.set_setting(CONF_RECT_R, str(real_r))
                    self.plugin.set_setting(CONF_RECT_B, str(real_b))
                    
                    l_str = str(real_l)
                    t_str = str(real_t)
                    r_str = str(real_r)
                    b_str = str(real_b)
                    self.detected = True
                
                l_dp = int(l_str)
                t_dp = int(t_str)
                r_dp = int(r_str)
                b_dp = int(b_str)

                # Если настройки 0 (после детекта) - используем системное (если есть) или выходим
                if r_dp <= 0 and l_dp <= 0:
                    return

                # Если оригинала нет - создаем
                if original is None:
                    NotchInfo = find_class("org.telegram.messenger.NotchInfoUtils$NotchInfo")
                    RectF = find_class("android.graphics.RectF")
                    original = NotchInfo.newInstance()
                    original.bounds = RectF.newInstance()
                    param.setResult(original)

                # Вычисляем px
                l_px = float(AU.dp(float(l_dp)))
                t_px = float(AU.dp(float(t_dp)))
                r_px = float(AU.dp(float(r_dp)))
                b_px = float(AU.dp(float(b_dp)))

                # Применяем границы
                b = original.bounds
                b.left = l_px
                b.top = t_px
                b.right = r_px
                b.bottom = b_px
                
                # Настройки типа выреза
                original.gravity = 17 # CENTER
                original.isLikelyCircle = True

        except Exception:
            pass