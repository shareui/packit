from collections import deque
from datetime import datetime
from typing import List

from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, HookResult
from client_utils import send_message, get_user_config, get_messages_controller, get_messages_storage
from java import jint
from java.util import ArrayList
from markdown_utils import parse_markdown
from org.telegram.messenger import MessageObject
from org.telegram.tgnet import TLRPC

__id__ = "sender"
__name__ = "Sender"
__description__ = "Re-send messages from **another devices** with **plugins**.\n**Usage**: `.send [message]` | `.ping`\n**Note**: Enable **Keep-Alive Service** and **Background Connection** for better experience."
__author__ = "@immat0x1"
__version__ = "1.0.2"
__min_version__ = "11.12.1"
__icon__ = "exteraPlugins/2"

PING_EMOJI_PC = "5870748341150683538"
PING_EMOJI_TIME = "5872756762347573066"
DELETE_DELAY_MS = 150

def _delete_messages(msg_ids: List[int], chat_id: int, topic_id: int = 0):
    if not msg_ids:
        return
    msgs_list = ArrayList()
    for msg_id in msg_ids:
        msgs_list.add(jint(msg_id))

    messages_ctrl = get_messages_controller()
    if messages_ctrl:
        messages_ctrl.deleteMessages(msgs_list, None, None, chat_id, topic_id, False, 0)


def _send_message(cmd_text: str, original_mo: MessageObject):
    chat_id = original_mo.getDialogId()
    topic_id = original_mo.getTopicId()

    try:
        parsed = parse_markdown(cmd_text)
        text = parsed.text
        entities = [e.to_tlrpc_object() for e in parsed.entities]
    except Exception as e:
        log(f"Markdown error: {e}")
        text = cmd_text
        entities = []

    params = {
        "message": text,
        "peer": chat_id,
        "entities": entities,
    }

    if topic_id:
        params["topicId"] = topic_id

    reply_id = original_mo.getReplyMsgId()
    if reply_id:
        reply_msg = get_messages_storage().getMessage(chat_id, reply_id)
        if reply_msg:
            reply_mo = MessageObject(get_user_config().selectedAccount, reply_msg, False, False)
            params["replyToMsg"] = reply_mo
            params["replyToTopMsg"] = reply_mo

    send_message(params)
    run_on_ui_thread(lambda: _delete_messages([original_mo.getId()], chat_id, topic_id), DELETE_DELAY_MS)


def _get_uptime(start_time: datetime) -> str:
    delta = datetime.now() - start_time
    total_seconds = int(delta.total_seconds())

    days, rem = divmod(total_seconds, 86400)
    hours, rem = divmod(rem, 3600)
    minutes, seconds = divmod(rem, 60)

    parts = []
    if days: parts.append(f"{days}d")
    if hours: parts.append(f"{hours}h")
    if minutes: parts.append(f"{minutes}m")
    parts.append(f"{seconds}s")

    return " ".join(parts)


class Sender(BasePlugin):
    def __init__(self):
        super().__init__()
        self.send_prefix = ".send "
        self.ping_command = ".ping"
        self.start_time = None
        self.processed_messages_cache = deque(maxlen=100)

    def on_plugin_load(self):
        self.add_hook("updateNewMessage", match_substring=True)
        self.add_hook("updateNewChannelMessage", match_substring=True)
        self.start_time = datetime.now()

    def on_updates_hook(self, container_name: str, account: int, updates_container: any) -> HookResult:
        updates = getattr(updates_container, 'updates', None)
        if updates:
            for update in updates.toArray():
                self._handle_update(account, update)
        return HookResult()

    def on_update_hook(self, update_name: str, account: int, update: any) -> HookResult:
        self._handle_update(account, update)
        return HookResult()

    def _handle_update(self, account: int, update: any):
        if not isinstance(update, (TLRPC.TL_updateNewMessage, TLRPC.TL_updateNewChannelMessage)):
            return

        msg = getattr(update, 'message', None)
        if not msg:
            return

        mo = MessageObject(account, msg, False, False)

        if mo.getSenderId() != get_user_config().getClientUserId():
            return

        unique_id = (mo.getDialogId(), mo.getId())
        if unique_id in self.processed_messages_cache:
            return

        self.processed_messages_cache.append(unique_id)
        self._process_message(mo)

    def _process_message(self, mo: MessageObject):
        text = mo.messageText
        if not text:
            return

        if text.startswith(self.send_prefix):
            cmd = text[len(self.send_prefix):]
            if cmd:
                _send_message(cmd, mo)

        elif text == self.ping_command:
            uptime = _get_uptime(self.start_time)
            resp = (
                f"[üíª]({PING_EMOJI_PC}) *Sender is alive!*\n"
                f"[‚è≤]({PING_EMOJI_TIME}) Uptime: `{uptime}`"
            )
            _send_message(resp, mo)
