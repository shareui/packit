import weakref
from typing import Dict, Any

from base_plugin import BasePlugin
from java import dynamic_proxy
from android_utils import log, OnClickListener
from client_utils import run_on_ui_thread, send_request, RequestCallback, get_last_fragment

from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment
from org.telegram.messenger import MessagesController, ContactsController, R, UserObject
from org.telegram.tgnet import TLRPC
from org.telegram.tgnet.tl import TL_account
from org.telegram.ui.Components import UItem
from org.telegram.ui.Cells import ProfileSearchCell
from java.util import ArrayList

__id__ = "custom_privacy"
__name__ = "Custom Privacy"
__description__ = "Manage individual user privacy settings from their profile."
__version__ = "1.0.0"
__author__ = "@luvztroy"

class UserPrivacyDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):

    PRIVACY_TYPES = {
        0:  "Last Seen & Online",
        1:  "Invites",
        2:  "Call",
        3:  "Peer-to-Peer Calls",
        4:  "Profile Photos",
        5:  "Forwarded Messages",
        6:  "Phone Number",
        7:  "Added by Phone",
        8:  "Voice Messages",
        9:  "Bio",
        10: "Messages",
        11: "Birthday",
        12: "Gifts",
        13: "Paid Messages",
        14: "Saved Music",
    }

    STATE_DEFAULT = 0
    STATE_ALWAYS  = 1
    STATE_NEVER   = 2

    STATE_LABELS = {
        STATE_DEFAULT: "Default",
        STATE_ALWAYS:  "Enabled",
        STATE_NEVER:   "Disabled",
    }

    def __init__(self, plugin, user, account):
        super().__init__()
        self._plugin_ref = weakref.ref(plugin)
        self.user = user
        self.account = account
        self.fragment = None
        self.current_states = {}
        self.loading = True
        self._pending_fetches = len(self.PRIVACY_TYPES)

    @property
    def plugin(self):
        return self._plugin_ref()

    def getTitle(self):
        return "Privacy"

    def onFragmentCreate(self):
        run_on_ui_thread(lambda: self._fetch_all_privacy(), 1200)

    def onFragmentDestroy(self): pass

    def beforeCreateView(self): return None

    def afterCreateView(self, view):
        if self.fragment and self.fragment.listView:
            adapter = self.fragment.listView.getAdapter()
            if adapter:
                try:
                    adapter.setUseSectionStyle(True)
                except Exception:
                    pass
        return view

    def onBackPressed(self):
        return True

    def onMenuItemClick(self, id): pass

    def _fetch_all_privacy(self):
        for privacy_type in self.PRIVACY_TYPES:
            self._fetch_privacy(privacy_type)

    def _fetch_privacy(self, privacy_type):
        key_factory = self.plugin.INPUT_PRIVACY_KEYS.get(privacy_type)
        if not key_factory: return
        req = TL_account.getPrivacy()
        req.key = key_factory()

        def on_response(response, error):
            if error or not response: return
            def process():
                contacts = ContactsController.getInstance(self.account)
                MessagesController.getInstance(self.account).putUsers(response.users, False)
                MessagesController.getInstance(self.account).putChats(response.chats, False)
                contacts.setPrivacyRules(response.rules, privacy_type)

                state = self.STATE_DEFAULT
                for i in range(response.rules.size()):
                    rule = response.rules.get(i)
                    if isinstance(rule, TLRPC.TL_privacyValueAllowUsers):
                        if rule.users.contains(self.user.id):
                            state = self.STATE_ALWAYS
                            break
                    elif isinstance(rule, TLRPC.TL_privacyValueDisallowUsers):
                        if rule.users.contains(self.user.id):
                            state = self.STATE_NEVER
                            break

                self.current_states[privacy_type] = state
                self._pending_fetches -= 1

                if self._pending_fetches <= 0:
                    self.loading = False

                if self.fragment and self.fragment.listView:
                    adapter = self.fragment.listView.getAdapter()
                    if self.loading == False and self._pending_fetches <= 0:
                        adapter.update(True)
                    else:
                        search_id = 1000 if privacy_type == 0 else privacy_type
                        for i in range(adapter.getItemCount()):
                            item = adapter.getItem(i)
                            if item and int(item.id) == search_id:
                                effective = self._is_allowed_by_rules(self.user, response.rules, state)
                                item.subtext = self.STATE_LABELS.get(state, "")
                                item.checked = effective
                                adapter.notifyItemChanged(i)
                                break
            
            run_on_ui_thread(process)

        send_request(req, RequestCallback(on_response))

    def _set_state(self, privacy_type, new_state):
        if self.current_states.get(privacy_type) == new_state: return
        self.current_states[privacy_type] = new_state

        if self.fragment and self.fragment.listView:
            adapter = self.fragment.listView.getAdapter()
            search_id = 1000 if privacy_type == 0 else privacy_type

            for i in range(adapter.getItemCount()):
                item = adapter.getItem(i)
                if item and int(item.id) == search_id:
                    contacts = ContactsController.getInstance(self.account)
                    rules = contacts.getPrivacyRules(privacy_type)
                    effective = self._is_allowed_by_rules(self.user, rules, new_state)

                    item.subtext = self.STATE_LABELS.get(new_state, "")
                    item.checked = effective
                    adapter.notifyItemChanged(i)
                    break

        self.plugin.update_user_privacy(
            self.account, self.user, privacy_type, new_state, self._on_update_done
        )

    def _on_update_done(self, privacy_type, success):
        if not success:
            self._check_all_states()
            if self.fragment and self.fragment.listView:
                self.fragment.listView.getAdapter().update(True)

    def fillItems(self, items: Any, adapter: Any):
        try:
            last_frag = get_last_fragment()
            if not last_frag:
                return

            context = last_frag.getContext()
            if not context:
                return

            user_cell = ProfileSearchCell(context)
            user_cell.setData(self.user, None, None, None, False, False)
            items.add(UItem.asCustom(-1, user_cell))

            is_contact = ContactsController.getInstance(self.account).contactsDict.get(int(self.user.id)) is not None
            if is_contact:
                delete_item = UItem.asButton(100, R.drawable.msg_delete, "Delete Contact").red()
                items.add(delete_item)
                name = UserObject.getFirstName(self.user)
                items.add(UItem.asShadow("Also " + name + " added you to their contacts."))

            if self.loading:
                items.add(UItem.asHeader("What can they see?"))
                for _ in range(6):
                    items.add(UItem.asFlicker(6))
                items.add(UItem.asHeader("What can they do?"))
                for _ in range(5):
                    items.add(UItem.asFlicker(6))
                return

            items.add(UItem.asHeader("What can they see?"))
            for p_type in [0, 4, 6, 9, 11, 14]:
                self._add_privacy_item(items, p_type)

            items.add(UItem.asHeader("What can they do?"))
            for p_type in [1, 2, 3, 5, 8]:
                self._add_privacy_item(items, p_type)

            items.add(UItem.asShadow(None))

        except Exception:
            pass

    def _add_privacy_item(self, items, p_type):
        label = self.PRIVACY_TYPES[p_type]
        state = self.current_states.get(p_type, self.STATE_DEFAULT)

        contacts = ContactsController.getInstance(self.account)
        rules = contacts.getPrivacyRules(p_type)
        effective = self._is_allowed_by_rules(self.user, rules, state)

        subtext = self.STATE_LABELS.get(state, "")
        uitem_id = 1000 if p_type == 0 else p_type

        item = UItem.asButtonCheck(uitem_id, label, subtext)
        item.checked = effective
        items.add(item)

    def onClick(self, item: Any, view: Any, position: int, x: float, y: float):
        actual_id = 0 if item.id == 1000 else item.id

        if actual_id in self.PRIVACY_TYPES:
            current_state = self.current_states.get(actual_id, self.STATE_DEFAULT)

            contacts = ContactsController.getInstance(self.account)
            rules = contacts.getPrivacyRules(actual_id)
            global_allows = self._is_allowed_by_rules(self.user, rules, self.STATE_DEFAULT)

            if global_allows:
                new_state = self.STATE_DEFAULT if current_state == self.STATE_NEVER else self.STATE_NEVER
            else:
                new_state = self.STATE_DEFAULT if current_state == self.STATE_ALWAYS else self.STATE_ALWAYS

            self._set_state(actual_id, new_state)
            return

        if item.id == 100:
            self._delete_contact()

    def onLongClick(self, item: Any, view: Any, position: int, x: float, y: float): return False

    def _delete_contact(self):
        from ui.alert import AlertDialogBuilder

        last_frag = get_last_fragment()
        if not last_frag: return
        activity = last_frag.getParentActivity()
        if not activity: return

        builder = AlertDialogBuilder(activity)
        builder.set_title("Delete Contact")
        builder.set_message("Are you sure you want to delete this contact?")
        builder.set_positive_button("Delete", lambda d, w: self._do_delete_contact())
        builder.set_negative_button("Cancel", None)
        builder.show()

    def _do_delete_contact(self):
        users = ArrayList()
        users.add(self.user)
        ContactsController.getInstance(self.account).deleteContact(users, True)
        run_on_ui_thread(lambda: get_last_fragment().finishFragment())

    def _is_allowed_by_rules(self, user, rules, state):
        if state == self.STATE_ALWAYS: return True
        if state == self.STATE_NEVER: return False
        if not rules: return True
        for i in range(rules.size()):
            rule = rules.get(i)
            if isinstance(rule, TLRPC.TL_privacyValueAllowUsers):
                if rule.users.contains(user.id):
                    return True
            elif isinstance(rule, TLRPC.TL_privacyValueDisallowUsers):
                if rule.users.contains(user.id):
                    return False

        for i in range(rules.size()):
            rule = rules.get(i)
            if isinstance(rule, TLRPC.TL_privacyValueAllowAll):
                return True
            if isinstance(rule, TLRPC.TL_privacyValueDisallowAll):
                return False
            if isinstance(rule, TLRPC.TL_privacyValueAllowContacts):
                return user.contact
            if isinstance(rule, TLRPC.TL_privacyValueDisallowContacts):
                return not user.contact

        return True

class UserPrivacyPlugin(BasePlugin):

    INPUT_PRIVACY_KEYS = {
        0:  lambda: TLRPC.TL_inputPrivacyKeyStatusTimestamp(),
        1:  lambda: TLRPC.TL_inputPrivacyKeyChatInvite(),
        2:  lambda: TLRPC.TL_inputPrivacyKeyPhoneCall(),
        3:  lambda: TLRPC.TL_inputPrivacyKeyPhoneP2P(),
        4:  lambda: TLRPC.TL_inputPrivacyKeyProfilePhoto(),
        5:  lambda: TLRPC.TL_inputPrivacyKeyForwards(),
        6:  lambda: TLRPC.TL_inputPrivacyKeyPhoneNumber(),
        7:  lambda: TLRPC.TL_inputPrivacyKeyAddedByPhone(),
        8:  lambda: TLRPC.TL_inputPrivacyKeyVoiceMessages(),
        9:  lambda: TLRPC.TL_inputPrivacyKeyAbout(),
        10: lambda: TLRPC.TL_inputPrivacyKeyNoPaidMessages(),
        11: lambda: TLRPC.TL_inputPrivacyKeyBirthday(),
        12: lambda: TLRPC.TL_inputPrivacyKeyStarGiftsAutoSave(),
        13: lambda: TLRPC.TL_inputPrivacyKeyNoPaidMessages(),
        14: lambda: TLRPC.TL_inputPrivacyKeySavedMusic(),
    }

    PRIVACY_ITEM_ID = 100

    def on_plugin_load(self):
        self._hook_profile_menu()

    def _hook_profile_menu(self):
        from base_plugin import MethodHook
        from hook_utils import find_class, get_private_field
        plugin_ref = weakref.ref(self)

        class CreateActionBarMenuHook(MethodHook):
            def after_hooked_method(self, param):
                plugin = plugin_ref()
                if not plugin: return
                try:
                    profile_activity = param.thisObject
                    chat_id = get_private_field(profile_activity, "chatId")
                    if chat_id and chat_id != 0: return
                    user_id = get_private_field(profile_activity, "userId")
                    if not user_id or user_id == 0: return
                    current_account = get_private_field(profile_activity, "currentAccount")
                    other_item = get_private_field(profile_activity, "otherItem")
                    if not other_item: return
                    
                    user = MessagesController.getInstance(current_account).getUser(int(user_id))
                    if not user or user.self: return

                    def on_privacy_click(v):
                        try:
                            user = MessagesController.getInstance(current_account).getUser(int(user_id))
                            if not user: return
                            delegate = UserPrivacyDelegate(plugin, user, current_account)
                            fragment = UniversalFragment(delegate)
                            delegate.fragment = fragment
                            profile_activity.presentFragment(fragment)
                            other_item.closeSubMenu()
                        except: pass

                    popup_layout = get_private_field(other_item, "popupLayout")
                    if popup_layout:
                        linear_layout = popup_layout.linearLayout
                        insert_index = -1
                        for i in range(linear_layout.getChildCount()):
                            tag = linear_layout.getChildAt(i).getTag()
                            if tag is not None:
                                try:
                                    tag_val = int(str(tag))
                                    if tag_val == 5:
                                        insert_index = i + 1
                                        break
                                    elif tag_val == 1:
                                        insert_index = i + 1
                                except: pass
                        ActionBarMenuSubItemClass = find_class("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
                        AndroidUtilitiesClass = find_class("org.telegram.messenger.AndroidUtilities")
                        LinearLayoutParamsClass = find_class("android.widget.LinearLayout$LayoutParams")
                        sub_item = ActionBarMenuSubItemClass(other_item.getContext(), False, False, False, None)
                        sub_item.setTextAndIcon("Manage Privacy", R.drawable.menu_privacy_policy, None)
                        sub_item.setMinimumWidth(AndroidUtilitiesClass.dp(196))
                        sub_item.setTag(plugin.PRIVACY_ITEM_ID)
                        sub_item.setOnClickListener(OnClickListener(on_privacy_click))
                        sub_item.setLayoutParams(LinearLayoutParamsClass(-1, AndroidUtilitiesClass.dp(48)))
                        linear_layout.addView(sub_item, insert_index) if insert_index >= 0 else linear_layout.addView(sub_item)
                    else:
                        sub_item = other_item.addSubItem(plugin.PRIVACY_ITEM_ID, R.drawable.menu_privacy_policy, "Privacy")
                        sub_item.setOnClickListener(OnClickListener(on_privacy_click))
                except: pass

        try:
            ProfileActivityClass = find_class("org.telegram.ui.ProfileActivity")
            for m in ProfileActivityClass.getClass().getDeclaredMethods():
                if m.getName() == "createActionBarMenu":
                    self._menu_hook = self.hook_method(m, CreateActionBarMenuHook())
                    break
        except: pass


    def update_user_privacy(self, account, user, privacy_type, new_state, callback):
        contacts = ContactsController.getInstance(account)
        rules = contacts.getPrivacyRules(privacy_type)
        input_rules = ArrayList()
        user_id = user.id

        key_factory = self.INPUT_PRIVACY_KEYS.get(privacy_type)
        if not key_factory:
            run_on_ui_thread(lambda: callback(privacy_type, False))
            return
        input_key = key_factory()

        found_allow = None
        found_disallow = None

        if rules:
            for i in range(rules.size()):
                rule = rules.get(i)
                input_rule = self._to_input_rule(account, rule)
                if not input_rule:
                    continue

                if isinstance(input_rule, TLRPC.TL_inputPrivacyValueAllowUsers):
                    if not found_allow:
                        found_allow = TLRPC.TL_inputPrivacyValueAllowUsers()
                    for j in range(input_rule.users.size()):
                        cur_u = input_rule.users.get(j)
                        is_target = isinstance(cur_u, (TLRPC.TL_inputUser, TLRPC.TL_inputUserSelf)) and cur_u.user_id == user_id
                        if not is_target:
                            found_allow.users.add(cur_u)

                elif isinstance(input_rule, TLRPC.TL_inputPrivacyValueDisallowUsers):
                    if not found_disallow:
                        found_disallow = TLRPC.TL_inputPrivacyValueDisallowUsers()
                    for j in range(input_rule.users.size()):
                        cur_u = input_rule.users.get(j)
                        is_target = isinstance(cur_u, (TLRPC.TL_inputUser, TLRPC.TL_inputUserSelf)) and cur_u.user_id == user_id
                        if not is_target:
                            found_disallow.users.add(cur_u)

                else:
                    input_rules.add(input_rule)

        if found_allow:
            input_rules.add(0, found_allow)
        if found_disallow:
            input_rules.add(0, found_disallow)

        input_user = MessagesController.getInstance(account).getInputUser(user)

        if new_state == UserPrivacyDelegate.STATE_ALWAYS:
            if not found_allow:
                found_allow = TLRPC.TL_inputPrivacyValueAllowUsers()
                input_rules.add(0, found_allow)
            found_allow.users.add(input_user)

        elif new_state == UserPrivacyDelegate.STATE_NEVER:
            if not found_disallow:
                found_disallow = TLRPC.TL_inputPrivacyValueDisallowUsers()
                input_rules.add(0, found_disallow)
            found_disallow.users.add(input_user)

        for i in range(input_rules.size() - 1, -1, -1):
            r = input_rules.get(i)
            if isinstance(r, (TLRPC.TL_inputPrivacyValueAllowUsers, TLRPC.TL_inputPrivacyValueDisallowUsers)):
                if r.users.isEmpty():
                    input_rules.remove(i)

        req = TL_account.setPrivacy()
        req.key = input_key
        req.rules = input_rules

        def on_response(response, error):
            if error:
                run_on_ui_thread(lambda: callback(privacy_type, False))
            else:
                def process():
                    contacts.setPrivacyRules(response.rules, privacy_type)
                    callback(privacy_type, True)
                run_on_ui_thread(process)

        send_request(req, RequestCallback(on_response))

    def _to_input_rule(self, account, rule):
        mc = MessagesController.getInstance(account)

        if isinstance(rule, TLRPC.TL_privacyValueAllowAll):
            return TLRPC.TL_inputPrivacyValueAllowAll()

        if isinstance(rule, TLRPC.TL_privacyValueAllowContacts):
            return TLRPC.TL_inputPrivacyValueAllowContacts()

        if isinstance(rule, TLRPC.TL_privacyValueDisallowAll):
            return TLRPC.TL_inputPrivacyValueDisallowAll()

        if isinstance(rule, TLRPC.TL_privacyValueDisallowContacts):
            return TLRPC.TL_inputPrivacyValueDisallowContacts()

        if isinstance(rule, TLRPC.TL_privacyValueAllowUsers):
            res = TLRPC.TL_inputPrivacyValueAllowUsers()
            for i in range(rule.users.size()):
                u = mc.getUser(rule.users.get(i))
                if u:
                    res.users.add(mc.getInputUser(u))
            return res

        if isinstance(rule, TLRPC.TL_privacyValueDisallowUsers):
            res = TLRPC.TL_inputPrivacyValueDisallowUsers()
            for i in range(rule.users.size()):
                u = mc.getUser(rule.users.get(i))
                if u:
                    res.users.add(mc.getInputUser(u))
            return res

        if isinstance(rule, TLRPC.TL_privacyValueAllowChatParticipants):
            res = TLRPC.TL_inputPrivacyValueAllowChatParticipants()
            for i in range(rule.chats.size()):
                res.chats.add(rule.chats.get(i))
            return res

        if isinstance(rule, TLRPC.TL_privacyValueDisallowChatParticipants):
            res = TLRPC.TL_inputPrivacyValueDisallowChatParticipants()
            for i in range(rule.chats.size()):
                res.chats.add(rule.chats.get(i))
            return res

        return None
