__id__ = "mediaupl"
__name__ = "MediaUPL"
__description__ = "–î–æ–±–∞–≤–ª—è–µ—Ç –∫–Ω–æ–ø–∫—É '–ü–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É' –≤ –º–µ–Ω—é —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–¥–∏–∞ –Ω–∞ —Ö–æ—Å—Ç–∏–Ω–≥ upl.yufic.ru.\n\nAdds a 'Get link' button to the message menu to upload media to upl.yufic.ru."
__version__ = "1.0.0"
__author__ = "@RnPlugins & @YouRooni"
__icon__ = "sPluginIDE/20"
__min_version__ = "11.12.0"

import os
import json
import time
import requests
import traceback
import threading
from typing import Any, Dict, Optional

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread, log
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Divider, Switch

from org.telegram.messenger import FileLoader, LocaleController, UserConfig, AndroidUtilities, ApplicationLoader
from android.content import Context, ClipData, ClipboardManager
from android.widget import EditText, LinearLayout
from android.graphics import Color

class MediaUplPlugin(BasePlugin):
    def on_plugin_load(self):
        s = self._get_strings()
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
            text=s["menu_item_text"],
            on_click=self._handle_menu_click,
            icon="msg_link",
            condition='message.isDocument() || message.isPhoto() || message.isVideo() || message.isSticker()'
        ))

    def _get_strings(self) -> dict:
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        is_ru = lang.startswith('ru')

        return {
            "menu_item_text": "–ü–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É" if is_ru else "Get link",
            "no_api_key": "üíº **API –∫–ª—é—á –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.**\n–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –µ–≥–æ –≤ –ø–ª–∞–≥–∏–Ω–µ." if is_ru else "üíº **API key not configured.**\nSet it up in the plugin settings.",
            "loading_dialog_title": "–ó–∞–≥—Ä—É–∑–∫–∞..." if is_ru else "Uploading...",
            "success_dialog_title": "‚úÖ –£—Å–ø–µ—à–Ω–æ" if is_ru else "‚úÖ Success",
            "error_dialog_title": "‚ùå –û—à–∏–±–∫–∞" if is_ru else "‚ùå Error",
            "copy_button": "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å" if is_ru else "Copy",
            "ok_button": "OK",
            "continue_button": "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å" if is_ru else "Continue",
            "cancel_button": "–û—Ç–º–µ–Ω–∞" if is_ru else "Cancel",
            "filename_dialog_title": "–ò–º—è —Ñ–∞–π–ª–∞ (–±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è)" if is_ru else "Filename (no extension)",
            "filename_dialog_hint": "–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)" if is_ru else "Enter filename (optional)",
            "link_copied": "–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞" if is_ru else "Link copied",
            "error_copied": "–û—à–∏–±–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞" if is_ru else "Error copied",
            "error_401": "üîë –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ (401).\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å API –∫–ª—é—á–∞." if is_ru else "üîë Authorization Error (401).\nPlease check your API key.",
            "config_api_key_title": "API –∫–ª—é—á" if is_ru else "API Key",
            "config_api_key_subtext": "–í–∞—à API –∫–ª—é—á –æ—Ç —Ö–æ—Å—Ç–∏–Ω–≥–∞ upl.yufic.ru" if is_ru else "Your API key from upl.yufic.ru hosting",
            "settings_header": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ MediaUPL" if is_ru else "MediaUPL Settings",
            "ask_filename_title": "–ó–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –∏–º—è —Ñ–∞–π–ª–∞" if is_ru else "Ask for filename",
            "ask_filename_subtext": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –¥–∏–∞–ª–æ–≥ –¥–ª—è –≤–≤–æ–¥–∞ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ –ø–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π" if is_ru else "Show a dialog to enter a filename before uploading",
            "error_file_not_found": "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ. –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –µ–≥–æ." if is_ru else "File not found on device. Download it first."
        }

    def create_settings(self):
        s = self._get_strings()
        return [
            Header(s["settings_header"]),
            Input(
                key="api_key",
                text=s["config_api_key_title"],
                subtext=s["config_api_key_subtext"],
                icon="msg_secret"
            ),
            Switch(
                key="ask_for_filename",
                text=s["ask_filename_title"],
                subtext=s["ask_filename_subtext"],
                default=True,
                icon="msg_edit"
            ),
            Divider("–ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–∞ @RnPlugins")
        ]

    def _handle_menu_click(self, context: Dict[str, Any]):
        s = self._get_strings()
        api_key = self.get_setting("api_key")

        if not api_key:
            run_on_ui_thread(lambda: BulletinHelper.show_error(s["no_api_key"]))
            return
        
        message = context.get("message")
        if not message: return

        if self.get_setting("ask_for_filename", True):
            self._show_filename_input_dialog(message)
        else:
            self._start_upload(message)

    def _get_original_filename(self, message: Any) -> str:
        doc = message.getDocument()
        
        if message.isRoundVideo():
            return f"round_video_{message.getId()}.mp4"
        
        if message.isSticker() and doc:
            mime = getattr(doc, 'mime_type', '')
            ext = '.webp'
            if 'tgsticker' in mime: ext = '.tgs'
            elif 'webm' in mime: ext = '.webm'
            return f"sticker_{doc.id}{ext}"
        
        if (message.isVideo() or message.isDocument()) and doc:
            if hasattr(doc, 'file_name_fixed') and doc.file_name_fixed:
                return doc.file_name_fixed
            if message.isVideo():
                return f"video_{message.getId()}.mp4"

        if message.isPhoto():
            return f"photo_{message.getId()}.jpg"
            
        return f"upload_{message.getId()}.bin"
    
    def _show_filename_input_dialog(self, message: Any):
        s = self._get_strings()
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        filename_input = EditText(activity)
        original_full_filename = self._get_original_filename(message)
        original_name_no_ext, _ = os.path.splitext(original_full_filename)
        filename_input.setText(original_name_no_ext)
        filename_input.setHint(s["filename_dialog_hint"])
        filename_input.setTextColor(Color.WHITE)
        filename_input.setHintTextColor(Color.GRAY)

        def on_continue(builder, which):
            custom_filename_base = filename_input.getText().toString().strip()
            self._start_upload(message, custom_filename_base)
            builder.dismiss()

        def build_dialog():
            layout = LinearLayout(activity)
            layout.setOrientation(LinearLayout.VERTICAL)
            padding = AndroidUtilities.dp(24)
            layout.setPadding(padding, AndroidUtilities.dp(16), padding, AndroidUtilities.dp(8))
            layout.addView(filename_input)
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(s["filename_dialog_title"])
            builder.set_view(layout)
            builder.set_positive_button(s["continue_button"], on_continue)
            builder.set_negative_button(s["cancel_button"], lambda b, w: b.dismiss())
            builder.show()

        run_on_ui_thread(build_dialog)

    def _start_upload(self, message: Any, custom_filename_base: Optional[str] = None):
        s = self._get_strings()
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        loading_dialog = AlertDialogBuilder(activity, AlertDialogBuilder.ALERT_TYPE_LOADING)
        loading_dialog.set_title(s["loading_dialog_title"])
        loading_dialog.set_cancelable(False)
        loading_dialog.show()
        
        api_key = self.get_setting("api_key")

        upload_thread = threading.Thread(
            target=self._upload_task,
            args=(message, api_key, activity, loading_dialog, custom_filename_base),
            daemon=True
        )
        upload_thread.start()

    def _get_file_path(self, account: int, message: Any) -> Optional[str]:
        file_loader = FileLoader.getInstance(account)
        file_path_obj = file_loader.getPathToMessage(message.messageOwner)

        if not file_path_obj or not os.path.exists(file_path_obj.toString()):
            attach = None
            if message.isPhoto():
                photo = message.getPhoto()
                if photo and photo.sizes:
                    biggest_size = max(photo.sizes, key=lambda s: getattr(s, 'w', 0) * getattr(s, 'h', 0))
                    attach = biggest_size.location
            else:
                attach = message.getDocument()

            if attach:
                file_loader.loadFile(attach, message, None, FileLoader.PRIORITY_HIGH, 1)

        for _ in range(300):
            current_path_obj = file_loader.getPathToMessage(message.messageOwner)
            if current_path_obj and os.path.exists(current_path_obj.toString()):
                return current_path_obj.toString()
            time.sleep(0.1)
        return None

    def _upload_task(self, message: Any, api_key: str, activity: Any, loading_dialog: AlertDialogBuilder, custom_filename_base: Optional[str]):
        s = self._get_strings()
        account = UserConfig.selectedAccount
        try:
            file_path = self._get_file_path(account, message)
            if not file_path:
                run_on_ui_thread(loading_dialog.dismiss)
                self._show_result_dialog(activity, s["error_dialog_title"], s["error_file_not_found"])
                return

            original_full_filename = self._get_original_filename(message)
            _, original_ext = os.path.splitext(original_full_filename)
            
            final_name_base = custom_filename_base or os.path.splitext(original_full_filename)[0]
            final_full_filename = final_name_base + original_ext

            mime_type = "application/octet-stream"
            doc = message.getDocument()
            if doc and hasattr(doc, 'mime_type'):
                mime_type = doc.mime_type
            elif message.isPhoto():
                mime_type = "image/jpeg"
            
            with open(file_path, "rb") as f: media_bytes = f.read()

            files = {'image': (final_full_filename, media_bytes, mime_type)}
            data = {'filename': final_name_base}
            url, headers = "https://upl.yufic.ru/api/upload.php", {"Authorization": f"Bearer {api_key}"}

            response = requests.post(url, headers=headers, data=data, files=files, timeout=60)
            
            run_on_ui_thread(loading_dialog.dismiss)

            if response.status_code == 401:
                self._show_result_dialog(activity, s["error_dialog_title"], s["error_401"])
                return
            
            response.raise_for_status()
            
            result_json = response.json()
            link = result_json.get("url")

            if link:
                self._show_result_dialog(activity, s["success_dialog_title"], link)
            else:
                self._show_result_dialog(activity, s["error_dialog_title"], result_json.get("error", str(result_json)))

        except requests.exceptions.HTTPError as e:
            error_details = f"–ö–æ–¥: {e.response.status_code}\n–û—Ç–≤–µ—Ç: {e.response.text}"
            log(f"HTTP Error: {error_details}")
            run_on_ui_thread(loading_dialog.dismiss)
            self._show_result_dialog(activity, s["error_dialog_title"], error_details)
        except Exception as e:
            log(f"Upload task failed: {traceback.format_exc()}")
            run_on_ui_thread(loading_dialog.dismiss)
            self._show_result_dialog(activity, s["error_dialog_title"], f"{type(e).__name__}")
    
    def _show_result_dialog(self, activity: Any, title: str, text: str):
        s = self._get_strings()
        
        def copy_action(builder, which):
            try:
                context = ApplicationLoader.applicationContext
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("MediaUPL", text)
                clipboard.setPrimaryClip(clip)
                is_error = title == s["error_dialog_title"]
                BulletinHelper.show_info(s["error_copied"] if is_error else s["link_copied"])
            except Exception as e: log(f"Copy failed: {e}")

        def show_dialog():
            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_message(text)
            builder.set_positive_button(s["ok_button"], lambda b, w: b.dismiss())
            builder.set_negative_button(s["copy_button"], copy_action)
            builder.set_cancelable(False)
            builder.set_canceled_on_touch_outside(False)
            builder.show()

        run_on_ui_thread(show_dialog)