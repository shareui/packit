__id__ = "currency_converter"
__name__ = "Currency Converter"
__description__ = "–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Ñ–∏–∞—Ç–Ω—ã–µ –∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –∫—É—Ä—Å–∞–º–∏\n\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .conv <–∏–∑> to <–≤> <—Å—É–º–º–∞>\n\n–ü—Ä–∏–º–µ—Ä—ã:\n‚Ä¢ .conv usd to rub 100\n‚Ä¢ .conv btc to usd 1\n‚Ä¢ .conv eth to rub 5\n\n–ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ñ–∏–∞—Ç–∞ –∏ 20 –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (BTC, ETH, USDT, BNB, SOL, XRP, USDC, ADA, DOGE, TRX, TON, LINK, MATIC, DOT, DAI, LTC, SHIB, BCH, AVAX, UNI)"
__author__ = "@oxd5f & @explugin"
__version__ = "1.0"
__icon__ = "pyDevSticker/1"
__min_version__ = "11.12.0"

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Switch, Selector, Input
from client_utils import send_message, get_send_messages_helper
from markdown_utils import parse_markdown
import requests, re
from java.util import Locale, ArrayList
from android_utils import log as logcat
from PIL import Image, ImageDraw, ImageFont
import os, tempfile

class Locales:
	en = {
		"error_format": "‚ùå Format: {cmd} <from> to <to> <amount>\nExample: {cmd} usd to rub 100",
		"error_network": "‚ùå Network error. Check your connection.",
		"error_currency": "‚ùå Currency not found: {}",
		"error_api": "‚ùå API error. Try again later.",
		"converting": "üîÑ Converting...",
		"conversion": "üí± Conversion",
		"result": "üíµ Result",
		"exchange_rate": "üìä Exchange rate",
		"rate": "Rate"
	}
	
	ru = {
		"error_format": "‚ùå –§–æ—Ä–º–∞—Ç: {cmd} <–∏–∑> to <–≤> <—Å—É–º–º–∞>\n–ü—Ä–∏–º–µ—Ä: {cmd} usd to rub 100",
		"error_network": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ.",
		"error_currency": "‚ùå –í–∞–ª—é—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {}",
		"error_api": "‚ùå –û—à–∏–±–∫–∞ API. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
		"converting": "üîÑ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é...",
		"conversion": "üí± –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è",
		"result": "üíµ –†–µ–∑—É–ª—å—Ç–∞—Ç",
		"exchange_rate": "üìä –ö—É—Ä—Å –æ–±–º–µ–Ω–∞",
		"rate": "–ö—É—Ä—Å"
	}
	
	de = {
		"error_format": "‚ùå Format: {cmd} <von> to <zu> <betrag>\nBeispiel: {cmd} usd to eur 100",
		"error_network": "‚ùå Netzwerkfehler. √úberpr√ºfen Sie Ihre Verbindung.",
		"error_currency": "‚ùå W√§hrung nicht gefunden: {}",
		"error_api": "‚ùå API-Fehler. Versuchen Sie es sp√§ter erneut.",
		"converting": "üîÑ Konvertiere...",
		"conversion": "üí± Konvertierung",
		"result": "üíµ Ergebnis",
		"exchange_rate": "üìä Wechselkurs",
		"rate": "Kurs"
	}

def localise(key: str, cmd=None, *args) -> str:
    lang = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, lang, Locales.en)
    text = locale_dict.get(key, key)
    if cmd:
        text = text.replace('{cmd}', cmd)
    return text.format(*args) if args else text

def log(*msg):
	m = msg if len(msg) > 1 else msg[0]
	if isinstance(m, Exception):
		m = f"{m.__traceback__.tb_lineno}: {m}"
	logcat(f'[{__id__}] {m}')

PAYMENT_METHODS = [
	("ton", "TON"),
	("usdt_trc20", "USDT TRC20"),
	("usdt_bep20", "USDT BEP20"),
	("btc", "BTC"),
	("eth", "ETH"),
    ("sbp", "–°–ë–ü"),
	("bank_card", "Bank card"),
    ("tbank", "TBank"),
	("yumoney", "–ÆMoney"),
	("donation_alerts", "Donation alerts"),
	("boosty", "Boosty"),
	("patreon", "Patreon")
]

MAX_PAYMENT_FIELDS = 5

class CurrencyAPI:
	FIAT_API_URL = "https://api.exchangerate-api.com/v4/latest/{}"
	CRYPTO_API_URL = "https://api.coingecko.com/api/v3/simple/price"
	
	CRYPTO_LIST = ['BTC', 'ETH', 'USDT', 'BNB', 'SOL', 'XRP', 'USDC', 'ADA', 'DOGE', 'TRX', 
	               'TON', 'LINK', 'MATIC', 'DOT', 'DAI', 'LTC', 'SHIB', 'BCH', 'AVAX', 'UNI']
	
	CRYPTO_IDS = {
		'BTC': 'bitcoin', 'ETH': 'ethereum', 'USDT': 'tether', 'BNB': 'binancecoin',
		'SOL': 'solana', 'XRP': 'ripple', 'USDC': 'usd-coin', 'ADA': 'cardano',
		'DOGE': 'dogecoin', 'TRX': 'tron', 'TON': 'the-open-network', 'LINK': 'chainlink',
		'MATIC': 'matic-network', 'DOT': 'polkadot', 'DAI': 'dai', 'LTC': 'litecoin',
		'SHIB': 'shiba-inu', 'BCH': 'bitcoin-cash', 'AVAX': 'avalanche-2', 'UNI': 'uniswap'
	}
	
	@staticmethod
	def get_rate(from_currency: str, to_currency: str):
		try:
			from_currency = from_currency.upper()
			to_currency = to_currency.upper()
			
			from_is_crypto = from_currency in CurrencyAPI.CRYPTO_LIST
			to_is_crypto = to_currency in CurrencyAPI.CRYPTO_LIST
			
			if from_is_crypto or to_is_crypto:
				return CurrencyAPI._get_crypto_rate(from_currency, to_currency)
			else:
				return CurrencyAPI._get_fiat_rate(from_currency, to_currency)
			
		except Exception as e:
			return None, str(e)
	
	@staticmethod
	def _get_fiat_rate(from_currency: str, to_currency: str):
		try:
			response = requests.get(
				CurrencyAPI.FIAT_API_URL.format(from_currency),
				timeout=10
			)
			response.raise_for_status()
			data = response.json()
			
			if 'rates' not in data:
				return None, "API error"
			
			if to_currency not in data['rates']:
				return None, f"Currency not found: {to_currency}"
			
			rate = data['rates'][to_currency]
			return rate, None
			
		except requests.exceptions.RequestException as e:
			return None, "Network error"
	
	@staticmethod
	def _get_crypto_rate(from_currency: str, to_currency: str):
		try:
			from_id = CurrencyAPI.CRYPTO_IDS.get(from_currency, from_currency.lower())
			
			vs_currency = to_currency.lower()
			if to_currency in CurrencyAPI.CRYPTO_LIST:
				to_id = CurrencyAPI.CRYPTO_IDS.get(to_currency)
				vs_currency = 'usd'
			
			params = {
				'ids': from_id,
				'vs_currencies': vs_currency
			}
			
			response = requests.get(
				CurrencyAPI.CRYPTO_API_URL,
				params=params,
				timeout=10
			)
			response.raise_for_status()
			data = response.json()
			
			if from_id not in data:
				return None, f"Crypto not found: {from_currency}"
			
			if vs_currency not in data[from_id]:
				return None, f"Currency not found: {to_currency}"
			
			rate = data[from_id][vs_currency]
			
			if to_currency in CurrencyAPI.CRYPTO_LIST:
				params2 = {
					'ids': CurrencyAPI.CRYPTO_IDS.get(to_currency),
					'vs_currencies': 'usd'
				}
				response2 = requests.get(CurrencyAPI.CRYPTO_API_URL, params=params2, timeout=10)
				data2 = response2.json()
				to_id = CurrencyAPI.CRYPTO_IDS.get(to_currency)
				if to_id in data2 and 'usd' in data2[to_id]:
					rate = rate / data2[to_id]['usd']
			
			return rate, None
			
		except requests.exceptions.RequestException as e:
			return None, "Network error"

class CurrencyConverter(BasePlugin):
	def on_plugin_load(self):
		self.add_on_send_message_hook()

	def on_settings_changed(self, key, value):
		if key == "command":
			self.set_setting("command", str(value).strip())
		elif key == "pay_command":
			self.set_setting("pay_command", str(value).strip())
		elif key == "compact_format":
			self.set_setting("compact_format", value)
		elif key == "show_emoji":
			self.set_setting("show_emoji", value)
		elif key == "generate_image":
			self.set_setting("generate_image", value)

	def create_settings(self):
		settings_list = [
			Header(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω–≤–µ—Ä—Ç–µ—Ä–∞"),
			Input(
				key="command",
				text="–ö–æ–º–∞–Ω–¥–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏",
				default=self.get_setting("command", ".conv"),
				icon="msg_edit"
			),
			Switch(
				key="show_emoji",
				text="–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —ç–º–æ–¥–∑–∏",
				default=self.get_setting("show_emoji", True),
				icon="msg_emoji_smiles"
			),
			Switch(
				key="compact_format",
				text="–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç",
				default=self.get_setting("compact_format", False),
				icon="msg_media"
			),
			Switch(
				key="generate_image",
				text="–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É",
				default=self.get_setting("generate_image", False),
				icon="msg_photo_settings"
			),
			Divider(),
			Header(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–µ–∫–≤–∏–∑–∏—Ç–æ–≤"),
			Input(
				key="pay_command",
				text="–ö–æ–º–∞–Ω–¥–∞ —Ä–µ–∫–≤–∏–∑–∏—Ç–æ–≤",
				default=self.get_setting("pay_command", ".pay"),
				icon="msg_edit"
			),
			Input(
				key="payment_username",
				text="–í–∞—à –Ω–∏–∫–Ω–µ–π–º",
				default="",
				subtext="–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ",
				icon="msg_contacts"
			),
			Switch(
				key="show_payment_username",
				text="–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∏–∫–Ω–µ–π–º",
				default=True,
				icon="msg_info"
			),
			Divider(),
			Header(text="–ü–ª–∞—Ç–µ–∂–Ω—ã–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã")
		]

		for key, label in PAYMENT_METHODS:
			settings_list.extend([
				Input(key=f"pay_{key}", text=label, default="", icon="msg_pin_code"),
				Switch(key=f"show_pay_{key}", text=f"–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å {label}", default=True, icon="msg_visibility"),
				Divider()
			])

		settings_list.append(Header(text="–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã"))

		for i in range(1, MAX_PAYMENT_FIELDS + 1):
			settings_list.extend([
				Input(key=f"pay_custom_name_{i}", text=f"–ù–∞–∑–≤–∞–Ω–∏–µ {i}", default="", icon="msg_edit"),
				Input(key=f"pay_custom_value_{i}", text=f"–ó–Ω–∞—á–µ–Ω–∏–µ {i}", default="", icon="msg_pin_code"),
				Switch(key=f"show_pay_custom_{i}", text=f"–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–ª–µ {i}", default=True, icon="msg_visibility"),
				Divider()
			])

		return settings_list

	def _validate_no_cyrillic(self, text):
		if not text:
			return True
		return not bool(re.search('[–∞-—è–ê-–Ø—ë–Å]', str(text)))

	def _validate_username(self, username):
		if not username:
			return True
		return bool(re.match(r'^[a-zA-Z0-9_]{3,32}$', username))

	def _handle_payment_command(self, params):
		show_username = self.get_setting("show_payment_username", True)
		username = self.get_setting("payment_username", "")
		
		if show_username and username and not self._validate_username(username):
			params.message = "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–∏–∫–Ω–µ–π–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω–∏—Ü—É, —Ü–∏—Ñ—Ä—ã –∏ –Ω–∏–∂–Ω–µ–µ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏–µ (3-32 —Å–∏–º–≤–æ–ª–∞)"
			if hasattr(params, 'entities') and params.entities:
				params.entities.clear()
			return HookResult(strategy=HookStrategy.MODIFY, params=params)

		all_values = []
		for key, _ in PAYMENT_METHODS:
			if self.get_setting(f"show_pay_{key}", True):
				all_values.append(self.get_setting(f"pay_{key}", ""))
		
		for i in range(1, MAX_PAYMENT_FIELDS + 1):
			if self.get_setting(f"show_pay_custom_{i}", True):
				all_values.append(self.get_setting(f"pay_custom_name_{i}", ""))
				all_values.append(self.get_setting(f"pay_custom_value_{i}", ""))
		
		if any(value and not self._validate_no_cyrillic(value) for value in all_values):
			params.message = "‚ùå –í —Ä–µ–∫–≤–∏–∑–∏—Ç–∞—Ö –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω–∏—Ü—É."
			if hasattr(params, 'entities') and params.entities:
				params.entities.clear()
			return HookResult(strategy=HookStrategy.MODIFY, params=params)

		message_parts = []
		
		if show_username and username:
			message_parts.append(f"Payment [{username}]")
			message_parts.append("")

		for key, label in PAYMENT_METHODS:
			show_item = self.get_setting(f"show_pay_{key}", True)
			item_value = self.get_setting(f"pay_{key}", "")
			if show_item and item_value:
				message_parts.append(f"{label}: `{item_value}`")

		for i in range(1, MAX_PAYMENT_FIELDS + 1):
			show_custom = self.get_setting(f"show_pay_custom_{i}", True)
			custom_name = self.get_setting(f"pay_custom_name_{i}", "")
			custom_value = self.get_setting(f"pay_custom_value_{i}", "")
			if show_custom and custom_name and custom_value:
				message_parts.append(f"{custom_name}: `{custom_value}`")

		if not any(part.strip() for part in message_parts if part):
			params.message = "‚ùå –†–µ–∫–≤–∏–∑–∏—Ç—ã –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞."
			return HookResult(strategy=HookStrategy.MODIFY, params=params)
		
		final_text = "\n".join(message_parts)
		parsed = parse_markdown(final_text)
		params.message = parsed.text
		
		if not hasattr(params, "entities") or params.entities is None:
			params.entities = ArrayList()
		else:
			params.entities.clear()
			
		for entity in parsed.entities:
			params.entities.add(entity.to_tlrpc_object())
			
		return HookResult(strategy=HookStrategy.MODIFY, params=params)

	def on_send_message_hook(self, account, params):
		if not hasattr(params, "message") or not isinstance(params.message, str):
			return HookResult()

		message = params.message.strip()
		conv_command = self.get_setting("command", ".conv").strip()
		pay_command = self.get_setting("pay_command", ".pay").strip()

		if message.lower().startswith(pay_command.lower()):
			return self._handle_payment_command(params)
		
		if not message.lower().startswith(conv_command.lower()):
			return HookResult()

		try:
			parts = message.split()
			
			if len(parts) < 5 or parts[2].lower() != "to":
				params.message = localise("error_format", cmd=conv_command)
				return HookResult(strategy=HookStrategy.MODIFY, params=params)
			
			from_curr = parts[1]
			to_curr = parts[3]
			
			try:
				amount = float(parts[4])
			except ValueError:
				params.message = localise("error_format", cmd=conv_command)
				return HookResult(strategy=HookStrategy.MODIFY, params=params)
			
			rate, error = CurrencyAPI.get_rate(from_curr, to_curr)
			
			if error:
				if "Network" in error:
					params.message = localise("error_network")
				elif "not found" in error:
					params.message = localise("error_currency", error.split(": ")[1])
				else:
					params.message = localise("error_api")
				return HookResult(strategy=HookStrategy.MODIFY, params=params)
			
			result = amount * rate
			
			from_curr_upper = from_curr.upper()
			to_curr_upper = to_curr.upper()
			
			show_emoji = self.get_setting("show_emoji", True)
			compact_format = self.get_setting("compact_format", False)
			
			if compact_format:
				emoji_arrow = "‚Üí" if show_emoji else "->"
				response = f"{amount:,.2f} {from_curr_upper} {emoji_arrow} {result:,.2f} {to_curr_upper}\n"
				response += f"{localise('rate')}: 1 {from_curr_upper} = {rate:.4f} {to_curr_upper}"
			else:
				emoji_conv = "üí± " if show_emoji else ""
				emoji_result = "üíµ " if show_emoji else ""
				emoji_rate = "üìä " if show_emoji else ""
				
				response = f"{emoji_conv}{localise('conversion')}\n"
				response += f"{amount:,.2f} {from_curr_upper} ‚Üí {to_curr_upper}\n\n"
				response += f"{emoji_result}{localise('result')}\n"
				response += f"{result:,.2f} {to_curr_upper}\n\n"
				response += f"{emoji_rate}{localise('exchange_rate')}\n"
				response += f"1 {from_curr_upper} = {rate:.4f} {to_curr_upper}"
			
			generate_image = self.get_setting("generate_image", False)
			if generate_image:
				self._send_as_image(params, amount, from_curr_upper, result, to_curr_upper, rate)
				return HookResult(strategy=HookStrategy.BLOCK)
			else:
				params.message = response
				return HookResult(strategy=HookStrategy.MODIFY, params=params)
			
		except Exception as e:
			pass

	def _send_as_image(self, params, amount, from_curr, result, to_curr, rate):
		from io import BytesIO
		try:
			width, height = 900, 400
			
			background_url = self.get_setting("background_url", "https://i.ibb.co/KptQTzH/Rectangle-2.png").strip()
			
			img = Image.new('RGB', (width, height), color=(15, 15, 25))
			
			if background_url:
				try:
					bg_response = requests.get(background_url, timeout=15, headers={'User-Agent': 'Mozilla/5.0'})
					bg_response.raise_for_status()
					
					bg_img = Image.open(BytesIO(bg_response.content))
					bg_img = bg_img.convert('RGB')
					bg_img = bg_img.resize((width, height), Image.LANCZOS)
					img = bg_img
				except Exception as e:
					pass
			
			draw = ImageDraw.Draw(img)
			
			font_url = "https://github.com/JetBrains/JetBrainsMono/raw/master/fonts/ttf/JetBrainsMono-Bold.ttf"
			font_dir = tempfile.gettempdir()
			font_path = os.path.join(font_dir, "JetBrainsMono-Bold.ttf")
			
			font_large = None
			font_medium = None
			
			if not os.path.exists(font_path):
				try:
					font_response = requests.get(font_url, timeout=15, headers={'User-Agent': 'Mozilla/5.0'})
					font_response.raise_for_status()
					with open(font_path, 'wb') as f:
						f.write(font_response.content)
				except Exception as e:
					pass
			
			try:
				font_large = ImageFont.truetype(font_path, 80)
				font_medium = ImageFont.truetype(font_path, 50)
			except Exception as e:
				font_large = ImageFont.load_default()
				font_medium = ImageFont.load_default()
			
			sticker_url = self.get_setting("sticker_url", "https://i.ibb.co/9k4xxgbw/Icon-2.png").strip()
			
			sticker_size = 300
			sticker_x = 30
			sticker_y = (height - sticker_size) // 2
			
			if sticker_url:
				try:
					sticker_response = requests.get(sticker_url, timeout=15, headers={'User-Agent': 'Mozilla/5.0'})
					sticker_response.raise_for_status()
					
					sticker_img = Image.open(BytesIO(sticker_response.content))
					
					if sticker_img.mode != 'RGBA':
						sticker_img = sticker_img.convert('RGBA')
					
					sticker_img = sticker_img.resize((sticker_size, sticker_size), Image.LANCZOS)
					
					img_rgba = img.convert('RGBA')
					img_rgba.paste(sticker_img, (sticker_x, sticker_y), sticker_img)
					img = img_rgba.convert('RGB')
				except Exception as e:
					pass
			
			draw = ImageDraw.Draw(img)
			
			def get_currency_icon(currency_code):
				icon_size = 50
				currency_lower = currency_code.lower()
				
				if currency_code in CurrencyAPI.CRYPTO_LIST:
					crypto_icons = {
						'BTC': 'https://assets.coingecko.com/coins/images/1/large/bitcoin.png',
						'ETH': 'https://assets.coingecko.com/coins/images/279/large/ethereum.png',
						'USDT': 'https://assets.coingecko.com/coins/images/325/large/Tether.png',
						'BNB': 'https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png',
						'SOL': 'https://assets.coingecko.com/coins/images/4128/large/solana.png',
						'XRP': 'https://assets.coingecko.com/coins/images/44/large/xrp-symbol-white-128.png',
						'USDC': 'https://assets.coingecko.com/coins/images/6319/large/usdc.png',
						'ADA': 'https://assets.coingecko.com/coins/images/975/large/cardano.png',
						'DOGE': 'https://assets.coingecko.com/coins/images/5/large/dogecoin.png',
						'TRX': 'https://assets.coingecko.com/coins/images/1094/large/tron-logo.png',
						'TON': 'https://assets.coingecko.com/coins/images/17980/large/ton_symbol.png',
						'LINK': 'https://assets.coingecko.com/coins/images/877/large/chainlink-new-logo.png',
						'MATIC': 'https://assets.coingecko.com/coins/images/4713/large/polygon.png',
						'DOT': 'https://assets.coingecko.com/coins/images/12171/large/polkadot.png',
						'DAI': 'https://assets.coingecko.com/coins/images/9956/large/Badge_Dai.png',
						'LTC': 'https://assets.coingecko.com/coins/images/2/large/litecoin.png',
						'SHIB': 'https://assets.coingecko.com/coins/images/11939/large/shiba.png',
						'BCH': 'https://assets.coingecko.com/coins/images/780/large/bitcoin-cash-circle.png',
						'AVAX': 'https://assets.coingecko.com/coins/images/12559/large/Avalanche_Circle_RedWhite_Trans.png',
						'UNI': 'https://assets.coingecko.com/coins/images/12504/large/uni.jpg'
					}
					
					if currency_code in crypto_icons:
						try:
							icon_response = requests.get(crypto_icons[currency_code], timeout=10, headers={'User-Agent': 'Mozilla/5.0'})
							if icon_response.status_code == 200:
								icon_img = Image.open(BytesIO(icon_response.content))
								icon_img = icon_img.convert('RGBA')
								icon_img = icon_img.resize((icon_size, icon_size), Image.LANCZOS)
								return icon_img
						except Exception as e:
							pass
				else:
					currency_map = {
						'USD': 'https://flagcdn.com/w80/us.png',
						'EUR': 'https://flagcdn.com/w80/eu.png',
						'RUB': 'https://flagcdn.com/w80/ru.png',
						'GBP': 'https://flagcdn.com/w80/gb.png',
						'JPY': 'https://flagcdn.com/w80/jp.png',
						'CNY': 'https://flagcdn.com/w80/cn.png',
						'CHF': 'https://flagcdn.com/w80/ch.png',
						'CAD': 'https://flagcdn.com/w80/ca.png',
						'AUD': 'https://flagcdn.com/w80/au.png',
						'NZD': 'https://flagcdn.com/w80/nz.png',
						'INR': 'https://flagcdn.com/w80/in.png',
						'BRL': 'https://flagcdn.com/w80/br.png',
						'KRW': 'https://flagcdn.com/w80/kr.png',
						'MXN': 'https://flagcdn.com/w80/mx.png',
						'SEK': 'https://flagcdn.com/w80/se.png',
						'NOK': 'https://flagcdn.com/w80/no.png',
						'DKK': 'https://flagcdn.com/w80/dk.png',
						'PLN': 'https://flagcdn.com/w80/pl.png',
						'TRY': 'https://flagcdn.com/w80/tr.png',
						'ZAR': 'https://flagcdn.com/w80/za.png'
					}
					
					if currency_code in currency_map:
						try:
							icon_response = requests.get(currency_map[currency_code], timeout=5, headers={'User-Agent': 'Mozilla/5.0'})
							if icon_response.status_code == 200:
								icon_img = Image.open(BytesIO(icon_response.content))
								icon_img = icon_img.convert('RGBA')
								icon_img = icon_img.resize((icon_size, icon_size), Image.LANCZOS)
								
								mask = Image.new('L', (icon_size, icon_size), 0)
								mask_draw = ImageDraw.Draw(mask)
								mask_draw.ellipse([(0, 0), (icon_size, icon_size)], fill=255)
								
								output = Image.new('RGBA', (icon_size, icon_size), (0, 0, 0, 0))
								output.paste(icon_img, (0, 0))
								output.putalpha(mask)
								
								return output
						except Exception as e:
							pass
				
				icon = Image.new('RGBA', (icon_size, icon_size), (50, 50, 50, 0))
				icon_draw = ImageDraw.Draw(icon)
				icon_draw.ellipse([(0, 0), (icon_size, icon_size)], fill=(100, 100, 150, 255))
				try:
					icon_font = ImageFont.truetype(font_path, 25)
				except:
					icon_font = font_medium
				letter = currency_code[0]
				icon_draw.text((icon_size//2, icon_size//2), letter, fill=(255, 255, 255), font=icon_font, anchor="mm")
				return icon
			
			from_icon = get_currency_icon(from_curr)
			to_icon = get_currency_icon(to_curr)
			
			icon_x = sticker_x + sticker_size + 60
			text_x = icon_x + 70
			
			line1_y = height // 2 - 80
			line2_y = height // 2 + 30
			
			input_text = f"{amount:,.2f} {from_curr}"
			result_text = f"{result:,.2f} {to_curr}"
			
			img_rgba = img.convert('RGBA')
			img_rgba.paste(from_icon, (icon_x, line1_y), from_icon)
			img_rgba.paste(to_icon, (icon_x, line2_y), to_icon)
			img = img_rgba.convert('RGB')
			draw = ImageDraw.Draw(img)
			
			draw.text((text_x, line1_y - 5), input_text, fill=(180, 180, 180), font=font_medium)
			draw.text((text_x, line2_y - 5), result_text, fill=(100, 255, 150), font=font_medium)
			
			tmp_dir = tempfile.gettempdir()
			output_path = os.path.join(tmp_dir, f"converter_{os.getpid()}.png")
			img.save(output_path)
			
			send_helper = get_send_messages_helper()
			photo = send_helper.generatePhotoSizes(output_path, None)
			
			send_params = {
				"message": None,
				"peer": params.peer,
				"photo": photo,
				"path": output_path
			}
			
			if hasattr(params, "replyToMsg"):
				send_params["replyToMsg"] = params.replyToMsg
			if hasattr(params, "replyToTopMsg"):
				send_params["replyToTopMsg"] = params.replyToTopMsg
			
			send_message(send_params)
			
			try:
				os.remove(output_path)
			except:
				pass
				
		except Exception as e:
			pass
