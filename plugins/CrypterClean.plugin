__id__ = "Crypter"
__name__ = "Crypter"
__description__ = "ÐŸÑ€Ð¾ÑÑ‚ÐµÐ½ÑŒÐºÐ¸Ð¹ ÑˆÐ¸Ñ„Ñ€Ð°Ñ‚Ð¾Ñ€ Ñ‚ÐµÐºÑÑ‚Ð° Ñ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼. ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹: Ð¨Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ: .cip [password] [text] Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ: ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚. Ð¼ÐµÐ½ÑŽ -> Ð¿Ð»Ð°Ð³Ð¸Ð½Ñ‹ -> Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ"
__author__ = "Unknown"
__version__ = "1.0.0"
__min_version__ = "11.12.0"
__icon__ = "AnimatedEmojies/16"

import re
import base64
import hashlib
import time
from typing import Optional, Tuple
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from ui.settings import Header, Switch, Input, Divider, Selector
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread
from java import jclass


class CryptoUtils:
    @staticmethod
    def derive_key(password: str, salt: bytes = None) -> Tuple[bytes, bytes]:
        if salt is None:
            salt = hashlib.sha256(password.encode()).digest()[:16]
        key = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000, dklen=32)
        return key, salt
    
    @staticmethod
    def xor_encrypt(plaintext: str, password: str) -> str:
        try:
            timestamp = str(int(time.time()))
            data_to_encrypt = f"{plaintext}|||{timestamp}"
            key, salt = CryptoUtils.derive_key(password)
            data_bytes = data_to_encrypt.encode('utf-8')
            encrypted_bytes = bytearray()
            key_length = len(key)
            for i, byte in enumerate(data_bytes):
                encrypted_bytes.append(byte ^ key[i % key_length])
            result_bytes = salt + bytes(encrypted_bytes)
            return base64.urlsafe_b64encode(result_bytes).decode('utf-8')
        except Exception as e:
            raise Exception(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ: {str(e)}")
    
    @staticmethod
    def xor_decrypt(encrypted_text: str, password: str) -> Tuple[bool, str, Optional[str]]:
        try:
            encrypted_bytes = base64.urlsafe_b64decode(encrypted_text.encode('utf-8'))
            salt = encrypted_bytes[:16]
            encrypted_data = encrypted_bytes[16:]
            key, _ = CryptoUtils.derive_key(password, salt)
            decrypted_bytes = bytearray()
            key_length = len(key)
            for i, byte in enumerate(encrypted_data):
                decrypted_bytes.append(byte ^ key[i % key_length])
            decrypted_text = decrypted_bytes.decode('utf-8')
            if '|||' in decrypted_text:
                original_text, timestamp = decrypted_text.rsplit('|||', 1)
                return True, original_text, timestamp
            else:
                return True, decrypted_text, None
        except Exception:
            return False, "ÐžÑˆÐ¸Ð±ÐºÐ° Ð´ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ", None
    
    @staticmethod
    def detect_encrypted(text: str) -> bool:
        try:
            clean_text = text.strip()
            if clean_text.startswith("ðŸ” "):
                clean_text = clean_text[2:].strip()
            if len(clean_text) % 4 == 0 and all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=' for c in clean_text):
                decoded = base64.urlsafe_b64decode(clean_text + '=' * (4 - len(clean_text) % 4))
                return len(decoded) > 16
        except:
            pass
        return False


class SecretMessengerPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.message_cache = {}
    
    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.add_menu_item(MenuItemData(menu_type=MenuItemType.MESSAGE_CONTEXT_MENU, text="ðŸ”“ Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", icon="msg_lock_solar", on_click=self._handle_decrypt_menu))
        self.add_menu_item(MenuItemData(menu_type=MenuItemType.CHAT_ACTION_MENU, text="ðŸ” Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ðµ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ", icon="msg_lock_solar", on_click=self._handle_quick_encrypt))
    
    def create_settings(self):
        return [
            Header(text="ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ"),
            Switch(key="enabled", text="Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð³Ð¸Ð½", subtext="ÐÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ/Ð´ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ", default=True),
            Divider(),
            Switch(key="auto_detect", text="ÐÐ²Ñ‚Ð¾Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ", subtext="ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÑ‚ÑŒ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ", default=True),
            Switch(key="show_encrypted_icon", text="ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð¸ÐºÐ¾Ð½ÐºÑƒ ðŸ”", subtext="Ð”Ð¾Ð±Ð°Ð²Ð»ÑÑ‚ÑŒ Ð·Ð½Ð°Ñ‡Ð¾Ðº Ð·Ð°Ð¼ÐºÐ° Ðº Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑÐ¼", default=True),
            Selector(key="encryption_method", text="ÐœÐµÑ‚Ð¾Ð´ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ", items=["XOR (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ)", "Base64 (Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹)"], default=0, subtext="ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ"),
            Divider(),
            Input(key="custom_command", text="ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°", default=".cip", subtext="ÐœÐ¾Ð¶Ð½Ð¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð½Ð° .encrypt, .ÑˆÐ¸Ñ„Ñ€ Ð¸ Ñ‚.Ð´."),
            Divider(text="Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ: [ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°] [Ð¿Ð°Ñ€Ð¾Ð»ÑŒ] [Ñ‚ÐµÐºÑÑ‚]. ÐŸÑ€Ð¸Ð¼ÐµÑ€: .cip Ð¼Ð¾Ð¹Ð¿Ð°Ñ€Ð¾Ð»ÑŒ ÑÐµÐºÑ€ÐµÑ‚Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
        ]
    
    def _extract_password_and_text(self, text: str) -> Tuple[Optional[str], Optional[str]]:
        command_match = re.match(r'^(\.\w+)\s+', text)
        if not command_match:
            return None, None
        rest_text = text[len(command_match.group(1)):].strip()
        parts = re.findall(r'"([^"]*)"', rest_text)
        if len(parts) >= 2:
            return parts[0], parts[1]
        words = rest_text.split()
        if len(words) >= 2:
            return words[0], ' '.join(words[1:])
        return None, None
    
    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str) or not self.get_setting("enabled", True):
            return HookResult()
        
        message = params.message.strip()
        custom_command = self.get_setting("custom_command", ".cip")
        
        if message.lower().startswith(custom_command.lower() + " "):
            try:
                password, plaintext = self._extract_password_and_text(message)
                if not password or not plaintext:
                    BulletinHelper.show_error("Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚: .cip Ð¿Ð°Ñ€Ð¾Ð»ÑŒ \"Ñ‚ÐµÐºÑÑ‚\" Ð¸Ð»Ð¸ .cip Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ñ‚ÐµÐºÑÑ‚")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                encrypted = CryptoUtils.xor_encrypt(plaintext, password)
                params.message = f"ðŸ” {encrypted}" if self.get_setting("show_encrypted_icon", True) else encrypted
                BulletinHelper.show_success("Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¾!")
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            except Exception as e:
                BulletinHelper.show_error(str(e))
                return HookResult(strategy=HookStrategy.CANCEL)
        
        if self.get_setting("auto_detect", True) and CryptoUtils.detect_encrypted(message) and self.get_setting("show_encrypted_icon", True) and not message.startswith("ðŸ”"):
            params.message = f"ðŸ” {message}"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        
        return HookResult()
    
    def _handle_decrypt_menu(self, context):
        try:
            message_obj = context.get("message")
            if not message_obj:
                BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
                return
            
            message_text = ""
            if hasattr(message_obj, 'messageText'):
                message_text = str(message_obj.messageText)
            elif hasattr(message_obj, 'getText'):
                message_text = str(message_obj.getText())
            elif hasattr(message_obj, 'text'):
                message_text = str(message_obj.text)
            
            if not message_text:
                BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
                return
            
            clean_text = message_text.strip()
            if clean_text.startswith("ðŸ” "):
                clean_text = clean_text[2:].strip()
            
            if not CryptoUtils.detect_encrypted(clean_text):
                BulletinHelper.show_error("Ð­Ñ‚Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð½Ðµ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¾")
                return
            
            self._current_encrypted_text = clean_text
            run_on_ui_thread(self._show_password_dialog)
        except Exception as e:
            BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ°: {str(e)}")
    
    def _show_password_dialog(self):
        try:
            fragment = get_last_fragment()
            if not fragment or not hasattr(fragment, 'getParentActivity'):
                BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð¸Ð°Ð»Ð¾Ð³")
                return
            
            context = fragment.getParentActivity()
            encrypted_text = getattr(self, '_current_encrypted_text', '')
            
            if not encrypted_text:
                BulletinHelper.show_error("ÐÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð° Ð´Ð»Ñ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸")
                return
            
            builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title("ðŸ”“ Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
            builder.set_message("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸:")
            
            from org.telegram.ui.Components import EditTextBoldCursor
            from android.text import InputType
            from org.telegram.messenger import AndroidUtilities
            
            edit_text = EditTextBoldCursor(context)
            edit_text.setHint("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ")
            edit_text.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)
            edit_text.setSingleLine(True)
            
            try:
                from org.telegram.ui.ActionBar import Theme
                from android.graphics.drawable import ColorDrawable
                from android.content.res import ColorStateList
                from android.graphics import Color
                
                edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextGray3))
                edit_text.setLineColors(Theme.getColor(Theme.key_dialogInputField), Theme.getColor(Theme.key_dialogInputFieldActivated), Theme.getColor(Theme.key_text_RedBold))
                edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                edit_text.setBackground(ColorDrawable(0))
                edit_text.setBackgroundTintList(ColorStateList.valueOf(Color.TRANSPARENT))
            except:
                pass
            
            padding_h = AndroidUtilities.dp(20)
            padding_v = AndroidUtilities.dp(12)
            edit_text.setPadding(padding_h, padding_v, padding_h, padding_v)
            builder.set_view(edit_text)
            
            def on_decrypt(dialog_builder, which):
                password = str(edit_text.getText())
                if not password:
                    BulletinHelper.show_error("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ")
                    return
                
                success, decrypted, timestamp = CryptoUtils.xor_decrypt(encrypted_text, password)
                
                if success:
                    result_builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    result_builder.set_title("âœ… Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚")
                    
                    message = decrypted
                    if timestamp:
                        from datetime import datetime
                        dt = datetime.fromtimestamp(int(timestamp))
                        message += f"\n\nðŸ• Ð—Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¾: {dt.strftime('%d.%m.%Y %H:%M')}"
                    
                    result_builder.set_message(message)
                    
                    def copy_to_clipboard(dialog, which_button):
                        try:
                            Context = jclass("android.content.Context")
                            ClipboardManager = jclass("android.content.ClipboardManager")
                            ClipData = jclass("android.content.ClipData")
                            clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                            clip = ClipData.newPlainText("Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚", decrypted)
                            clipboard.setPrimaryClip(clip)
                            BulletinHelper.show_success("Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°")
                        except:
                            BulletinHelper.show_error("ÐžÑˆÐ¸Ð±ÐºÐ° ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ")
                    
                    result_builder.set_positive_button("ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", copy_to_clipboard)
                    result_builder.set_negative_button("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ", lambda b, w: b.dismiss())
                    result_builder.show()
                else:
                    BulletinHelper.show_error("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð¸Ð»Ð¸ Ð¿Ð¾Ð²Ñ€ÐµÐ¶Ð´Ñ‘Ð½Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
                
                dialog_builder.dismiss()
            
            builder.set_positive_button("Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", on_decrypt)
            builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", lambda b, w: b.dismiss())
            builder.show()
            
            def focus_edit():
                edit_text.requestFocus()
                from android.view.inputmethod import InputMethodManager
                from android.content import Context
                imm = context.getSystemService(Context.INPUT_METHOD_SERVICE)
                if imm:
                    imm.showSoftInput(edit_text, 0)
            
            run_on_ui_thread(lambda: edit_text.post(focus_edit))
        except Exception as e:
            BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ°: {str(e)}")
    
    def _handle_quick_encrypt(self, context):
        def show_encrypt_dialog():
            try:
                fragment = get_last_fragment()
                if not fragment or not hasattr(fragment, 'getParentActivity'):
                    BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð¸Ð°Ð»Ð¾Ð³")
                    return
                
                context = fragment.getParentActivity()
                builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                builder.set_title("ðŸ” Ð¨Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
                
                from org.telegram.ui.Components import EditTextBoldCursor
                from android.text import InputType
                from org.telegram.messenger import AndroidUtilities
                from android.widget import LinearLayout
                from android.view import ViewGroup
                
                layout = LinearLayout(context)
                layout.setOrientation(LinearLayout.VERTICAL)
                layout_params = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                layout_params.setMargins(AndroidUtilities.dp(20), 0, AndroidUtilities.dp(20), 0)
                layout.setLayoutParams(layout_params)
                
                password_input = EditTextBoldCursor(context)
                password_input.setHint("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ")
                password_input.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)
                password_input.setSingleLine(True)
                
                text_input = EditTextBoldCursor(context)
                text_input.setHint("Ð¢ÐµÐºÑÑ‚ Ð´Ð»Ñ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ")
                text_input.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE)
                text_input.setMinLines(3)
                text_input.setMaxLines(5)
                
                try:
                    from org.telegram.ui.ActionBar import Theme
                    from android.graphics.drawable import ColorDrawable
                    from android.content.res import ColorStateList
                    from android.graphics import Color
                    
                    for edit in [password_input, text_input]:
                        edit.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                        edit.setHintTextColor(Theme.getColor(Theme.key_dialogTextGray3))
                        edit.setLineColors(Theme.getColor(Theme.key_dialogInputField), Theme.getColor(Theme.key_dialogInputFieldActivated), Theme.getColor(Theme.key_text_RedBold))
                        edit.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                        edit.setBackground(ColorDrawable(0))
                        edit.setBackgroundTintList(ColorStateList.valueOf(Color.TRANSPARENT))
                        
                        padding_h = AndroidUtilities.dp(16)
                        padding_v = AndroidUtilities.dp(12)
                        edit.setPadding(padding_h, padding_v, padding_h, padding_v)
                        
                        layout_params = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                        layout_params.setMargins(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
                        edit.setLayoutParams(layout_params)
                except:
                    pass
                
                layout.addView(password_input)
                layout.addView(text_input)
                builder.set_view(layout)
                
                def encrypt_action(dialog_builder, which):
                    password = str(password_input.getText())
                    plaintext = str(text_input.getText())
                    
                    if not password or not plaintext:
                        BulletinHelper.show_error("Ð—Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ Ð²ÑÐµ Ð¿Ð¾Ð»Ñ")
                        return
                    
                    try:
                        encrypted = CryptoUtils.xor_encrypt(plaintext, password)
                        Context = jclass("android.content.Context")
                        ClipboardManager = jclass("android.content.ClipboardManager")
                        ClipData = jclass("android.content.ClipData")
                        clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                        encrypted_text = f"ðŸ” {encrypted}" if self.get_setting("show_encrypted_icon", True) else encrypted
                        clip = ClipData.newPlainText("Ð—Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ", encrypted_text)
                        clipboard.setPrimaryClip(clip)
                        BulletinHelper.show_success("Ð¢ÐµÐºÑÑ‚ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½ Ð¸ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°")
                    except Exception as e:
                        BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ: {str(e)}")
                    
                    dialog_builder.dismiss()
                
                builder.set_positive_button("Ð—Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", encrypt_action)
                builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", lambda b, w: b.dismiss())
                builder.show()
                
                def focus_password():
                    password_input.requestFocus()
                    from android.view.inputmethod import InputMethodManager
                    from android.content import Context
                    imm = context.getSystemService(Context.INPUT_METHOD_SERVICE)
                    if imm:
                        imm.showSoftInput(password_input, 0)
                
                run_on_ui_thread(lambda: password_input.post(focus_password))
            except Exception as e:
                BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ°: {str(e)}")
        
        run_on_ui_thread(show_encrypt_dialog)
    
    def on_setting_updated(self, key: str, value):
        super().on_setting_updated(key, value)
        if key == "custom_command" and value:
            BulletinHelper.show_success(f"ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð° Ð½Ð°: {value}")


def encrypt_text(text: str, password: str) -> str:
    return CryptoUtils.xor_encrypt(text, password)

def decrypt_text(encrypted: str, password: str) -> Tuple[bool, str]:
    success, decrypted, _ = CryptoUtils.xor_decrypt(encrypted, password)
    return success, decrypted