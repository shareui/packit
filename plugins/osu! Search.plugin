import requests
import re
import traceback
import time
import os
import threading

from urllib.parse import urlparse
from java import jarray, jlong, jint, jbyte
from java.io import File, FileInputStream, FileOutputStream
from java.util.zip import ZipInputStream
from java.lang import Integer, Long, Runnable
from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import run_on_queue, get_last_fragment, send_message, get_send_messages_helper, get_account_instance
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Input, Divider, Switch, Selector, Text
from ui.bulletin import BulletinHelper
from markdown_utils import parse_markdown
from typing import Any, Optional, List, Dict
from datetime import datetime
from android.os import Environment
from org.telegram.messenger import SendMessagesHelper
from org.telegram.tgnet import TLRPC

__id__ = "osu_mur_stats"
__name__ = "osu! Search"
__description__ = '–î–æ–±–∞–≤–ª—è–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞ –∫–∞—Ä—Ç –∏ –ø—Ä–æ—Ñ–∏–ª–µ–π –∏–∑ —Å–∞–π—Ç–∞ "osu.ppy.sh" —Å –≥–∏–±–∫–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–æ–π –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏–∏, –∞ —Ç–∞–∫–∂–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–∫–∞—á–∏–≤–∞—Ç—å –∫–∞—Ä—Ç—ã –∏ –º—É–∑—ã–∫—É —Å –æ—Ç–ø—Ä–∞–≤–∫–æ–π —Ñ–∞–π–ª–∞ –≤ —á–∞—Ç. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –†—É—Å—Å–∫–∏–π/English. \n \n–ö–æ–º–∞–Ω–¥—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è: \n.osu <–∑–∞–ø—Ä–æ—Å>:<—Ä–µ–∂–∏–º> - –ü–æ–∏—Å–∫ –ø—Ä–æ—Ñ–∏–ª–µ–π. \n.map <–∑–∞–ø—Ä–æ—Å> - –ü–æ–∏—Å–∫ –∫–∞—Ä—Ç. \n.osz <–∑–∞–ø—Ä–æ—Å> - –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞—Ä—Ç –≤ —á–∞—Ç. \n.song <–∑–∞–ø—Ä–æ—Å> - –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –º—É–∑—ã–∫–∏ –∏–∑ –∫–∞—Ä—Ç—ã –≤ —á–∞—Ç. \n \n–î–∞–Ω–Ω—ã–µ –≤–≤–æ–¥–∞: \n<–∑–∞–ø—Ä–æ—Å> - –Ω–∏–∫–Ω–µ–π–º, –Ω–∞–∑–≤–≤–∞–Ω–∏–µ, id, —Å—Å—ã–ª–∫–∞. \n<—Ä–µ–∂–∏–º> - osu, mania, taiko, catch'
__author__ = "@muralovty (@mur_live)"
__version__ = "1.3.0" 
__icon__ = "OsuStickers/1"
__min_version__ = "11.12.0"

USER_API_URL_V1 = "https://osu.ppy.sh/api/get_user"
USER_BEST_API_URL_V1 = "https://osu.ppy.sh/api/get_user_best"
BEATMAP_API_URL_V1 = "https://osu.ppy.sh/api/get_beatmaps"

OAUTH_TOKEN_URL = "https://osu.ppy.sh/oauth/token"
MAP_SEARCH_URL_V2 = "https://osu.ppy.sh/api/v2/beatmapsets/search"

DEFAULT_API_KEY_V1 = "3e0c7c9baf734a70f780f2960332d825c50c4690"
DEFAULT_CLIENT_ID_V2 = "44039"
DEFAULT_CLIENT_SECRET_V2 = "3DuTNC4OjpAEhvmCOWdVmhM7znWJRLoznPyvp0gt"

SAYOBOT_DOWNLOAD_URL = "https://txy1.sayobot.cn/download/osz/{}"
SAYOBOT_NOVIDEO_DOWNLOAD_URL = "https://txy1.sayobot.cn/download/osz/{}/novideo"

API_HEADERS = {"User-Agent": "exteraGram-OsuPlugin/3.17.5"}

class OsuPlugin(BasePlugin):
    strings = {
        'ru': {
            'help_command_header': "*–ö–æ–º–∞–Ω–¥—ã –ø–ª–∞–≥–∏–Ω–∞ osu! Search:*\n",
            'settings_lang_header': "–Ø–∑—ã–∫ –ø–ª–∞–≥–∏–Ω–∞", 'settings_lang_text': "–Ø–∑—ã–∫ (Language)",
            'settings_api_submenu': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ API",
            'settings_api_header': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ API osu! v1 (–∏–≥—Ä–æ–∫, –∫–∞—Ä—Ç–∞ –ø–æ ID)", 'settings_api_source_text': "–ò—Å—Ç–æ—á–Ω–∏–∫ API v1", 'settings_api_source_items': ["–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π", "–†—É—á–Ω–æ–π"], 'settings_api_key_text': "API –∫–ª—é—á v1", 'settings_api_key_subtext': "–í–∞—à –∫–ª—é—á –æ—Ç API osu! v1", 'settings_api_key_desc': "–ü–æ–ª—É—á–∏—Ç—å –∫–ª—é—á –º–æ–∂–Ω–æ –∑–¥–µ—Å—å: osu.ppy.sh/p/api",
            'settings_api_v2_header': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ API osu! v2 (–∫–∞—Ä—Ç–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é)", 'settings_api_v2_source_text': "–ò—Å—Ç–æ—á–Ω–∏–∫ API v2", 'settings_api_v2_source_items': ["–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π", "–†—É—á–Ω–æ–π"], 'settings_client_id_text': "Client ID", 'settings_client_secret_text': "Client Secret", 'settings_api_v2_desc': "–°–æ–∑–¥–∞–π—Ç–µ OAuth –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–¥–µ—Å—å: osu.ppy.sh/home/account/edit#oauth",
            'settings_plugin_header': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–º–∞–Ω–¥", 'settings_cmd_prefix_text': "–ü—Ä–µ—Ñ–∏–∫—Å: –ò–≥—Ä–æ–∫", 'settings_cmd_prefix_subtext': "–ù–∞–ø—Ä–∏–º–µ—Ä: .osu", 'settings_map_cmd_prefix_text': "–ü—Ä–µ—Ñ–∏–∫—Å: –ö–∞—Ä—Ç–∞", 'settings_map_cmd_prefix_subtext': "–ù–∞–ø—Ä–∏–º–µ—Ä: .map", 'settings_osz_cmd_prefix_text': "–ü—Ä–µ—Ñ–∏–∫—Å: –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã", 'settings_osz_cmd_prefix_subtext': "–ù–∞–ø—Ä–∏–º–µ—Ä: .osz", 'settings_song_cmd_prefix_text': "–ü—Ä–µ—Ñ–∏–∫—Å: –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –º—É–∑—ã–∫–∏", 'settings_song_cmd_prefix_subtext': "–ù–∞–ø—Ä–∏–º–µ—Ä: .song",
            'settings_download_header': "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç (.osz)", 'settings_download_mode_text': "–ò—Å—Ç–æ—á–Ω–∏–∫", 'settings_download_mode_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (Sayobot)", "–†—É—á–Ω–æ–π"], 'settings_manual_url_text': "–°–≤–æ–π URL", 'settings_manual_url_subtext': "–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ '–†—É—á–Ω–æ–º' —Ä–µ–∂–∏–º–µ", 'settings_manual_url_desc': "–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π URL-—à–∞–±–ª–æ–Ω –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {} –∫–∞–∫ –º–µ—Å—Ç–æ –¥–ª—è ID –∫–∞—Ä—Ç—ã. –ü—Ä–∏–º–µ—Ä (Sayobot): https://txy1.sayobot.cn/download/osz/{}",
            'settings_download_path_text': "–ü—É—Ç—å –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è", 'settings_download_path_subtext': "–ü–∞–ø–∫–∞ –≤–Ω—É—Ç—Ä–∏ /Download. –ü—É—Å—Ç–æ = /Download, 'osu/maps' = /Download/osu/maps", 'settings_download_video_text': "–°–∫–∞—á–∏–≤–∞—Ç—å —Å –≤–∏–¥–µ–æ", 'settings_download_video_subtext': "",
            'settings_auto_delete_map_text': "–ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã", 'settings_auto_delete_map_subtext': "–£–¥–∞–ª—è—Ç—å –∫–∞—Ä—Ç—É –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —á–∞—Ç.",
            'settings_song_download_header': "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –º—É–∑—ã–∫–∏ (.mp3)", 'settings_song_download_path_text': "–ü—É—Ç—å –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è", 'settings_song_download_path_subtext': "–ü–∞–ø–∫–∞ –≤–Ω—É—Ç—Ä–∏ /Download. –ü—É—Å—Ç–æ = /Download, 'osu/songs' = /Download/osu/songs", 'settings_song_download_source_text': "–ò—Å—Ç–æ—á–Ω–∏–∫", 'settings_song_download_source_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (Sayobot)", "–†—É—á–Ω–æ–π"], 'settings_song_manual_url_text': "–°–≤–æ–π URL", 'settings_song_manual_url_subtext': "–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ '–†—É—á–Ω–æ–º' —Ä–µ–∂–∏–º–µ", 'settings_song_manual_url_desc': "–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π URL-—à–∞–±–ª–æ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {} –∫–∞–∫ –º–µ—Å—Ç–æ –¥–ª—è ID –∫–∞—Ä—Ç—ã.",
            'settings_auto_delete_song_text': "–ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ –º—É–∑—ã–∫–∏", 'settings_auto_delete_song_subtext': "–£–¥–∞–ª—è—Ç—å –º—É–∑—ã–∫—É –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —á–∞—Ç.",
            'settings_filename_header': "–ò–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∫–∞—Ä—Ç", 'settings_filename_mode_text': "–†–µ–∂–∏–º –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞", 'settings_filename_mode_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", "–†—É—á–Ω–æ–π", "–¢–æ–ª—å–∫–æ ID –∏ –í—Ä–µ–º—è"], 'settings_filename_template_text': "–®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞", 'settings_filename_template_subtext': "–¢–µ–≥–∏: {id}, {artist}, {title}, {creator}, {date}, {video}",
            'settings_song_filename_header': "–ò–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –º—É–∑—ã–∫–∏", 'settings_song_filename_mode_text': "–†–µ–∂–∏–º –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞", 'settings_song_filename_mode_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", "–†—É—á–Ω–æ–π"], 'settings_song_filename_template_text': "–®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞", 'settings_song_filename_template_subtext': "–¢–µ–≥–∏: {id}, {artist}, {title}, {creator}, {date}",
            'settings_caption_header': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–ø–∏—Å–∏ –∫ —Ñ–∞–π–ª—É –∫–∞—Ä—Ç—ã", 'settings_caption_mode_text': "–†–µ–∂–∏–º –ø–æ–¥–ø–∏—Å–∏", 'settings_caption_mode_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", "–†—É—á–Ω–æ–π", "–í—ã–∫–ª—é—á–∏—Ç—å"], 'settings_caption_template_text': "–®–∞–±–ª–æ–Ω –ø–æ–¥–ø–∏—Å–∏", 'settings_caption_template_subtext': "–¢–µ–≥–∏: {id}, {artist}, {title}, {creator}, {date}, {video}",
            'settings_song_caption_header': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–ø–∏—Å–∏ –∫ —Ñ–∞–π–ª—É –º—É–∑—ã–∫–∏", 'settings_song_caption_mode_text': "–†–µ–∂–∏–º –ø–æ–¥–ø–∏—Å–∏", 'settings_song_caption_mode_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", "–†—É—á–Ω–æ–π", "–í—ã–∫–ª—é—á–∏—Ç—å"],
            'settings_song_caption_template_text': "–®–∞–±–ª–æ–Ω –ø–æ–¥–ø–∏—Å–∏", 'settings_song_caption_template_subtext': "–¢–µ–≥–∏: {id}, {artist}, {title}, {creator}, {date}",
            'settings_display_submenu': "–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ", 'settings_user_stats_submenu': "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞", 'settings_map_info_submenu': "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ä—Ç–µ",
            'settings_quote_user_stats': "–¶–∏—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É", 'settings_emoji_main_submenu': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≠–º–æ–¥–∑–∏",
            'settings_emoji_display_mode_text': "–í–∏–¥ —ç–º–æ–¥–∑–∏",
            'settings_emoji_display_mode_items': ["–û–±—ã—á–Ω—ã–π", "–ü—Ä–µ–º–∏—É–º (–±–µ–ª–∞—è)", "–†—É—á–Ω–æ–π"],
            'settings_emoji_id_guide_header': "–ö–∞–∫ –Ω–∞–π—Ç–∏ ID —ç–º–æ–¥–∑–∏ (–¥–ª—è –ø—Ä–µ–º–æ–∫)",
            'settings_emoji_id_guide_text': (
                "–°–ø–æ—Å–æ–± –ø–æ–ª—É—á–µ–Ω–∏—è ID —Å –ø–æ–º–æ—â—å—é –±–æ—Ç–∞:\n\n"
                "1. –í –ø–æ–∏—Å–∫–µ —Ç–µ–ª–µ–≥—Ä–∞–º–∞ –Ω–∞–π–¥–∏—Ç–µ @AdsMarkdownBot\n"
                "2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–º—É –ø—Ä–µ–º–∏—É–º-—ç–º–æ–¥–∑–∏ –∫–∞–∫ –æ–±—ã—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n"
                "3. –ë–æ—Ç –≤ –æ—Ç–≤–µ—Ç –ø—Ä–∏—à–ª–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ [—ç–º–æ–¥–∑–∏](id). –ü—Ä–∏–º–µ—Ä: [‚ô•Ô∏è] (5451765549757400442)\n"
                "4. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç –∏ –≤ \"–†—É—á–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ —ç–º–æ–¥–∑–∏\" –≤—Å—Ç–∞–≤–ª—è–π—Ç–µ –µ–≥–æ –≤ –Ω—É–∂–Ω–æ–µ –≤–∞–º –º–µ—Å—Ç–æ.\n\n"
                "–°–ø–æ—Å–æ–± –ø–æ–ª—É—á–µ–Ω–∏—è ID —Å –ø–æ–º–æ—â—å—é –ø–ª–∞–≥–∏–Ω–∞:\n"
                "1. –°–∫–∞—á–∞–π—Ç–µ –ø–ª–∞–≥–∏–Ω \"Emoji Parser\" –≤ https://t.me/exteraPluginsSup/260\n"
                "2. –í –∏–∑–±—Ä–∞–Ω–Ω–æ–º –∏–ª–∏ –ª—é–±–æ–º —á–∞—Ç–µ –Ω–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≤–∞—à–∏–º–∏ —ç–º–æ–¥–∑–∏\n"
                "3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥–µ .eid –≤ –æ—Ç–≤–µ—Ç –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n"
                "4. –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ ID —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –≤ \"–†—É—á–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ —ç–º–æ–¥–∑–∏\" –≤—Å—Ç–∞–≤–ª—è–π—Ç–µ –µ–≥–æ –≤ –Ω—É–∂–Ω–æ–µ –≤–∞–º –º–µ—Å—Ç–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ [—ç–º–æ–¥–∑–∏](id). –ü—Ä–∏–º–µ—Ä: [‚ô•Ô∏è] (5451765549757400442)"
            ),
            'settings_manual_emoji_header': "–†—É—á–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ —ç–º–æ–¥–∑–∏",
            'settings_emoji_user_stats_header': "–≠–º–æ–¥–∑–∏: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞", 'settings_emoji_map_info_header': "–≠–º–æ–¥–∑–∏: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ä—Ç–µ",
            'settings_emoji_gamemode_header': "–≠–º–æ–¥–∑–∏: –†–µ–∂–∏–º—ã –∏–≥—Ä—ã", 'settings_emoji_mode_osu': "–≠–º–æ–¥–∑–∏: osu!", 'settings_emoji_mode_taiko': "–≠–º–æ–¥–∑–∏: Taiko", 'settings_emoji_mode_catch': "–≠–º–æ–¥–∑–∏: Catch", 'settings_emoji_mode_mania': "–≠–º–æ–¥–∑–∏: Mania",
            'settings_search_header': "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∏—Å–∫–∞", 'settings_search_all_maps_text': "–ò—Å–∫–∞—Ç—å –≤—Å–µ —Å—Ç–∞—Ç—É—Å—ã –∫–∞—Ä—Ç", 'settings_search_all_maps_subtext': "–í–∫–ª—é—á–∞–µ—Ç –≤ –ø–æ–∏—Å–∫ –∫–∞—Ä—Ç—ã —Å–æ —Å—Ç–∞—Ç—É—Å–∞–º–∏ Graveyard, WIP, Pending",
            'settings_pp_style_text': "–ù–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è PP", 'settings_pp_style_items': ["PP", "Performance Point"],
            'settings_profile_link_mode_text': "–°—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–æ—Ñ–∏–ª—å", 'settings_profile_link_mode_items': ["–ù–∞ –Ω–∏–∫–Ω–µ–π–º–µ", "–í –∫–æ–Ω—Ü–µ", "–í—ã–∫–ª—é—á–∏—Ç—å"],
            'settings_mapper_link_mode_text': "–°—Å—ã–ª–∫–∞ –Ω–∞ –º–∞–ø–ø–µ—Ä–∞", 'settings_mapper_link_mode_items': ["–ù–∞ –Ω–∏–∫–Ω–µ–π–º–µ", "–í –∫–æ–Ω—Ü–µ", "–í—ã–∫–ª—é—á–∏—Ç—å"], 'settings_map_status_lang': "–Ø–∑—ã–∫ —Å—Ç–∞—Ç—É—Å–æ–≤ –∫–∞—Ä—Ç", 'settings_map_status_lang_items': ["–ê–Ω–≥–ª–∏–π—Å–∫–∏–π", "–†—É—Å—Å–∫–∏–π"], 'settings_map_stats_style_text': "–°—Ç–∏–ª—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏", 'settings_map_stats_style_items': ["–≠–º–æ–¥–∑–∏", "–¢–µ–∫—Å—Ç"], 'settings_map_video_style_text': "–°—Ç–∏–ª—å –≤–∏–¥–µ–æ", 'settings_map_video_style_items': ["–≠–º–æ–¥–∑–∏", "–¢–µ–∫—Å—Ç"], 'settings_map_link_mode_text': "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É", 'settings_map_link_mode_items': ["–í –Ω–∞–∑–≤–∞–Ω–∏–∏", "–û—Ç–¥–µ–ª—å–Ω–æ –≤ –∫–æ–Ω—Ü–µ", "–í—ã–∫–ª—é—á–∏—Ç—å"], 'settings_quote_map_diffs': "–¶–∏—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏", 'settings_quote_map_stats': "–¶–∏—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
            'settings_diff_display_header': "–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–µ–π",
            'settings_diff_gamemode_display_text': "–†–µ–∂–∏–º –∏–≥—Ä—ã –≤ —Å–ª–æ–∂–Ω–æ—Å—Ç—è—Ö", 'settings_diff_gamemode_display_items': ["–≠–º–æ–¥–∑–∏", "–¢–µ–∫—Å—Ç", "–í—ã–∫–ª—é—á–∏—Ç—å"],
            'settings_sort_mode_text': "–†–µ–∂–∏–º –ø–æ—Ä—è–¥–∫–∞", 'settings_sort_mode_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", "–†—É—á–Ω–æ–π"], 'settings_manual_sort_note': "–ü–æ—Ä—è–¥–æ–∫ –Ω–∏–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ '–†—É—á–Ω–æ–º' —Ä–µ–∂–∏–º–µ.",
            'settings_user_gamemode_text': "–í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã", 'settings_user_gamemode_items': ["–ê–≤—Ç–æ", "osu!", "Taiko", "Catch", "Mania"],
            'settings_user_stats_sort_text': "–ü–æ—Ä—è–¥–æ–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏", 'settings_user_stats_sort_desc': "–ö–ª—é—á–∏: mode, user_id, global_rank, country_rank, pp, accuracy, playcount, ranks, best_pp_map, level, time_played, join_date. –†–∞–∑–¥–µ–ª—è–π—Ç–µ –∑–∞–ø—è—Ç–æ–π.",
            'settings_map_info_sort_text': "–ü–æ—Ä—è–¥–æ–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏", 'settings_map_info_sort_desc': "–ö–ª—é—á–∏: map_id, creator, status, source, stats, video_presence, dates. –†–∞–∑–¥–µ–ª—è–π—Ç–µ –∑–∞–ø—è—Ç–æ–π.", 'settings_map_info_header_general': "–û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
            'settings_diff_info_sort_text': "–ü–æ—Ä—è–¥–æ–∫ —Å–ª–æ–∂–Ω–æ—Å—Ç–µ–π", 'settings_diff_info_sort_desc': "–ö–ª—é—á–∏: stars, length, bpm, csar. –†–∞–∑–¥–µ–ª—è–π—Ç–µ –∑–∞–ø—è—Ç–æ–π.",
            'output_gamemode': "*–†–µ–∂–∏–º:* `{mode_name}`\n", 'output_title_linked': "*–ù–∏–∫–Ω–µ–π–º [{username}]({profile_url}) [{country}]:* ", 'output_title_unlinked': "*–ù–∏–∫–Ω–µ–π–º {username} [{country}]:* ", 'output_user_id': "*ID:* `{user_id}`\n", 'output_global_rank': "*–ì–ª–æ–±–∞–ª —Ä–∞–Ω–≥:* ", 'output_country_rank': "*–†–∞–Ω–≥ –≤ —Å—Ç—Ä–∞–Ω–µ:* ", 'output_accuracy': "*–¢–æ—á–Ω–æ—Å—Ç—å:* ", 'output_playcount': "*–í—Å–µ–≥–æ –∏–≥—Ä:* ", 'output_level': "*–£—Ä–æ–≤–µ–Ω—å:* ", 'output_time_played': "*–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:* ", 'time_played_unit': "—á.", 'output_join_date': "*–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:* ", 'output_ranks': "*–†–∞–Ω–≥–∏:* ", 'output_best_pp_map': "*–õ—É—á—à–∞—è –∫–∞—Ä—Ç–∞:* [{pp} PP]({url})\n", 'output_profile_link': "*–ü—Ä–æ—Ñ–∏–ª—å:* [–æ—Ç–∫—Ä—ã—Ç—å]({url})",
            'output_map_title_linked': "*{artist}* - [{title}]({url})\n", 'output_map_title_unlinked': "*{artist}* - *{title}*\n", 'output_map_id': "*ID:* `{map_id}`\n", 'output_map_creator': "*–ú–∞–ø–ø–µ—Ä:* `{creator}`\n", 'output_map_creator_linked': "*–ú–∞–ø–ø–µ—Ä:* [{creator}]({url})\n", 'output_map_status': "*–°—Ç–∞—Ç—É—Å:* `{status}`\n", 'output_map_source': "*–ò—Å—Ç–æ—á–Ω–∏–∫:* `{source}`\n", 'output_map_stats_emoji': "*–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:* `{plays}` {emoji_plays}; `{favs}` {emoji_favs}\n", 'output_map_stats_text': "*–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:* `{plays}` –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–π; `{favs}` –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º\n", 'output_map_video_emoji': "*–í–∏–¥–µ–æ:* {emoji_video_status}\n", 'output_map_video_text': "*–í–∏–¥–µ–æ:* {video_status_text}\n", 'output_map_dates': "*–î–∞—Ç—ã:* –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ `{submit}`; –æ–±–Ω–æ–≤–ª–µ–Ω–∞ `{update}`\n", 'output_map_link': "*–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É:* [–æ—Ç–∫—Ä—ã—Ç—å]({url})", 'output_mapper_profile_link': "*–°—Å—ã–ª–∫–∞ –Ω–∞ –º–∞–ø–ø–µ—Ä–∞:* [–æ—Ç–∫—Ä—ã—Ç—å]({url})", 'output_map_diffs_header': "*–°–ª–æ–∂–Ω–æ—Å—Ç–∏:* ",
            'gamemode_osu': "osu!", 'gamemode_taiko': "Taiko", 'gamemode_catch': "Catch", 'gamemode_mania': "Mania",
            'usage_user_message': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: {prefix} [–Ω–∏–∫–Ω–µ–π–º] –∏–ª–∏ {prefix} [–Ω–∏–∫–Ω–µ–π–º:—Ä–µ–∂–∏–º]", 'usage_map_message': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: {prefix} [–Ω–∞–∑–≤–∞–Ω–∏–µ, ID –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É]", 'usage_osz_message': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: {prefix} [–Ω–∞–∑–≤–∞–Ω–∏–µ, ID –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É]", 'usage_song_message': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: {prefix} [–Ω–∞–∑–≤–∞–Ω–∏–µ, ID –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É]",
            'loading_message': "–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ osu!...", 'loading_map_message': "–ü–æ–∏—Å–∫ –∫–∞—Ä—Ç—ã osu!...", 'loading_song_search_message': "–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏ osu!...", 'loading_osz_message': "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã„ÉªID {id}", 'loading_song_message': "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –º—É–∑—ã–∫–∏„ÉªID {id}", 'loading_osz_trying_mirror': "–ü–æ–ø—ã—Ç–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Å {source_name}...", 'loading_osz_progress_with_size': "{d_mb} –ú–ë / {t_mb} –ú–ë ({progress}%)", 'loading_osz_progress_no_size': "{d_mb} –ú–ë —Å–∫–∞—á–∞–Ω–æ", 'critical_error_message': "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –ø–ª–∞–≥–∏–Ω–µ osu!: {error}",
            'error_player_not_found': "–ò–≥—Ä–æ–∫ —Å –Ω–∏–∫–æ–º '{nickname}' –Ω–µ –Ω–∞–π–¥–µ–Ω.", 'error_map_not_found': "–ö–∞—Ä—Ç—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É '{query}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.", 'error_api_key_missing': "API –∫–ª—é—á v1 –Ω–µ —É–∫–∞–∑–∞–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ª—É—á–∏—Ç–µ –µ–≥–æ –Ω–∞ —Å–∞–π—Ç–µ osu! –∏ –¥–æ–±–∞–≤—å—Ç–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö, –ª–∏–±–æ –≤—ã–±–µ—Ä–∏—Ç–µ '–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π' –∏—Å—Ç–æ—á–Ω–∏–∫ API.", 'error_api_v1_401': "–û—à–∏–±–∫–∞ 401: –£–∫–∞–∑–∞–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á v1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.", 'error_v2_credentials_missing': "Client ID –∏–ª–∏ Client Secret –¥–ª—è API v2 –Ω–µ —É–∫–∞–∑–∞–Ω—ã –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ª—É—á–∏—Ç–µ –∏—Ö –Ω–∞ —Å–∞–π—Ç–µ osu! –∏ –¥–æ–±–∞–≤—å—Ç–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö, –ª–∏–±–æ –≤—ã–±–µ—Ä–∏—Ç–µ '–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π' –∏—Å—Ç–æ—á–Ω–∏–∫ API.", 'error_v2_auth_failed': "–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ API v2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–≤–æ–∏ Client ID –∏ Client Secret.", 'error_api_error': "–û—à–∏–±–∫–∞ API osu! (—Å—Ç–∞—Ç—É—Å: {status_code}).", 'error_network_error': "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ API osu!.", 'error_formatting_error': "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö. API –º–æ–≥ –≤–µ—Ä–Ω—É—Ç—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.", 'error_download_failed': "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª: {error}", 'error_map_id_not_found': "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ ID –∫–∞—Ä—Ç—ã –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.", 'error_download_source_failed': "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª —Å —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞.", 'error_sending_file': "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª.", 'success_download_sent': "–§–∞–π–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ –ó–∞–≥—Ä—É–∑–∫–∞—Ö.", 'error_invalid_manual_url': "–ù–µ–≤–µ—Ä–Ω—ã–π —à–∞–±–ª–æ–Ω —Å–≤–æ–µ–≥–æ URL –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç {}.", 'error_invalid_gamemode': "–ù–µ–≤–µ—Ä–Ω—ã–π —Ä–µ–∂–∏–º –∏–≥—Ä—ã '{mode}'. –î–æ—Å—Ç—É–ø–Ω—ã–µ: osu, taiko, catch, mania.",
            'video_present': "–ï—Å—Ç—å", 'video_absent': "–ù–µ—Ç",
            'settings_cancel_button': "–û—Ç–º–µ–Ω–∞",
            'download_cancellable_notice': "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—É—Å—Ç–æ–µ –º–µ—Å—Ç–æ, —á—Ç–æ–±—ã —Ñ–∞–π–ª —Å–∫–∞—á–∏–≤–∞–ª—Å—è –Ω–∞ —Ñ–æ–Ω–µ. –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—ã —Å–Ω–∏–∑—É –ø–æ–ª—É—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.",
            'download_cancelled_message': "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
            'file_deleted_message': "–§–∞–π–ª '{filename}' —É–¥–∞–ª–µ–Ω.",
            'settings_collapse_diffs_text': "–°–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏",
            'settings_collapse_diffs_subtext': "–°—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø—Ä–∏ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ø—Ä–µ–¥–µ–ª–µ –Ω–∏–∂–µ",
            'settings_collapse_diffs_threshold_text': "–ú–∏–Ω–∏–º—É–º –¥–ª—è —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è",
            'settings_collapse_diffs_threshold_subtext': "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–∂–Ω–æ—Å—Ç–µ–π, –Ω–∞—á–∏–Ω–∞—è —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–Ω–∏ –±—É–¥—É—Ç —Å–≤–µ—Ä–Ω—É—Ç—ã.",
            'use_emojis_text': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç–º–æ–¥–∑–∏",
            'settings_emoji_username': "–≠–º–æ–¥–∑–∏: –ù–∏–∫–Ω–µ–π–º",
            'settings_emoji_user_id': "–≠–º–æ–¥–∑–∏: ID",
            'settings_emoji_global_rank': "–≠–º–æ–¥–∑–∏: –ì–ª–æ–±–∞–ª —Ä–∞–Ω–≥",
            'settings_emoji_country_rank': "–≠–º–æ–¥–∑–∏: –†–∞–Ω–≥ –≤ —Å—Ç—Ä–∞–Ω–µ",
            'settings_emoji_pp': "–≠–º–æ–¥–∑–∏: PP",
            'settings_emoji_accuracy': "–≠–º–æ–¥–∑–∏: –¢–æ—á–Ω–æ—Å—Ç—å",
            'settings_emoji_playcount': "–≠–º–æ–¥–∑–∏: –ò–≥—Ä—ã",
            'settings_emoji_ranks': "–≠–º–æ–¥–∑–∏: –†–∞–Ω–≥–∏",
            'settings_emoji_best_map': "–≠–º–æ–¥–∑–∏: –õ—É—á—à–∞—è –∫–∞—Ä—Ç–∞",
            'settings_emoji_level': "–≠–º–æ–¥–∑–∏: –£—Ä–æ–≤–µ–Ω—å",
            'settings_emoji_time_played': "–≠–º–æ–¥–∑–∏: –í—Ä–µ–º—è –≤ –∏–≥—Ä–µ",
            'settings_emoji_join_date': "–≠–º–æ–¥–∑–∏: –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏",
            'settings_emoji_profile_link': "–≠–º–æ–¥–∑–∏: –°—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–æ—Ñ–∏–ª—å",
            'settings_emoji_map_title': "–≠–º–æ–¥–∑–∏: –ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã",
            'settings_emoji_map_id': "–≠–º–æ–¥–∑–∏: ID –∫–∞—Ä—Ç—ã",
            'settings_emoji_map_creator': "–≠–º–æ–¥–∑–∏: –ú–∞–ø–ø–µ—Ä",
            'settings_emoji_map_status': "–≠–º–æ–¥–∑–∏: –°—Ç–∞—Ç—É—Å",
            'settings_emoji_map_source': "–≠–º–æ–¥–∑–∏: –ò—Å—Ç–æ—á–Ω–∏–∫",
            'settings_emoji_map_stats': "–≠–º–æ–¥–∑–∏: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
            'settings_emoji_map_plays': "–≠–º–æ–¥–∑–∏: –ò–≥—Ä—ã",
            'settings_emoji_map_favs': "–≠–º–æ–¥–∑–∏: –ò–∑–±—Ä–∞–Ω–Ω–æ–µ",
            'settings_emoji_map_video': "–≠–º–æ–¥–∑–∏: –í–∏–¥–µ–æ (–æ–±—â–∏–π)",
            'settings_emoji_map_video_present': "–≠–º–æ–¥–∑–∏: –í–∏–¥–µ–æ (–µ—Å—Ç—å)",
            'settings_emoji_map_video_absent': "–≠–º–æ–¥–∑–∏: –í–∏–¥–µ–æ (–Ω–µ—Ç)",
            'settings_emoji_map_dates': "–≠–º–æ–¥–∑–∏: –î–∞—Ç—ã",
            'settings_emoji_map_link': "–≠–º–æ–¥–∑–∏: –°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É",
            'settings_emoji_map_mapper_link': "–≠–º–æ–¥–∑–∏: –°—Å—ã–ª–∫–∞ –Ω–∞ –º–∞–ø–ø–µ—Ä–∞",
            'settings_emoji_map_diffs': "–≠–º–æ–¥–∑–∏: –°–ª–æ–∂–Ω–æ—Å—Ç–∏",    
        },
        'en': {
            'help_command_header': "*osu! Search Plugin Commands:*\n",
            'settings_lang_header': "Plugin Language", 'settings_lang_text': "Language",
            'settings_api_submenu': "API Settings",
            'settings_api_header': "osu! API v1 Settings (player, map by ID)", 'settings_api_source_text': "API v1 Source", 'settings_api_source_items': ["Built-in", "Manual"], 'settings_api_key_text': "API Key v1", 'settings_api_key_subtext': "Your osu! API v1 key", 'settings_api_key_desc': "Get your key here: osu.ppy.sh/p/api",
            'settings_api_v2_header': "osu! API v2 Settings (map by name)", 'settings_api_v2_source_text': "API v2 Source", 'settings_api_v2_source_items': ["Built-in", "Manual"], 'settings_client_id_text': "Client ID", 'settings_client_secret_text': "Client Secret", 'settings_api_v2_desc': "Used for searching maps by name. Create an OAuth application here: osu.ppy.sh/home/account/edit#oauth",
            'settings_plugin_header': "Commands Settings", 'settings_cmd_prefix_text': "Prefix: Player", 'settings_cmd_prefix_subtext': "Example: .osu", 'settings_map_cmd_prefix_text': "Prefix: Map", 'settings_map_cmd_prefix_subtext': "Example: .map", 'settings_osz_cmd_prefix_text': "Prefix: Download Map", 'settings_osz_cmd_prefix_subtext': "Example: .osz", 'settings_song_cmd_prefix_text': "Prefix: Download Song", 'settings_song_cmd_prefix_subtext': "Example: .song",
            'settings_download_header': "Map Download (.osz)", 'settings_download_mode_text': "Source", 'settings_download_mode_items': ["Default (Sayobot)", "Manual"], 'settings_manual_url_text': "Custom URL", 'settings_manual_url_subtext': "Only used in 'Manual' mode", 'settings_manual_url_desc': "Enter the Custom URL template for downloading. Use {} as a placeholder for the mapset ID. Example (Sayobot): https://txy1.sayobot.cn/download/osz/{}",
            'settings_download_path_text': "Download path", 'settings_download_path_subtext': "Folder inside /Download. Empty = /Download, 'osu/maps' = /Download/osu/maps", 'settings_download_video_text': "Download with video", 'settings_download_video_subtext': "",
            'settings_auto_delete_map_text': "Auto-delete map", 'settings_auto_delete_map_subtext': "Delete map after sending to chat.",
            'settings_song_download_header': "Song Download (.mp3)", 'settings_song_download_path_text': "Download path", 'settings_song_download_path_subtext': "Folder inside /Download. Empty = /Download, 'osu/songs' = /Download/osu/songs", 'settings_song_download_source_text': "Source", 'settings_song_download_source_items': ["–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (Sayobot)", "–†—É—á–Ω–æ–π"], 'settings_song_manual_url_text': "Custom URL", 'settings_song_manual_url_subtext': "Only used in 'Manual' mode", 'settings_song_manual_url_desc': "Enter your URL template. Use {} for the mapset ID.",
            'settings_auto_delete_song_text': "Auto-delete song", 'settings_auto_delete_song_subtext': "Delete song after sending to chat.",
            'settings_filename_header': "Map File Naming", 'settings_filename_mode_text': "File name mode", 'settings_filename_mode_items': ["Default", "Manual", "ID and Time only"], 'settings_filename_template_text': "Filename template", 'settings_filename_template_subtext': "Tags: {id}, {artist}, {title}, {creator}, {date}, {video}",
            'settings_song_filename_header': "Song File Naming", 'settings_song_filename_mode_text': "File name mode", 'settings_song_filename_mode_items': ["Default", "Manual"], 'settings_song_filename_template_text': "Filename template", 'settings_song_filename_template_subtext': "Tags: {id}, {artist}, {title}, {creator}, {date}",
            'settings_caption_header': "Map File Caption Settings", 'settings_caption_mode_text': "Caption mode", 'settings_caption_mode_items': ["Default", "Manual", "Disable"], 'settings_caption_template_text': "Caption template", 'settings_caption_template_subtext': "Tags: {id}, {artist}, {title}, {creator}, {date}, {video}",
            'settings_song_caption_header': "Song File Caption Settings", 'settings_song_caption_mode_text': "Caption mode", 'settings_song_caption_mode_items': ["Default", "Manual", "Disable"],
            'settings_song_caption_template_text': "Caption template", 'settings_song_caption_template_subtext': "Tags: {id}, {artist}, {title}, {creator}, {date}",
            'settings_display_submenu': "Display & Formatting", 'settings_user_stats_submenu': "Player Statistics", 'settings_map_info_submenu': "Map Information",
            'settings_quote_user_stats': "Quote player statistics", 'settings_emoji_main_submenu': "Emoji Settings",
            'settings_emoji_display_mode_text': "Emoji Display Mode",
            'settings_emoji_display_mode_items': ["Default", "Premium (white)", "Manual"],
            'settings_emoji_id_guide_header': "How to find emoji ID (for Premium)",
            'settings_emoji_id_guide_text': (
                "Method to get ID using a bot:\n\n"
                "1. Search for @AdsMarkdownBot on Telegram.\n"
                "2. Send it a premium emoji as a regular message.\n"
                "3. The bot will reply with text in [emoji](id) format. Example: [‚ô•Ô∏è] (5451765549757400442)\n"
                "4. Copy the text and paste it into the desired field in \"Manual Emoji Settings\".\n\n"
                "Method to get ID using a plugin:\n"
                "1. Download the \"Emoji Parser\" plugin from https://t.me/exteraPluginsSup/260\n"
                "2. In Saved Messages or any chat, write a message with your emojis.\n"
                "3. Use the .eid command in reply to this message.\n"
                "4. Copy the obtained IDs and paste them into the desired field in \"Manual Emoji Settings\" in [emoji](id) format. Example: [‚ô•Ô∏è] (5451765549757400442)"
            ),
            'settings_manual_emoji_header': "Manual Emoji Settings",
            'settings_emoji_user_stats_header': "Emoji: Player Statistics", 'settings_emoji_map_info_header': "Emoji: Map Information",
            'settings_emoji_gamemode_header': "Emoji: Game Modes", 'settings_emoji_mode_osu': "Emoji: osu!", 'settings_emoji_mode_taiko': "Emoji: Taiko", 'settings_emoji_mode_catch': "Emoji: Catch", 'settings_emoji_mode_mania': "Emoji: Mania",
            'settings_search_header': "Search Settings", 'settings_search_all_maps_text': "Search all map statuses", 'settings_search_all_maps_subtext': "Includes Graveyard, WIP, and Pending maps in search results",
            'settings_pp_style_text': "Label for PP", 'settings_pp_style_items': ["PP", "Performance Point"],
            'settings_profile_link_mode_text': "Profile link", 'settings_profile_link_mode_items': ["On nickname", "At the end", "Disabled"],
            'settings_mapper_link_mode_text': "Mapper profile link", 'settings_mapper_link_mode_items': ["On nickname", "At the end", "Disabled"], 'settings_map_status_lang': "Map Status Language", 'settings_map_status_lang_items': ["English", "Russian"], 'settings_map_stats_style_text': "Stats display style", 'settings_map_stats_style_items': ["Emoji", "Text"], 'settings_map_video_style_text': "Video style", 'settings_map_video_style_items': ["Emoji", "Text"], 'settings_map_link_mode_text': "Map link", 'settings_map_link_mode_items': ["On title", "At the end", "Disabled"], 'settings_quote_map_diffs': "Quote difficulties", 'settings_quote_map_stats': "Quote map statistics",
            'settings_diff_display_header': "Difficulties Display",
            'settings_diff_gamemode_display_text': "Display game mode in difficulties", 'settings_diff_gamemode_display_items': ["Emoji", "Text", "Disable"],
            'settings_sort_mode_text': "Sort Mode", 'settings_sort_mode_items': ["Default", "Manual"], 'settings_manual_sort_note': "The order below is only used in 'Manual' mode.",
            'settings_user_gamemode_text': "Game Mode Selection", 'settings_user_gamemode_items': ["Auto", "osu!", "Taiko", "Catch", "Mania"],
            'settings_user_stats_sort_text': "Stats Order", 'settings_user_stats_sort_desc': "Keys: mode, user_id, global_rank, country_rank, pp, accuracy, playcount, ranks, best_pp_map, level, time_played, join_date. Separate with commas.",
            'settings_map_info_sort_text': "Info Order", 'settings_map_info_sort_desc': "Keys: map_id, creator, status, source, stats, video_presence, dates. Separate with commas.", 'settings_map_info_header_general': "General Information",
            'settings_diff_info_sort_text': "Difficulties Order", 'settings_diff_info_sort_desc': "Keys: stars, length, bpm, csar. Separate with commas.",
            'output_gamemode': "*Mode:* `{mode_name}`\n", 'output_title_linked': "*Nickname [{username}]({profile_url}) [{country}]:* ", 'output_title_unlinked': "*Nickname {username} [{country}]:* ", 'output_user_id': "*ID:* `{user_id}`\n", 'output_global_rank': "*Global Rank:* ", 'output_country_rank': "*Country Rank:* ", 'output_accuracy': "*Accuracy:* ", 'output_playcount': "*Playcount:* ", 'output_level': "*Level:* ", 'output_time_played': "*Time Played:* ", 'time_played_unit': "h.", 'output_join_date': "*Join Date:* ", 'output_ranks': "*Ranks:* ", 'output_best_pp_map': "*Best Map:* [{pp} PP]({url})\n", 'output_profile_link': "*Profile:* [open]({url})",
            'output_map_title_linked': "*{artist}* - [{title}]({url})\n", 'output_map_title_unlinked': "*{artist}* - *{title}*\n", 'output_map_id': "*ID:* `{map_id}`\n", 'output_map_creator': "*Mapper:* `{creator}`\n", 'output_map_creator_linked': "*Mapper:* [{creator}]({url})\n", 'output_map_status': "*Status:* `{status}`\n", 'output_map_source': "*Source:* `{source}`\n", 'output_map_stats_emoji': "*Stats:* `{plays}` {emoji_plays}; `{favs}` {emoji_favs}\n", 'output_map_stats_text': "*Stats:* `{plays}` plays; `{favs}` favourites\n", 'output_map_video_emoji': "*Video:* {emoji_video_status}\n", 'output_map_video_text': "*Video:* {video_status_text}\n", 'output_map_dates': "*Dates:* submitted on `{submit}`; updated on `{update}`\n", 'output_map_link': "*Map Link:* [open]({url})", 'output_mapper_profile_link': "*Mapper Link:* [open]({url})", 'output_map_diffs_header': "*Difficulties:* ",
            'gamemode_osu': "osu!", 'gamemode_taiko': "Taiko", 'gamemode_catch': "Catch", 'gamemode_mania': "Mania",
            'usage_user_message': "Usage: {prefix} [nickname] or {prefix} [nickname:mode]", 'usage_map_message': "Usage: {prefix} [map name, ID or link]", 'usage_osz_message': "Usage: {prefix} [map name, ID or link]", 'usage_song_message': "Usage: {prefix} [map name, ID or link]",
            'loading_message': "Loading osu! stats...", 'loading_map_message': "Searching osu! map...", 'loading_song_search_message': "Searching osu! song...", 'loading_osz_message': "Downloading map„ÉªID {id}", 'loading_song_message': "Downloading song„ÉªID {id}", 'loading_osz_trying_mirror': "Trying download from {source_name}...", 'loading_osz_progress_with_size': "{d_mb} MB / {t_mb} MB ({progress}%)", 'loading_osz_progress_no_size': "{d_mb} MB downloaded", 'critical_error_message': "Critical error in osu! plugin: {error}",
            'error_player_not_found': "Player with nickname '{nickname}' not found.", 'error_map_not_found': "Map matching '{query}' not found.", 'error_api_key_missing': "API key v1 is not specified. Please get it from the osu! website and add it in the settings, or select the 'Built-in' API source.", 'error_api_v1_401': "Error 401: Invalid API v1 key provided. Please check the key in the settings.", 'error_v2_credentials_missing': "Client ID or Client Secret for API v2 not specified. Please get them from the osu! website and add them in settings, or select the 'Built-in' API source.", 'error_v2_auth_failed': "API v2 authentication failed. Check your Client ID and Client Secret.", 'error_api_error': "osu! API error (status: {status_code}).", 'error_network_error': "Network error when requesting the osu! API.", 'error_formatting_error': "An error occurred while formatting data. The API may have returned invalid values.", 'error_download_failed': "Failed to download file: {error}", 'error_map_id_not_found': "Could not find a map ID to download.", 'error_download_source_failed': "Failed to download the file from the specified source.", 'error_sending_file': "Failed to send the downloaded file.", 'success_download_sent': "File sent and saved to Downloads.", 'error_invalid_manual_url': "Invalid manual download Custom URL template in settings. Make sure it contains {}.", 'error_invalid_gamemode': "Invalid game mode '{mode}'. Available: osu, taiko, catch, mania.",
            'video_present': "Present", 'video_absent': "Absent",
            'settings_cancel_button': "Cancel",
            'download_cancellable_notice': "Tap outside to download the file in the background. You will be notified upon completion.",
            'download_cancelled_message': "Download cancelled.",
            'file_deleted_message': "File '{filename}' —É–¥–∞–ª–µ–Ω.",
            'settings_collapse_diffs_text': "Collapse difficulties",
            'settings_collapse_diffs_subtext': "Triggers when the quantity limit below is reached",
            'settings_collapse_diffs_threshold_text': "Minimum to collapse",
            'settings_collapse_diffs_threshold_subtext': "Number of difficulties from which they will be collapsed.",
            'use_emojis_text': "Use Emojis",
            'settings_emoji_username': "Emoji: Nickname",
            'settings_emoji_user_id': "Emoji: ID",
            'settings_emoji_global_rank': "Emoji: Global Rank",
            'settings_emoji_country_rank': "Emoji: Country Rank",
            'settings_emoji_pp': "Emoji: PP",
            'settings_emoji_accuracy': "Emoji: Accuracy",
            'settings_emoji_playcount': "Emoji: Playcount",
            'settings_emoji_ranks': "Emoji: Ranks",
            'settings_emoji_best_map': "Emoji: Best Map",
            'settings_emoji_level': "Emoji: Level",
            'settings_emoji_time_played': "Emoji: Time Played",
            'settings_emoji_join_date': "Emoji: Join Date",
            'settings_emoji_profile_link': "Emoji: Profile Link",
            'settings_emoji_map_title': "Emoji: Map Title",
            'settings_emoji_map_id': "Emoji: Map ID",
            'settings_emoji_map_creator': "Emoji: Mapper",
            'settings_emoji_map_status': "Emoji: Status",
            'settings_emoji_map_source': "Emoji: Source",
            'settings_emoji_map_stats': "Emoji: Stats",
            'settings_emoji_map_plays': "Emoji: Plays",
            'settings_emoji_map_favs': "Emoji: Favourites",
            'settings_emoji_map_video': "Emoji: Video (general)",
            'settings_emoji_map_video_present': "Emoji: Video (present)",
            'settings_emoji_map_video_absent': "Emoji: Video (absent)",
            'settings_emoji_map_dates': "Emoji: Dates",
            'settings_emoji_map_link': "Emoji: Map Link",
            'settings_emoji_map_mapper_link': "Emoji: Mapper Link",
            'settings_emoji_map_diffs': "Emoji: Difficulties",
        }
    }

    def __init__(self):
        super().__init__()
        self.progress_dialog_builder: Optional[AlertDialogBuilder] = None
        self.is_download_cancelled = False
        
        self.premium_pack_white = {
            "emoji_mode_osu": "5206293067685988022",
            "emoji_mode_taiko": "5206291216555084391",
            "emoji_mode_catch": "5206205489007857482",
            "emoji_mode_mania": "5206357986116665788",
            "emoji_username": "5879770735999717115",
            "emoji_user_id": "5877597667231534929",
            "emoji_global_rank": "5879585266426973039",
            "emoji_country_rank": "5994378304751145264",
            "emoji_pp": "5994809115740737538",
            "emoji_accuracy": "5994378914636500516",
            "emoji_playcount": "5775981206319402773",
            "emoji_ranks": "5931472654660800739",
            "emoji_best_map": "5766879414704935108",
            "emoji_level": "6005807101056651268",
            "emoji_time_played": "5778605968208170641",
            "emoji_join_date": "5967412305338568701",
            "emoji_profile_link": "5877465816030515018",
            "emoji_map_title": "5775949822993371030",
            "emoji_map_id": "5877597667231534929",
            "emoji_map_creator": "5879770735999717115",
            "emoji_map_status": "5879785854284599288",
            "emoji_map_source": "5879585266426973039",
            "emoji_map_stats": "5931472654660800739",
            "emoji_map_plays": "5775981206319402773",
            "emoji_map_favs": "5994453058656931434",
            "emoji_map_video": "6005986106703613755",
            "emoji_map_video_present": "5776375003280838798",
            "emoji_map_video_absent": "5778527486270770928",
            "emoji_map_dates": "5967412305338568701",
            "emoji_map_link": "5877465816030515018",
            "emoji_map_diffs": "5994495149336434048",
            "emoji_map_mapper_link": "5877465816030515018"
        }

    def on_plugin_load(self):
        self.add_on_send_message_hook()

    def _get_strings(self):
        lang_index = self.get_setting("language", 0)
        lang_code = 'ru' if lang_index == 0 else 'en'
        return self.strings.get(lang_code, self.strings['ru'])

    def _fetch_osu_user_data(self, nickname: str, api_key: str, mode: int):
        if not api_key:
            return {"error_key": "error_api_key_missing"}
        
        params = {"k": api_key, "u": nickname, "m": mode}
        try:
            response = requests.get(USER_API_URL_V1, params=params, headers=API_HEADERS, timeout=15)
            if response.status_code == 401:
                return {"error_key": "error_api_v1_401"}
            if response.status_code == 200:
                data = response.json()
                if not data:
                    return {"error_key": "error_player_not_found", "nickname": nickname}
                return data[0]
            else:
                log(f"OsuPlugin: Failed to fetch user data (v1), status: {response.status_code}")
                return {"error_key": "error_api_error", "status_code": response.status_code}
        except Exception as e:
            log(f"OsuPlugin: Network error on user fetch (v1): {e}")
            return {"error_key": "error_network_error"}

    def _fetch_user_best_data(self, user_id: str, api_key: str, mode: int):
        if not api_key:
            return {"error_key": "error_api_key_missing"}
        
        params = {"k": api_key, "u": user_id, "limit": 1, "m": mode}
        try:
            response = requests.get(USER_BEST_API_URL_V1, params=params, headers=API_HEADERS, timeout=15)
            if response.status_code == 200:
                data = response.json()
                if not data:
                    return {}
                return data[0]
            else:
                log(f"OsuPlugin: Failed to fetch user best data (v1), status: {response.status_code}")
                return {"error_key": "error_api_error", "status_code": response.status_code}
        except Exception as e:
            log(f"OsuPlugin: Network error on user best fetch (v1): {e}")
            return {"error_key": "error_network_error"}

    def _fetch_beatmap_data_v1(self, beatmapset_id: str, api_key: str):
        if not api_key:
            return {"error_key": "error_api_key_missing"}
        
        params = {"k": api_key, "s": beatmapset_id}
        try:
            response = requests.get(BEATMAP_API_URL_V1, params=params, headers=API_HEADERS, timeout=15)
            if response.status_code == 401:
                return {"error_key": "error_api_v1_401"}
            if response.status_code == 200:
                data = response.json()
                if not data:
                    return {"error_key": "error_map_not_found", "query": beatmapset_id}
                return data
            else:
                log(f"OsuPlugin: Failed to fetch map data (v1), status: {response.status_code}")
                return {"error_key": "error_api_error", "status_code": response.status_code}
        except Exception as e:
            log(f"OsuPlugin: Network error on map fetch (v1): {e}")
            return {"error_key": "error_network_error"}

    def _fetch_osu_v2_token(self, client_id: str, client_secret: str):
        if not client_id or not client_secret:
            return None, {"error_key": "error_v2_credentials_missing"}

        data = {'client_id': client_id, 'client_secret': client_secret, 'grant_type': 'client_credentials', 'scope': 'public'}
        try:
            response = requests.post(OAUTH_TOKEN_URL, data=data, timeout=10)
            if response.status_code == 200:
                return response.json().get('access_token'), None
            else:
                log(f"OsuPlugin: Failed to get v2 token, status: {response.status_code}, response: {response.text}")
                return None, {"error_key": "error_v2_auth_failed"}
        except Exception as e:
            log(f"OsuPlugin: Network error on v2 token fetch: {e}")
            return None, {"error_key": "error_network_error"}

    def _fetch_beatmap_data_v2(self, query: str, client_id: str, client_secret: str):
        token, error = self._fetch_osu_v2_token(client_id, client_secret)
        if error: return error

        headers = {**API_HEADERS, "Authorization": f"Bearer {token}"}
        
        search_all_statuses = self.get_setting("search_all_maps", True)
        params = {"q": query}
        if search_all_statuses:
            params["s"] = "any"

        try:
            response = requests.get(MAP_SEARCH_URL_V2, params=params, headers=headers, timeout=15)
            if response.status_code == 200:
                data = response.json()
                if not data.get("beatmapsets"):
                    return {"error_key": "error_map_not_found", "query": query}
                return data["beatmapsets"][0]
            else:
                log(f"OsuPlugin: Failed to fetch map data (v2), status: {response.status_code}")
                return {"error_key": "error_api_error", "status_code": response.status_code}
        except Exception as e:
            log(f"OsuPlugin: Network error on map fetch (v2): {e}")
            return {"error_key": "error_network_error"}
            
    def _get_emoji_value(self, setting_key: str, default_val: str, prefix_check: bool = True) -> str:
        if not self.get_setting("use_emojis", True):
            return '' if prefix_check else ''

        emoji_display_mode = self.get_setting("emoji_display_mode", 1)

        if emoji_display_mode == 0:
            return default_val
        elif emoji_display_mode == 1:
            premium_id = self.premium_pack_white.get(setting_key)
            if premium_id:
                return f"[{default_val}]({premium_id})"
            else:
                return default_val
        elif emoji_display_mode == 2:
            premium_id = self.premium_pack_white.get(setting_key)
            manual_default = f"[{default_val}]({premium_id})" if premium_id else default_val
            return self.get_setting(setting_key, manual_default)

        return ''

    def _create_user_emoji_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_emoji_user_stats_header']),
            Input(key="emoji_username", text=s['settings_emoji_username'], default="[üë§](5879770735999717115)"),
            Input(key="emoji_user_id", text=s['settings_emoji_user_id'], default="[ü™™](5877597667231534929)"),
            Input(key="emoji_global_rank", text=s['settings_emoji_global_rank'], default="[üèÜ](5879585266426973039)"),
            Input(key="emoji_country_rank", text=s['settings_emoji_country_rank'], default="[üéñ](5994378304751145264)"),
            Input(key="emoji_pp", text=s['settings_emoji_pp'], default="[üî•](5994809115740737538)"),
            Input(key="emoji_accuracy", text=s['settings_emoji_accuracy'], default="[üìà](5994378914636500516)"),
            Input(key="emoji_playcount", text=s['settings_emoji_playcount'], default="[üéÆ](5775981206319402773)"),
            Input(key="emoji_ranks", text=s['settings_emoji_ranks'], default="[ü•á](5931472654660800739)"),
            Input(key="emoji_best_map", text=s['settings_emoji_best_map'], default="[üëë](5766879414704935108)"),
            Input(key="emoji_level", text=s['settings_emoji_level'], default="[üÜô](6005807101056651268)"),
            Input(key="emoji_time_played", text=s['settings_emoji_time_played'], default="[‚è≥](5778605968208170641)"),
            Input(key="emoji_join_date", text=s['settings_emoji_join_date'], default="[üìÖ](5967412305338568701)"),
            Input(key="emoji_profile_link", text=s['settings_emoji_profile_link'], default="[üîó](5877465816030515018)"),
        ]

    def _create_map_emoji_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_emoji_map_info_header']),
            Input(key="emoji_map_title", text=s['settings_emoji_map_title'], default="[üéµ](5775949822993371030)"),
            Input(key="emoji_map_id", text=s['settings_emoji_map_id'], default="[ü™™](5877597667231534929)"),
            Input(key="emoji_map_creator", text=s['settings_emoji_map_creator'], default="[üë§](5879770735999717115)"),
            Input(key="emoji_map_status", text=s['settings_emoji_map_status'], default="[‚úÖ](5879785854284599288)"),
            Input(key="emoji_map_source", text=s['settings_emoji_map_source'], default="[üé¨](5879585266426973039)"),
            Input(key="emoji_map_stats", text=s['settings_emoji_map_stats'], default="[üìä](5931472654660800739)"),
            Input(key="emoji_map_plays", text=s['settings_emoji_map_plays'], default="[üéÆ](5775981206319402773)"),
            Input(key="emoji_map_favs", text=s['settings_emoji_map_favs'], default="[‚ù§Ô∏è](5994453058656931434)"),
            Input(key="emoji_map_video", text=s['settings_emoji_map_video'], default="[üé•](6005986106703613755)"),
            Input(key="emoji_map_video_present", text=s['settings_emoji_map_video_present'], default="[‚úÖ](5776375003280838798)"),
            Input(key="emoji_map_video_absent", text=s['settings_emoji_map_video_absent'], default="[‚ùå](5778527486270770928)"),
            Input(key="emoji_map_dates", text=s['settings_emoji_map_dates'], default="[üóì](5967412305338568701)"),
            Input(key="emoji_map_link", text=s['settings_emoji_map_link'], default="[üîó](5877465816030515018)"),
            Input(key="emoji_map_diffs", text=s['settings_emoji_map_diffs'], default="[‚≠ê](5994495149336434048)"),
            Input(key="emoji_map_mapper_link", text=s['settings_emoji_map_mapper_link'], default="[üîó](5877465816030515018)"),
        ]
        
    def _create_gamemode_emoji_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Input(key="emoji_mode_osu", text=s['settings_emoji_mode_osu'], default="[üî¥](5206293067685988022)"),
            Input(key="emoji_mode_taiko", text=s['settings_emoji_mode_taiko'], default="[ü•Å](5206291216555084391)"),
            Input(key="emoji_mode_catch", text=s['settings_emoji_mode_catch'], default="[üçè](5206205489007857482)"),
            Input(key="emoji_mode_mania", text=s['settings_emoji_mode_mania'], default="[üéπ](5206357986116665788)"),
        ]

    def _create_user_stats_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_user_stats_submenu']),
            Selector(key="user_gamemode", text=s['settings_user_gamemode_text'], default=0, items=s['settings_user_gamemode_items'], icon="msg_fave"),
            Selector(key="user_stats_sort_mode", text=s['settings_sort_mode_text'], default=0, items=s['settings_sort_mode_items'], icon="msg_log"),
            Divider(text=s['settings_manual_sort_note']),
            Input(key="user_stats_sort_order", text=s['settings_user_stats_sort_text'], default="mode, user_id, global_rank, country_rank, pp, accuracy, playcount, ranks, best_pp_map, level, time_played, join_date", icon="msg_edit"),
            Divider(text=s['settings_user_stats_sort_desc']),
            Switch(key="quote_user_stats", text=s['settings_quote_user_stats'], default=True, icon="menu_select_quote"),
            Selector(key="pp_display_style", text=s['settings_pp_style_text'], default=0, items=s['settings_pp_style_items'], icon="msg_edit"),
            Selector(key="profile_link_mode", text=s['settings_profile_link_mode_text'], default=0, items=s['settings_profile_link_mode_items'], icon="msg_link"),
        ]

    def _create_map_display_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_map_info_submenu']),
            Switch(key="search_all_maps", text=s['settings_search_all_maps_text'], subtext=s['settings_search_all_maps_subtext'], default=True, icon="msg_search"),
            Divider(),
            Header(text=s['settings_map_info_header_general']),
            Selector(key="map_info_sort_mode", text=s['settings_sort_mode_text'], default=0, items=s['settings_sort_mode_items'], icon="msg_log"),
            Divider(text=s['settings_manual_sort_note']),
            Input(key="map_info_sort_order", text=s['settings_map_info_sort_text'], default="map_id, creator, status, source, stats, video_presence, dates", icon="msg_edit"),
            Divider(text=s['settings_map_info_sort_desc']),
            Switch(key="quote_map_stats", text=s['settings_quote_map_stats'], default=True, icon="menu_select_quote"),
            Selector(key="map_creator_link_mode", text=s['settings_mapper_link_mode_text'], default=0, items=s['settings_mapper_link_mode_items'], icon="msg_link"),
            Selector(key="map_status_language", text=s['settings_map_status_lang'], default=0, items=s['settings_map_status_lang_items'], icon="msg_language"),
            Selector(key="map_stats_style", text=s['settings_map_stats_style_text'], default=0, items=s['settings_map_stats_style_items'], icon="menu_edit_appearance"),
            Selector(key="map_video_style", text=s['settings_map_video_style_text'], default=0, items=s['settings_map_video_style_items'], icon="msg_video"),
            Selector(key="map_link_mode", text=s['settings_map_link_mode_text'], default=0, items=s['settings_map_link_mode_items'], icon="msg_link"),
            Divider(),
            Header(text=s['settings_diff_display_header']),
            Switch(key="quote_map_diffs", text=s['settings_quote_map_diffs'], default=True, icon="menu_select_quote"),
            Switch(key="collapse_diffs_enabled", text=s['settings_collapse_diffs_text'], subtext=s['settings_collapse_diffs_subtext'], default=True, icon="menu_link_below"),
            Input(key="collapse_diffs_threshold", text=s['settings_collapse_diffs_threshold_text'], subtext=s['settings_collapse_diffs_threshold_subtext'], default="5", icon="msg_edit"),
            Selector(key="diff_gamemode_display", text=s['settings_diff_gamemode_display_text'], default=0, items=s['settings_diff_gamemode_display_items'], icon="msg_fave"),
            Selector(key="map_diff_sort_mode", text=s['settings_sort_mode_text'], default=0, items=s['settings_sort_mode_items'], icon="msg_log"),
            Divider(text=s['settings_manual_sort_note']),
            Input(key="map_diff_sort_order", text=s['settings_diff_info_sort_text'], default="stars, length, bpm, csar", icon="msg_edit"),
            Divider(text=s['settings_diff_info_sort_desc']),
        ]

    def _create_download_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_download_header']),
            Selector(key="download_mode", text=s['settings_download_mode_text'], default=0, items=s['settings_download_mode_items'], icon="msg_bots"),
            Input(key="manual_download_url", text=s['settings_manual_url_text'], subtext=s['settings_manual_url_subtext'], default=SAYOBOT_DOWNLOAD_URL, icon="msg_link"),
            Divider(text=s['settings_manual_url_desc']),
            Switch(key="download_with_video", text=s['settings_download_video_text'], default=True, icon="msg_video"),
            Switch(key="auto_delete_map", text=s['settings_auto_delete_map_text'], subtext=s['settings_auto_delete_map_subtext'], default=False, icon="msg_delete"),
            Input(key="download_path", text=s['settings_download_path_text'], default="osu/maps", icon="files_internal", subtext=s['settings_download_path_subtext']),
            Divider(),
            Header(text=s['settings_filename_header']),
            Selector(key="filename_mode", text=s['settings_filename_mode_text'], default=0, items=s['settings_filename_mode_items'], icon="menu_storage_path"),
            Input(key="filename_template", text=s['settings_filename_template_text'], default="ID {id}„Éª{title}„Éª{date}„Éª{video}", icon="msg_edit", subtext=s['settings_filename_template_subtext']),
            Divider(),
            Header(text=s['settings_caption_header']),
            Selector(key="caption_mode", text=s['settings_caption_mode_text'], default=0, items=s['settings_caption_mode_items'], icon="menu_tag_rename"),
            Input(key="caption_template", text=s['settings_caption_template_text'], default="ID {id}„Éª{artist} - {title} by {creator}„Éª{video}", icon="msg_edit", subtext=s['settings_caption_template_subtext']),
        ]

    def _create_song_download_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_song_download_header']),
            Selector(key="song_download_mode", text=s['settings_song_download_source_text'], default=0, items=s['settings_song_download_source_items'], icon="msg_bots"),
            Input(key="song_manual_download_url", text=s['settings_song_manual_url_text'], subtext=s['settings_song_manual_url_subtext'], default=SAYOBOT_DOWNLOAD_URL, icon="msg_link"),
            Divider(text=s['settings_song_manual_url_desc']),
            Switch(key="auto_delete_song", text=s['settings_auto_delete_song_text'], subtext=s['settings_auto_delete_song_subtext'], default=False, icon="msg_delete"),
            Input(key="song_download_path", text=s['settings_song_download_path_text'], default="osu/songs", icon="files_internal", subtext=s['settings_song_download_path_subtext']),
            Divider(),
            Header(text=s['settings_song_filename_header']),
            Selector(key="song_filename_mode", text=s['settings_song_filename_mode_text'], default=0, items=s['settings_song_filename_mode_items'], icon="menu_storage_path"),
            Input(key="song_filename_template", text=s['settings_song_filename_template_text'], default="{artist} - {title}„Éª{date}", icon="msg_edit", subtext=s['settings_song_filename_template_subtext']),
            Divider(),
            Header(text=s['settings_song_caption_header']),
            Selector(key="song_caption_mode", text=s['settings_song_caption_mode_text'], default=0, items=s['settings_caption_mode_items'], icon="menu_tag_rename"),
            Input(key="song_caption_template", text=s['settings_song_caption_template_text'], default="ID {id}„Éª{artist} - {title}", icon="msg_edit", subtext=s['settings_song_caption_template_subtext']),
        ]
        
    def _create_api_settings(self) -> List[Any]:
        s = self._get_strings()
        return [
            Header(text=s['settings_api_header']),
            Selector(key="api_v1_source", text=s['settings_api_source_text'], default=0, items=s['settings_api_source_items'], icon="msg_permissions"),
            Input(key="api_key_v1", text=s['settings_api_key_text'], default="", subtext=s['settings_api_key_subtext'], icon="msg_pin_code"),
            Divider(text=s['settings_api_key_desc']),
            Header(text=s['settings_api_v2_header']),
            Selector(key="api_v2_source", text=s['settings_api_v2_source_text'], default=0, items=s['settings_api_v2_source_items'], icon="msg_permissions"),
            Input(key="client_id", text=s['settings_client_id_text'], default="", icon="msg_bot"),
            Input(key="client_secret", text=s['settings_client_secret_text'], default="", icon="msg_pin_code"),
            Divider(text=s['settings_api_v2_desc']),
        ]

    def create_settings(self) -> List[Any]:
        s = self._get_strings()
        lang_index = self.get_setting("language", 0)
        
        return [
            Header(text=s['settings_lang_header']),
            Selector(key="language", text=s['settings_lang_text'], default=lang_index, items=["–†—É—Å—Å–∫–∏–π", "English"], icon="msg_language"),
            Divider(),
            Header(text=s['settings_plugin_header']),
            Input(key="user_command_prefix", text=s['settings_cmd_prefix_text'], default=".osu", subtext=s['settings_cmd_prefix_subtext'], icon="msg_contacts"),
            Input(key="map_command_prefix", text=s['settings_map_cmd_prefix_text'], default=".map", subtext=s['settings_map_cmd_prefix_subtext'], icon="msg_search"),
            Input(key="osz_command_prefix", text=s['settings_osz_cmd_prefix_text'], default=".osz", subtext=s['settings_osz_cmd_prefix_subtext'], icon="msg_download"),
            Input(key="song_command_prefix", text=s['settings_song_cmd_prefix_text'], default=".song", subtext=s['settings_song_cmd_prefix_subtext'], icon="notifications_on"),
            Divider(),
            Text(text=s['settings_api_submenu'], icon="msg_permissions", create_sub_fragment=lambda: self._create_api_settings()),
            Divider(),
            Header(text=s['settings_display_submenu']),
            Text(text=s['settings_user_stats_submenu'], icon="msg_contacts", create_sub_fragment=lambda: self._create_user_stats_settings()),
            Text(text=s['settings_map_info_submenu'], icon="msg_gallery", create_sub_fragment=lambda: self._create_map_display_settings()),
            Text(text=s['settings_download_header'], icon="msg_download", create_sub_fragment=lambda: self._create_download_settings()),
            Text(text=s['settings_song_download_header'], icon="notifications_on", create_sub_fragment=lambda: self._create_song_download_settings()),
            Divider(),
            Header(text=s['settings_emoji_main_submenu']),
            Switch(key="use_emojis", text=s['use_emojis_text'], default=True, icon="input_smile"),
            Selector(key="emoji_display_mode", text=s['settings_emoji_display_mode_text'], default=1, items=s['settings_emoji_display_mode_items'], icon="menu_edit_appearance"),
            Text(
                text=s['settings_emoji_id_guide_header'],
                icon="msg_info",
                on_click=lambda view: self._show_emoji_id_guide_dialog()
            ),
            Divider(),
            Header(text=s['settings_manual_emoji_header']),
            Text(text=s['settings_emoji_gamemode_header'], icon="msg_fave", create_sub_fragment=lambda: self._create_gamemode_emoji_settings()),
            Text(
                text=s['settings_emoji_user_stats_header'],
                icon="msg_contacts",
                create_sub_fragment=lambda: self._create_user_emoji_settings()
            ),
            Text(
                text=s['settings_emoji_map_info_header'],
                icon="msg_gallery",
                create_sub_fragment=lambda: self._create_map_emoji_settings()
            ),
        ]

    def _show_emoji_id_guide_dialog(self):
        s = self._get_strings()
        fragment = get_last_fragment()
        if not fragment or not fragment.getParentActivity():
            log("OsuPlugin: Could not get context to show emoji ID guide dialog.")
            return

        activity = fragment.getParentActivity()
        builder = AlertDialogBuilder(activity)
        builder.set_title(s['settings_emoji_id_guide_header'])
        builder.set_message(s['settings_emoji_id_guide_text'])
        builder.set_positive_button("OK", lambda b, w: b.dismiss())
        builder.show()

    def _try_parse_date(self, date_str: str) -> str:
        if not date_str:
            return 'N/A'
        try:
            return datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S%z').strftime('%d/%m/%Y %H:%M')
        except ValueError:
            try:
                return datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S').strftime('%d/%m/%Y %H:%M')
            except ValueError:
                return 'N/A'

    def _format_user_data(self, data: dict, best_score: Optional[dict], mode: int) -> str:
        s = self._get_strings()

        if not data or "error_key" in data:
            key = data["error_key"] if data else "error_network_error"
            if key == "error_player_not_found": return s[key].format(nickname=data.get('nickname', ''))
            if key == "error_api_error": return s[key].format(status_code=data.get('status_code', 'N/A'))
            return s.get(key, "An unknown error occurred.")

        
        user_emoji_defaults = {
            'username': 'üë§', 'user_id': 'ü™™', 'global_rank': 'üèÜ', 'country_rank': 'üéñ', 'pp': 'üî•', 
            'accuracy': 'üìà', 'playcount': 'üéÆ', 'ranks': 'ü•á', 'best_map': 'üëë', 'level': 'üÜô', 
            'time_played': '‚è≥', 'join_date': 'üìÖ', 'profile_link': 'üîó'
        }
        gamemode_emoji_defaults = {'osu': 'üî¥', 'taiko': 'ü•Å', 'catch': 'üçè', 'mania': 'üéπ'}

        def get_user_emoji(key):
            return self._get_emoji_value(f'emoji_{key}', user_emoji_defaults.get(key, ''), prefix_check=True)

        def get_gamemode_emoji(key):
            return self._get_emoji_value(f'emoji_mode_{key}', gamemode_emoji_defaults.get(key, ''), prefix_check=True)

        try:
            link_mode = self.get_setting("profile_link_mode", 0)
            username = data.get('username', 'N/A').replace('_', '\\_').replace('*', '\\*').replace('`', '\\`')
            profile_url = f"https://osu.ppy.sh/users/{data.get('user_id')}"
            country = data.get('country', 'N/A')
            emoji_username = get_user_emoji('username')
            
            title_text = ""
            if link_mode == 0: 
                title_text = s['output_title_linked'].format(username=username, profile_url=profile_url, country=country)
            else: 
                title_text = s['output_title_unlinked'].format(username=username, country=country)
            title_part = f"{emoji_username}{' ' if emoji_username else ''}{title_text}"
            
            default_order = "mode, user_id, global_rank, country_rank, pp, accuracy, playcount, ranks, best_pp_map, level, time_played, join_date"
            sort_mode = self.get_setting("user_stats_sort_mode", 0)
            sort_order_str = default_order if sort_mode == 0 else self.get_setting("user_stats_sort_order", default_order)
            sort_order_keys = [key.strip() for key in sort_order_str.split(',') if key.strip()]

            stats_parts = {}
            
            if 'mode' in sort_order_keys:
                mode_names = s['settings_user_gamemode_items'][1:]
                mode_name = mode_names[mode] if 0 <= mode < len(mode_names) else "osu!"
                mode_emojis = {
                    0: get_gamemode_emoji('osu'), 1: get_gamemode_emoji('taiko'),
                    2: get_gamemode_emoji('catch'), 3: get_gamemode_emoji('mania')
                }
                emoji = mode_emojis.get(mode, '')
                mode_text = s['output_gamemode'].format(mode_name=mode_name)
                stats_parts['mode'] = f"{emoji}{' ' if emoji else ''}{mode_text.strip()}"

            if 'user_id' in sort_order_keys:
                emoji = get_user_emoji('user_id')
                id_text = s['output_user_id'].format(user_id=data.get('user_id', 'N/A'))
                stats_parts['user_id'] = f"{emoji}{' ' if emoji else ''}{id_text.strip()}"
            
            if 'global_rank' in sort_order_keys:
                emoji = get_user_emoji('global_rank')
                text = f"{s['output_global_rank']}`#{int(data.get('pp_rank', 0) or 0):,}`"
                stats_parts['global_rank'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"

            if 'country_rank' in sort_order_keys:
                emoji = get_user_emoji('country_rank')
                text = f"{s['output_country_rank']}`#{int(data.get('pp_country_rank', 0) or 0):,}`"
                stats_parts['country_rank'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"

            if 'pp' in sort_order_keys:
                emoji = get_user_emoji('pp')
                text = f"*{s['settings_pp_style_items'][self.get_setting('pp_display_style', 0)]}:* `{float(data.get('pp_raw', 0) or 0):,.2f}`"
                stats_parts['pp'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"

            if 'accuracy' in sort_order_keys:
                emoji = get_user_emoji('accuracy')
                text = f"{s['output_accuracy']}`{float(data.get('accuracy', 0) or 0):.2f}%`"
                stats_parts['accuracy'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"
                
            if 'playcount' in sort_order_keys:
                emoji = get_user_emoji('playcount')
                text = f"{s['output_playcount']}`{int(data.get('playcount', 0) or 0):,}`"
                stats_parts['playcount'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"
            
            if 'ranks' in sort_order_keys:
                emoji = get_user_emoji('ranks')
                text = f"{s['output_ranks']}`SS: {int(data.get('count_rank_ssh', 0) or 0) + int(data.get('count_rank_ss', 0) or 0):,} / S: {int(data.get('count_rank_sh', 0) or 0) + int(data.get('count_rank_s', 0) or 0):,} / A: {int(data.get('count_rank_a', 0) or 0):,}`"
                stats_parts['ranks'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"
            
            if 'best_pp_map' in sort_order_keys and best_score and "error_key" not in best_score and best_score.get('beatmap_id'):
                emoji = get_user_emoji('best_map')
                pp_value = f"{float(best_score.get('pp', 0) or 0):,.2f}"
                map_url = f"https://osu.ppy.sh/b/{best_score.get('beatmap_id')}"
                best_map_string = s['output_best_pp_map'].format(pp=pp_value, url=map_url)
                stats_parts['best_pp_map'] = f"{emoji}{' ' if emoji else ''}{best_map_string.strip()}"

            if 'level' in sort_order_keys:
                emoji = get_user_emoji('level')
                text = f"{s['output_level']}`{int(float(data.get('level', 0) or 0))}`"
                stats_parts['level'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"

            if 'time_played' in sort_order_keys:
                emoji = get_user_emoji('time_played')
                text = f"{s['output_time_played']}`{int(data.get('total_seconds_played', 0) or 0) // 3600:,} {s['time_played_unit']}`"
                stats_parts['time_played'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"

            if 'join_date' in sort_order_keys and data.get('join_date'):
                emoji = get_user_emoji('join_date')
                text = f"{s['output_join_date']}`{self._try_parse_date(data.get('join_date'))}`"
                stats_parts['join_date'] = f"{emoji}{' ' if emoji else ''}{text.strip()}"

            output_lines = [title_part.strip()]
            
            pg_quote_user_stats_setting = self.get_setting("quote_user_stats", True)

            if not pg_quote_user_stats_setting:
                output_lines.append("")

            for key in sort_order_keys:
                if key in stats_parts:
                    line_content = stats_parts[key].strip()
                    if pg_quote_user_stats_setting:
                        output_lines.append(f"> {line_content}")
                    else:
                        output_lines.append(line_content)
            
            footer_part = ""
            if link_mode == 1:
                emoji = get_user_emoji('profile_link')
                text = s['output_profile_link'].format(url=profile_url)
                footer_part = f"\n{emoji}{' ' if emoji else ''}{text.strip()}"

            output_text = "\n".join(output_lines) + footer_part
            return output_text.strip()
            
        except (ValueError, TypeError, KeyError) as e:
            log(f"OsuPlugin: Error formatting user data: {e}, data: {data}")
            return s['error_formatting_error']

    def _format_beatmap_data_v1(self, data: list, query: str) -> str:
        s = self._get_strings()
        if isinstance(data, dict) and "error_key" in data:
            key = data["error_key"]
            if key == "error_map_not_found": return s[key].format(query=query)
            if key == "error_api_error": return s[key].format(status_code=data.get('status_code', 'N/A'))
            return s.get(key, "An unknown error occurred.")
        
        
        map_emoji_defaults = {
            'map_title': 'üéµ', 'map_id': 'ü™™', 'map_creator': 'üë§', 'map_status': '‚úÖ', 'map_source': 'üé¨', 'map_stats': 'üìä',
            'map_plays': 'üéÆ', 'map_favs': '‚ù§Ô∏è', 'map_video': 'üé•', 'map_video_present': '‚úÖ', 'map_video_absent': '‚ùå',
            'map_dates': 'üóì', 'map_link': 'üîó', 'map_mapper_link': 'üîó', 'map_diffs': '‚≠ê'
        }
        gamemode_emoji_defaults = {'osu': 'üî¥', 'taiko': 'ü•Å', 'catch': 'üçè', 'mania': 'üéπ'}
        
        def get_map_emoji(key, is_prefix=True):
            return self._get_emoji_value(f'emoji_{key}', map_emoji_defaults.get(key, ''), prefix_check=is_prefix)
        
        def get_diff_gamemode_emoji_independent(key):
            return self._get_emoji_value(f'emoji_mode_{key}', gamemode_emoji_defaults.get(key, ''), prefix_check=True)

        try:
            first_map = data[0]
            map_link_mode = self.get_setting("map_link_mode", 0)
            map_url = f"https://osu.ppy.sh/s/{first_map.get('beatmapset_id')}"
            title = first_map.get('title', 'N/A').replace('[', '(').replace(']', ')')
            artist = first_map.get('artist', 'N/A').replace('[', '(').replace(']', ')')
            
            emoji_title = get_map_emoji('map_title')
            if map_link_mode == 0:
                title_text = s['output_map_title_linked'].format(artist=artist, title=title, url=map_url)
            else:
                title_text = s['output_map_title_unlinked'].format(artist=artist, title=title)

            default_order = "map_id, creator, status, source, stats, video_presence, dates"
            sort_mode = self.get_setting("map_info_sort_mode", 0)
            sort_order_str = default_order if sort_mode == 0 else self.get_setting("map_info_sort_order", default_order)
            sort_order_keys = [key.strip() for key in sort_order_str.split(',') if key.strip()]
            
            main_info_parts = {}
            if 'map_id' in sort_order_keys:
                emoji = get_map_emoji('map_id')
                main_info_parts['map_id'] = f"{emoji}{' ' if emoji else ''}{s['output_map_id'].format(map_id=first_map.get('beatmapset_id', 'N/A'))}"
            
            if 'creator' in sort_order_keys:
                creator = first_map.get('creator', 'N/A')
                creator_id = first_map.get('creator_id')
                creator_link_mode = self.get_setting("map_creator_link_mode", 0)
                emoji = get_map_emoji('map_creator')
                if creator_id and creator_link_mode == 0:
                    creator_url = f'https://osu.ppy.sh/users/{creator_id}'
                    text = s['output_map_creator_linked'].format(creator=creator, url=creator_url)
                else:
                    text = s['output_map_creator'].format(creator=creator)
                main_info_parts['creator'] = f"{emoji}{' ' if emoji else ''}{text}"
            
            if 'status' in sort_order_keys:
                status_map_ru = {-2: "–ó–∞–±—Ä–æ—à–µ–Ω–Ω—ã–π", -1: "–í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ", 0: "–í –æ–∂–∏–¥–∞–Ω–∏–µ", 1: "–†–µ–π—Ç–∏–Ω–≥–æ–≤–∞—è", 2: "–û–¥–æ–±—Ä–µ–Ω–Ω–∞—è", 3: "–ö–≤–∞–ª–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è", 4: "–õ—é–±–∏–º–∞—è"}
                status_map_en = {-2: "Graveyard", -1: "WIP", 0: "Pending", 1: "Ranked", 2: "Approved", 3: "Qualified", 4: "Loved"}
                status_text = status_map_ru.get(int(first_map.get('approved',0))) if self.get_setting("map_status_language", 0) == 0 else status_map_en.get(int(first_map.get('approved',0)), "Unknown")
                emoji = get_map_emoji('map_status')
                main_info_parts['status'] = f"{emoji}{' ' if emoji else ''}{s['output_map_status'].format(status=status_text)}"
            
            if 'source' in sort_order_keys and first_map.get('source'):
                emoji = get_map_emoji('map_source')
                main_info_parts['source'] = f"{emoji}{' ' if emoji else ''}{s['output_map_source'].format(source=first_map['source'])}"
            
            if 'stats' in sort_order_keys:
                plays = sum(int(d.get('playcount', 0)) for d in data)
                favs = int(first_map.get('favourite_count', 0))
                stats_style = self.get_setting("map_stats_style", 0)
                emoji_stats = get_map_emoji('map_stats')
                if stats_style != 2:
                    if stats_style == 0:
                        stats_string = s['output_map_stats_emoji'].format(plays=f"{plays:,}", favs=f"{favs:,}", emoji_plays=get_map_emoji('map_plays', is_prefix=False), emoji_favs=get_map_emoji('map_favs', is_prefix=False))
                    else:
                        stats_string = s['output_map_stats_text'].format(plays=f"{plays:,}", favs=f"{favs:,}")
                    main_info_parts['stats'] = f"{emoji_stats}{' ' if emoji_stats else ''}{stats_string}"
            
            if 'video_presence' in sort_order_keys:
                has_video = self._map_has_video(data)
                video_style = self.get_setting("map_video_style", 0)
                if video_style != 2:
                    emoji_video_icon = get_map_emoji('map_video')
                    video_string = ""
                    if video_style == 0:
                        emoji_video_status = get_map_emoji('map_video_present', is_prefix=False) if has_video else get_map_emoji('map_video_absent', is_prefix=False)
                        video_string = s['output_map_video_emoji'].format(emoji_video_status=emoji_video_status)
                    else:
                        video_status_text = s['video_present'] if has_video else s['video_absent']
                        video_string = s['output_map_video_text'].format(video_status_text=video_status_text)
                    main_info_parts['video_presence'] = f"{emoji_video_icon}{' ' if emoji_video_icon else ''}{video_string}"

            if 'dates' in sort_order_keys:
                submit = self._try_parse_date(first_map.get('submit_date'))
                update = self._try_parse_date(first_map.get('last_update'))
                emoji = get_map_emoji('map_dates')
                main_info_parts['dates'] = f"{emoji}{' ' if emoji else ''}{s['output_map_dates'].format(submit=submit, update=update)}"

            sorted_info_list = [main_info_parts[key] for key in sort_order_keys if key in main_info_parts]
            main_info_block = "".join(sorted_info_list)

            pg_quote_map_stats_setting = self.get_setting("quote_map_stats", True)
            if pg_quote_map_stats_setting:
                info_lines = main_info_block.strip().splitlines()
                pg_quoted_info_lines = ["> " + line for line in info_lines if line.strip()]
                main_info_block = "\n".join(pg_quoted_info_lines)

            diff_default_order = "stars, length, bpm, csar"
            diff_sort_mode = self.get_setting("map_diff_sort_mode", 0)
            diff_sort_order_str = diff_default_order if diff_sort_mode == 0 else self.get_setting("map_diff_sort_order", diff_default_order)
            diff_sort_order_keys = [key.strip() for key in diff_sort_order_str.split(',') if key.strip()]

            diffs_block = ""
            if diff_sort_order_keys:
                diff_lines = []
                emoji = get_map_emoji('map_diffs', is_prefix=False)
                diff_lines.append(f"\n{emoji}{' ' if emoji else ''}{s['output_map_diffs_header']}")

                pg_collapse_diffs_enabled = self.get_setting("collapse_diffs_enabled", True)
                pg_collapse_diffs_threshold = int(self.get_setting("collapse_diffs_threshold", "5"))
                pg_should_collapse_diffs = pg_collapse_diffs_enabled and len(data) >= pg_collapse_diffs_threshold

                pg_quote_map_diffs_setting = self.get_setting("quote_map_diffs", True)
                pg_prefix_for_diff = ""
                if pg_should_collapse_diffs:
                    pg_prefix_for_diff = ">> "
                elif pg_quote_map_diffs_setting:
                    pg_prefix_for_diff = "> "
                
                gamemode_display_mode = self.get_setting("diff_gamemode_display", 0)

                mode_sort_order = {0: 0, 3: 1, 1: 2, 2: 3}
                sorted_diffs = sorted(data, key=lambda x: (mode_sort_order.get(int(x.get('mode', 0)), 4), float(x.get('difficultyrating', 0))))
                
                for diff in sorted_diffs:
                    mode_prefix = ""
                    if gamemode_display_mode != 2:
                        mode = int(diff.get('mode', 0))
                        keys = diff.get('diff_size', '0')
                        
                        if gamemode_display_mode == 0:
                            if mode == 0: mode_prefix = f"{get_diff_gamemode_emoji_independent('osu')}„Éª"
                            elif mode == 1: mode_prefix = f"{get_diff_gamemode_emoji_independent('taiko')}„Éª"
                            elif mode == 2: mode_prefix = f"{get_diff_gamemode_emoji_independent('catch')}„Éª"
                            elif mode == 3: mode_prefix = f"{get_diff_gamemode_emoji_independent('mania')} {keys}K„Éª"
                        else:
                            if mode == 0: mode_prefix = f"{s.get('gamemode_osu', 'osu!')}„Éª"
                            elif mode == 1: mode_prefix = f"{s.get('gamemode_taiko', 'Taiko')}„Éª"
                            elif mode == 2: mode_prefix = f"{s.get('gamemode_catch', 'Catch')}„Éª"
                            elif mode == 3: mode_prefix = f"{s.get('gamemode_mania', 'Mania')} {keys}K„Éª"

                    diff_parts_map = {}
                    if 'stars' in diff_sort_order_keys: diff_parts_map['stars'] = f"‚òÖ{float(diff.get('difficultyrating', 0)):.2f}"
                    if 'length' in diff_sort_order_keys:
                        m, sec = divmod(int(diff.get('total_length', 0)), 60)
                        diff_parts_map['length'] = f"{m:02d}:{sec:02d}"
                    if 'bpm' in diff_sort_order_keys: diff_parts_map['bpm'] = f"{float(diff.get('bpm', 0))} BPM"
                    if 'csar' in diff_sort_order_keys: diff_parts_map['csar'] = f"CS:{diff.get('diff_size', 'N/A')} AR:{diff.get('diff_approach', 'N/A')} OD:{diff.get('diff_overall', 'N/A')} HP:{diff.get('diff_drain', 'N/A')}"
                    
                    version = diff.get('version', 'N/A')
                    sorted_diff_parts = [version] + [diff_parts_map[key] for key in diff_sort_order_keys if key in diff_parts_map]
                    
                    diff_line_content = " | ".join(sorted_diff_parts)
                    final_diff_line = f"{mode_prefix}{diff_line_content}"
                    diff_text = f"{pg_prefix_for_diff}{final_diff_line}"
                    diff_lines.append(diff_text)
                diffs_block = "\n".join(diff_lines)

            footer_links = []
            if self.get_setting("map_creator_link_mode", 0) == 1 and first_map.get('creator_id'):
                emoji = get_map_emoji('map_mapper_link')
                mapper_url = f"https://osu.ppy.sh/users/{first_map.get('creator_id')}"
                footer_links.append(f"{emoji}{' ' if emoji else ''}{s['output_mapper_profile_link'].format(url=mapper_url)}")
            if map_link_mode == 1:
                emoji = get_map_emoji('map_link')
                footer_links.append(f"{emoji}{' ' if emoji else ''}{s['output_map_link'].format(url=map_url)}")
            footer_block = "\n".join(footer_links)

            output_text = f"{emoji_title}{' ' if emoji_title else ''}{title_text}{main_info_block}{diffs_block}\n{footer_block}".strip()
            
            return output_text

        except (ValueError, TypeError, KeyError, IndexError) as e:
            log(f"OsuPlugin: Error formatting map v1 data: {e}, data: {data}")
            return s['error_formatting_error']

    def _format_beatmap_data_v2(self, data: dict, query: str) -> str:
        s = self._get_strings()
        if "error_key" in data:
            key = data["error_key"]
            if key == "error_map_not_found": return s[key].format(query=query)
            if key == "error_api_error": return s[key].format(status_code=data.get('status_code', 'N/A'))
            return s.get(key, "An unknown error occurred.")
        
        
        map_emoji_defaults = {
            'map_title': 'üéµ', 'map_id': 'ü™™', 'map_creator': 'üë§', 'map_status': '‚úÖ', 'map_source': 'üé¨', 'map_stats': 'üìä',
            'map_plays': 'üéÆ', 'map_favs': '‚ù§Ô∏è', 'map_video': 'üé•', 'map_video_present': '‚úÖ', 'map_video_absent': '‚ùå',
            'map_dates': 'üóì', 'map_link': 'üîó', 'map_mapper_link': 'üîó', 'map_diffs': '‚≠ê'
        }
        gamemode_emoji_defaults = {'osu': 'üî¥', 'taiko': 'ü•Å', 'catch': 'üçè', 'mania': 'üéπ'}
        
        def get_map_emoji(key, is_prefix=True):
            return self._get_emoji_value(f'emoji_{key}', map_emoji_defaults.get(key, ''), prefix_check=is_prefix)
            
        def get_diff_gamemode_emoji_independent(key):
            return self._get_emoji_value(f'emoji_mode_{key}', gamemode_emoji_defaults.get(key, ''), prefix_check=True)
        
        try:
            map_link_mode = self.get_setting("map_link_mode", 0)
            map_url = f"https://osu.ppy.sh/s/{data.get('id')}"
            title = data.get('title', 'N/A').replace('[', '(').replace(']', ')')
            artist = data.get('artist', 'N/A').replace('[', '(').replace(']', ')')
            emoji_title = get_map_emoji('map_title')
            
            if map_link_mode == 0:
                title_text = s['output_map_title_linked'].format(artist=artist, title=title, url=map_url)
            else:
                title_text = s['output_map_title_unlinked'].format(artist=artist, title=title)
            
            default_order = "map_id, creator, status, source, stats, video_presence, dates"
            sort_mode = self.get_setting("map_info_sort_mode", 0)
            sort_order_str = default_order if sort_mode == 0 else self.get_setting("map_info_sort_order", default_order)
            sort_order_keys = [key.strip() for key in sort_order_str.split(',') if key.strip()]

            main_info_parts = {}
            if 'map_id' in sort_order_keys:
                emoji = get_map_emoji('map_id')
                main_info_parts['map_id'] = f"{emoji}{' ' if emoji else ''}{s['output_map_id'].format(map_id=data.get('id', 'N/A'))}"
            
            if 'creator' in sort_order_keys:
                creator = data.get('creator', 'N/A')
                creator_id = data.get('user_id')
                creator_link_mode = self.get_setting("map_creator_link_mode", 0)
                emoji = get_map_emoji('map_creator')
                if creator_id and creator_link_mode == 0:
                    creator_url = f'https://osu.ppy.sh/users/{creator_id}'
                    text = s['output_map_creator_linked'].format(creator=creator, url=creator_url)
                else:
                    text = s['output_map_creator'].format(creator=creator)
                main_info_parts['creator'] = f"{emoji}{' ' if emoji else ''}{text}"
            
            if 'status' in sort_order_keys:
                status_map_ru = {"graveyard": "–ó–∞–±—Ä–æ—à–µ–Ω–Ω—ã–π", "wip": "–í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ", "pending": "–í –æ–∂–∏–¥–∞–Ω–∏–∏", "ranked": "–†–µ–π—Ç–∏–Ω–≥–æ–≤–∞—è", "approved": "–û–¥–æ–±—Ä–µ–Ω–Ω–∞—è", "qualified": "–ö–≤–∞–ª–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è", "loved": "–õ—é–±–∏–º–∞—è"}
                status_map_en = {"graveyard": "Graveyard", "wip": "WIP", "pending": "Pending", "ranked": "Ranked", "approved": "Approved", "qualified": "Qualified", "loved": "Loved"}
                status_key = data.get('status', 'unknown').lower()
                status_text = status_map_ru.get(status_key, status_key.capitalize()) if self.get_setting("map_status_language", 0) == 0 else status_map_en.get(status_key, status_key.capitalize())
                emoji = get_map_emoji('map_status')
                main_info_parts['status'] = f"{emoji}{' ' if emoji else ''}{s['output_map_status'].format(status=status_text)}"
            
            if 'source' in sort_order_keys and data.get('source'):
                emoji = get_map_emoji('map_source')
                main_info_parts['source'] = f"{emoji}{' ' if emoji else ''}{s['output_map_source'].format(source=data['source'])}"

            if 'stats' in sort_order_keys:
                stats_style = self.get_setting("map_stats_style", 0)
                emoji_stats = get_map_emoji('map_stats')
                if stats_style != 2:
                    if stats_style == 0:
                        stats_string = s['output_map_stats_emoji'].format(plays=f"{int(data.get('play_count', 0)):,}", favs=f"{int(data.get('favourite_count', 0)):,}", emoji_plays=get_map_emoji('map_plays', is_prefix=False), emoji_favs=get_map_emoji('map_favs', is_prefix=False))
                    else:
                        stats_string = s['output_map_stats_text'].format(plays=f"{int(data.get('play_count', 0)):,}", favs=f"{int(data.get('favourite_count', 0)):,}")
                    main_info_parts['stats'] = f"{emoji_stats}{' ' if emoji_stats else ''}{stats_string}"
                
            if 'video_presence' in sort_order_keys:
                has_video = data.get('video')
                video_style = self.get_setting("map_video_style", 0)
                if video_style != 2:
                    emoji_video_icon = get_map_emoji('map_video')
                    video_string = ""
                    if video_style == 0:
                        emoji_video_status = get_map_emoji('map_video_present', is_prefix=False) if has_video else get_map_emoji('map_video_absent', is_prefix=False)
                        video_string = s['output_map_video_emoji'].format(emoji_video_status=emoji_video_status)
                    else:
                        video_status_text = s['video_present'] if has_video else s['video_absent']
                        video_string = s['output_map_video_text'].format(video_status_text=video_status_text)
                    main_info_parts['video_presence'] = f"{emoji_video_icon}{' ' if emoji_video_icon else ''}{video_string}"

            if 'dates' in sort_order_keys:
                submit = self._try_parse_date(data.get('submitted_date'))
                update = self._try_parse_date(data.get('last_updated'))
                emoji = get_map_emoji('map_dates')
                main_info_parts['dates'] = f"{emoji}{' ' if emoji else ''}{s['output_map_dates'].format(submit=submit, update=update)}"

            sorted_info_list = [main_info_parts[key] for key in sort_order_keys if key in main_info_parts]
            main_info_block = "".join(sorted_info_list)

            pg_quote_map_stats_setting = self.get_setting("quote_map_stats", True)
            if pg_quote_map_stats_setting:
                info_lines = main_info_block.strip().splitlines()
                pg_quoted_info_lines = ["> " + line for line in info_lines if line.strip()]
                main_info_block = "\n".join(pg_quoted_info_lines)

            diff_default_order = "stars, length, bpm, csar"
            diff_sort_mode = self.get_setting("map_diff_sort_mode", 0)
            diff_sort_order_str = diff_default_order if diff_sort_mode == 0 else self.get_setting("map_diff_sort_order", diff_default_order)
            diff_sort_order_keys = [key.strip() for key in diff_sort_order_str.split(',') if key.strip()]

            diffs_block = ""
            if diff_sort_order_keys and data.get('beatmaps'):
                diff_lines = []
                emoji = get_map_emoji('map_diffs', is_prefix=False)
                diff_lines.append(f"\n{emoji}{' ' if emoji else ''}{s['output_map_diffs_header']}")

                pg_collapse_diffs_enabled = self.get_setting("collapse_diffs_enabled", True)
                pg_collapse_diffs_threshold = int(self.get_setting("collapse_diffs_threshold", "5"))
                pg_should_collapse_diffs = pg_collapse_diffs_enabled and len(data['beatmaps']) >= pg_collapse_diffs_threshold

                pg_quote_map_diffs_setting = self.get_setting("quote_map_diffs", True)
                pg_prefix_for_diff = ""
                if pg_should_collapse_diffs:
                    pg_prefix_for_diff = ">> "
                elif pg_quote_map_diffs_setting:
                    pg_prefix_for_diff = "> "

                gamemode_display_mode = self.get_setting("diff_gamemode_display", 0)

                mode_sort_order = {0: 0, 3: 1, 1: 2, 2: 3}
                sorted_diffs = sorted(data['beatmaps'], key=lambda x: (mode_sort_order.get(int(x.get('mode_int', 0)), 4), float(x.get('difficulty_rating', 0))))
                
                for diff in sorted_diffs:
                    mode_prefix = ""
                    if gamemode_display_mode != 2:
                        mode = int(diff.get('mode_int', 0))
                        keys = diff.get('cs', '0')
                        
                        if gamemode_display_mode == 0:
                            if mode == 0: mode_prefix = f"{get_diff_gamemode_emoji_independent('osu')}„Éª"
                            elif mode == 1: mode_prefix = f"{get_diff_gamemode_emoji_independent('taiko')}„Éª"
                            elif mode == 2: mode_prefix = f"{get_diff_gamemode_emoji_independent('catch')}„Éª"
                            elif mode == 3: mode_prefix = f"{get_diff_gamemode_emoji_independent('mania')} {keys}K„Éª"
                        else:
                            if mode == 0: mode_prefix = f"{s.get('gamemode_osu', 'osu!')}„Éª"
                            elif mode == 1: mode_prefix = f"{s.get('gamemode_taiko', 'Taiko')}„Éª"
                            elif mode == 2: mode_prefix = f"{s.get('gamemode_catch', 'Catch')}„Éª"
                            elif mode == 3: mode_prefix = f"{s.get('gamemode_mania', 'Mania')} {keys}K„Éª"

                    diff_parts_map = {}
                    if 'stars' in diff_sort_order_keys: diff_parts_map['stars'] = f"‚òÖ{float(diff.get('difficulty_rating', 0)):.2f}"
                    if 'length' in diff_sort_order_keys:
                        m, sec = divmod(int(diff.get('total_length', 0)), 60)
                        diff_parts_map['length'] = f"{m:02d}:{sec:02d}"
                    if 'bpm' in diff_sort_order_keys: diff_parts_map['bpm'] = f"{float(diff.get('bpm', 0))} BPM"
                    if 'csar' in diff_sort_order_keys: diff_parts_map['csar'] = f"CS:{diff.get('cs', 'N/A')} AR:{diff.get('ar', 'N/A')} OD:{diff.get('accuracy', 'N/A')} HP:{diff.get('drain', 'N/A')}"

                    version = diff.get('version', 'N/A')
                    sorted_diff_parts = [version] + [diff_parts_map[key] for key in diff_sort_order_keys if key in diff_parts_map]
                    
                    diff_line_content = " | ".join(sorted_diff_parts)
                    final_diff_line = f"{mode_prefix}{diff_line_content}"
                    diff_text = f"{pg_prefix_for_diff}{final_diff_line}"
                    diff_lines.append(diff_text)
                diffs_block = "\n".join(diff_lines)
            
            footer_links = []
            if self.get_setting("map_creator_link_mode", 0) == 1 and data.get('user_id'):
                emoji = get_map_emoji('map_mapper_link')
                mapper_url = f"https://osu.ppy.sh/users/{data.get('user_id')}"
                footer_links.append(f"{emoji}{' ' if emoji else ''}{s['output_mapper_profile_link'].format(url=mapper_url)}")
            if map_link_mode == 1:
                emoji = get_map_emoji('map_link')
                footer_links.append(f"{emoji}{' ' if emoji else ''}{s['output_map_link'].format(url=map_url)}")
            footer_block = "\n".join(footer_links)

            output_text = f"{emoji_title}{' ' if emoji_title else ''}{title_text}{main_info_block}{diffs_block}\n{footer_block}".strip()
            
            return output_text

        except (ValueError, TypeError, KeyError, IndexError) as e:
            log(f"OsuPlugin: Error formatting map v2 data: {e}, data: {data}")
            return s['error_formatting_error']

    def _get_utf16_length(self, text: str) -> int:
        return len(text.encode('utf_16_le')) // 2

    def _send_formatted_message(self, content: str, peer_id: Any, reply_to_msg_obj: Optional[Any] = None):
        try:
            pg_original_lines = content.splitlines()
            pg_clean_lines = []
            pg_blockquote_ranges: List[Dict[str, Any]] = []
            pg_current_block_info = None

            for i, line in enumerate(pg_original_lines):
                pg_is_collapsible_quoted = line.startswith(">> ")
                pg_is_regular_quoted = line.startswith("> ")
                
                if pg_is_collapsible_quoted:
                    pg_clean_line_content = line[3:]
                elif pg_is_regular_quoted:
                    pg_clean_line_content = line[2:]
                else:
                    pg_clean_line_content = line
                
                pg_clean_lines.append(pg_clean_line_content)

                if pg_is_collapsible_quoted or pg_is_regular_quoted:
                    if pg_current_block_info is None:
                        pg_current_block_info = {
                            'start_line': i,
                            'is_collapsible': pg_is_collapsible_quoted
                        }
                else:
                    if pg_current_block_info is not None:
                        pg_blockquote_ranges.append({
                            'start_line': pg_current_block_info['start_line'],
                            'end_line': i - 1,
                            'is_collapsible': pg_current_block_info['is_collapsible']
                        })
                        pg_current_block_info = None
            
            if pg_current_block_info is not None:
                pg_blockquote_ranges.append({
                    'start_line': pg_current_block_info['start_line'],
                    'end_line': len(pg_original_lines) - 1,
                    'is_collapsible': pg_current_block_info['is_collapsible']
                })

            pg_raw_message_text = "\n".join(pg_clean_lines)
            pg_parsed_message = parse_markdown(pg_raw_message_text)
            pg_final_text_to_send = pg_parsed_message.text
            pg_other_entities = [e.to_tlrpc_object() for e in pg_parsed_message.entities]

            pg_lines_in_final_text = pg_final_text_to_send.splitlines(keepends=True)
            pg_utf16_line_offsets = []
            pg_current_utf16_offset = 0
            for line_fragment in pg_lines_in_final_text:
                pg_utf16_line_offsets.append(pg_current_utf16_offset)
                pg_current_utf16_offset += self._get_utf16_length(line_fragment)
            
            pg_utf16_line_offsets.append(pg_current_utf16_offset) 

            pg_blockquote_entities = []
            for pg_range in pg_blockquote_ranges:
                pg_start_offset = pg_utf16_line_offsets[pg_range['start_line']]
                pg_end_offset_of_last_line = pg_utf16_line_offsets[pg_range['end_line'] + 1]
                pg_length = pg_end_offset_of_last_line - pg_start_offset
                pg_blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                pg_blockquote_entity.offset = pg_start_offset
                pg_blockquote_entity.length = pg_length
                pg_blockquote_entity.collapsed = pg_range['is_collapsible']
                pg_blockquote_entities.append(pg_blockquote_entity)

            pg_all_entities = pg_blockquote_entities + pg_other_entities
            
            pg_params = {
                "peer": peer_id,
                "message": pg_final_text_to_send, 
                "entities": pg_all_entities
            }
            if reply_to_msg_obj:
                pg_params["replyToMsg"] = reply_to_msg_obj
            send_message(pg_params)
            
        except Exception as e:
            log(f"OsuPlugin: Error during new markdown processing: {e}\n{traceback.format_exc()}")
            pg_plain_content = content.replace(">> ", "").replace("> ", "")
            pg_params_plain = {"peer": peer_id, "message": pg_plain_content}
            if reply_to_msg_obj:
                pg_params_plain["replyToMsg"] = reply_to_msg_obj
            send_message(pg_params_plain)

    def _dismiss_dialog(self):
        if self.progress_dialog_builder:
            self.progress_dialog_builder.dismiss()
            self.progress_dialog_builder = None
    
    def _cancel_download(self, *args):
        s = self._get_strings()
        if not self.is_download_cancelled:
            self.is_download_cancelled = True
            log("OsuPlugin: Download cancellation requested by user.")
            run_on_ui_thread(lambda: BulletinHelper.show_info(s['download_cancelled_message']))
        if self.progress_dialog_builder:
            run_on_ui_thread(self.progress_dialog_builder.dismiss)

    def _background_download_listener(self, builder: AlertDialogBuilder):
        log("OsuPlugin: Dialog dismissed by user, download will continue in background.")
        self.progress_dialog_builder = None

    def _schedule_file_deletion(self, file_path: str, delay_seconds: int, filename: str):
        s = self._get_strings()
        def delete_file():
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)
                    log(f"OsuPlugin: Scheduled deletion of file '{file_path}' successful.")
                except Exception as e:
                    log(f"OsuPlugin: Failed to delete scheduled file '{file_path}': {e}")
            else:
                log(f"OsuPlugin: Scheduled file '{file_path}' not found for deletion.")
        
        pg_deletion_timer = threading.Timer(delay_seconds, delete_file)
        pg_deletion_timer.daemon = True
        pg_deletion_timer.start()
        log(f"OsuPlugin: File '{file_path}' scheduled for deletion in {delay_seconds} seconds.")

    def array_list(self, items=None):
        from java.util import ArrayList
        _l = ArrayList()
        if items:
            for item in items:
                _l.add(item)
        return _l
        
    def _map_has_video(self, map_data: Any) -> bool:
        if isinstance(map_data, list):
            return any(d.get('video') == '1' for d in map_data)
        elif isinstance(map_data, dict):
            return map_data.get('video', False)
        return False

    def _process_user_request(self, nickname: str, peer_id: Any, reply_to_msg_obj: Optional[Any] = None, mode_query: Optional[str] = None):
        api_v1_source = self.get_setting("api_v1_source", 0)
        api_key = DEFAULT_API_KEY_V1 if api_v1_source == 0 else self.get_setting("api_key_v1", "")
        s = self._get_strings()
    
        user_data = None
        best_score_data = None
        final_mode_index = 0
    
        if mode_query:
            mode_map = {
                "osu": 0, "o": 0, "std": 0,
                "taiko": 1, "t": 1,
                "catch": 2, "c": 2, "ctb": 2,
                "mania": 3, "m": 3
            }
            requested_mode_index = mode_map.get(mode_query)

            if requested_mode_index is None:
                error_message = s['error_invalid_gamemode'].format(mode=mode_query)
                run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(error_message, peer_id, reply_to_msg_obj)))
                return
            
            final_mode_index = requested_mode_index
            user_data = self._fetch_osu_user_data(nickname, api_key, final_mode_index)
        else:
            game_mode_setting = self.get_setting("user_gamemode", 0)
            if game_mode_setting == 0:
                best_mode_data = None
                max_playcount = -1
                first_error = None

                for mode_index in range(4):
                    current_mode_data = self._fetch_osu_user_data(nickname, api_key, mode_index)
                    
                    if "error_key" in current_mode_data:
                        if current_mode_data["error_key"] == "error_player_not_found":
                            best_mode_data = current_mode_data
                            break
                        if not first_error:
                            first_error = current_mode_data
                        continue

                    playcount = int(current_mode_data.get('playcount', 0) or 0)
                    if playcount > max_playcount:
                        max_playcount = playcount
                        best_mode_data = current_mode_data
                        final_mode_index = mode_index
                
                user_data = best_mode_data if best_mode_data is not None else first_error
            else:
                final_mode_index = game_mode_setting - 1
                user_data = self._fetch_osu_user_data(nickname, api_key, final_mode_index)
        
        if user_data and "error_key" not in user_data and user_data.get('user_id'):
            best_score_data = self._fetch_user_best_data(user_data['user_id'], api_key, final_mode_index)
            
        formatted_message = self._format_user_data(user_data, best_score_data, final_mode_index)
        run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(formatted_message, peer_id, reply_to_msg_obj)))

    def _process_map_request(self, query: str, peer_id: Any, reply_to_msg_obj: Optional[Any] = None):
        api_v1_source = self.get_setting("api_v1_source", 0)
        api_key = DEFAULT_API_KEY_V1 if api_v1_source == 0 else self.get_setting("api_key_v1", "")

        api_v2_source = self.get_setting("api_v2_source", 0)
        client_id = DEFAULT_CLIENT_ID_V2 if api_v2_source == 0 else self.get_setting("client_id", "")
        client_secret = DEFAULT_CLIENT_SECRET_V2 if api_v2_source == 0 else self.get_setting("client_secret", "")
        
        if query.isdigit():
            map_data = self._fetch_beatmap_data_v1(query, api_key)
            formatted_message = self._format_beatmap_data_v1(map_data, query)
        else:
            map_data = self._fetch_beatmap_data_v2(query, client_id, client_secret)
            formatted_message = self._format_beatmap_data_v2(map_data, query)
        
        run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(formatted_message, peer_id, reply_to_msg_obj)))

    def _download_and_send_map(self, beatmapset_id: str, map_data: Any, peer_id: Any, reply_to_msg_obj: Optional[Any] = None):
        self.is_download_cancelled = False
        s = self._get_strings()
        
        if not beatmapset_id:
            message = s['error_map_id_not_found']
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        download_mode = self.get_setting("download_mode", 0)
        download_with_video = self.get_setting("download_with_video", True)
        auto_delete_map = self.get_setting("auto_delete_map", False)
        
        download_url_template = ""
        source_name = "Default"

        if download_mode == 0:
            download_url_template = SAYOBOT_NOVIDEO_DOWNLOAD_URL if not download_with_video else SAYOBOT_DOWNLOAD_URL
            source_name = "Sayobot"
        else:
            download_url_template = self.get_setting("manual_download_url", SAYOBOT_DOWNLOAD_URL)
            source_name = "Manual"
            
        if not download_url_template or "{}" not in download_url_template:
            message = s['error_invalid_manual_url']
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        downloads_dir_base = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath()
        custom_folder = self.get_setting("download_path", "osu/maps").strip()
        
        final_downloads_dir = os.path.join(downloads_dir_base, custom_folder) if custom_folder else downloads_dir_base
        
        try:
            os.makedirs(final_downloads_dir, exist_ok=True)
        except Exception as e:
            log(f"OsuPlugin: Could not create directory {final_downloads_dir}: {e}")

        map_info = {}
        if isinstance(map_data, list) and map_data: map_info = map_data[0]
        elif isinstance(map_data, dict): map_info = map_data

        has_video = self._map_has_video(map_data)
        video_tag_for_filename = "vid" if has_video else "no_vid"
        
        filename_mode = self.get_setting("filename_mode", 0)
        if filename_mode == 0:
            filename_template = "ID {id}„Éª{title}„Éª{date}„Éª{video}"
        elif filename_mode == 1:
            filename_template = self.get_setting("filename_template", "ID {id}„Éª{title}„Éª{date}„Éª{video}")
        else:
            filename_template = "ID {id}„Éª{date}"

        filename_template_data = {
            "id": beatmapset_id,
            "artist": map_info.get('artist', 'UnknownArtist'),
            "title": map_info.get('title', 'UnknownTitle'),
            "creator": map_info.get('creator', 'UnknownCreator'),
            "date": datetime.now().strftime('%d%m%y_%H%M'),
            "video": video_tag_for_filename
        }

        raw_filename = filename_template.format(**filename_template_data)
        sanitized_filename = re.sub(r'[<>:"/\\|?*]', '_', raw_filename).strip()
        sanitized_filename = (sanitized_filename[:200]) if len(sanitized_filename) > 200 else sanitized_filename
        file_name = f"{sanitized_filename}.osz"
        file_path = os.path.join(final_downloads_dir, file_name)
        
        file_caption = ""
        caption_mode = self.get_setting("caption_mode", 0)
        if caption_mode != 2:
            caption_template_data = {
                "id": beatmapset_id,
                "artist": map_info.get('artist', 'UnknownArtist'),
                "title": map_info.get('title', 'UnknownTitle'),
                "creator": map_info.get('creator', 'UnknownCreator'),
                "date": datetime.now().strftime('%d%m%y_%H%M'),
                "video": s['video_present'] if has_video else s['video_absent']
            }
            if caption_mode == 0:
                caption_template = "ID {id}„Éª{artist} - {title} by {creator}„Éª{video}"
                file_caption = caption_template.format(**caption_template_data)
            elif caption_mode == 1:
                caption_template = self.get_setting("caption_template", "ID {id}„Éª{artist} - {title} by {creator}„Éª{video}")
                file_caption = caption_template.format(**caption_template_data)

        download_successful = False
        try:
            run_on_ui_thread(lambda: self.progress_dialog_builder.set_message(s['loading_osz_trying_mirror'].format(source_name=source_name)) if self.progress_dialog_builder else None)
            download_url = download_url_template.format(beatmapset_id)
            log(f"OsuPlugin: Trying download from {source_name}: {download_url}")
            
            response = requests.get(download_url, stream=True, timeout=300)
            response.raise_for_status()
            total_size = int(response.headers.get('content-length', 0))
            downloaded_size = 0
            last_update_time = time.time()
            
            def update_dialog_progress(d_size, t_size):
                if not self.progress_dialog_builder: return
                if t_size > 0:
                    progress = int((d_size / t_size) * 100)
                    d_mb, t_mb = d_size / (1024*1024), t_size / (1024*1024)
                    message = s['loading_osz_progress_with_size'].format(d_mb=f"{d_mb:.1f}", t_mb=f"{t_mb:.1f}", progress=progress)
                    self.progress_dialog_builder.set_progress(progress)
                else: 
                    d_mb = d_size / (1024*1024)
                    message = s['loading_osz_progress_no_size'].format(d_mb=f"{d_mb:.1f}")
                self.progress_dialog_builder.set_message(message)

            with open(file_path, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if self.is_download_cancelled:
                        log("OsuPlugin: Download cancelled during chunk iteration.")
                        break
                    if not chunk: continue
                    downloaded_size += len(chunk)
                    f.write(chunk)
                    current_time = time.time()
                    if (current_time - last_update_time) >= 0.5:
                        last_update_time = current_time
                        run_on_ui_thread(lambda d=downloaded_size, t=total_size: update_dialog_progress(d, t))
            
            if not self.is_download_cancelled:
                log(f"OsuPlugin: Download successful from {source_name}.")
                download_successful = True

        except Exception as e:
            if self.is_download_cancelled:
                log(f"OsuPlugin: Download process interrupted, likely due to cancellation. Error: {e}")
            else:
                log(f"OsuPlugin: Failed to download from {source_name}: {e}")
                run_on_ui_thread(self._dismiss_dialog)
        
        if self.is_download_cancelled:
            log(f"OsuPlugin: Download was cancelled. Deleting partial file: {file_path}")
            if os.path.exists(file_path):
                try: os.remove(file_path)
                except Exception as del_e: log(f"OsuPlugin: Could not delete cancelled download file {file_path}: {del_e}")
            return
        
        if download_successful:
            run_on_ui_thread(self._dismiss_dialog)
            try:
                log(f"OsuPlugin: Download complete. Sending file {file_path} to {peer_id}")
                self.send_file(
                    peer=peer_id,
                    path=file_path,
                    caption=file_caption,
                    replyToMsg=reply_to_msg_obj,
                    parse_message=True,
                    mime="application/x-osu-beatmap-archive"
                )
                
                log(f"OsuPlugin: Kept downloaded map: {file_path}")
                success_message = s['success_download_sent']
                run_on_ui_thread(lambda: BulletinHelper.show_success(success_message))

                if auto_delete_map:
                    self._schedule_file_deletion(file_path, 4, file_name)

            except Exception as e:
                log(f"OsuPlugin: Error sending file: {e}\n{traceback.format_exc()}")
                error_msg = s.get('error_sending_file', 'Failed to send downloaded file.')
                run_on_ui_thread(lambda: self._send_formatted_message(error_msg, peer_id, reply_to_msg_obj))
        else:
            message = s['error_download_source_failed']
            run_on_ui_thread(lambda: self._send_formatted_message(message, peer_id, reply_to_msg_obj))
            if os.path.exists(file_path):
                try: os.remove(file_path)
                except Exception as del_e: log(f"OsuPlugin: Could not delete failed download file {file_path}: {del_e}")

    def _extract_mp3_from_osz(self, osz_path: str, output_dir: str) -> Optional[str]:
        try:
            log(f"OsuPlugin: Starting MP3 extraction from {osz_path}")
            fis = FileInputStream(osz_path)
            zis = ZipInputStream(fis)
            zip_entry = zis.getNextEntry()
            
            while zip_entry is not None:
                entry_name = zip_entry.getName()
                if not zip_entry.isDirectory() and entry_name.lower().endswith(".mp3"):
                    log(f"OsuPlugin: Found MP3 file in archive: {entry_name}")
                    
                    sanitized_entry_name = os.path.basename(entry_name)
                    output_path = os.path.join(output_dir, sanitized_entry_name)
                    
                    fos = FileOutputStream(output_path)
                    buffer = jarray(jbyte)(bytearray(1024))
                    length = zis.read(buffer)
                    while length > 0:
                        fos.write(buffer, 0, length)
                        length = zis.read(buffer)
                    
                    fos.close()
                    zis.closeEntry()
                    zis.close()
                    fis.close()
                    log(f"OsuPlugin: Successfully extracted MP3 to {output_path}")
                    return output_path
                
                zis.closeEntry()
                zip_entry = zis.getNextEntry()
                
            zis.close()
            fis.close()
            log("OsuPlugin: No MP3 file found in the archive.")
            return None
        except Exception as e:
            log(f"OsuPlugin: Error during MP3 extraction: {e}\n{traceback.format_exc()}")
            return None

    def _download_and_send_song(self, beatmapset_id: str, map_data: Any, peer_id: Any, reply_to_msg_obj: Optional[Any] = None):
        self.is_download_cancelled = False
        s = self._get_strings()

        if not beatmapset_id:
            message = s['error_map_id_not_found']
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        song_download_mode = self.get_setting("song_download_mode", 0)
        auto_delete_song = self.get_setting("auto_delete_song", False)
        download_url_template = ""
        source_name = "Default"

        if song_download_mode == 0:
            download_url_template = SAYOBOT_DOWNLOAD_URL
            source_name = "Sayobot"
        else:
            download_url_template = self.get_setting("song_manual_download_url", SAYOBOT_DOWNLOAD_URL)
            source_name = "Manual"
        
        if not download_url_template or "{}" not in download_url_template:
            message = s['error_invalid_manual_url']
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        temp_dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath()
        temp_osz_path = os.path.join(temp_dir, f"temp_{beatmapset_id}_{int(time.time())}.osz")
        
        osz_download_successful = False
        try:
            run_on_ui_thread(lambda: self.progress_dialog_builder.set_message(s['loading_osz_trying_mirror'].format(source_name=source_name)) if self.progress_dialog_builder else None)
            download_url = download_url_template.format(beatmapset_id)
            
            response = requests.get(download_url, stream=True, timeout=300)
            response.raise_for_status()
            total_size = int(response.headers.get('content-length', 0))
            downloaded_size = 0
            last_update_time = time.time()

            def update_dialog_progress(d_size, t_size):
                if not self.progress_dialog_builder: return
                if t_size > 0:
                    progress = int((d_size / t_size) * 100)
                    d_mb, t_mb = d_size / (1024*1024), t_size / (1024*1024)
                    message = s['loading_osz_progress_with_size'].format(d_mb=f"{d_mb:.1f}", t_mb=f"{t_mb:.1f}", progress=progress)
                    self.progress_dialog_builder.set_progress(progress)
                else: 
                    d_mb = d_size / (1024*1024)
                    message = s['loading_osz_progress_no_size'].format(d_mb=f"{d_mb:.1f}")
                self.progress_dialog_builder.set_message(message)

            with open(temp_osz_path, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if self.is_download_cancelled: break
                    if not chunk: continue
                    downloaded_size += len(chunk)
                    f.write(chunk)
                    current_time = time.time()
                    if (current_time - last_update_time) >= 0.5:
                        last_update_time = current_time
                        run_on_ui_thread(lambda d=downloaded_size, t=total_size: update_dialog_progress(d, t))
            
            if not self.is_download_cancelled:
                osz_download_successful = True
        except Exception as e:
            if not self.is_download_cancelled: log(f"OsuPlugin: Failed to download .osz for song: {e}")

        if self.is_download_cancelled or not osz_download_successful:
            if os.path.exists(temp_osz_path): os.remove(temp_osz_path)
            if not self.is_download_cancelled:
                message = s['error_download_source_failed']
                run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        downloads_dir_base = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath()
        custom_folder = self.get_setting("song_download_path", "osu/songs").strip()
        final_downloads_dir = os.path.join(downloads_dir_base, custom_folder) if custom_folder else downloads_dir_base
        try:
            os.makedirs(final_downloads_dir, exist_ok=True)
        except Exception as e:
            log(f"OsuPlugin: Could not create song directory {final_downloads_dir}: {e}")

        extracted_mp3_path = self._extract_mp3_from_osz(temp_osz_path, final_downloads_dir)
        
        if os.path.exists(temp_osz_path): os.remove(temp_osz_path)

        if not extracted_mp3_path:
            message = s['error_download_failed'].format(error="No MP3 file found in beatmap.")
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return
            
        map_info = map_data[0] if isinstance(map_data, list) and map_data else map_data if isinstance(map_data, dict) else {}
        
        filename_mode = self.get_setting("song_filename_mode", 0)
        filename_template = "{artist} - {title}„Éª{date}" if filename_mode == 0 else self.get_setting("song_filename_template", "{artist} - {title}„Éª{date}")
        filename_data = {"id": beatmapset_id, "artist": map_info.get('artist', 'N/A'), "title": map_info.get('title', 'N/A'), "creator": map_info.get('creator', 'N/A'), "date": datetime.now().strftime('%d%m%y_%H%M')}
        
        sanitized_filename = re.sub(r'[<>:"/\\|?*]', '_', filename_template.format(**filename_data)).strip()
        file_name = f"{sanitized_filename}.mp3"
        final_mp3_path = os.path.join(final_downloads_dir, file_name)
        os.rename(extracted_mp3_path, final_mp3_path)

        caption_mode = self.get_setting("song_caption_mode", 0)
        file_caption = ""
        if caption_mode != 2:
            caption_template = "ID {id}„Éª{artist} - {title}" if caption_mode == 0 else self.get_setting("song_caption_template", "ID {id}„Éª{artist} - {title}")
            file_caption = caption_template.format(**filename_data)

        run_on_ui_thread(self._dismiss_dialog)
        try:
            self.send_file(peer=peer_id, path=final_mp3_path, caption=file_caption, replyToMsg=reply_to_msg_obj, parse_message=True, mime="audio/mpeg")
            run_on_ui_thread(lambda: BulletinHelper.show_success(s['success_download_sent']))
            
            if auto_delete_song:
                self._schedule_file_deletion(final_mp3_path, 4, file_name)

        except Exception as e:
            log(f"OsuPlugin: Error sending song file: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda: self._send_formatted_message(s['error_sending_file'], peer_id, reply_to_msg_obj))
    
    def send_file(self, peer: int, path: str, caption: Optional[str] = None, *, parse_message: bool = True, parse_mode: str = "MARKDOWN", **kwargs):
        try:
            account_instance = get_account_instance()
            if not account_instance:
                log("[osu! Search] Error: Could not get AccountInstance.")
                return
    
            entities = None
            if caption and parse_message:
                try:
                    parsed = parse_markdown(caption)
                    caption = parsed.text
                    entities = self.array_list([e.to_tlrpc_object() for e in parsed.entities])
                except Exception as e:
                    log(f"[osu! Search] Markdown parsing failed, sending as plain text. Error: {e}")
                    entities = None

            method = next((m for m in SendMessagesHelper.getClass().getDeclaredMethods() if m.getName() == "prepareSendingDocumentInternal"), None)
            if not method:
                log("[osu! Search] Error: Could not find method 'prepareSendingDocumentInternal'.")
                return

            method.setAccessible(True)
            mime_type = kwargs.get("mime", "application/octet-stream")
            group_id = jarray(jlong)([0])
            doc_type = jarray(Integer)([0])
    
            result = method.invoke(
                None, account_instance, path, path, None, mime_type, peer,
                kwargs.get("replyToMsg", None), kwargs.get("replyToTopMsg", None),
                None, None, entities, None, group_id, True, caption,
                kwargs.get("notify", True), jint(kwargs.get("scheduleDate", 0)),
                doc_type, True, kwargs.get("quickReplyShortcut", None),
                jint(kwargs.get("quickReplyShortcutId", 0)), kwargs.get("effect_id", 0),
                kwargs.get("invertMedia", False), kwargs.get("payStars", 0),
                kwargs.get("monoForumPeerId", 0), kwargs.get("suggestionParams", None)
            )
            
            log("[osu! Search] File queued for sending successfully via prepareSendingDocumentInternal")
            return result
            
        except Exception as e:
            error_msg = f"Critical error during file sending: {e}\n{traceback.format_exc()}"
            log(f"[osu! Search] {error_msg}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Failed to send file: {str(e)}"))
            return None

    def _process_osz_request(self, query: str, peer_id: Any, reply_to_msg_obj: Optional[Any] = None):
        s = self._get_strings()
        map_data = None
        
        if query.isdigit():
            api_v1_source = self.get_setting("api_v1_source", 0)
            api_key = DEFAULT_API_KEY_V1 if api_v1_source == 0 else self.get_setting("api_key_v1", "")
            map_data = self._fetch_beatmap_data_v1(query, api_key)
        else:
            api_v2_source = self.get_setting("api_v2_source", 0)
            client_id = DEFAULT_CLIENT_ID_V2 if api_v2_source == 0 else self.get_setting("client_id", "")
            client_secret = DEFAULT_CLIENT_SECRET_V2 if api_v2_source == 0 else self.get_setting("client_secret", "")
            map_data = self._fetch_beatmap_data_v2(query, client_id, client_secret)
        
        if not map_data or (isinstance(map_data, dict) and "error_key" in map_data):
            error_data = map_data if isinstance(map_data, dict) else {}
            key = error_data.get("error_key", "error_map_not_found")
            
            if key == "error_map_not_found":
                message = s[key].format(query=query)
            elif key == "error_api_error":
                message = s[key].format(status_code=error_data.get('status_code', 'N/A'))
            else:
                message = s.get(key, "An unknown error occurred.")
                
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        beatmapset_id = None
        if isinstance(map_data, list) and map_data:
            beatmapset_id = map_data[0].get('beatmapset_id')
        elif isinstance(map_data, dict):
            beatmapset_id = map_data.get('id')

        if beatmapset_id:
            download_title = s['loading_osz_message'].format(id=beatmapset_id)
            run_on_ui_thread(lambda: self.progress_dialog_builder.set_title(download_title) if self.progress_dialog_builder else None)
            
            self._download_and_send_map(str(beatmapset_id), map_data, peer_id, reply_to_msg_obj)
        else:
            message = s['error_map_id_not_found']
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))

    def _process_song_request(self, query: str, peer_id: Any, reply_to_msg_obj: Optional[Any] = None):
        s = self._get_strings()
        map_data = None
        
        if query.isdigit():
            api_v1_source = self.get_setting("api_v1_source", 0)
            api_key = DEFAULT_API_KEY_V1 if api_v1_source == 0 else self.get_setting("api_key_v1", "")
            map_data = self._fetch_beatmap_data_v1(query, api_key)
        else:
            api_v2_source = self.get_setting("api_v2_source", 0)
            client_id = DEFAULT_CLIENT_ID_V2 if api_v2_source == 0 else self.get_setting("client_id", "")
            client_secret = DEFAULT_CLIENT_SECRET_V2 if api_v2_source == 0 else self.get_setting("client_secret", "")
            map_data = self._fetch_beatmap_data_v2(query, client_id, client_secret)
        
        if not map_data or (isinstance(map_data, dict) and "error_key" in map_data):
            error_data = map_data if isinstance(map_data, dict) else {}
            key = error_data.get("error_key", "error_map_not_found")
            
            if key == "error_map_not_found":
                message = s[key].format(query=query)
            elif key == "error_api_error":
                message = s[key].format(status_code=error_data.get('status_code', 'N/A'))
            else:
                message = s.get(key, "An unknown error occurred.")
                
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))
            return

        beatmapset_id = None
        if isinstance(map_data, list) and map_data:
            beatmapset_id = map_data[0].get('beatmapset_id')
        elif isinstance(map_data, dict):
            beatmapset_id = map_data.get('id')

        if beatmapset_id:
            download_title = s['loading_song_message'].format(id=beatmapset_id)
            run_on_ui_thread(lambda: self.progress_dialog_builder.set_title(download_title) if self.progress_dialog_builder else None)
            
            self._download_and_send_song(str(beatmapset_id), map_data, peer_id, reply_to_msg_obj)
        else:
            message = s['error_map_id_not_found']
            run_on_ui_thread(lambda: (self._dismiss_dialog(), self._send_formatted_message(message, peer_id, reply_to_msg_obj)))

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not isinstance(params.message, str):
            return HookResult()

        s = self._get_strings()
        user_cmd_prefix = self.get_setting("user_command_prefix", ".osu")
        map_cmd_prefix = self.get_setting("map_command_prefix", ".map")
        osz_cmd_prefix = self.get_setting("osz_command_prefix", ".osz")
        song_cmd_prefix = self.get_setting("song_command_prefix", ".song")

        is_user_cmd = params.message.startswith(f"{user_cmd_prefix} ")
        is_map_cmd = params.message.startswith(f"{map_cmd_prefix} ")
        is_osz_cmd = params.message.startswith(f"{osz_cmd_prefix} ")
        is_song_cmd = params.message.startswith(f"{song_cmd_prefix} ")

        if not any([is_user_cmd, is_map_cmd, is_osz_cmd, is_song_cmd]):
            return HookResult()

        try:
            parts = params.message.strip().split(" ", 1)
            if len(parts) < 2 or not parts[1].strip():
                if is_user_cmd: usage_message = s['usage_user_message'].format(prefix=user_cmd_prefix)
                elif is_map_cmd: usage_message = s['usage_map_message'].format(prefix=map_cmd_prefix)
                elif is_osz_cmd: usage_message = s['usage_osz_message'].format(prefix=osz_cmd_prefix)
                else: usage_message = s['usage_song_message'].format(prefix=song_cmd_prefix)
                send_message({"peer": params.peer, "message": usage_message})
                return HookResult(strategy=HookStrategy.CANCEL)
            
            raw_query = parts[1].strip()
            query = raw_query
            mode_query = None

            if is_user_cmd:
                if ':' in raw_query:
                    query_parts = raw_query.rsplit(':', 1)
                    query = query_parts[0].strip()
                    mode_query = query_parts[1].strip().lower()
                
                user_url_match = re.search(r'osu\.ppy\.sh/users/(\d+)', query)
                if user_url_match:
                    query = user_url_match.group(1)
            
            elif is_map_cmd or is_osz_cmd or is_song_cmd:
                beatmapset_match = re.search(r'osu\.ppy\.sh/(?:beatmapsets|s)/(\d+)', query)
                if beatmapset_match:
                    query = beatmapset_match.group(1)

            def show_dialog_and_process():
                current_fragment = get_last_fragment()
                if not current_fragment or not current_fragment.getParentActivity():
                    log("OsuPlugin: Could not get context to show dialog.")
                    if is_user_cmd: run_on_queue(lambda: self._process_user_request(query, params.peer, params.replyToMsg, mode_query))
                    elif is_map_cmd: run_on_queue(lambda: self._process_map_request(query, params.peer, params.replyToMsg))
                    elif is_osz_cmd: run_on_queue(lambda: self._process_osz_request(query, params.peer, params.replyToMsg))
                    elif is_song_cmd: run_on_queue(lambda: self._process_song_request(query, params.peer, params.replyToMsg))
                    return

                activity = current_fragment.getParentActivity()
                
                dialog_type = AlertDialogBuilder.ALERT_TYPE_SPINNER
                loading_text = ""
                is_download_cmd = is_osz_cmd or is_song_cmd
                
                if is_user_cmd: loading_text = s['loading_message']
                elif is_map_cmd: loading_text = s['loading_map_message']
                elif is_download_cmd:
                    if query.isdigit():
                        loading_text = s['loading_osz_message'].format(id=query) if is_osz_cmd else s['loading_song_message'].format(id=query)
                    else:
                        if is_osz_cmd: loading_text = s['loading_map_message']
                        elif is_song_cmd: loading_text = s.get('loading_song_search_message', s['loading_map_message'])
                    dialog_type = AlertDialogBuilder.ALERT_TYPE_LOADING

                self.progress_dialog_builder = AlertDialogBuilder(activity, dialog_type)
                if is_download_cmd:
                    self.progress_dialog_builder.set_title(loading_text)
                    self.progress_dialog_builder.set_message(s['download_cancellable_notice'])
                    self.progress_dialog_builder.set_negative_button(s['settings_cancel_button'], self._cancel_download)
                    self.progress_dialog_builder.set_on_cancel_listener(self._background_download_listener)
                    self.progress_dialog_builder.set_cancelable(True)
                else:
                    self.progress_dialog_builder.set_message(loading_text)
                    self.progress_dialog_builder.set_cancelable(False)

                self.progress_dialog_builder.show()

                if is_user_cmd:
                    run_on_queue(lambda: self._process_user_request(query, params.peer, params.replyToMsg, mode_query))
                elif is_map_cmd:
                    run_on_queue(lambda: self._process_map_request(query, params.peer, params.replyToMsg))
                elif is_osz_cmd:
                    run_on_queue(lambda: self._process_osz_request(query, params.peer, params.replyToMsg))
                elif is_song_cmd:
                    run_on_queue(lambda: self._process_song_request(query, params.peer, params.replyToMsg))

            run_on_ui_thread(show_dialog_and_process)
            
            return HookResult(strategy=HookStrategy.CANCEL)
        except Exception as e:
            log(f"OsuPlugin: Critical error in on_send_message_hook: {e}\n{traceback.format_exc()}")
            send_message({"peer": params.peer, "message": s['critical_error_message'].format(error=str(e))})
            run_on_ui_thread(self._dismiss_dialog)
            return HookResult(strategy=HookStrategy.CANCEL)