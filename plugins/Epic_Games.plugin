#
#
#
#
#      –ù—É —Å–º–æ—Ç—Ä–∏, —Å–º–æ—Ç—Ä–∏ :)
#
#
#
from ui.settings import Header, Input, Switch, Selector, Divider, Text
from base_plugin import BasePlugin, HookResult, HookStrategy
import json
import requests
from java.util import Locale
from markdown_utils import parse_markdown
import time
import threading
from org.telegram.ui.ActionBar import AlertDialog
from client_utils import send_message, get_last_fragment, get_send_messages_helper, get_messages_controller, get_user_config, send_request
from android_utils import log
from java.io import File
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet.tl import TL_account
from org.telegram.tgnet import TLRPC
from ui.bulletin import BulletinHelper
import os
import uuid
from typing import Optional
import io
from PIL import Image, ImageDraw, ImageFont, ImageFilter
from ui.alert import AlertDialogBuilder
import base64

__id__ = "epicgames"
__name__ = "Epic Games"
__version__ = "1.0"
__description__ = "üéÆ Shows current game on Epic Games\n\nüìã Commands:\n‚Ä¢ [.nowepic/.enp] ‚Äî current game\n‚Ä¢ [.elibrary] ‚Äî games library\n‚Ä¢ [.eflibrary] ‚Äî full library\n\nüé® Design - @reNightly, @qmrrchh THANKS"
__author__ = "@Snaps_Game"
__min_version__ = "11.12.0"
__icon__ = "EpicBySnaps_by_TgEmodziBot"
__load__ = True

FONTS = {
    "NotoSansJP": "https://github.com/itsNightly/font_link/raw/refs/heads/main/NotoSansJP-Regular.ttf",
    "Zpix": "https://github.com/Ar4ikTrirtyFour/windose20/raw/refs/heads/main/fonts/zpix.ttf",
    "Impact": "https://github.com/localizator/ukrainian-fonts-pack/raw/refs/heads/master/TimesNRCyrMT-Bold%20-%20Times%20New%20Roman%20Cyr%20-%20Bold.ttf"
}

class Locales:
    default = {
        "settings_main_header": "‚öôÔ∏è Basic Settings",
        "settings_epic_account_id": "Epic Account ID",
        "settings_epic_account_id_subtext": "Enter your Epic Account ID",
        "settings_client_id": "Epic Client ID",
        "settings_client_id_subtext": "Get it from Epic Developer Portal",
        "settings_client_secret": "Epic Client Secret", 
        "settings_client_secret_subtext": "Get it from Epic Developer Portal",
        "settings_auto_update_header": "üéÆ Profile Auto-Update",
        "settings_enable_auto": "Enable auto-update",
        "settings_enable_auto_subtext": "Automatically updates profile with game info",
        "settings_check_interval": "Check interval (seconds)",
        "settings_check_interval_subtext": "How often to check game status",
        "settings_update_location": "Update location",
        "settings_update_location_items": ["About", "Location (Premium)"],
        "settings_text_template": "Text template",
        "settings_text_template_subtext": "Use {game} for game name",
        "settings_default_text": "Default text",
        "settings_default_text_subtext": "Shown when no game is running",
        "settings_sort_by_playtime": "Sort by playtime",
        "settings_sort_by_playtime_subtext": "If disabled, sorts by last played date",
        "settings_usage_divider": "Usage: .nowepic",
        "card_settings_header": "üñºÔ∏è Card settings",
        "card_text_format": "Card text format",
        "card_text_format_subtext": "Use {nick} and {game}",
        "card_font_family": "Card font",
        "settings_show_card_authors": "Show authors credit on card",
        "settings_show_card_authors_subtext": "Adds 'Plugin by @KangelPlugins & @MGEPlugins' footer",
        "settings_icon_style": "Icon style",
        "settings_icon_style_items": ["Standard", "Fortnite Style"],
        "custom_font_link": "Custom font link",
        "custom_font_link_subtext": "Direct link to .ttf file",
        "custom_font_help_title": "How to use custom fonts",
        "library_settings_header": "üìö Library settings",
        "error_account_id_not_set": "First set up your Epic Account ID in plugin settings!",
        "error_client_id_not_set": "First set up your Client ID in plugin settings!",
        "error_client_secret_not_set": "First set up your Client Secret in plugin settings!",
        "error_account_not_found": "Epic Account not found or profile is hidden",
        "error_invalid_credentials": "Invalid Epic credentials. Check your Client ID and Secret",
        "error_network": "Network error! Check your internet connection",
        "error_api": "Error: Invalid response from Epic API",
        "error_unknown": "Error: {e}",
        "error_invalid_account_id": "‚ùå Error: Invalid Epic Account ID",
        "error_auth_failed": "‚ùå Error: Authentication failed",
        "error_api_code": "‚ùå API Error: {code}",
        "error_invalid_response": "‚ùå Error: Invalid response from Epic API",
        "error_private_profile": "‚ùå Error: Unable to get games list. Check your profile privacy settings.",
        "error_network_generic": "‚ùå Network error: {e}",
        "error_json_parse": "‚ùå JSON parse error: {e}",
        "error_unknown_generic": "‚ùå Unknown error: {e}",
        "failed_to_load_library": "‚ùå An error occurred while loading the library. Please check logs.",
        "searching": "Searching...",
        "loading_library": "üîç Loading game list...",
        "library_empty": "üìö Your game library is empty",
        "library_header": "Library of Epic Games",
        "full_library_header": "Full Epic Games library",
        "total_games_and_time": "Total games: {count}",
        "sorting_label": "Sorting:",
        "sort_by_achievements_text": "By achievements progress",
        "sort_by_last_played_text": "By last played date",
        "btn_sort_by_achievements": "üèÜ By achievements",
        "btn_sort_by_last_played": "üìÖ By last played date",
        "last_played_suffix": " (last played: {date})",
        "achievements_progress": "Achievements: {progress}%",
        "and_more_games": "...and {count} more games",
        "stream_alert_title": "‚ö†Ô∏è‚ö†Ô∏èWARNING‚ö†Ô∏è‚ö†Ô∏è",
        "stream_alert_message": "This feature may work inconsistently due to Telegram's profile change limits. Your profile information may not update immediately. Use at your own risk.",
        "not_playing": "Not playing anything...",
        "playing_format": "**Currently playing:** {game}",
        "developers": "**Developers:** {developers}",
        "publishers": "**Publishers:** {publishers}",
        "rating": "**Rating:** {rating}",
        "genres": "**Genres:** {genres}",
        "playtime": "**Playtime:** {hours} hrs. {minutes} min.",
        "playtime_minutes": "**Playtime:** {minutes} min.",
        "achievements": "**Achievements:** {achieved}/{total} ({progress}%)",
        "game_link": "[Game Link]({url})",
        "font_faq_title": "üé® How to use custom fonts",
        "font_faq_text": (
            "üìù How to add a custom font?\n\n"
            "1Ô∏è‚É£ Select 'Custom font' in the font selector\n\n"
            "2Ô∏è‚É£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
            "üîó Example links:\n"
            "‚Ä¢ https://example.com/font.ttf\n"
            "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "üí° AND THERE MUST BE .ttf AT THE END\n\n"
            "3Ô∏è‚É£ Create a card with .nowepic command\n\n"
            "‚ö° The plugin will automatically download the font and use it!\n\n"
            "üö® IMPORTANT! ON FIRST USE/FONT CHANGE, IT WILL TAKE LONGER TO CREATE THAN USUAL\n\n"
            "üíª The author recommends uploading fonts to Github\n\n"
            "üåê Sites where you can find fonts (with direct links):\n"
            "‚Ä¢ https://fontsaddict.com\n\n"
            "‚Ä¢ https://en.bestfonts.pro\n\n"
        ),
        "alert_close_button": "‚úÖ Got it",
    }
    en = default
    ru = {
        "settings_main_header": "‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings_epic_account_id": "Epic Account ID",
        "settings_epic_account_id_subtext": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Epic Account ID",
        "settings_client_id": "Epic Client ID",
        "settings_client_id_subtext": "–ü–æ–ª—É—á–∏—Ç—å –≤ Epic Developer Portal",
        "settings_client_secret": "Epic Client Secret",
        "settings_client_secret_subtext": "–ü–æ–ª—É—á–∏—Ç—å –≤ Epic Developer Portal",
        "settings_auto_update_header": "üéÆ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è",
        "settings_enable_auto": "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
        "settings_enable_auto_subtext": "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∏–≥—Ä–µ",
        "settings_check_interval": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ (—Å–µ–∫—É–Ω–¥—ã)",
        "settings_check_interval_subtext": "–ö–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å—Ç–∞—Ç—É—Å –∏–≥—Ä—ã",
        "settings_update_location": "–ú–µ—Å—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è",
        "settings_update_location_items": ["–û —Å–µ–±–µ", "–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è (–ü—Ä–µ–º–∏—É–º)"],
        "settings_text_template": "–®–∞–±–ª–æ–Ω —Ç–µ–∫—Å—Ç–∞",
        "settings_text_template_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {game} –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è –∏–≥—Ä—ã",
        "settings_default_text": "–¢–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings_default_text_subtext": "–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞",
        "settings_sort_by_playtime": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –ø—Ä–æ–≥—Ä–µ—Å—Å—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π",
        "settings_sort_by_playtime_subtext": "–ï—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ, —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç –ø–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "settings_usage_divider": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .nowepic",
        "card_settings_header": "üñºÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—Ä—Ç–æ—á–∫–∏",
        "card_text_format": "–§–æ—Ä–º–∞—Ç —Ç–µ–∫—Å—Ç–∞ –∫–∞—Ä—Ç–æ—á–∫–∏",
        "card_text_format_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {nick} –∏ {game}",
        "card_font_family": "–®—Ä–∏—Ñ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏",
        "settings_show_card_authors": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å—å –∞–≤—Ç–æ—Ä–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ",
        "settings_show_card_authors_subtext": "–î–æ–±–∞–≤–ª—è–µ—Ç —Ñ—É—Ç–µ—Ä 'Plugin by @KangelPlugins & @MGEPlugins'",
        "settings_icon_style": "–°—Ç–∏–ª—å –∏–∫–æ–Ω–æ–∫",
        "settings_icon_style_items": ["–û–±—ã—á–Ω—ã–µ", "Fortnite Style"],
        "custom_font_link": "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç",
        "custom_font_link_subtext": "–°—Å—ã–ª–∫–∞ –Ω–∞ .ttf —Ñ–∞–π–ª",
        "custom_font_help_title": "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
        "library_settings_header": "üìö –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏",
        "error_account_id_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ Epic Account ID –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_client_id_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ Client ID –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_client_secret_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ Client Secret –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_account_not_found": "Epic Account –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç",
        "error_invalid_credentials": "–ù–µ–≤–µ—Ä–Ω—ã–µ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ Epic. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ Client ID –∏ Secret",
        "error_network": "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É",
        "error_api": "–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Epic API",
        "error_unknown": "–û—à–∏–±–∫–∞: {e}",
        "error_invalid_account_id": "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π Epic Account ID",
        "error_auth_failed": "‚ùå –û—à–∏–±–∫–∞: –û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏",
        "error_api_code": "‚ùå –û—à–∏–±–∫–∞ API: {code}",
        "error_invalid_response": "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Epic API",
        "error_private_profile": "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–≥—Ä. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ñ–∏–ª—è.",
        "error_network_generic": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: {e}",
        "error_json_parse": "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: {e}",
        "error_unknown_generic": "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}",
        "failed_to_load_library": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.",
        "searching": "–ò—â–µ–º –∏–≥—Ä—É...",
        "loading_library": "üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä...",
        "library_empty": "üìö –í–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞",
        "library_header": "–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä Epic Games",
        "full_library_header": "–ü–æ–ª–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Epic Games",
        "total_games_and_time": "–í—Å–µ–≥–æ –∏–≥—Ä: {count}",
        "sorting_label": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:",
        "sort_by_achievements_text": "–ü–æ –ø—Ä–æ–≥—Ä–µ—Å—Å—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π",
        "sort_by_last_played_text": "–ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "btn_sort_by_achievements": "üèÜ –ü–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è–º",
        "btn_sort_by_last_played": "üìÖ –ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "last_played_suffix": " (–ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑: {date})",
        "achievements_progress": "–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è: {progress}%",
        "and_more_games": "...–∏ –µ—â–µ {count} –∏–≥—Ä",
        "stream_alert_title": "‚ö†Ô∏è‚ö†Ô∏è–í–ù–ò–ú–ê–ù–ò–ï‚ö†Ô∏è‚ö†Ô∏è",
        "stream_alert_message": "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Telegram –Ω–∞ —á–∞—Å—Ç—É—é —Å–º–µ–Ω—É –ø—Ä–æ—Ñ–∏–ª—è. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫.",
        "not_playing": "–°–µ–π—á–∞—Å –Ω–µ –∏–≥—Ä–∞—é –Ω–∏ –≤–æ —á—Ç–æ...",
        "playing_format": "**–°–µ–π—á–∞—Å –∏–≥—Ä–∞—é –≤:** {game}",
        "developers": "**–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏:** {developers}",
        "publishers": "**–ò–∑–¥–∞—Ç–µ–ª–∏:** {publishers}",
        "rating": "**–†–µ–π—Ç–∏–Ω–≥:** {rating}",
        "genres": "**–ñ–∞–Ω—Ä—ã:** {genres}",
        "playtime": "**–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {hours} —á. {minutes} –º–∏–Ω.",
        "playtime_minutes": "**–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {minutes} –º–∏–Ω.",
        "achievements": "**–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è:** {achieved}/{total} ({progress}%)",
        "game_link": "[–°—Å—ã–ª–∫–∞ –Ω–∞ –∏–≥—Ä—É]({url})",
        "font_faq_title": "üé® –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
        "font_faq_text": (
            "üìù –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç?\n\n"
            "1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ '–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —à—Ä–∏—Ñ—Ç–æ–≤\n\n"
            "2Ô∏è‚É£ –í –ø–æ–ª–µ '–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª\n\n"
            "üîó –ü—Ä–∏–º–µ—Ä—ã —Å—Å—ã–ª–æ–∫:\n"
            "‚Ä¢ https://example.com/font.ttf\n"
            "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "üí° –ò –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –¢–ê–ú –î–û–õ–ñ–ï–ù –ë–´–¢–¨ –í –ö–û–ù–¶–ï .ttf\n\n"
            "3Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É –∫–æ–º–∞–Ω–¥–æ–π .nowepic\n\n"
            "‚ö° –ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞—á–∞–µ—Ç —à—Ä–∏—Ñ—Ç –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ!\n\n"
            "üö® –í–ê–ñ–ù–û! –ü–†–ò –ü–ï–†–í–û–ú –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ò/–°–ú–ï–ù–ï –®–†–ò–§–¢–ê –ë–£–î–ï–¢ –î–û–õ–¨–®–ï –°–û–ó–î–ê–í–ê–¢–¨–°–Ø –ß–ï–ú –û–ë–´–ß–ù–û\n\n"
            "üíª –ê–≤—Ç–æ—Ä —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã –Ω–∞ Github\n\n"
            "üåê –°–∞–π—Ç—ã –≥–¥–µ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ —à—Ä–∏—Ñ—Ç—ã (—Å –ø—Ä—è–º—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏):\n"
            "‚Ä¢ https://fontsaddict.com\n\n"
            "‚Ä¢ https://en.bestfonts.pro\n\n"
        ),
        "alert_close_button": "‚úÖ –ü–æ–Ω—è–ª",
    }

def localise(key: str, **kwargs) -> str:
    lang = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, lang, Locales.default)
    text = locale_dict.get(key, key)
    return text.format(**kwargs) if kwargs else text

TEMP_DIR_NAME = "temp_epic_images"
DEFAULT_STREAM_STRING = localise("playing_format")
DEFAULT_STREAM_TEXT = localise("not_playing")
DEFAULT_CHECK_INTERVAL = 30

NO_EPIC_FALLBACK_URL = "https://raw.githubusercontent.com/Ar4ikTrirtyFour/windose20/refs/heads/main/wallpapers/epic_games.jpg"

class EpicAPI:
    def __init__(self, client_id, client_secret):
        self.client_id = client_id
        self.client_secret = client_secret
        self.access_token = None
        self.token_expires = 0

    def _get_auth_header(self):
        return base64.b64encode(f"{self.client_id}:{self.client_secret}".encode()).decode()

    def _get_access_token(self):
        if self.access_token and time.time() < self.token_expires:
            return self.access_token

        try:
            url = "https://api.epicgames.dev/epic/oauth/v1/token"
            headers = {
                "Authorization": f"Basic {self._get_auth_header()}",
                "Content-Type": "application/x-www-form-urlencoded"
            }
            data = {
                "grant_type": "client_credentials"
            }

            response = requests.post(url, headers=headers, data=data, timeout=10)
            response.raise_for_status()
            
            token_data = response.json()
            self.access_token = token_data['access_token']
            self.token_expires = time.time() + token_data['expires_in'] - 60
            
            return self.access_token
        except Exception as e:
            log(f"[EpicAPI] Token error: {e}")
            return None

    def get_user_info(self, account_id):
        token = self._get_access_token()
        if not token:
            return None

        try:
            url = f"https://api.epicgames.dev/epic/id/v1/accounts"
            params = {"accountId": account_id}
            headers = {"Authorization": f"Bearer {token}"}

            response = requests.get(url, headers=headers, params=params, timeout=10)
            if response.status_code == 404:
                return None
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            log(f"[EpicAPI] User info error: {e}")
            return None

    def get_user_games(self, account_id):
        token = self._get_access_token()
        if not token:
            return None

        try:
            url = f"https://api.epicgames.dev/library/v1/accounts/{account_id}/games"
            headers = {"Authorization": f"Bearer {token}"}

            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            log(f"[EpicAPI] Games error: {e}")
            return None

    def get_game_details(self, product_id):
        token = self._get_access_token()
        if not token:
            return None

        try:
            url = f"https://api.epicgames.dev/catalog/v1/products/{product_id}"
            headers = {"Authorization": f"Bearer {token}"}

            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            log(f"[EpicAPI] Game details error: {e}")
            return None

    def get_achievements(self, account_id, product_id):
        token = self._get_access_token()
        if not token:
            return None

        try:
            url = f"https://api.epicgames.dev/achievements/v1/accounts/{account_id}/products/{product_id}/achievements"
            headers = {"Authorization": f"Bearer {token}"}

            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            
            return response.json()
        except Exception as e:
            log(f"[EpicAPI] Achievements error: {e}")
            return None

progress_dialog = None

class AlertManager:
    def __init__(self):
        self.alert_builder_instance: Optional[AlertDialogBuilder] = None

    def show_info_alert(self, title: str, message: str, positive_button: str):
        last_fragment = get_last_fragment()
        if not last_fragment or not last_fragment.getParentActivity(): return
        context = last_fragment.getParentActivity()
        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.alert_builder_instance = builder
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda d, w: self.dismiss_dialog())
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def dismiss_dialog(self):
        if self.alert_builder_instance and self.alert_builder_instance.get_dialog() and self.alert_builder_instance.get_dialog().isShowing():
            self.alert_builder_instance.dismiss()
            self.alert_builder_instance = None

class EpicPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self._streamer_thread = None
        self._stop_streamer = False
        self.alert_manager = AlertManager()
        self.epic_api = None
        threading.Thread(target=self._streamer, daemon=True).start()

    def _get_icon(self, key: str) -> str:
        style = self.get_setting("icon_style", 1)
        fortnite = {
            "star": "[üåü](5398096269786764342)",
            "game": "[üéÆ](5265139050263626266)",
            "dev": "[‚ö°](5363920828465431862)",
            "pub": "[üè¢](5366551886776253280)",
            "rating": "[‚≠ê](5364175348227395877)",
            "genre": "[üéØ](5267392860122006833)",
            "time": "[‚è∞](5267166897597599285)",
            "link": "[üîó](5265139050263626266)",
            "achievement": "[üèÜ](5278305362703835500)",
        }
        std = {
            "star": "[üåü](5242483467144416949)",
            "game": "[üéÆ](5467583879948803288)",
            "dev": "[üë®‚Äçüíª](5190498849440931467)",
            "pub": "[üè¢](5264733042710181045)",
            "rating": "[‚≠ê](5438496463044752972)",
            "genre": "[üè∑](5278305362703835500)",
            "time": "[‚è±](5382194935057372936)",
            "link": "[üì±](5373144051690258848)",
            "achievement": "[üéØ](5382194935057372936)",
        }
        icons = fortnite if style == 1 else std
        return icons.get(key, "")

    def _with_icon(self, text: str, icon: str) -> str:
        try:
            if "|" in text:
                return f"{icon} | {text.split('|', 1)[1].strip()}"
            return f"{icon} | {text}"
        except Exception:
            return text

    def _initialize_api(self):
        client_id = self.get_setting("client_id", "").strip()
        client_secret = self.get_setting("client_secret", "").strip()
        
        if not client_id or not client_secret:
            return None
            
        if not self.epic_api or self.epic_api.client_id != client_id:
            self.epic_api = EpicAPI(client_id, client_secret)
            
        return self.epic_api

    def _streamer(self):
        log("[EpicGames] Streamer started")
        while not self._stop_streamer:
            try:
                if self.get_setting("update_bio", False):
                    log("[EpicGames] Update bio is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[EpicGames] Failed to get userFull")
                        time.sleep(5)
                        continue

                    api = self._initialize_api()
                    if not api:
                        log("[EpicGames] API not initialized")
                        time.sleep(30)
                        continue

                    account_id = self.get_setting("epic_account_id", "").strip()
                    if not account_id:
                        log("[EpicGames] Account ID not set")
                        time.sleep(30)
                        continue

                    stream_place = self.get_setting("stream_place", 1 if get_user_config().isPremium() else 0)
                    max_len = 140 if get_user_config().isPremium() else 70

                    log(f"[EpicGames] Fetching games for account {account_id}")
                    games_data = api.get_user_games(account_id)
                    
                    current_game = None
                    if games_data and 'games' in games_data:
                        for game in games_data['games']:
                            if game.get('status') == 'ACTIVE':  # Assuming active means playing
                                current_game = game
                                break

                    if current_game:
                        game_name = current_game.get('name', 'Unknown Game')
                        log(f"[EpicGames] Found active game: {game_name}")
                        
                        new_about_text = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                        new_about_text = new_about_text.replace("{game}", game_name)
                        
                        if stream_place == 0:
                            if userFull.about != new_about_text[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = new_about_text[:max_len]
                                    send_request(req, ())
                                    log("[EpicGames] Successfully updated bio")
                                except Exception as e:
                                    log(f"[EpicGames] Error updating bio: {e}")
                        else:
                            if not get_user_config().isPremium():
                                log("[EpicGames] User is not premium, can't update business location")
                                time.sleep(5)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = new_about_text[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[EpicGames] Successfully updated business location")
                            except Exception as e:
                                log(f"[EpicGames] Error updating business location: {e}")
                    else:
                        log("[EpicGames] No active game found")
                        default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                        if stream_place == 0:
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                    log("[EpicGames] Set default bio")
                                except Exception as e:
                                    log(f"[EpicGames] Error setting default bio: {e}")
                        else:
                            if not get_user_config().isPremium():
                                log("[EpicGames] User is not premium, can't update business location")
                                time.sleep(5)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = default_bio[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[EpicGames] Set default bio in business location")
                            except Exception as e:
                                log(f"[EpicGames] Error setting default bio in business location: {e}")

                    check_interval = self.get_setting("check_interval", DEFAULT_CHECK_INTERVAL)
                    time.sleep(check_interval)
                    
            except Exception as e:
                log(f"[EpicGames] Streamer error: {e}")
                time.sleep(10)

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            threading.Thread(target=self._download_fonts, daemon=True).start()
            log("Epic Games plugin loaded successfully")
        else:
            log("Failed to initialize temp directory for Epic Games")

    def _download_fonts(self):
        try:
            for font_name, font_url in FONTS.items():
                font_path = File(self._temp_dir, f"{font_name}-Regular.ttf").getAbsolutePath()
                if not os.path.exists(font_path):
                    response = requests.get(font_url)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                    log(f"Downloaded font: {font_name}")
        except Exception as e:
            log(f"Error downloading fonts: {e}")

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None

    def download_game_image(self, image_url):
        if not image_url:
            return None
        temp_dir = self._get_temp_dir()
        if not temp_dir or not temp_dir.isDirectory():
            return None

        filename = f"game_{uuid.uuid4()}.jpg"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()

        try:
            head = requests.head(image_url, timeout=5)
            content_length = int(head.headers.get('content-length', 0))
            if content_length > 10 * 1024 * 1024:
                return None

            resp = requests.get(image_url, stream=True, timeout=10)
            resp.raise_for_status()

            with open(temp_photo_path, 'wb') as f:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return temp_photo_path
        except Exception as e:
            try:
                if os.path.exists(temp_photo_path):
                    os.remove(temp_photo_path)
            except Exception:
                pass
            return None

    def delete_temp_file_async(self, file_path, delay_seconds=5):
        def _delete():
            try:
                time.sleep(delay_seconds)
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                pass
        threading.Thread(target=_delete, daemon=True).start()

    def _handle_show_faq_alert_click(self, view):
        title = localise("font_faq_title")
        text = localise("font_faq_text")
        close_button = localise("alert_close_button")
        self.alert_manager.show_info_alert(title, text, close_button)

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        update_bio = self.get_setting("update_bio", False)
        font_items = ["Noto Sans JP", "Zpix", "Impact", "–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç" if lang.startswith('ru') else "Custom font"]

        settings = [
            Header(text=localise("settings_main_header")),
            Input(
                key="epic_account_id",
                text=localise("settings_epic_account_id"),
                subtext=localise("settings_epic_account_id_subtext"),
                default="",
                icon="filled_username"
            ),
            Input(
                key="client_id",
                text=localise("settings_client_id"),
                subtext=localise("settings_client_id_subtext"),
                default="",
                icon="msg_secret"
            ),
            Input(
                key="client_secret",
                text=localise("settings_client_secret"),
                subtext=localise("settings_client_secret_subtext"),
                default="",
                icon="msg_secret"
            ),
            Selector(
                key="icon_style",
                text=localise("settings_icon_style"),
                default=1,
                items=localise("settings_icon_style_items"),
                icon="msg_emoji_smiles"
            ),
            Divider(),
            Header(text=localise("card_settings_header")),
            Input(
                key="card_text_format",
                text=localise("card_text_format"),
                subtext=localise("card_text_format_subtext"),
                default=("{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}" if lang.startswith('ru') else "{nick} plays {game}"),
                icon="msg_view_file"
            ),
            Selector(
                key="card_font_family",
                text=localise("card_font_family"),
                default=0,
                items=font_items,
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_path",
                text=localise("custom_font_link"),
                subtext=localise("custom_font_link_subtext"),
                default="",
                icon="msg_link"
            ),
            Text(
                text=localise("custom_font_help_title"),
                icon="msg_info",
                on_click=self._handle_show_faq_alert_click
            ),
            Switch(
                key="show_card_authors",
                text=localise("settings_show_card_authors"),
                default=True,
                subtext=localise("settings_show_card_authors_subtext"),
                icon="msg_info"
            ),
            Divider(),
            Header(text=localise("settings_auto_update_header")),
            Switch(
                key="update_bio",
                text=localise("settings_enable_auto"),
                default=False,
                subtext=localise("settings_enable_auto_subtext"),
                on_change=lambda new_value: self._show_stream_alert(new_value),
                icon="ic_ab_search"
            ),
            Input(
                key="check_interval",
                text=localise("settings_check_interval"),
                subtext=localise("settings_check_interval_subtext"),
                default=str(DEFAULT_CHECK_INTERVAL),
                icon="input_schedule"
            ) if update_bio else None,
            Selector(
                key="stream_place",
                text=localise("settings_update_location"),
                default=1 if get_user_config().isPremium() else 0,
                items=localise("settings_update_location_items"),
                icon="menu_premium_location" if get_user_config().isPremium() else "msg_openprofile"
            ) if update_bio and get_user_config().isPremium() else None,
            Input(
                key="track_display_format",
                text=localise("settings_text_template"),
                default=DEFAULT_STREAM_STRING,
                subtext=localise("settings_text_template_subtext"),
                icon="input_forward"
            ) if update_bio else None,
            Input(
                key="default_stream_text",
                text=localise("settings_default_text"),
                default=DEFAULT_STREAM_TEXT,
                subtext=localise("settings_default_text_subtext"),
                icon="input_reply"
            ) if update_bio else None,
            Divider(),
            Header(text=localise("library_settings_header")),
            Switch(
                key="sort_by_achievements",
                text=localise("settings_sort_by_playtime"),
                default=True,
                subtext=localise("settings_sort_by_playtime_subtext"),
                icon="filled_info"
            ),
        ]
        return [s for s in settings if s is not None]

    def _show_stream_alert(self, value):
        if value:
            title = localise("stream_alert_title")
            message = localise("stream_alert_message")
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            dialog = AlertDialog(ctx, 3)
            dialog.setTitle(title)
            dialog.setMessage(message)
            dialog.setButton("OK", None)
            dialog.show()

    def get_current_game(self, account_id):
        api = self._initialize_api()
        if not api:
            return localise("error_auth_failed"), None, None, None, None

        if not account_id or not account_id.strip():
            BulletinHelper.show_error(localise("error_account_id_not_set"))
            return localise("error_invalid_account_id"), None, None, None, None

        max_retries = 3
        retry_delay = 2

        for attempt in range(max_retries):
            try:
                log(f"[EpicPlugin] Getting user games (attempt {attempt + 1}/{max_retries})...")
                
                user_info = api.get_user_info(account_id)
                if not user_info:
                    return localise("error_account_not_found"), None, None, None, None

                display_name = user_info.get('displayName', 'Unknown')
                log(f"[EpicPlugin] User display name: {display_name}")

                games_data = api.get_user_games(account_id)
                if not games_data or 'games' not in games_data:
                    return self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT), None, None, None, display_name

                current_game = None
                for game in games_data['games']:
                    if game.get('status') == 'ACTIVE':
                        current_game = game
                        break

                if not current_game:
                    return self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT), None, None, None, display_name

                game_name = current_game.get('name', 'Unknown Game')
                product_id = current_game.get('productId')
                log(f"[EpicPlugin] Found active game: {game_name}, ID: {product_id}")

                game_details = None
                image_url = None
                achievements_data = None

                if product_id:
                    game_details = api.get_game_details(product_id)
                    if game_details:
                        images = game_details.get('keyImages', [])
                        for img in images:
                            if img.get('type') == 'Featured':
                                image_url = img.get('url')
                                break
                        if not image_url and images:
                            image_url = images[0].get('url')

                    achievements_data = api.get_achievements(account_id, product_id)

                game_info = {
                    'name': game_name,
                    'product_id': product_id,
                    'details': game_details,
                    'achievements': achievements_data
                }

                return game_info, image_url, None, f"https://store.epicgames.com/en/p/{product_id}", display_name

            except requests.exceptions.RequestException as e:
                log(f"[EpicPlugin] Network error (attempt {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return localise("error_network"), None, None, None, None
            except Exception as e:
                log(f"[EpicPlugin] Unknown error: {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return localise("error_unknown", e=str(e)), None, None, None, None

    def get_epic_library(self, account_id):
        log(f"[EpicPlugin] Getting library for account: {account_id}")

        if not account_id or not account_id.strip():
            error_msg = localise("error_invalid_account_id")
            log(f"[EpicPlugin] {error_msg}")
            return None, error_msg

        api = self._initialize_api()
        if not api:
            error_msg = localise("error_auth_failed")
            log(f"[EpicPlugin] {error_msg}")
            return None, error_msg

        try:
            log(f"[EpicPlugin] Sending request to Epic API")
            games_data = api.get_user_games(account_id)
            
            if not games_data or 'games' not in games_data:
                error_msg = localise("error_private_profile")
                log(f"[EpicPlugin] {error_msg}")
                return None, error_msg

            games = games_data['games']
            log(f"[EpicPlugin] Found games: {len(games)}")

            if not games:
                log("[EpicPlugin] Game library is empty")
                return [], localise("library_empty")

            log(f"[EpicPlugin] Successfully received {len(games)} games")
            return games, None

        except requests.exceptions.RequestException as e:
            error_msg = localise("error_network_generic", e=str(e))
            log(f"[EpicPlugin] {error_msg}")
            return None, error_msg
        except Exception as e:
            import traceback
            error_msg = localise("error_unknown_generic", e=str(e)) + f"\n{traceback.format_exc()}"
            log(f"[EpicPlugin] {error_msg}")
            return None, error_msg

    def on_callback_query_hook(self, account, params):
        try:
            if not hasattr(params, 'data'):
                return HookResult()

            data = params.data
            log(f"[EpicPlugin] Received callback: {data}")

            if data.startswith('sort_'):
                sort_type, account_id = data.split('_', 1)[1].split('_', 1)

                try:
                    get_messages_controller().callCallbackQuery(params.query_id, "")
                except:
                    pass

                self.send_sorted_library(params.peer, account_id, sort_type)

                try:
                    get_messages_controller().editMessageReplyMarkup(params.peer, params.msg_id, None)
                except Exception as e:
                    log(f"[EpicPlugin] Error removing buttons: {str(e)}")

                return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            log(f"[EpicPlugin] Error in on_callback_query_hook: {str(e)}")
            import traceback
            log(f"[EpicPlugin] Traceback: {traceback.format_exc()}")

        return HookResult()

    def send_sorted_library(self, peer, account_id, sort_type='achievements', full_list=False):
        def _send():
            try:
                log(f"[EpicPlugin] Loading library with sorting: {sort_type}, full_list={full_list}")
                games, error = self.get_epic_library(account_id)

                if error:
                    log(f"[EpicPlugin] Error getting library: {error}")
                    send_message({"peer": peer, "message": error})
                    return

                if not games:
                    log("[EpicPlugin] Game library is empty")
                    send_message({"peer": peer, "message": localise("library_empty")})
                    return

                api = self._initialize_api()
                
                if sort_type == 'achievements' and api:
                    games_with_progress = []
                    for game in games:
                        product_id = game.get('productId')
                        if product_id:
                            achievements = api.get_achievements(account_id, product_id)
                            if achievements and 'achievements' in achievements:
                                total = len(achievements['achievements'])
                                achieved = sum(1 for a in achievements['achievements'] if a.get('achieved', False))
                                progress = (achieved / total * 100) if total > 0 else 0
                                game['achievement_progress'] = progress
                            else:
                                game['achievement_progress'] = 0
                        games_with_progress.append(game)
                    
                    games_sorted = sorted(games_with_progress, key=lambda x: x.get('achievement_progress', 0), reverse=True)
                    sort_text = localise("sort_by_achievements_text")
                else:
                    games_sorted = sorted(games, 
                        key=lambda x: x.get('lastPlayed', ''),
                        reverse=True)
                    sort_text = localise("sort_by_last_played_text")

                games_list = []
                total_games = len(games_sorted)

                max_games = 30
                games_to_show = games_sorted[:max_games]

                for i, game in enumerate(games_to_show, 1):
                    try:
                        name = game.get('name', 'Unknown game')
                        
                        if sort_type == 'achievements':
                            progress = game.get('achievement_progress', 0)
                            progress_str = localise("achievements_progress", progress=int(progress))
                            games_list.append(f"{i}. {name} - {progress_str}")
                        else:
                            last_played = game.get('lastPlayed', '')
                            if last_played:
                                last_played_date = last_played.split('T')[0]
                                last_played_str = localise("last_played_suffix", date=last_played_date)
                                games_list.append(f"{i}. {name}{last_played_str}")
                            else:
                                games_list.append(f"{i}. {name}")

                    except Exception as game_err:
                        log(f"[EpicPlugin] Error processing game {i}: {str(game_err)}")

                if total_games > max_games:
                    games_list.append("\n" + localise("and_more_games", count=total_games - max_games))

                if full_list:
                    message = f"üéÆ *{localise('full_library_header')}*\n" + localise('total_games_and_time', count=total_games) + "\n\n"

                    games_by_letter = {}
                    for game in games_sorted:
                        name = game.get('name', 'Unknown game')
                        first_letter = name[0].upper() if name and name[0].isalpha() else '#'
                        if first_letter not in games_by_letter:
                            games_by_letter[first_letter] = []
                        games_by_letter[first_letter].append(name)

                    sorted_letters = sorted(games_by_letter.keys())

                    for letter in sorted_letters:
                        games_str = ', '.join(games_by_letter[letter])
                        message += f"\n*{letter}*: {games_str}\n"

                    message += f"\nüìä *{localise('sorting_label')}* {sort_text}"
                else:
                    sort_buttons = [
                        [{"text": localise("btn_sort_by_achievements"), "callback_data": f"sort_achievements_{account_id}"}],
                        [{"text": localise("btn_sort_by_last_played"), "callback_data": f"sort_last_played_{account_id}"}]
                    ]

                    message = f"üéÆ *{localise('library_header')}*\n" + localise('total_games_and_time', count=total_games) + "\n\n"
                    message += "\n".join(games_list)
                    message += f"\n\nüìä *{localise('sorting_label')}* {sort_text}"

                log(f"[EpicPlugin] Sending {'full' if full_list else 'sorted'} game list")
                parsed = parse_markdown(message)

                entities = [entity.to_tlrpc_object() for entity in parsed.entities]
                try:
                    blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                    blockquote_entity.collapsed = True
                    blockquote_entity.offset = 0
                    try:
                        blockquote_entity.length = len(parsed.text.encode('utf-16le')) // 2
                    except Exception:
                        blockquote_entity.length = len(parsed.text)
                    entities.append(blockquote_entity)
                except Exception as e:
                    log(f"[EpicPlugin] Failed to add collapsed quote: {e}")

                message_data = {
                    "peer": peer,
                    "message": parsed.text,
                    "entities": entities
                }

                if not full_list and 'sort_buttons' in locals():
                    message_data["reply_markup"] = {"inline_keyboard": sort_buttons}

                send_message(message_data)

            except Exception as e:
                log(f"[EpicPlugin] Error sending sorted library: {str(e)}")
                import traceback
                log(f"[EpicPlugin] Traceback: {traceback.format_exc()}")
                try:
                    send_message({
                        "peer": peer,
                        "message": localise("failed_to_load_library")
                    })
                except:
                    pass

        threading.Thread(target=_send, daemon=True).start()

    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        message = params.message.strip()

        if message in (".elibrary", ".eflibrary"):
            is_full_library = message == ".eflibrary"
            command_name = ".eflibrary" if is_full_library else ".elibrary"

            try:
                log(f"[EpicPlugin] Processing command {command_name}")
                account_id = self.get_setting("epic_account_id", "").strip()

                if not account_id:
                    params.message = localise("error_account_id_not_set")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                try:
                    BulletinHelper.show_info(localise("loading_library"))
                    log("[EpicPlugin] Showed loading notification")
                except Exception as e:
                    log(f"[EpicPlugin] Error showing notification: {str(e)}")

                try:
                    BulletinHelper.show_info(localise("loading_library"))
                    sort_type = 'achievements' if self.get_setting("sort_by_achievements", True) else 'last_played'
                    self.send_sorted_library(params.peer, account_id, sort_type, is_full_library)
                except Exception as e:
                    log(f"[EpicPlugin] Error starting thread: {str(e)}")
                    params.message = localise("failed_to_load_library")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                return HookResult(strategy=HookStrategy.CANCEL)

            except Exception as e:
                import traceback
                error_msg = f"‚ùå Critical error: {str(e)}\n\n{traceback.format_exc()}"
                log(f"[EpicPlugin] {error_msg}")
                params.message = "‚ùå Critical error occurred. Please check logs."
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if not (message.lower().startswith(".nowepic") or message.lower().startswith(".enp")):
            return HookResult()

        try:
            account_id = self.get_setting("epic_account_id", "")

            log(f"[EpicPlugin] Command .nowepic received. Account ID: {account_id}")

            if not account_id:
                BulletinHelper.show_error(localise("error_account_id_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            def search_and_reply(peer):
                try:
                    log("[EpicPlugin] Starting game info search...")
                    result, image_url, playtime, game_url, nickname = self.get_current_game(account_id)
                    log(f"[EpicPlugin] Received result: {result}, nickname: {nickname}")
                    
                    if isinstance(result, str) and result.startswith('‚ùå Error'):
                        BulletinHelper.show_error(result)
                        return

                    if result == self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT):
                        log("[EpicPlugin] Player not in game")
                        text_np = self._with_icon(str(result), self._get_icon("star"))
                        parsed = parse_markdown(text_np)
                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                        })
                        return

                    caption_message = ""
                    if isinstance(result, dict):
                        caption_lines = []
                        caption_lines.append(self._with_icon(localise("playing_format", game=result['name']), self._get_icon('game')))
                        
                        if result.get('details'):
                            details = result['details']
                            if details.get('developer'):
                                caption_lines.append(self._with_icon(localise("developers", developers=details['developer']), self._get_icon('dev')))
                            if details.get('publisher') and details['publisher'] != details.get('developer', ''):
                                caption_lines.append(self._with_icon(localise("publishers", publishers=details['publisher']), self._get_icon('pub')))
                            if details.get('rating'):
                                caption_lines.append(self._with_icon(localise("rating", rating=details['rating']), self._get_icon('rating')))
                            if details.get('genres'):
                                caption_lines.append(self._with_icon(localise("genres", genres=', '.join(details['genres'][:3])), self._get_icon('genre')))

                        if result.get('achievements') and 'achievements' in result['achievements']:
                            achievements = result['achievements']['achievements']
                            total = len(achievements)
                            achieved = sum(1 for a in achievements if a.get('achieved', False))
                            progress = (achieved / total * 100) if total > 0 else 0
                            caption_lines.append(self._with_icon(localise("achievements", achieved=achieved, total=total, progress=int(progress)), self._get_icon('achievement')))

                        if result.get('product_id'):
                            caption_lines.append("\n" + self._with_icon(localise("game_link", url=game_url), self._get_icon('link')))

                        caption_message = "\n".join(caption_lines)
                    else:
                        line_playing = self._with_icon(localise("playing_format", game=result), self._get_icon('game'))
                        caption_message = line_playing
                        if game_url:
                            caption_message += "\n\n" + self._with_icon(localise("game_link", url=game_url), self._get_icon('link'))

                    try:
                        temp_photo_path = self._make_card(result, nickname, image_url)
                        helper = get_send_messages_helper()
                        if temp_photo_path:
                            generated_photo = helper.generatePhotoSizes(temp_photo_path, None)
                            if generated_photo is not None:
                                log("[EpicPlugin] Sending message with card and caption")
                                parsed_caption = parse_markdown(caption_message.strip())
                                send_message({
                                    "peer": peer,
                                    "photo": generated_photo,
                                    "path": temp_photo_path,
                                    "caption": parsed_caption.text,
                                    "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                    "message": None
                                })
                                self.delete_temp_file_async(temp_photo_path)
                                return
                            else:
                                log("[EpicPlugin] Failed to generate photo (card)")
                                self.delete_temp_file_async(temp_photo_path)
                        log("[EpicPlugin] Switching to fallback photo without processing")
                        fallback_path = self.download_game_image(NO_EPIC_FALLBACK_URL)
                        if fallback_path:
                            generated_photo = helper.generatePhotoSizes(fallback_path, None)
                            if generated_photo is not None:
                                parsed_caption = parse_markdown(caption_message.strip())
                                send_message({
                                    "peer": peer,
                                    "photo": generated_photo,
                                    "path": fallback_path,
                                    "caption": parsed_caption.text,
                                    "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                    "message": None
                                })
                                self.delete_temp_file_async(fallback_path)
                                return
                            else:
                                log("[EpicPlugin] Failed to generate photo (fallback)")
                                self.delete_temp_file_async(fallback_path)
                        BulletinHelper.show_error(localise("error_unknown_generic", e="card generation failed"))
                    except Exception as e:
                        log(f"[EpicPlugin] Error creating or sending card: {e}")
                        BulletinHelper.show_error(localise("error_unknown", e=str(e)))

                except Exception as e:
                    log(f"[EpicPlugin] Error in search thread: {e}")
                    BulletinHelper.show_error(localise("error_unknown", e=str(e)))

            try:
                BulletinHelper.show_info(localise("searching"))
            except Exception as e:
                log(f"[EpicPlugin] Error creating dialog: {e}")

            threading.Thread(target=lambda: search_and_reply(params.peer), daemon=True).start()
            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            params.message = localise("error_unknown", e=str(e))
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def _make_card(self, game_info, nickname, image_url):
        log(f"[EpicPlugin] Starting _make_card with game_info: {game_info}, nickname: {nickname}")
        width, height = 1280, 720
        background_color = "#2A2A2A"
        text_color = "#FFFFFF"

        log(f"[EpicPlugin] Creating card with dimensions: {width}x{height}")

        if not image_url or not image_url.strip():
            log(f"[EpicPlugin] No image_url provided ‚Äî cancel card generation to trigger raw fallback")
            return None

        original_image = None
        try:
            log(f"[EpicPlugin] Downloading original image from: {image_url}")
            response = requests.get(image_url, timeout=10)
            response.raise_for_status()
            original_image = Image.open(io.BytesIO(response.content)).convert("RGBA")
        except Exception as e:
            log(f"[EpicPlugin] Error downloading cover image: {e}")
            return None

        full_background = Image.new('RGB', (width, height), background_color)
        if original_image:
            try:
                blurred_background = original_image.resize((width, height))
                blurred_background = blurred_background.filter(ImageFilter.GaussianBlur(30))
                overlay = Image.new("RGBA", (width, height), (42, 42, 42, 180))
                full_background = Image.alpha_composite(blurred_background, overlay).convert("RGB")
                log(f"[EpicPlugin] Full blurred background created")
            except Exception as e:
                log(f"[EpicPlugin] Error processing background cover: {e}")

        card = full_background
        draw = ImageDraw.Draw(card)

        if original_image:
            try:
                log(f"[EpicPlugin] Original image size: {original_image.size}, mode: {original_image.mode}")

                target_width = 1023 
                target_height = int(target_width / 2.14)
                
                thumbnail = original_image.copy()
                if thumbnail.mode != 'RGBA':
                    thumbnail = thumbnail.convert('RGBA')

                thumbnail = thumbnail.resize((target_width, target_height), Image.Resampling.LANCZOS)
                log(f"[EpicPlugin] Resized to {target_width}x{target_height}, mode: {thumbnail.mode}")
                
                paste_x = (width - target_width) // 2
                paste_y = 50
                
                if thumbnail.mode == 'RGBA':
                    card.paste(thumbnail, (paste_x, paste_y), thumbnail)
                else:
                    card.paste(thumbnail, (paste_x, paste_y))
                    
                log(f"[EpicPlugin] Image pasted at position ({paste_x}, {paste_y})")

                text_start_y = paste_y + target_height + 20
            except Exception as e:
                log(f"[EpicPlugin] Error processing album cover thumbnail: {e}")
                return None

        game_name = game_info.get('name', 'Unknown Game') if isinstance(game_info, dict) else game_info

        font_index = self.get_setting("card_font_family", 0)
        main_font, footer_font = None, None

        if font_index == 3:
            custom_font_url = self.get_setting("custom_font_path", "").strip()
            if custom_font_url and custom_font_url.startswith(('http://', 'https://')):
                try:
                    custom_font_file = File(self._temp_dir, "custom_font.ttf").getAbsolutePath()
                    if not os.path.exists(custom_font_file):
                        response = requests.get(custom_font_url)
                        with open(custom_font_file, 'wb') as f:
                            f.write(response.content)
                    main_font = ImageFont.truetype(custom_font_file, 45)
                    footer_font = ImageFont.truetype(custom_font_file, 25)
                    try:
                        setattr(main_font, "_path", custom_font_file)
                    except Exception:
                        pass
                except Exception as e:
                    log(f"[EpicPlugin] Failed to load custom font: {e}, falling back.")
                    font_index = 0

        if not main_font:
            font_key = list(FONTS.keys())[font_index]
            font_file_name = f"{font_key}-Regular.ttf"
            try:
                font_path = File(self._temp_dir, font_file_name).getAbsolutePath()
                main_font = ImageFont.truetype(font_path, 45)
                footer_font = ImageFont.truetype(font_path, 25)
                try:
                    setattr(main_font, "_path", font_path)
                except Exception:
                    pass
            except Exception as e:
                log(f"Error loading font, using default: {e}")
                main_font = ImageFont.load_default()
                footer_font = ImageFont.load_default()

        card_text_format = self.get_setting("card_text_format", "{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}")
        main_text = card_text_format.replace("{nick}", nickname).replace("{game}", game_name)
        footer_text = "Plugin by @KangelPlugins & @MGEPlugins" if self.get_setting("show_card_authors", True) else None
        
        def wrap_lines(text, font, max_width):
            words = text.split()
            lines = []
            current = ""
            for w in words:
                test = (current + (" " if current else "") + w).strip()
                wlen = draw.textlength(test, font=font)
                if wlen <= max_width:
                    current = test
                else:
                    if current:
                        lines.append(current)
                        current = w
                    else:
                        lines.append(w)
                        current = ""
            if current:
                lines.append(current)
            return lines

        def fit_and_draw_centered(start_y, text, base_font, fill, max_width, max_lines=3, min_size=20):
            size = base_font.size if hasattr(base_font, 'size') else 45
            font_path = getattr(base_font, '_path', None)

            def with_size(sz):
                try:
                    if font_path:
                        return ImageFont.truetype(font_path, sz)
                except Exception:
                    pass
                return base_font

            while size >= min_size:
                font_try = with_size(size)
                lines = wrap_lines(text, font_try, max_width)
                if len(lines) <= max_lines:
                    y = start_y
                    line_height = font_try.getbbox("Ay")[3] - font_try.getbbox("Ay")[1]
                    spacing = 6 
                    total_h = len(lines) * line_height + (len(lines)-1) * spacing
                    y = start_y
                    for line in lines:
                        bbox = draw.textbbox((0, 0), line, font=font_try)
                        tw = bbox[2] - bbox[0]
                        draw.text(((width - tw) / 2, y), line, font=font_try, fill=fill)
                        y += line_height + spacing
                    return True
                size -= 2

            font_try = with_size(min_size)
            lines = wrap_lines(text, font_try, max_width)
            y = start_y
            line_height = font_try.getbbox("Ay")[3] - font_try.getbbox("Ay")[1]
            spacing = 6
            for i, line in enumerate(lines[:max_lines]):
                bbox = draw.textbbox((0, 0), line, font=font_try)
                tw = bbox[2] - bbox[0]
                draw.text(((width - tw) / 2, y), line, font=font_try, fill=fill)
                y += line_height + spacing
            return True

        available_width = width - 120
        try:
            _ = text_start_y
        except NameError:
            text_start_y = int(height * 0.6)

        fit_and_draw_centered(text_start_y, main_text, main_font, text_color, available_width)
        if footer_text:
            footer_bbox = draw.textbbox((0, 0), footer_text, font=footer_font)
            footer_w = footer_bbox[2] - footer_bbox[0]
            draw.text(((width - footer_w) / 2, height - 40), footer_text, font=footer_font, fill=text_color)

        filename = f"now_epic.png"
        temp_photo_path = File(self._temp_dir, filename).getAbsolutePath()
        log(f"[EpicPlugin] Saving card to: {temp_photo_path}")
        card.save(temp_photo_path)
        log(f"[EpicPlugin] Card saved successfully")
        return temp_photo_path

    def on_plugin_unload(self):
        log("Epic Games plugin unloaded")
        self.alert_manager.dismiss_dialog()