"""


                            –î–ò–°–ö–õ–ï–ô–ú–ï–†

–ö–æ—Ä–æ—á–µ , –µ—Å–ª–∏ —Ç–µ–±–µ –Ω—É–∂–µ–Ω –∫—É—Å–æ–∫ –∫–æ–¥–∞ –∏–∑ —ç—Ç–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ , —Ç–æ –ø–∂
—É–∫–∞–∑—ã–≤–∞–π –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ –∏–ª–∏ –≥–¥–µ-—Ç–æ –µ—â–µ , —á—Ç–æ –≤–∑—è–ª –∫–æ–¥ —Å @KangelPlugins.
                              –°–ø–∞—Å–∏–±–æ
                        üôè –ë–õ–ê–ì–û–°–õ–ê–í–õ–ï–ù–ò–ï üôè

‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚°§‚†§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚°§‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚†â‚¢Ä‚£§‚†∂‚†Æ‚†∑‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°º‚†ã‚†à‚£Ω‚£Ü‚†π‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†∂‚†∂‚†∂‚†∂‚£Ñ‚†Ä‚†Ä‚†Ä‚£û‚£Å‚£†‚†¥‚†Ø‚†∞‚†∂‚†∂‚†∂‚£æ‚†Å‚†ô‚£Ø‚£≥‚£•‚†û‚¢π‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°æ‚†Ä‚¢†‚°æ‚†Å‚¢π‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†è‚†Ä‚£ä‚£Ä‚£ê‚£Ä‚°à‚¢ì‚£¶‚°ñ‚†ã‚†Å‚†Ä‚°∞‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚£π‚¢†‚£Ñ‚£Ω‚†¨‚£æ‚†â‚¢π‚†≥‚°Ñ‚†Ä‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚¢∏‚†Ä‚¢Ä‚°º‚°á‚¢à‚°æ‚°¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚°è‚£†‚°æ‚†â‚¢Ä‚†Ä‚£Ä‚°Ω‚†õ‚¢É‚°Ñ‚†Ä‚†Ä‚°ú‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†õ‚†õ‚¢ß‚°Ä‚†à‚†ª‚¢æ‚°Ñ‚†à‚¢ß‚°Ä‚†Ä‚¢∏‚†Ä‚†Ä‚¢∏‚°∞‚°ø‚†õ‚°ß‚†ä‚°Ñ‚£ø‚£Æ‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°æ‚¢π‚°á‚†Ä‚†Ä‚£¥‚†õ‚†Ä‚¢Ä‚†é‚†Ä‚†Ä‚£º‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°π‚£¶‚°Ä‚†Ä‚£≥‚†∂‚£æ‚£≥‚°Ñ‚£∏‚†Ä‚†Ä‚¢∏‚†É‚¢Ä‚£¥‚†É‚†Ä‚¢°‚£ß‚£Ω‚†Ä‚†π‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°á‚¢∏‚°á‚¢∞‚°æ‚†ì‚†Ä‚†Ä‚°é‚†Ä‚†Ä‚¢†‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°û‚°â‚¢∫‚£Ø‚£´‚°∑‚†¶‚°ø‚†ô‚¢∑‚°á‚†Ä‚¢Ä‚°è‚£†‚†ø‚°ü‚†Ä‚¢†‚£æ‚°ñ‚°ü‚°Ü‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚†Ä‚£≥‚¢ø‚°æ‚†Ä‚†Ä‚£º‚†Å‚†Ä‚£Ä‚£æ‚£ø‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚†Ä‚†∑‚¢ø‚°ü‚†Å‚†à‚†ª‚£ß‚°á‚£†‚¢æ‚£á‚£§‚†û‚£¥‚†É‚°æ‚†Å‚¢Ä‚°ø‚†â‚†í‚¢ª‚°á‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚¢ª‚£ß‚°æ‚¢†‚†É‚¢Ä‚°á‚†Ä‚¢Ä‚°æ‚†Å‚†∏‚£º‚°Ä‚£á‚†Ä‚†Ä‚†Ä‚£Ü‚†Ä‚¢∏‚°Ü‚†Ä‚¢†‚¢ß‚°Ä‚†Ä‚†Ä‚°∑‚£û‚£°‚†é‚£á‚£§‚†û‚†Å‚°º‚†Å‚¢Ä‚°ø‚†Å‚†Ä‚†Ä‚¢π‚†Å‚¢†‚†á‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚°†‚†Ä‚¢Ä‚£ø‚£è‚°á‚¢∏‚°Ä‚†Ä‚°á‚†Ä‚£æ‚†É‚†Ä‚†Ä‚†â‚†ª‚†è‚†ì‚†∂‚†∂‚†ø‚¢§‚£Ä‚°∑‚¢Ñ‚£∏‚¢Æ‚£ø‚°¶‚£§‚°ü‚†â‚£ø‚¢∏‚°è‚†Å‚†Ä‚£∏‚†Å‚¢Ä‚°û‚†É‚†Ä‚†Ä‚†î‚°ø‚†Ä‚°æ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚°í‚†Ä‚†ò‚£ø‚£ø‚°á‚†∏‚£á‚¢∞‚°á‚¢∞‚£ß‚£∂‚£∂‚£∂‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚£ñ‚£Ñ‚£í‚£¶‚£º‚£è‚£∞‚£æ‚†ø‚¢æ‚£Ø‚£â‚£è‚£æ‚°á‚†Ä‚†Ä‚°á‚†Ä‚£º‚†Å‚†Ä‚†Ä‚†Ä‚£∞‚†É‚£º‚†Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†≥‚†õ‚†∂‚£Ω‚°á‚†Ä‚£ø‚°Ñ‚¢ª‚£∏‚£é‚†â‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚†â‚†â‚†Å‚¢π‚°è‚†Å‚†Ä‚£∏‚°è‚†ô‚°ø‚£ª‚†ë‚¢Ñ‚†Ä‚£ß‚†Ä‚°ü‚°Ü‚†Ä‚†Ä‚¢®‚†è‚°¥‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚¢∑‚†Ä‚£ø‚¢π‚£Ñ‚£ø‚†ø‚°Ç‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢æ‚†Å‚†Ä‚†Ä‚°ø‚£ß‚†û‚£±‚†á‚†Ä‚°ò‚†¶‚°Ω‚£Ñ‚£ø‚†π‚£Ñ‚°¥‚¢â‚†î‚†Å‚¢≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚°ø‚¢∏‚£ß‚†ò‚£ü‚†ô‚£ø‚°Ñ‚†Ä‚†Ä‚¢Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£Ø‚†ñ‚†Ä‚¢∞‚£∑‚¢á‚°º‚†É‚¢Ä‚†û‚†Ä‚°Ü‚†Ä‚†ô‚£ø‚°¶‚†ô‚¢∂‚°Å‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†≤‚¢ø‚†ã‚†â‚†â‚†ô‚¢¶‚£Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚°∑‚†º‚¢∂‚†Ω‚£ø‚£Ü‚†Ä‚†à‚†ª‚†§‚†§‚†§‚†û‚†Ä‚†Ä‚†Ä‚†Ä‚¢¥‚£ø‚†á‚†Ä‚†Ä‚£∏‚°ø‚†ã‚†Ä‚†Ä‚†é‚†Ä‚°û‚†Ä‚£†‚†û‚¢Å‚†Ω‚¢¶‚°Ä‚†ô‚¢¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚¢∏‚£Ö‚†Ä‚†Ä‚†à‚†â‚†õ‚†â‚†î‚£ª‚£∏‚¢∏‚£ø‚†ø‚£†‚°è‚£ß‚†ô‚¢ø‚£ß‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£æ‚†É‚†Ä‚†Ä‚¢∞‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚¢Å‚°î‚†É‚†Ä‚†Å‚†ã‚†ó‚¢¶‚£à‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢ø‚£ù‚¢¶‚£∏‚°ú‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚£ß‚°á‚†Ä‚°ø‚†Ä‚†Ä‚†Ä‚†â‚†Å‚†Ä‚†â‚†õ‚¢∑‚£Ñ‚£Ä‚£†‚£¥‚†û‚†â‚¢Å‚°æ‚†Å‚†Ä‚†Ä‚£∞‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚†É‚¢∞‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚¢∑‚£µ‚£Ñ‚†Ä‚†Ä‚†Ä
‚¢ª‚£ü‚£ø‚°ª‚£é‚¢£‚£≥‚°ò‚£Ü‚†Ä‚¢†‚°û‚°è‚†Ä‚£æ‚£ß‚†Ä‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°ü‚£ø‚†Ä‚£†‚¢Ç‚£ü‚£°‚†Ñ‚£†‚¢æ‚£ã‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚¢∞‚£ø‚†É‚¢†‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£ø‚†ª‚£Ñ‚†Ä
‚°à‚¢ª‚£Ü‚†ª‚°ü‚£Ü‚¢ª‚£ß‚¢ª‚£Ñ‚°º‚¢∏‚°á‚£¶‚£ø‚°º‚£ß‚£Ω‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£ã‚£§‚£ø‚¢à‚†ü‚¢π‚°ø‚£°‚°û‚†â‚†â‚†Ä‚†Ä‚£∞‚£∂‚£ô‚£∑‚£Ø‚°è‚†Ä‚£∏‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£∑‚†à‚¢ß
‚£ñ‚†¶‚£æ‚£∑‚°ô‚†ø‚†Ä‚†ô‚†Ä‚¢ª‚°á‚¢∏‚°á‚†ò‚¢ø‚£∑‚°å‚†ª‚£ø‚£§‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°ø‚†ã‚£±‚£ø‚†ü‚†Å‚£†‚£ø‚¢†‚°è‚†Ä‚†Ä‚¢Ä‚°æ‚†ü‚†ã‚†Å‚†Ä‚£®‚¢ø‚°á‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ß‚†Ä
‚†ò‚¢ø‚£é‚°ô‚†õ‚†Ç‚†Ä‚†Ä‚†Ä‚°º‚†É‚¢∏‚†á‚†ò‚°Ñ‚†ô‚†õ‚†Ä‚†à‚†â‚†Ä‚£†‚£æ‚¢è‚°ú‚¢°‚°æ‚†õ‚†Ä‚£†‚°æ‚†â‚¢ª‚£ø‚£Ñ‚£Ä‚°æ‚†õ‚†Ä‚†Ä‚†Ä‚°†‚†ä‚†Ä‚†Ä‚¢≥‚†Ä‚¢≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°Ñ
‚†Ä‚†Ä‚†ô‚¢ø‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚¢∏‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚†É‚°é‚¢†‚°ø‚†•‚£§‚†û‚†â‚¢∞‚£¶‚£Ä‚°Ω‚†õ‚†õ‚†Ä‚†Ä‚†Ä‚¢†‚†é‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£Ü‚†ò‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ñ‚¢á‚†Ä‚†Ä‚†Ä‚¢≥
‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚¢π‚£Ü‚°Ä‚†Ä‚†Ä‚°Ä‚£à‚£ø‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚¢ø‚£á‚†ò‚¢†‚°ü‚¢Ä‚°¥‚†ã‚£Ä‚£∏‚£∑‚£ø‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£∑‚£å‚†≥‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†Ä‚†Ä‚†Ä‚¢∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ô‚†õ‚†õ‚†â‚†â‚†â‚†Ä‚£æ‚£æ‚°Ä‚†Ä‚¢Ä‚£æ‚¢è‚£æ‚°æ‚¢Ä‚°û‚¢†‚°æ‚£∑‚£ø‚£ø‚£ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚¢Ä‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ò‚°å‚†ô‚†∑‚£¨‚°ª‚£ó‚†í‚†í‚†¶‚†§‚†§‚†§‚¢§‚£Ñ‚£Ä‚†Ä‚†Ä‚¢∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†æ‚¢Ø‚°Å‚†Ä‚†Ä‚†Ä‚†Ä‚††‚¢û‚£ª‚¢∑‚£§‚£æ‚£è‚£∏‚¢π‚£ß‚£∏‚££‚¢ü‚£§‚£ø‚£ø‚°ø‚†•‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ß‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†≥‚†§‚†§‚†§‚£Ñ‚£Ä‚£Ä‚†Ä‚†à‚†â‚†ì‚†ø
‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†¶‚°º‚†•‚†§‚†§‚¢Ñ‚°§‚†ñ‚†ã‚†Å‚†ò‚°ü‚†Ä‚†à‚†≥‚£ú‚£ø‚£ø‚££‚£æ‚†ü‚†ã‚†Å‚†Ä‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†π‚£≤‚£§‚°Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚¢Ä‚°¨‚£ù‚†Ç‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚£§‚£ô‚°ü‚†â‚°Ø‚†§‚†§‚†Ä‚†Ä‚††‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†¥‚†õ‚†Å‚†Ä‚†ô‚£¶
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†É‚†Ä‚£∏‚†Ä‚¢Ä‚£¥‚°ü‚†Ä‚††‚†î‚†í‚£ß‚£§‚£∑‚°¶‚°Ñ‚†Ä‚†Ä‚†Ä‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†û‚†Å‚†Ä‚†Ä‚¢Ä‚°§‚†é‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚†Ä‚†Ä‚†Ä‚¢†‚†Ä‚†É‚¢†‚†è‚°º‚†Ä‚†Ä‚†Ä‚£†‚°º‚£ø‚£è‚°è‚¢ø‚¢Ñ‚†Ä‚†Ä‚†Ä‚°è‚¢ß‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†ã‚†Ä‚¢Ä‚£§‚†¥‚†ü‚†â‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢õ‚°ª‚°á‚†Ä‚†Ä‚†à‚†Ü‚†Ä‚¢∏‚°Ñ‚†ß‚†§‚†¥‚†õ‚†â‚£∏‚£ß‚¢ª‚†Ä‚†ò‚†Ä‚†õ‚†¶‚†º‚†É‚£Ä‚£π‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢£‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†ã‚¢Ä‚£§‚†û‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†ò‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚¢Ä‚°º‚£ª‚°Ω‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£è‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°Ü‚†Ä‚¢†‚°ü‚¢Ä‚°¥‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

                            DISCLAIMER

Anyway, if you need a piece of code from this plugin, 
please mention in the description or somewhere else that you got it from @KangelPlugins. 
                             Thanks.
                            üôèBLESSüôè
"""


from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Selector, Input, Text, Switch
from client_utils import get_send_messages_helper, get_messages_controller, send_request, RequestCallback, send_message, get_user_config
from ui.bulletin import BulletinHelper
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet import TLRPC
from java.io import File
from java.util import Locale
from android_utils import log

from PIL import Image, ImageDraw, ImageFont, ImageOps
import requests, uuid, os, traceback, random, threading, re

__id__ = "ar34quotify"
__name__ = "Quotify"
__description__ = "Quote messages by replying with .q command and fake quotes with reply .fq <text> \nRequired: exteraGram/Ayugram 12.0.1 or higher"
__author__ = "@TailedPlugins & @KangelPlugins"
__min_version__ = "12.0.1"
__icon__ = "Kangelcons_by_fStikBot/1"
__version__ = "1.4.0"

def qlog(message):
    try:
        log(f"[Quotify] {message}")
    except Exception:
        pass

class DebugLogger:
    logs_dir = "/storage/emulated/0/Download/tailed_quotes_logs"
    logs = []
    
    @staticmethod
    def make_log(log):
        DebugLogger.logs.append(log)
        
    @staticmethod
    def save_logs():
        save_dir = DebugLogger.logs_dir + f"/log-{uuid.uuid4()}.txt"
        Filesystem.write_file(save_dir, '\n'.join(DebugLogger.logs).encode('utf-8'))
        return save_dir
    
    @staticmethod
    def format_tl_error(error):
        return f"TLRPC Error: {error.text} ({error.code})"

class QuoterPlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            FontManager.init()
            LocalizationManager.init()
            self.add_on_send_message_hook()
            self._alert_builder_instance = None
        except Exception as e:
            qlog("on_plugin_load error\n" + str(traceback.format_exc()))

    def _show_font_faq_alert(self, view=None):
        from ui.alert import AlertDialogBuilder
        from org.telegram.messenger import ApplicationLoader
        from client_utils import get_last_fragment
        lang = Locale.getDefault().getLanguage()
        if lang.startswith('ru'):
            title = "üé® –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã"
            text = (
                "üìù –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç?\n\n"
                "1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ '–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —à—Ä–∏—Ñ—Ç–æ–≤\n\n"
                "2Ô∏è‚É£ –í –ø–æ–ª–µ '–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª\n\n"
                "üîó –ü—Ä–∏–º–µ—Ä—ã —Å—Å—ã–ª–æ–∫:\n"
                "‚Ä¢ https://example.com/font.ttf\n"
                "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "üí° –í –ö–û–ù–¶–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –î–û–õ–ñ–ù–û –ë–´–¢–¨ .ttf\n\n"
                "3Ô∏è‚É£ –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ —Å–æ–∑–¥–∞–π—Ç–µ —Ü–∏—Ç–∞—Ç—É (.q)\n\n"
                "‚ö° –ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞—á–∞–µ—Ç —à—Ä–∏—Ñ—Ç –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ!\n\n"
                "üö® –í–ê–ñ–ù–û! –ü–†–ò –ü–ï–†–í–û–ú –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ò/–°–ú–ï–ù–ï –®–†–ò–§–¢–ê –ö–ê–†–¢–û–ß–ö–ê –ë–£–î–ï–¢ –°–û–ó–î–ê–í–ê–¢–¨–°–Ø –î–û–õ–¨–®–ï\n\n"
                "üíª –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∑–∞–≥—Ä—É–∂–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã –Ω–∞ Github\n\n"
                "üåê –ì–¥–µ –∏—Å–∫–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã (—Å –ø—Ä—è–º—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏):\n"
                "‚Ä¢ https://fontsaddict.com\n"
                "‚Ä¢ https://en.bestfonts.pro\n"
            )
            close_button = "‚úÖ –ü–æ–Ω—è–ª"
        else:
            title = "üé® How to use custom fonts"
            text = (
                "üìù How to add a custom font?\n\n"
                "1Ô∏è‚É£ Select 'Custom font' in the font selector\n\n"
                "2Ô∏è‚É£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
                "üîó Example links:\n"
                "‚Ä¢ https://example.com/font.ttf\n"
                "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "üí° AND THERE MUST BE .ttf AT THE END\n\n"
                "3Ô∏è‚É£ Save settings and create a quote (.q)\n\n"
                "‚ö° The plugin will automatically download and use the font!\n\n"
                "üö® IMPORTANT! ON FIRST USE/FONT CHANGE, CARD CREATION WILL TAKE LONGER\n\n"
                "üíª Recommended to upload fonts to Github\n\n"
                "üåê Where to find fonts (with direct links):\n"
                "‚Ä¢ https://fontsaddict.com\n"
                "‚Ä¢ https://en.bestfonts.pro\n"
            )
            close_button = "‚úÖ Got it"
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(title)
        builder.set_message(text)
        builder.set_positive_button(close_button, lambda d, w: None)
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()
        self._alert_builder_instance = builder

    def create_settings(self):
        return [
            Header(
                LocalizationManager.get_string("QUOTE_SETTINGS_TITLE")
            ),
            Selector(
                key="layout",
                text=LocalizationManager.get_string("SETTINGS_LAYOUT"),
                default=0,
                items=[
                    LocalizationManager.get_string("SETTINGS_LAYOUT_HORIZONTAL"),
                    LocalizationManager.get_string("SETTINGS_LAYOUT_VERTICAL"),
                ],
                icon="chats_replies"
            ),
            Switch(
                key="fixed_width",
                text=LocalizationManager.get_string("SETTINGS_FIXED_WIDTH"),
                default=True,
                icon="filled_location_forever"
            ),
            Selector(
                key="bg_effect",
                text=LocalizationManager.get_string("SETTINGS_BG_EFFECT"),
                default=0,
                items=[
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_NONE"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_BLUR"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_SHARPEN"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_SMOOTH"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_EDGE"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_EMBOSS"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_CONTOUR"),
                    LocalizationManager.get_string("SETTINGS_BG_EFFECT_DETAIL"),
                ],
                icon="fab_compose_small"
            ),
            Header(
                LocalizationManager.get_string("FONT_SETTINGS_TITLE")
            ),
            Selector(
                key="font",
                text=LocalizationManager.get_string("SETTINGS_FONT"),
                default=0,
                items=FontManager.get_fonts_names(),
                icon="msg_photo_text_regular"
            ),            
            Input(
                key="custom_font_url",
                text=LocalizationManager.get_string("SETTINGS_CUSTOM_FONT_URL"),
                default="",
                subtext=LocalizationManager.get_string("SETTINGS_CUSTOM_FONT_URL_SUB"),
                icon="msg_photo_text_framed3"
            ),
            Input(
                key="gfonts_query",
                text=LocalizationManager.get_string("SETTINGS_GFONTS_QUERY"),
                default=self.get_setting("gfonts_query", ""),
                icon="msg_search"
            ),
            Text(
                text=LocalizationManager.get_string("SETTINGS_GFONTS_SEARCH"),
                icon="ic_ab_search",
                on_click=self._search_google_fonts_and_pick
            ),
            Text(
                text=LocalizationManager.get_string("SETTINGS_CUSTOM_FONT_FAQ"),
                icon="msg_info",
                on_click=self._show_font_faq_alert
            )
        ]

    def _search_google_fonts_and_pick(self, view=None):
        try:
            import requests
        except Exception:
            BulletinHelper.show_error(LocalizationManager.get_string("GFONTS_ERROR"))
            return
        try:
            from client_utils import get_last_fragment, run_on_ui_thread
            from ui.alert import AlertDialogBuilder
        except Exception:
            pass

        query = (self.get_setting("gfonts_query", "") or "").strip().lower()
        api_key = "AIzaSyBZBi89KDR77uodfz4y14M69ZOI9vQwn3E"

        try:
            url = f"https://www.googleapis.com/webfonts/v1/webfonts?key={api_key}&sort=popularity"
            resp = requests.get(url, timeout=20)
            if resp.status_code != 200:
                BulletinHelper.show_error(LocalizationManager.get_string("GFONTS_ERROR"))
                return
            data = resp.json()
            items = data.get("items", []) if isinstance(data, dict) else []
            if query:
                items = [it for it in items if query in (it.get("family", "").lower())]
            if not items:
                BulletinHelper.show_info(LocalizationManager.get_string("GFONTS_NO_RESULTS"))
                return

            def show_family_picker():
                try:
                    from client_utils import get_last_fragment
                    fragment = get_last_fragment()
                    ctx = fragment.getParentActivity() if fragment else None
                    if not ctx:
                        return
                    builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    builder.set_title(LocalizationManager.get_string("SETTINGS_GFONTS_SEARCH"))
                    names = [it.get("family", "?") for it in items]

                    def on_family(bld, index):
                        try:
                            bld.dismiss()
                            self._pick_gfont_variant(items[index])
                        except Exception:
                            pass

                    builder.set_items(names, on_family)
                    builder.set_negative_button("OK", lambda d, w: d.dismiss())
                    builder.show()
                except Exception:
                    pass

            run_on_ui_thread(show_family_picker)
        except Exception:
            BulletinHelper.show_error(LocalizationManager.get_string("GFONTS_ERROR"))

    def _pick_gfont_variant(self, item):
        try:
            from client_utils import get_last_fragment, run_on_ui_thread
            from ui.alert import AlertDialogBuilder
        except Exception:
            pass
        try:
            files = item.get("files", {}) if isinstance(item, dict) else {}
            candidates = [(variant, url) for variant, url in files.items() if isinstance(url, str) and (url.endswith('.ttf') or url.endswith('.otf'))]
            if not candidates:
                BulletinHelper.show_info(LocalizationManager.get_string("GFONTS_ONLY_TTF"))
                return

            def show_variant_picker():
                try:
                    fragment = get_last_fragment()
                    ctx = fragment.getParentActivity() if fragment else None
                    if not ctx:
                        return
                    builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    builder.set_title(LocalizationManager.get_string("SETTINGS_GFONTS_SEARCH"))
                    items = [v for (v, _) in candidates]

                    def on_variant(bld, index):
                        try:
                            _, url = candidates[index]
                            self.set_setting("custom_font_url", url)
                            # switch selector to custom font (index 3)
                            self.set_setting("font", 3)
                            BulletinHelper.show_success(LocalizationManager.get_string("SETTINGS_FONT"))
                            bld.dismiss()
                        except Exception:
                            bld.dismiss()

                    builder.set_items(items, on_variant)
                    builder.set_negative_button("OK", lambda d, w: d.dismiss())
                    builder.show()
                except Exception:
                    pass

            run_on_ui_thread(show_variant_picker)
        except Exception:
            BulletinHelper.show_error(LocalizationManager.get_string("GFONTS_ERROR"))
        
    def on_send_message_hook(self, account, params) -> HookStrategy:
        if not isinstance(params.message, str):
            return HookResult()
        
        message_text = params.message.strip()
        message_lower = message_text.lower()
        
        if message_lower.startswith(".quotedebuglogs"):
            save_dir = DebugLogger.save_logs()
            params.message = f"logs saved into {save_dir}"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        
        if message_lower.startswith(".fq"):
            try:
                font_index = self.get_setting("font", 0)
                custom_font_url = self.get_setting("custom_font_url", "")
                layout_index = self.get_setting("layout", 0)
                fixed_width = self.get_setting("fixed_width", True)
                bg_effect = self.get_setting("bg_effect", 0)
                FontManager.custom_font_url = custom_font_url
                parts = message_text.split(" ", 1)
                fake_text = parts[1].strip() if len(parts) > 1 else ""
                if not fake_text:
                    BulletinHelper.show_error(LocalizationManager.get_string("FAKE_QUOTE_EMPTY"))
                    return HookResult(strategy=HookStrategy.CANCEL)
                try:
                    current_reply_to_msg = getattr(params, 'replyToMsg', None)
                except Exception:
                    current_reply_to_msg = None
                if (current_reply_to_msg is None) and hasattr(params, 'reply_to_message'):
                    try:
                        setattr(params, 'replyToMsg', getattr(params, 'reply_to_message'))
                    except Exception:
                        pass
                quote = QuoteManager(params, font_index, layout_index, fixed_width, bg_effect)
                quote.generate_fake_quote(fake_text)
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception:
                qlog(".fq processing error\n" + str(traceback.format_exc()))
                params.message = LocalizationManager.get_string("PLUGIN_ERROR")
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if not message_lower.startswith(".q"):
            return HookResult()
        try:
            reply_obj = getattr(params, 'replyToMsg', None)
            if reply_obj is None:
                reply_obj = getattr(params, 'reply_to_message', None)
        except Exception:
            reply_obj = None
        if reply_obj is None:
            BulletinHelper.show_error(LocalizationManager.get_string("FORGOT_TO_REPLY"))
            return HookResult(strategy=HookStrategy.CANCEL)

        try:
            try:
                current_reply_to_msg = getattr(params, 'replyToMsg', None)
            except Exception:
                current_reply_to_msg = None
            if (current_reply_to_msg is None) and hasattr(params, 'reply_to_message'):
                try:
                    setattr(params, 'replyToMsg', getattr(params, 'reply_to_message'))
                except Exception:
                    pass
            font_index = self.get_setting("font", 0)
            custom_font_url = self.get_setting("custom_font_url", "")
            layout_index = self.get_setting("layout", 0)
            fixed_width = self.get_setting("fixed_width", True)
            bg_effect = self.get_setting("bg_effect", 0)
            FontManager.custom_font_url = custom_font_url
            quote = QuoteManager(params, font_index, layout_index, fixed_width, bg_effect)
            
            quote.generate_quote()
            
            return HookResult(strategy=HookStrategy.CANCEL)
        except Exception as e:
            params.message = LocalizationManager.get_string("PLUGIN_ERROR")
            qlog("on_send_message_hook error\n" + str(traceback.format_exc()))
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
       
class LocalizationManager:
    language = "en"
    @staticmethod
    def init():
        language = Locale.getDefault().getLanguage()
        LocalizationManager.language = language if language in LocalizationManager._get_supported_languages() else "en"
        
    @staticmethod
    def get_string(string):
        locali = LocalizationManager.strings[LocalizationManager.language][string] 
        return locali if locali is not None else string
    
    @staticmethod
    def _get_supported_languages():
        return LocalizationManager.strings.keys()
    
    strings = {
        "ru": {
            "FORGOT_TO_REPLY": "‚ö†Ô∏è –¢—ã –∑–∞–±—ã–ª —Ä–µ–ø–ª–∞–π–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ!",
            "TLRPC_USERPHOTOS_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –ø–æ–ª—É—á–∏—Ç—å –∞–≤—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "TLRPC_GETFILE_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –∞–≤—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "PLUGIN_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ –ø–ª–∞–≥–∏–Ω–∞",
            "USERPHOTOS_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "GETFILE_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ —Å–∫–∞—á–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "QUOTE_SETTINGS_TITLE": "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ü–∏—Ç–∞—Ç—ã",
            "FONT_SETTINGS_TITLE": "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —à—Ä–∏—Ñ—Ç–∞",
            "FAKE_QUOTE_EMPTY": "‚ö†Ô∏è –£–∫–∞–∂–∏ —Ç–µ–∫—Å—Ç –ø–æ—Å–ª–µ .fq",
            "SETTINGS_LAYOUT": "–°—Ç–∏–ª—å —Ü–∏—Ç–∞—Ç—ã",
            "SETTINGS_LAYOUT_HORIZONTAL": "–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è",
            "SETTINGS_LAYOUT_VERTICAL": "–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è",
            "SETTINGS_FONT": "–®—Ä–∏—Ñ—Ç",
            "SETTINGS_CUSTOM_FONT_URL": "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "–í—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª. –ü—Ä–∏–º–µ—Ä: https://example.com/font.ttf",
            "SETTINGS_SHOW_IN_REPLY": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å '(–≤ –æ—Ç–≤–µ—Ç ...)' –≤ —Ü–∏—Ç–∞—Ç–µ",
            "SETTINGS_SHOW_IN_REPLY_SUB": "–ü–æ–¥–ø–∏—Å—å '(–≤ –æ—Ç–≤–µ—Ç ...)' –≤ —Ü–∏—Ç–∞—Ç–µ",
            "SETTINGS_CUSTOM_FONT_FAQ": "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
            "SETTINGS_FIXED_WIDTH": "–§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ —Å–∏–º–≤–æ–ª–æ–≤",
            "SETTINGS_BG_EFFECT": "–≠—Ñ—Ñ–µ–∫—Ç —Ñ–æ–Ω–∞",
            "SETTINGS_BG_EFFECT_NONE": "–ë–µ–∑ —ç—Ñ—Ñ–µ–∫—Ç–∞",
            "SETTINGS_BG_EFFECT_BLUR": "–†–∞–∑–º—ã—Ç–∏–µ",
            "SETTINGS_BG_EFFECT_SHARPEN": "–†–µ–∑–∫–æ—Å—Ç—å",
            "SETTINGS_BG_EFFECT_SMOOTH": "–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ",
            "SETTINGS_BG_EFFECT_EDGE": "–í—ã–¥–µ–ª–µ–Ω–∏–µ –∫—Ä–∞—ë–≤",
            "SETTINGS_BG_EFFECT_EMBOSS": "–¢–∏—Å–Ω–µ–Ω–∏–µ",
            "SETTINGS_BG_EFFECT_CONTOUR": "–ö–æ–Ω—Ç—É—Ä",
            "SETTINGS_BG_EFFECT_DETAIL": "–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è",
            "SETTINGS_GFONTS_QUERY": "–ü–æ–∏—Å–∫ Google Fonts",
            "SETTINGS_GFONTS_SEARCH": "–ù–∞–π—Ç–∏ —à—Ä–∏—Ñ—Ç –≤ Google Fonts",
            "GFONTS_NO_RESULTS": "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
            "GFONTS_ONLY_TTF": "–î–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã .ttf/.otf",
            "GFONTS_ERROR": "–û—à–∏–±–∫–∞ Google Fonts",
            "ATTACH_TYPE_1": "[—Ñ–æ—Ç–æ]",
            "ATTACH_TYPE_2": "[–≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]",
            "ATTACH_TYPE_3": "[–≤–∏–¥–µ–æ]", 
            "ATTACH_TYPE_4": "[–≥–µ–æ]", 
            "ATTACH_TYPE_5": "[–∫—Ä—É–∂–æ–∫]", 
            "ATTACH_TYPE_6": "[–∑–∞–≥—Ä—É–∑–∫–∞]", 
            "ATTACH_TYPE_8": "[–≥–∏—Ñ]", 
            "ATTACH_TYPE_9": "[—Ñ–∞–π–ª]", 
            "ATTACH_TYPE_10": "[–¥–∞—Ç–∞]", 
            "ATTACH_TYPE_11": "[—Ñ–æ—Ç–æ]", 
            "ATTACH_TYPE_12": "[–∫–æ–Ω—Ç–∞–∫—Ç]", 
            "ATTACH_TYPE_13": "[—Å—Ç–∏–∫–µ—Ä]", 
            "ATTACH_TYPE_14": "[–º—É–∑—ã–∫–∞]", 
            "ATTACH_TYPE_15": "[–∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—Ç–∏–∫–µ—Ä]", 
            "ATTACH_TYPE_16": "[–∑–≤–æ–Ω–æ–∫]", 
            "ATTACH_TYPE_17": "[–æ–ø—Ä–æ—Å]", 
            "ATTACH_TYPE_18": "[–ø—Ä–µ–º–∏—É–º]", 
            "ATTACH_TYPE_19": "[—ç–º–æ–¥–∑–∏]", 
            "ATTACH_TYPE_20": "[–ø—Ä–µ–≤—å—é]", 
            "ATTACH_TYPE_21": "[–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ñ–æ—Ç–æ]", 
            "ATTACH_TYPE_22": "[–∑–∞–¥–Ω–∏–π —Ñ–æ–Ω]", 
            "ATTACH_TYPE_23": "[–∏—Å—Ç–æ—Ä–∏—è]", 
            "ATTACH_TYPE_24": "[—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏]", 
            "ATTACH_TYPE_25": "[–ø—Ä–µ–º–∏—É–º]", 
            "ATTACH_TYPE_26": "[—Ä–∞–∑–¥–∞—á–∞]", 
            "ATTACH_TYPE_27": "[–∑–∞—à—ë–ª –≤ –∫–∞–Ω–∞–ª]", 
            "ATTACH_TYPE_28": "[—Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–¥–∞—á–∏]", 
            "ATTACH_TYPE_29": "[–ø–ª–∞—Ç–Ω–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ]", 
            "ATTACH_TYPE_30": "[–∑–≤—ë–∑–¥—ã]",
            "IN_REPLY": "[–≤ –æ—Ç–≤–µ—Ç {0}]"
        },
        "en": {
            "FORGOT_TO_REPLY": "‚ö†Ô∏è you forgot to reply to message!",
            "QUOTE_SETTINGS_TITLE": "Quote settings",
            "FONT_SETTINGS_TITLE": "Font settings",
            "TLRPC_GETCHANNELS_ERROR": "‚õî an error occurred while trying to fetch the chat data!",
            "TLRPC_GETCHATPHOTO_ERROR": "‚õî an error occurred while trying to fetch the chat thumbnail!",
            "TLRPC_USERPHOTOS_ERROR": "‚õî an error occurred while trying to fetch the user's avatar!",
            "TLRPC_GETFILE_ERROR": "‚õî an error occurred while downloading avatar!",
            "PLUGIN_ERROR": "‚õî an error occurred in plugin code!",
            "SETTINGS_TITLE": "Plugin settings",
            "FAKE_QUOTE_EMPTY": "‚ö†Ô∏è Provide text after .fq",
            "SETTINGS_LAYOUT": "Quote style",
            "SETTINGS_LAYOUT_HORIZONTAL": "Horizontal",
            "SETTINGS_LAYOUT_VERTICAL": "Vertical",
            "SETTINGS_FONT": "Font",
            "SETTINGS_CUSTOM_FONT_URL": "Custom font link (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "Paste a direct link to a .ttf file. Example: https://example.com/font.ttf",
            "SETTINGS_SHOW_IN_REPLY": "Show '(in reply ...)' in quote",
            "SETTINGS_SHOW_IN_REPLY_SUB": "Show '(in reply ...)' in quote",
            "SETTINGS_CUSTOM_FONT_FAQ": "How to use custom fonts",
            "SETTINGS_FIXED_WIDTH": "Fixed character width",
            "SETTINGS_BG_EFFECT": "Background effect",
            "SETTINGS_BG_EFFECT_NONE": "No effect",
            "SETTINGS_BG_EFFECT_BLUR": "Blur",
            "SETTINGS_BG_EFFECT_SHARPEN": "Sharpen",
            "SETTINGS_BG_EFFECT_SMOOTH": "Smooth",
            "SETTINGS_BG_EFFECT_EDGE": "Edge enhance",
            "SETTINGS_BG_EFFECT_EMBOSS": "Emboss",
            "SETTINGS_BG_EFFECT_CONTOUR": "Contour",
            "SETTINGS_BG_EFFECT_DETAIL": "Detail",
            "SETTINGS_GFONTS_QUERY": "Google Fonts search",
            "SETTINGS_GFONTS_SEARCH": "Search in Google Fonts",
            "GFONTS_NO_RESULTS": "Nothing found",
            "GFONTS_ONLY_TTF": "Only .ttf/.otf variants are available",
            "GFONTS_ERROR": "Google Fonts error",
            "ATTACH_TYPE_1": "[photo]",
            "ATTACH_TYPE_2": "[voice message]",
            "ATTACH_TYPE_3": "[video]",
            "ATTACH_TYPE_4": "[geo]",
            "ATTACH_TYPE_5": "[round message]",
            "ATTACH_TYPE_6": "[upload]",
            "ATTACH_TYPE_8": "[gif]",
            "ATTACH_TYPE_9": "[file]",
            "ATTACH_TYPE_10": "[date]",
            "ATTACH_TYPE_11": "[photo]",
            "ATTACH_TYPE_12": "[contact]",
            "ATTACH_TYPE_13": "[sticker]",
            "ATTACH_TYPE_14": "[music]",
            "ATTACH_TYPE_15": "[animated sticker]",
            "ATTACH_TYPE_16": "[call]",
            "ATTACH_TYPE_17": "[poll]",
            "ATTACH_TYPE_18": "[premium]",
            "ATTACH_TYPE_19": "[emoji]",
            "ATTACH_TYPE_20": "[preview]",
            "ATTACH_TYPE_21": "[photo suggestion]",
            "ATTACH_TYPE_22": "[background]",
            "ATTACH_TYPE_23": "[story]",
            "ATTACH_TYPE_24": "[story mention]",
            "ATTACH_TYPE_25": "[premium]",
            "ATTACH_TYPE_26": "[giveaway]",
            "ATTACH_TYPE_27": "[joined channel]",
            "ATTACH_TYPE_28": "[giveaway result]",
            "ATTACH_TYPE_29": "[paid attachment]",
            "ATTACH_TYPE_30": "[stars]",
            "IN_REPLY": "[in reply to {0}]"
        }
    }
    
class Filesystem:
    @staticmethod
    def write_file(file_path, content):
        file_full_path = "/".join(file_path.split("/")[:-1])
        if not os.path.exists(file_full_path):
            os.makedirs(file_full_path)
            
        with open(file_path, 'wb') as file:
            file.write(content)
            
    @staticmethod
    def get_absolute_path(dir, file_name):
        return File(dir, file_name).getAbsolutePath()
            
    @staticmethod
    def get_temp_dir():
        try:
            fixed_dir = ApplicationLoader.getFilesDirFixed()
            
            if not fixed_dir:
                return None
            
            temp_dir = File(fixed_dir, "tailed_quotes").getAbsolutePath()
            
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
                
            return temp_dir
            
        except Exception as e:
            qlog("get_temp_dir error\n" + str(traceback.format_exc()))
            return None
        
class TelegramUtils:
    @staticmethod
    def get_user(user_id):
        return get_messages_controller().getUser(user_id)
    
    @staticmethod 
    def get_channel(channel_id, callback):
        req = TLRPC.TL_channels_getChannels()
        input_channel = get_messages_controller().getInputChannel(channel_id)
        req.id.add(input_channel)
        
        cb = RequestCallback(callback)
        
        send_request(req, cb)
        
    @staticmethod
    def get_chat(chat_id, callback):
        req = TLRPC.TL_messages_getChats()
        input_chat = get_messages_controller().getInputChat(chat_id)
        req.id.add(input_chat)
        
        cb = RequestCallback(callback)
        
        send_request(req, cb)
        
    @staticmethod
    def create_input_location(photo, size):
        location = TLRPC.TL_inputPhotoFileLocation()
        
        location.id = photo.id
        location.access_hash = photo.access_hash
        location.file_reference = photo.file_reference
        location.thumb_size = size.type

        return location
    
    @staticmethod
    def create_peer_input_location(chat, peer):
        location = TLRPC.TL_inputPeerPhotoFileLocation()
        location.big = True
        location.peer = get_messages_controller().getInputPeer(peer)
        location.photo_id = chat.photo.photo_id
        
        return location
        
    @staticmethod
    def get_chat_thumbnail(chat, peer, callback):
        req = TLRPC.TL_upload_getFile()
        cb = RequestCallback(callback)
        
        location = TelegramUtils.create_peer_input_location(chat, peer)
        
        req.location = location
        req.offset = 0
        req.limit = 1024 * 1024
        
        send_request(req, cb)

class ReplyerID:
    def __init__(self, peer):
        if peer is None:
            self.channel_id = 0
            self.chat_id = 0
            self.user_id = -1
            self.peer = None
            return
        
        self.channel_id = peer.channel_id
        self.chat_id = peer.chat_id
        self.user_id = peer.user_id
        
        self.peer = peer
        
    def get_replyer_type(self):
        if self.channel_id != 0:
            return 2
        elif self.chat_id != 0:
            return 1
        else:
            return 0
        
    def get_id(self):
        if self.channel_id != 0:
            return self.channel_id
        elif self.chat_id != 0:
            return self.chat_id
        else:
            return self.user_id
        
class Replyer:
    def __init__(self):
        self.name = ""

class QuoteManager:
    def __init__(self, params, font_index, layout_index, fixed_width, bg_effect=0):
        self.params = params
        self.user = None
        self.replyer_id = None
        self.replyer = Replyer()
        self.font_index = font_index
        self.layout_index = layout_index
        self.override_quote_text = None
        self.fixed_width = fixed_width
        self.bg_effect = bg_effect
        
    def generate_quote(self):
        try:
            self.replyer_id = self.init_replyer_id()
            
            replyer_type = self.replyer_id.get_replyer_type()
            
            if replyer_type == 0:
                if self.replyer_id.user_id == -1:
                    return self.create_quote_without_input()
                user = TelegramUtils.get_user(self.replyer_id.user_id)

                self.user = user
                
                self.replyer.name = self.get_full_replyer_name()
                
                req = TLRPC.TL_photos_getUserPhotos()

                cb = RequestCallback(self.handle_user_photos_callback)

                input_user = get_messages_controller().getInputUser(user.id)

                req.user_id = input_user
                req.limit = 1
                
                send_request(req, cb)
            elif replyer_type == 1:
                TelegramUtils.get_chat(self.replyer_id.chat_id, self.handle_get_channels_callback)
            elif replyer_type == 2:
                TelegramUtils.get_channel(self.replyer_id.channel_id, self.handle_get_channels_callback)
        except Exception as e:
            qlog("generate_quote error\n" + str(traceback.format_exc()))
            
    def generate_fake_quote(self, text):
        try:
            self.override_quote_text = text
            try:
                reply_obj = getattr(self.params, 'replyToMsg', None)
                if reply_obj is None:
                    reply_obj = getattr(self.params, 'reply_to_message', None)
            except Exception:
                reply_obj = None

            if reply_obj is not None:
                self.replyer_id = self.init_replyer_id()
                replyer_type = self.replyer_id.get_replyer_type()

                if replyer_type == 0:
                    if self.replyer_id.user_id == -1:
                        return self.create_quote_without_input()
                    user = TelegramUtils.get_user(self.replyer_id.user_id)
                    self.user = user
                    self.replyer.name = self.get_full_replyer_name()

                    req = TLRPC.TL_photos_getUserPhotos()
                    cb = RequestCallback(self.handle_user_photos_callback)
                    input_user = get_messages_controller().getInputUser(user.id)
                    req.user_id = input_user
                    req.limit = 1
                    send_request(req, cb)
                    return
                elif replyer_type == 1:
                    TelegramUtils.get_chat(self.replyer_id.chat_id, self.handle_get_channels_callback)
                    return
                elif replyer_type == 2:
                    TelegramUtils.get_channel(self.replyer_id.channel_id, self.handle_get_channels_callback)
                    return

            user_id = get_user_config().getClientUserId()
            me = get_messages_controller().getUser(user_id)
            self.replyer.name = self.get_full_replyer_name_from_userobject(me) if me is not None else ""
            tmp_file = f"tmp_fake_{uuid.uuid4()}.jpg"
            temp_dir = Filesystem.get_temp_dir()
            file_path = Filesystem.get_absolute_path(temp_dir, tmp_file)
            self.create_and_send_image(
                output_path=file_path,
                author=self.replyer.name,
                quote=self.get_quote_message(),
                layout_vertical=(self.layout_index == 1),
                bg_effect=self.bg_effect
            )
        except Exception:
            qlog("generate_fake_quote error\n" + str(traceback.format_exc()))

    def handle_get_channels_callback(self, response, error):
        if error:
            qlog(DebugLogger.format_tl_error(error))
            BulletinHelper.show_error(LocalizationManager.get_string("TLRPC_GETCHANNELS_ERROR"))
            return
        
        if not error and response:
            if response.chats is None or response.chats.size() == 0:
                return None
            
            chat = response.chats.get(0)
            
            self.replyer.name = chat.title
            
            if chat.photo.photo_id == 0:
                return self.create_quote_without_input()
            
            TelegramUtils.get_chat_thumbnail(chat, self.replyer_id.peer, self.handle_get_file_callback)
            
    def get_quote_message(self):
        if self.override_quote_text is not None:
            return self.override_quote_text
        raw_message = self.get_replyer()
        message = raw_message.message if isinstance(raw_message.message, str) else ""
        
        try:
            message_type = self.params.replyToMsg.type
            
            if message_type is not None and message_type in range(1, 30):
                message = LocalizationManager.get_string("ATTACH_TYPE_" + str(message_type)) + "\n" + message
            return message
        except Exception as e:
            qlog("get_quote_message error\n" + str(traceback.format_exc()))
            
            BulletinHelper.show_error(LocalizationManager.get_string("PLUGIN_ERROR"))
        
    def init_replyer_id(self):
        replyer = self.get_replyer()
        replyer_peer = replyer.from_id
        
        if replyer.fwd_from is not None:
            replyer_peer = replyer.fwd_from.from_id
            
            if replyer.fwd_from.from_id is None:
                self.replyer.name = replyer.fwd_from.saved_from_name
        
        return ReplyerID(replyer_peer)
            
    def get_full_replyer_name(self):
        first_name = self.user.first_name
        first_name = first_name if first_name is not None else ""
        
        last_name = self.user.last_name
        last_name = last_name if last_name is not None else ""
        
        return " ".join([first_name, last_name]).strip()
    
    def get_full_replyer_name_from_userobject(self, user):
        first_name = user.first_name
        first_name = first_name if first_name is not None else ""
        
        last_name = user.last_name
        last_name = last_name if last_name is not None else ""
        
        return " ".join([first_name, last_name]).strip()
            
    def get_replyer(self):
        return self.params.replyToMsg.messageOwner
            
    def get_replyer_id(self):
        return self.replyer_id.get_id()
    

    def handle_user_photos_callback(self, response, error):
        try:

            if not error and response:
                try:
                    if response.photos is not None and response.photos.size() > 0:
                        photo = response.photos.get(0)
                        size = photo.sizes.get(0)
                        
                        req = TLRPC.TL_upload_getFile()
                        cb = RequestCallback(self.handle_get_file_callback)
                        
                        input_file = TelegramUtils.create_input_location(photo, size)
                        
                        req.location = input_file
                        req.offset = 0
                        req.limit = 1024 * 1024
                        
                        send_request(req, cb)
                        return
                except Exception as e:
                    pass
            
            username = getattr(self.user, 'username', None)
            if not username:
                return self.create_quote_without_input()
            
            self._fetch_avatar_and_create_quote()
        except Exception as e:
            qlog(f"handle_user_photos_callback error: {e}\n{traceback.format_exc()}")
            return self.create_quote_without_input()
    
    def _fetch_avatar_and_create_quote(self):
        try:
            username = getattr(self.user, 'username', None)
            user_id = getattr(self.user, 'id', None)
            
            if not username:
                if not user_id:
                    return self.create_quote_without_input()
                username = str(user_id)

            url = f"https://t.me/{username}"
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
            
            html_response = requests.get(url, headers=headers, timeout=10)
            html_response.raise_for_status()
            
            avatar_url = None
            match = re.search(r'<meta property="og:image" content="([^"]+)"', html_response.text)
            if match:
                avatar_url = match.group(1)
            else:
                match = re.search(r'<meta name="twitter:image" content="([^"]+)"', html_response.text)
                if match:
                    avatar_url = match.group(1)
                else:
                    match = re.search(r'<img class="tgme_page_photo_image" src="([^"]+)"', html_response.text)
                    if match:
                        avatar_url = match.group(1)
            
            if not avatar_url:
                return self.create_quote_without_input()
            
            avatar_response = requests.get(avatar_url, headers=headers, timeout=10)
            avatar_response.raise_for_status()
            tmp_file = f"img_{self.get_replyer_id()}.jpg"
            temp_dir = Filesystem.get_temp_dir()
            file_path = Filesystem.get_absolute_path(temp_dir, tmp_file)
            
            Filesystem.write_file(file_path, avatar_response.content)
            
            full_replyer_name = self.replyer.name
            message = self.get_quote_message()
            
            self.create_and_send_image(
                image_path=file_path,
                output_path=file_path,
                author=full_replyer_name,
                quote=message,
                layout_vertical=(self.layout_index == 1),
                bg_effect=self.bg_effect
            )
        except Exception as e:
            qlog(f"_fetch_avatar_and_create_quote error: {e}\n{traceback.format_exc()}")
            return self.create_quote_without_input()
    
    def create_quote_without_input(self):
        try:
            tmp_file = f"tmp_{self.get_replyer_id()}.jpg"
                        
            temp_dir = Filesystem.get_temp_dir()
                        
            file_path = Filesystem.get_absolute_path(
                temp_dir, tmp_file
            )
                        
            full_replyer_name = self.replyer.name
            message = self.get_quote_message()
                        
            self.create_and_send_image(
                output_path=file_path,
                author=full_replyer_name,
                quote=message,
                layout_vertical=(self.layout_index == 1),
                bg_effect=self.bg_effect
            )
        except Exception as e:
            qlog("create_quote_without_input error\n" + str(traceback.format_exc()))
    
    def handle_get_file_callback(self, response, error):
        if error:
            qlog(DebugLogger.format_tl_error(error))
            return self._fetch_avatar_and_create_quote()
            
        if not error and response:
            try:
                buffer = response.bytes.buffer
                buffer.rewind()
                length = buffer.remaining()
                
                py_bytes = bytes([buffer.get() & 0xFF for _ in range(length)])
                
                tmp_file = f"img_{self.get_replyer_id()}.jpg"
                
                temp_dir = Filesystem.get_temp_dir()
                
                file_path = Filesystem.get_absolute_path(
                    temp_dir, tmp_file
                )
                
                Filesystem.write_file(file_path, py_bytes)
                
                full_replyer_name = self.replyer.name
                message = self.get_quote_message()
                
                self.create_and_send_image(
                    image_path=file_path,
                    output_path=file_path,
                    author=full_replyer_name,
                    quote=message,
                    layout_vertical=(self.layout_index == 1),
                    bg_effect=self.bg_effect
                )
            except Exception as e:
                qlog("handle_get_file_callback error\n" + str(traceback.format_exc()))
                return self.create_quote_without_input()
                
    def create_and_send_image(
        self, 
        bg_color=(0, 0, 0),
        image_path=None,
        quote="",
        author="",
        output_path="quote_dynamic_stretch.png",
        img_width=300,
        canvas_width=900,
        min_canvas_height=400,
        padding=30,
        layout_vertical=False,
        bg_effect=0
    ):
        from PIL import ImageFilter
        font_path = FontManager.get(self.font_index).get_path()
        quote_font = ImageFont.truetype(font_path, 36)
        author_font = ImageFont.truetype(font_path, 28)

        dummy_img = Image.new("RGB", (canvas_width, min_canvas_height), (0,0,0))
        dummy_draw = ImageDraw.Draw(dummy_img)
        author_text = f"‚Äî {author}"

        if layout_vertical:
            canvas_width = min(canvas_width, 1280)
            img_width = min(img_width, 720)
            max_text_width = canvas_width - padding * 2
            wrapped_quote = "\n".join(
                self._wrap_text(dummy_draw, line, quote_font, max_text_width)
                for line in quote.split("\n")
            )
            bbox = dummy_draw.multiline_textbbox((0, 0), wrapped_quote, font=quote_font)
            quote_size = (bbox[2] - bbox[0], bbox[3] - bbox[1])
            author_wrapped = self._wrap_text_by_char_count(author_text, 24)
            bbox = dummy_draw.multiline_textbbox((0, 0), author_wrapped, font=author_font)
            author_size = (bbox[2] - bbox[0], bbox[3] - bbox[1])
            avatar_h = img_width
            total_height = avatar_h + padding + quote_size[1] + 20 + author_size[1]
            canvas_height = max(min_canvas_height, total_height + padding * 2)
        else:
            max_text_width = canvas_width - img_width - padding * 3
            wrapped_quote = "\n".join(
                self._wrap_text(dummy_draw, line, quote_font, max_text_width)
                for line in quote.split("\n")
            )
            bbox = dummy_draw.multiline_textbbox((0, 0), wrapped_quote, font=quote_font)
            quote_size = (bbox[2] - bbox[0], bbox[3] - bbox[1])
            author_wrapped = self._wrap_text_by_char_count(author_text, 24)
            bbox = dummy_draw.multiline_textbbox((0, 0), author_wrapped, font=author_font)
            author_size = (bbox[2] - bbox[0], bbox[3] - bbox[1])
            total_text_height = quote_size[1] + author_size[1] + 15
            canvas_height = max(min_canvas_height, total_text_height + padding * 2)

        
        if image_path:
            orig_img = Image.open(image_path).convert("RGBA")
            src_w, src_h = orig_img.size
            if src_w and src_h:
                scale = max(canvas_width / src_w, canvas_height / src_h)
                new_w = max(1, int(src_w * scale))
                new_h = max(1, int(src_h * scale))
                resized = orig_img.resize((new_w, new_h), Image.LANCZOS)
                left = max(0, (new_w - canvas_width) // 2)
                top = max(0, (new_h - canvas_height) // 2)
                cropped = resized.crop((left, top, left + canvas_width, top + canvas_height))
            else:
                cropped = orig_img.resize((canvas_width, canvas_height), Image.LANCZOS)

            # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –≤–∞—Ä–∏–∞–Ω—Ç "–±–µ–∑ —ç—Ñ—Ñ–µ–∫—Ç–∞", –∏—Å–ø–æ–ª—å–∑—É–µ–º —á—ë—Ä–Ω—ã–π —Ñ–æ–Ω
            if bg_effect == 0:
                canvas = Image.new("RGB", (canvas_width, canvas_height), (0, 0, 0))
            else:
                effects = {
                    1: lambda img: img.filter(ImageFilter.GaussianBlur(24)),
                    2: lambda img: img.filter(ImageFilter.SHARPEN),
                    3: lambda img: img.filter(ImageFilter.SMOOTH_MORE),
                    4: lambda img: img.filter(ImageFilter.EDGE_ENHANCE_MORE),
                    5: lambda img: img.filter(ImageFilter.EMBOSS),
                    6: lambda img: img.filter(ImageFilter.CONTOUR),
                    7: lambda img: img.filter(ImageFilter.DETAIL),
                }
                bg = effects.get(bg_effect, effects[1])(cropped)
                overlay = Image.new("RGBA", (canvas_width, canvas_height), (0, 0, 0, 160))
                bg = Image.alpha_composite(bg, overlay)
                canvas = bg.convert("RGB")
        else:
            canvas = Image.new("RGB", (canvas_width, canvas_height), (0, 0, 0))

        draw = ImageDraw.Draw(canvas)

        img = None
        img_height = img_width
        if image_path:
            orig_img = Image.open(image_path).convert("RGBA")
            orig_w, orig_h = orig_img.size
            if layout_vertical:
                # Keep avatar circle to img_width size
                scale_factor = img_width / max(1, max(orig_w, orig_h))
                target_size = (img_width, img_width)
                img = orig_img.resize(target_size, Image.LANCZOS)
                img_height = img_width
            else:
                scale_factor = img_width / orig_w
                img_height = int(orig_h * scale_factor)
                img = orig_img.resize((img_width, img_height))
            mask = Image.new("L", (img_width, img_height), 0)
            mask_draw = ImageDraw.Draw(mask)
            mask_draw.ellipse((0, 0, img_width, img_height), fill=255)
            img.putalpha(mask)
        else:
            img = Image.new("RGBA", (img_width, img_width), (0, 0, 0, 0))
            circle_draw = ImageDraw.Draw(img)
            rnd_color = tuple(random.randint(100, 255) for _ in range(3))
            circle_draw.ellipse((0, 0, img_width, img_width), fill=rnd_color)
            letter_font = ImageFont.truetype(font_path, int(img_width * 0.4))
            letter = author.strip()[0].upper() if author.strip() else "?"
            bbox = circle_draw.textbbox((0, 0), letter, font=letter_font)
            w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
            circle_draw.text(
                ((img_width - w) // 2, (img_width - h) // 2),
                letter,
                font=letter_font,
                fill=(255, 255, 255)
            )
            img_height = img_width

        if layout_vertical:
            img_pos = ((canvas_width - img_width) // 2, padding)
            canvas.paste(img, img_pos, img)
            text_x = (canvas_width - quote_size[0]) // 2
            text_y = img_pos[1] + img_height + padding
            draw.multiline_text((text_x, text_y), wrapped_quote, font=quote_font, fill=(255, 255, 255), align="center")
            author_x = (canvas_width - author_size[0]) // 2
            author_y = text_y + quote_size[1] + 20 
            draw.multiline_text((author_x, author_y), author_wrapped, font=author_font, fill=(180, 180, 180), align="center")
        else:
            img_pos = (padding, (canvas_height - img_height) // 2)
            canvas.paste(img, img_pos, img)
            text_x = img_pos[0] + img_width + padding
            total_text_height = quote_size[1] + author_size[1] + 15
            text_y = (canvas_height - total_text_height) // 2
            draw.multiline_text((text_x, text_y), wrapped_quote, font=quote_font, fill=(255, 255, 255))
            draw.multiline_text((text_x, text_y + quote_size[1] + 10), author_wrapped, font=author_font, fill=(180, 180, 180))

        canvas.save(output_path)
        self._send_quote(output_path)
        
    def _send_quote(self, output_path):
        send_helper = get_send_messages_helper()
        photo = send_helper.generatePhotoSizes(output_path, None)
        
        params = {
            "message": None,
            "peer": self.params.peer
        }
        
        params["photo"] = photo
        params["path"] = output_path
        
        params["replyToMsg"] = self.params.replyToMsg
        params["replyToTopMsg"] = self.params.replyToTopMsg
        
        send_message(params)
        
    def _wrap_text(self, draw, text, font, max_width):
        lines = []
        words = text.split()
        while words:
            line_words = []
            while words:
                line_words.append(words.pop(0))
                test_text = " ".join(line_words + words[:1])
                bbox = draw.textbbox((0, 0), test_text, font=font)
                w = bbox[2] - bbox[0]
                if w > max_width:
                    break
            lines.append(" ".join(line_words))
        return "\n".join(lines)

    def _wrap_text_fixed(self, draw, text, font, max_width):
        char_w = max(1, int(draw.textlength("M", font=font)))
        max_chars = max(1, int(max_width // char_w))
        result_lines = []
        for src_line in text.split("\n"):
            s = src_line
            while len(s) > max_chars:
                cut = max_chars
                space_idx = s.rfind(" ", 0, max_chars)
                if space_idx >= 0 and space_idx > 0:
                    cut = space_idx
                result_lines.append(s[:cut].rstrip())
                s = s[cut:].lstrip()
            result_lines.append(s)
        return "\n".join(result_lines)

    def _wrap_text_by_char_count(self, text, max_chars_per_line):
        lines = []
        for src_line in text.split("\n"):
            s = src_line
            while len(s) > max_chars_per_line:
                cut = max_chars_per_line
                space_idx = s.rfind(" ", 0, max_chars_per_line)
                if space_idx >= 0 and space_idx > 0:
                    cut = space_idx
                lines.append(s[:cut].rstrip())
                s = s[cut:].lstrip()
            lines.append(s)
        return "\n".join(lines)

class FontManager:
    fonts = []
    custom_font_url = ""
    custom_font_path = None
    last_custom_url = None
    @staticmethod
    def init():
        FontManager.fonts = [
            Font("Hack", "https://github.com/source-foundry/Hack/raw/refs/heads/master/build/ttf/Hack-Bold.ttf"),
            Font("Zpix", "https://github.com/Ar4ikTrirtyFour/windose20/raw/refs/heads/main/fonts/zpix.ttf"),
            Font("Times New Roman", "https://github.com/misuchiru03/font-times-new-roman/raw/refs/heads/master/Times%20New%20Roman.ttf"),
            Font("–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç", None)
        ]
        threading.Thread(target=FontManager._download_fonts, daemon=True).start()
                
    @staticmethod
    def _download_fonts():
        for font in FontManager.fonts:
            if font.download_uri and not font.exists():
                font.download()
    @staticmethod
    def get(index):
        if index == 3:  
            url = (FontManager.custom_font_url or "").strip()
            if not url:
                return FontManager.fonts[0]  # fallback
            temp_dir = Filesystem.get_temp_dir()
            font_path = Filesystem.get_absolute_path(temp_dir, "custom_font.ttf")
            need_download = (not os.path.exists(font_path)) or (FontManager.last_custom_url != url)
            if need_download:
                try:
                    response = requests.get(url, timeout=15)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                    FontManager.last_custom_url = url
                except Exception as e:
                    DebugLogger.make_log(f"custom font download failed: {e}")
                    return FontManager.fonts[0]
            FontManager.custom_font_path = font_path
            return Font("–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç", None, custom_path=font_path)
        return FontManager.fonts[index]
    
    @staticmethod
    def get_fonts_names():
        fonts = []
        for font in FontManager.fonts:
            fonts.append(font.name)
        return fonts

class Font:
    def __init__(self, name, download_uri, custom_path=None):
        self.name = name
        self.download_uri = download_uri
        self.custom_path = custom_path
        
    def get_path(self):
        if self.custom_path:
            return self.custom_path
        temp_dir = Filesystem.get_temp_dir()
        file_name = self.name + "." + self.get_type()
        return Filesystem.get_absolute_path(temp_dir, file_name)
    
    def get_type(self):
        if self.download_uri:
            return self.download_uri.split(".")[-1]
        return "ttf"
    
    def exists(self):
        return os.path.exists(self.get_path())
        
    def download(self):
        if self.exists() or not self.download_uri:
            return
        font_path = self.get_path()
        response = requests.get(self.download_uri)
        with open(font_path, 'wb') as file:
            file.write(response.content)