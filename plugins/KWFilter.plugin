import re
import json
import time
from typing import Any, List, Dict
from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, MethodHook, HookResult, HookStrategy
from hook_utils import find_class
from client_utils import get_last_fragment, get_user_config
from ui.settings import Header, Switch, Text, Divider
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper

__id__ = "KWFilter"
__name__ = "Keyword Message Filter"
__description__ = "Hiding messages by keywords"
__author__ = "@NCRCPlugins"
__version__ = "1.0.0"
__icon__ = "NCRCPlugins/0"
__min_version__ = "11.12.0"


class DebugLog:
    _logs: List[str] = []
    _max = 500
    
    @classmethod
    def add(cls, msg: str):
        ts = time.strftime("%H:%M:%S")
        entry = f"[{ts}] {msg}"
        cls._logs.append(entry)
        if len(cls._logs) > cls._max:
            cls._logs.pop(0)
        log(f"[KWFilter] {msg}")
    
    @classmethod
    def get_all(cls) -> str:
        return "\n".join(cls._logs)
    
    @classmethod
    def clear(cls):
        cls._logs.clear()


class MessageCellHook(MethodHook):
    def __init__(self, plugin: 'KeywordFilterPlugin'):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        pass
    
    def after_hooked_method(self, param):
        if not self.plugin.filter_enabled or not self.plugin.compiled_patterns:
            return
        
        try:
            cell = param.thisObject
            msg_obj = param.args[0] if param.args else None
            if msg_obj is None:
                return
            
            # Get message ID and group ID for cache
            msg_id = self._get_msg_id(msg_obj)
            group_id = self._get_group_id(msg_obj)
            
            # Log message type for debugging
            cell_class = cell.getClass().getSimpleName() if cell else "Unknown"
            is_group = group_id is not None and group_id != 0
            
            # Check cache - use group_id if available
            cache_key = f"g{group_id}" if is_group else msg_id
            if cache_key is not None:
                cache_result = self.plugin.get_cached_result(cache_key)
                if cache_result is not None:
                    if cache_result:
                        DebugLog.add(f"Cache hit (hide): {cache_key}, cell={cell_class}")
                        self._hide_cell(cell)
                    return
            
            # Skip own messages
            if not self.plugin.filter_own_messages:
                if self._is_own_message(msg_obj):
                    if cache_key is not None:
                        self.plugin.cache_result(cache_key, False)
                    return
            
            # Check text
            text = self._extract_text(msg_obj)
            should_hide = bool(text and self.plugin.matches_filter(text))
            
            # Cache result
            if cache_key is not None:
                self.plugin.cache_result(cache_key, should_hide)
            
            if should_hide:
                DebugLog.add(f"Hiding: id={msg_id}, group={group_id}, cell={cell_class}, text={text[:30]}...")
                self._hide_cell(cell)
                
        except Exception as e:
            DebugLog.add(f"Hook err: {e}")
    
    def _get_msg_id(self, msg_obj):
        try:
            if hasattr(msg_obj, 'getId'):
                return msg_obj.getId()
            if hasattr(msg_obj, 'messageOwner') and msg_obj.messageOwner:
                return msg_obj.messageOwner.id
        except:
            pass
        return None
    
    def _get_group_id(self, msg_obj):
        #Get media group ID for albums
        try:
            if hasattr(msg_obj, 'messageOwner') and msg_obj.messageOwner:
                owner = msg_obj.messageOwner
                # grouped_id is used for media albums
                if hasattr(owner, 'grouped_id'):
                    return owner.grouped_id
            if hasattr(msg_obj, 'getGroupId'):
                return msg_obj.getGroupId()
        except:
            pass
        return None
    
    def _is_own_message(self, msg_obj) -> bool:
        try:
            if hasattr(msg_obj, 'isOutOwner'):
                return msg_obj.isOutOwner()
            if hasattr(msg_obj, 'messageOwner') and msg_obj.messageOwner:
                return getattr(msg_obj.messageOwner, 'out', False)
        except:
            pass
        return False
    
    def _extract_text(self, msg_obj) -> str:
        parts = []
        
        try:
            if hasattr(msg_obj, 'messageOwner') and msg_obj.messageOwner:
                owner = msg_obj.messageOwner
                if hasattr(owner, 'message') and owner.message:
                    parts.append(str(owner.message))
        except:
            pass
        
        try:
            if hasattr(msg_obj, 'messageText') and msg_obj.messageText:
                parts.append(str(msg_obj.messageText))
        except:
            pass
        
        try:
            if hasattr(msg_obj, 'caption') and msg_obj.caption:
                parts.append(str(msg_obj.caption))
        except:
            pass
        
        return " ".join(parts)
    
    def _hide_cell(self, cell):
        try:
            def do_hide():
                try:
                    current_height = cell.getMeasuredHeight()
                    if current_height <= 0:
                        current_height = cell.getHeight()
                    
                    cell.setAlpha(0.0)
                    cell.setVisibility(8)
                    
                    lp = cell.getLayoutParams()
                    if lp:
                        lp.height = 0
                        try:
                            if current_height > 0:
                                lp.bottomMargin = -current_height
                            else:
                                lp.bottomMargin = -200
                        except:
                            pass
                        try:
                            lp.topMargin = 0
                        except:
                            pass
                        cell.setLayoutParams(lp)
                    
                    try:
                        cell.setMinimumHeight(0)
                    except:
                        pass
                    
                    try:
                        cell.setPadding(0, 0, 0, 0)
                    except:
                        pass
                    
                    try:
                        cell.setTranslationY(-10000)
                    except:
                        pass
                    
                    cell.requestLayout()
                    
                    try:
                        parent = cell.getParent()
                        if parent:
                            parent.requestLayout()
                            try:
                                parent.invalidateItemDecorations()
                            except:
                                pass
                    except:
                        pass
                except Exception as e:
                    DebugLog.add(f"Hide err: {e}")
            
            run_on_ui_thread(do_hide)
        except Exception as e:
            DebugLog.add(f"Hide outer err: {e}")


class KeywordFilterPlugin(BasePlugin):
    CACHE_MAX_SIZE = 1000
    
    def __init__(self):
        super().__init__()
        self.keywords: List[str] = []
        self.compiled_patterns: List[re.Pattern] = []
        self.filter_enabled: bool = True
        self.filter_own_messages: bool = False
        self.case_insensitive: bool = True
        self.use_regex: bool = False
        self._hooks_applied: bool = False
        self._cache: Dict[Any, bool] = {}
    
    def on_plugin_load(self):
        DebugLog.add("Loading...")
        self._load_settings()
        self._load_keywords()
        self._apply_hooks()
        DebugLog.add(f"Loaded: {len(self.keywords)} keywords")
    
    def on_plugin_unload(self):
        self._cache.clear()
        DebugLog.add("Unloaded")
    
    def get_cached_result(self, key):
        return self._cache.get(key)
    
    def cache_result(self, key, should_hide: bool):
        if len(self._cache) > self.CACHE_MAX_SIZE:
            keys = list(self._cache.keys())[:200]
            for k in keys:
                del self._cache[k]
        self._cache[key] = should_hide
    
    def clear_cache(self):
        self._cache.clear()
    
    def _load_settings(self):
        self.filter_enabled = self.get_setting("filter_enabled", True)
        self.filter_own_messages = self.get_setting("filter_own_messages", False)
        self.case_insensitive = self.get_setting("case_insensitive", True)
        self.use_regex = self.get_setting("use_regex", False)
    
    def _load_keywords(self):
        try:
            kw_json = self.get_setting("keywords_list", "[]")
            self.keywords = json.loads(kw_json)
            if not isinstance(self.keywords, list):
                self.keywords = []
        except:
            self.keywords = []
        self._compile_patterns()
    
    def _save_keywords(self):
        try:
            self.set_setting("keywords_list", json.dumps(self.keywords, ensure_ascii=False))
        except:
            pass
    
    def _compile_patterns(self):
        self.compiled_patterns = []
        if not self.keywords:
            self.clear_cache()
            return 0
        
        flags = re.IGNORECASE if self.case_insensitive else 0
        errors = 0
        
        for kw in self.keywords:
            if not kw:
                continue
            try:
                pattern = kw if self.use_regex else re.escape(kw)
                self.compiled_patterns.append(re.compile(pattern, flags))
            except re.error:
                errors += 1
        
        self.clear_cache()
        DebugLog.add(f"Compiled {len(self.compiled_patterns)} patterns")
        return errors
    
    def matches_filter(self, text: str) -> bool:
        if not text:
            return False
        for pattern in self.compiled_patterns:
            if pattern.search(text):
                return True
        return False
    
    def _apply_hooks(self):
        DebugLog.add("Applying hooks...")
        
        CellClass = find_class("org.telegram.ui.Cells.ChatMessageCell")
        if not CellClass:
            DebugLog.add("ChatMessageCell not found!")
            return
        
        try:
            hook = MessageCellHook(self)
            unhook_list = self.hook_all_methods(CellClass, "setMessageObject", hook)
            if unhook_list:
                self._hooks_applied = True
                DebugLog.add(f"Hooked {len(unhook_list)} setMessageObject methods")
            else:
                DebugLog.add("No setMessageObject hooked")
        except Exception as e:
            DebugLog.add(f"Hook failed: {e}")
    
    def on_update_hook(self, update_name: str, account: int, update: Any) -> HookResult:
        if not self.filter_enabled or not self.compiled_patterns:
            return HookResult()
        
        if update_name == "TL_updateNewMessage":
            try:
                message = update.message
                
                if not self.filter_own_messages:
                    if getattr(message, 'out', False):
                        return HookResult()
                
                text = getattr(message, 'message', '')
                if text and self.matches_filter(text):
                    DebugLog.add(f"API blocked: {text[:30]}...")
                    return HookResult(strategy=HookStrategy.CANCEL)
            except:
                pass
        
        return HookResult()
    
    def add_keyword(self, keyword: str) -> bool:
        keyword = keyword.strip()
        if not keyword or keyword in self.keywords:
            return False
        self.keywords.append(keyword)
        self._save_keywords()
        self._compile_patterns()
        DebugLog.add(f"Added: {keyword}")
        return True
    
    def remove_keyword(self, keyword: str) -> bool:
        if keyword in self.keywords:
            self.keywords.remove(keyword)
            self._save_keywords()
            self._compile_patterns()
            DebugLog.add(f"Removed: {keyword}")
            return True
        return False
    
    def refresh_filters(self):
        self._load_settings()
        self._load_keywords()
        DebugLog.add("Refreshed")
    
    def _show_add_dialog(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            activity = fragment.getParentActivity()
            if not activity:
                return
            
            from android.widget import EditText as AndroidEditText
            from android.text import InputType
            
            input_field = AndroidEditText(activity)
            input_field.setHint("Keyword or regex")
            input_field.setInputType(InputType.TYPE_CLASS_TEXT)
            
            builder = AlertDialogBuilder(activity)
            builder.set_title("Add Keyword")
            builder.set_view(input_field)
            builder.set_positive_button("Add", lambda d, w: self._on_add(input_field))
            builder.set_negative_button("Cancel", None)
            run_on_ui_thread(lambda: builder.show())
        except Exception as e:
            DebugLog.add(f"Dialog err: {e}")
    
    def _on_add(self, input_field):
        try:
            text = str(input_field.getText())
            if self.add_keyword(text):
                BulletinHelper.show_success(f"Added: {text}")
            else:
                BulletinHelper.show_error("Already exists or empty")
        except:
            pass
    
    def _show_keywords_list(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            activity = fragment.getParentActivity()
            if not activity:
                return
            
            if not self.keywords:
                BulletinHelper.show_info("No keywords")
                return
            
            items = self.keywords.copy()
            builder = AlertDialogBuilder(activity)
            builder.set_title(f"Keywords ({len(items)})")
            builder.set_items(items, lambda d, w: self._confirm_delete(items[w]))
            builder.set_negative_button("Close", None)
            run_on_ui_thread(lambda: builder.show())
        except:
            pass
    
    def _confirm_delete(self, keyword: str):
        try:
            fragment = get_last_fragment()
            if not fragment:
                self.remove_keyword(keyword)
                return
            activity = fragment.getParentActivity()
            if not activity:
                self.remove_keyword(keyword)
                return
            
            builder = AlertDialogBuilder(activity)
            builder.set_title("Delete")
            builder.set_message(f"Delete '{keyword}'?")
            builder.set_positive_button("Delete", lambda d, w: self._do_delete(keyword))
            builder.set_negative_button("Cancel", None)
            run_on_ui_thread(lambda: builder.show())
        except:
            self.remove_keyword(keyword)
    
    def _do_delete(self, keyword: str):
        if self.remove_keyword(keyword):
            BulletinHelper.show_success(f"Deleted: {keyword}")
    
    def _refresh_and_notify(self):
        self.refresh_filters()
        errors = self._compile_patterns()
        if errors > 0:
            BulletinHelper.show_error(f"Refreshed with {errors} errors")
        else:
            BulletinHelper.show_success(f"Refreshed: {len(self.compiled_patterns)} filters")
    
    def _show_status(self):
        kw_list = "\n".join(f"- {k}" for k in self.keywords[:10])
        if len(self.keywords) > 10:
            kw_list += f"\n... +{len(self.keywords) - 10} more"
        
        status = f"""Filter: {'ON' if self.filter_enabled else 'OFF'}
Keywords: {len(self.keywords)}
Cache: {len(self._cache)}
Hooks: {'Yes' if self._hooks_applied else 'No'}

{kw_list if kw_list else 'No keywords'}"""
        
        self._alert("Status", status)
    
    def _copy_to_clipboard(self, text: str):
        try:
            from android.content import Context
            fragment = get_last_fragment()
            if fragment:
                activity = fragment.getParentActivity()
                if activity:
                    clipboard = activity.getSystemService(Context.CLIPBOARD_SERVICE)
                    from android.content import ClipData
                    clip = ClipData.newPlainText("logs", text)
                    clipboard.setPrimaryClip(clip)
                    BulletinHelper.show_success("Copied to clipboard")
        except Exception as e:
            DebugLog.add(f"Copy err: {e}")
    
    def _export_logs(self):
        logs = DebugLog.get_all()
        if not logs:
            BulletinHelper.show_info("No logs yet")
            return
        
        try:
            fragment = get_last_fragment()
            if fragment:
                activity = fragment.getParentActivity()
                if activity:
                    builder = AlertDialogBuilder(activity)
                    builder.set_title("Debug Logs")
                    builder.set_message(logs[-5000:] if len(logs) > 5000 else logs)
                    builder.set_positive_button("Copy", lambda d, w: self._copy_to_clipboard(logs))
                    builder.set_negative_button("Close", None)
                    builder.set_neutral_button("Clear", lambda d, w: self._clear_logs())
                    run_on_ui_thread(lambda: builder.show())
        except:
            pass
    
    def _clear_logs(self):
        DebugLog.clear()
        BulletinHelper.show_success("Logs cleared")
    
    def create_settings(self) -> List[Any]:
        return [
            Header(text="Message Filter"),
            
            Switch(
                key="filter_enabled",
                text="Enable filtering",
                default=True,
                subtext="Hide messages with keywords",
                icon="msg_block2",
                on_change=lambda v: setattr(self, 'filter_enabled', v)
            ),
            
            Divider(),
            Header(text="Keywords"),
            
            Text(
                text="Add keyword",
                icon="msg_addbot",
                on_click=lambda v: self._show_add_dialog()
            ),
            
            Text(
                text="View/Delete keywords",
                icon="msg_list",
                on_click=lambda v: self._show_keywords_list()
            ),
            
            Text(
                text="Refresh filters",
                icon="msg_retry",
                accent=True,
                on_click=lambda v: self._refresh_and_notify()
            ),
            
            Divider(text="Options"),
            
            Switch(
                key="filter_own_messages",
                text="Filter own messages",
                default=False,
                subtext="Also hide your own messages",
                icon="msg_openprofile",
                on_change=lambda v: setattr(self, 'filter_own_messages', v)
            ),
            
            Switch(
                key="case_insensitive",
                text="Ignore case",
                default=True,
                subtext="Case insensitive matching",
                icon="msg_edit",
                on_change=lambda v: self._update_opt("case_insensitive", v)
            ),
            
            Switch(
                key="use_regex",
                text="Enable regex",
                default=False,
                subtext="Use regular expressions",
                icon="msg_link",
                on_change=lambda v: self._update_opt("use_regex", v)
            ),
            
            Divider(text="Debug"),
            
            Text(
                text="Status",
                icon="msg_info",
                on_click=lambda v: self._show_status()
            ),
            
            Text(
                text="Export logs",
                icon="msg_log",
                on_click=lambda v: self._export_logs()
            ),
            
            Text(
                text="Clear cache",
                icon="msg_clear",
                on_click=lambda v: self._clear_cache_notify()
            ),
            
            Divider(),
            
            Text(
                text="Clear all keywords",
                icon="msg_delete",
                red=True,
                on_click=lambda v: self._confirm_clear()
            ),
            
            Divider(text=f"Version {__version__} / vibe-coded by NCRC")
        ]
    
    def _update_opt(self, key: str, value: bool):
        setattr(self, key, value)
        self._compile_patterns()
        BulletinHelper.show_success("Settings updated")
    
    def _clear_cache_notify(self):
        self.clear_cache()
        BulletinHelper.show_success("Cache cleared")
    
    def _confirm_clear(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                self._clear_all()
                return
            activity = fragment.getParentActivity()
            if not activity:
                self._clear_all()
                return
            
            builder = AlertDialogBuilder(activity)
            builder.set_title("Clear All")
            builder.set_message(f"Delete {len(self.keywords)} keywords?")
            builder.set_positive_button("Clear", lambda d, w: self._clear_all())
            builder.set_negative_button("Cancel", None)
            run_on_ui_thread(lambda: builder.show())
        except:
            self._clear_all()
    
    def _clear_all(self):
        self.keywords = []
        self._save_keywords()
        self._compile_patterns()
        BulletinHelper.show_success("All keywords cleared")
    
    def _alert(self, title: str, message: str):
        try:
            fragment = get_last_fragment()
            if fragment:
                activity = fragment.getParentActivity()
                if activity:
                    builder = AlertDialogBuilder(activity)
                    builder.set_title(title)
                    builder.set_message(message)
                    builder.set_positive_button("OK", None)
                    run_on_ui_thread(lambda: builder.show())
        except:
            pass
