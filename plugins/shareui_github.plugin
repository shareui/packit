import requests
import threading
from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Switch, Selector
from java.util import Locale
from org.telegram.tgnet import TLRPC
from client_utils import run_on_queue, send_message
from android_utils import run_on_ui_thread
from ui.bulletin import BulletinHelper
from client_utils import get_last_fragment

# над каждой функцией поставлен комментарии 
# что бы улучшить читабельность кода.

# License: apache 2.0 copyright @shareui
# нарушение будет снесено через dmca@telegram.org

__id__ = "shareui_github"
__name__ = "GitHub utilities"
__version__ = "1.4.3"
__author__ = "@shrdevv"
__description__ = """Ищет ресурсы на GitHub.com
Команды:
    .gitsrc - ищет репозитории
    .gituser - ищет аккаунты
    .gitorg - ищет организации"""
__min_version__ = "11.12.1"
__icon__ = "plugin232/10"

GITHUB_API_URL = "https://api.github.com"

class Locales:
    ru = {
        "USAGE_SRC": "Пример: .gitsrc exteraGram",
        "USAGE_USER": "Пример: .gituser torvalds",
        "USAGE_ORG": "Пример: .gitorg exteragram",
        "NOT_FOUND": "Ничего не найдено :(",
        "ERROR": "Ошибка при поиске: ",
        "SETTINGS_TITLE": "Настройки GitHub Search",
        "SETTINGS_SHOW_ORGS": "Показывать организации пользователя",
        "SETTINGS_SHOW_ORGS_SUB": "Включает/отключает отображение организаций в .gituser",
        "SEARCHING": "Идет поиск на GitHub...",
        "SETTINGS_REPO_SORT": "Сортировка репо",
        "SETTINGS_REPO_SORT_ITEMS_DATE": "По дате обновления",
        "SETTINGS_REPO_SORT_ITEMS_STARS": "По звездам",
        "SUBSCRIBE_MESSAGE": "Подпишись на @shrdevv"
    }
    en = {
        "USAGE_SRC": "Usage: .gitsrc exteraGram",
        "USAGE_USER": "Usage: .gituser torvalds",
        "USAGE_ORG": "Usage: .gitorg exteragram",
        "NOT_FOUND": "Nothing found :(",
        "ERROR": "Search error: ",
        "SETTINGS_TITLE": "GitHub Search Settings",
        "SETTINGS_SHOW_ORGS": "Show user organizations",
        "SETTINGS_SHOW_ORGS_SUB": "Enable/disable displaying organizations in .gituser",
        "SEARCHING": "Searching on GitHub...",
        "SETTINGS_REPO_SORT": "Repo Sorting",
        "SETTINGS_REPO_SORT_ITEMS_DATE": "By update date",
        "SETTINGS_REPO_SORT_ITEMS_STARS": "By stars",
        "SUBSCRIBE_MESSAGE": "Subscribe to @shrdevv"
    }
    default = en

# эта функция возвращает локализацию по умолчанию
def get_locale_pg():
    lang = Locale.getDefault().getLanguage()
    return getattr(Locales, lang, Locales.default)

class GitHubSearchPlugin(BasePlugin):
    # эта функция срабатывает при загрузке плагина
    def on_plugin_load(self):
        self.add_on_send_message_hook()

    # эта функция создаёт настройки плагина
    def create_settings(self):
        loc = get_locale_pg()
        return [
            Header(loc["SETTINGS_TITLE"]),
            Divider(),
            Switch(
                key="show_organizations",
                text=loc["SETTINGS_SHOW_ORGS"],
                subtext=loc["SETTINGS_SHOW_ORGS_SUB"],
                default=True,
                icon="msg_contacts"
            ),
            Selector(
                key="repo_sort_order",
                text=loc["SETTINGS_REPO_SORT"],
                items=[loc["SETTINGS_REPO_SORT_ITEMS_DATE"], loc["SETTINGS_REPO_SORT_ITEMS_STARS"]],
                default=0,
                icon="tabs_reorder_solar"
            ),
            Divider(text=loc["SUBSCRIBE_MESSAGE"])
        ]

    # эта функция обрабатывает команды отправленных сообщений
    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()
        msg = params.message.strip()
        loc = get_locale_pg()
        command_map = {
            ".gitsrc": ("repo", 7, loc["USAGE_SRC"]),
            ".gituser": ("user", 9, loc["USAGE_USER"]),
            ".gitorg": ("org", 8, loc["USAGE_ORG"])
        }
        for cmd, (search_type, length, usage_msg) in command_map.items():
            if msg.lower().startswith(cmd):
                query = msg[length:].strip()
                if not query:
                    send_message({"peer": params.peer, "message": usage_msg, "replyToMsg": getattr(params, "replyToMsg", None)})
                    return HookResult(strategy=HookStrategy.CANCEL)
                run_on_ui_thread(lambda: BulletinHelper.show_info(loc["SEARCHING"], get_last_fragment()))
                run_on_queue(lambda: self._process_search_request(params, query, search_type))
                return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()

    # эта функция запускает поиск в зависимости от типа
    def _process_search_request(self, params, query, search_type):
        if search_type == "repo":
            result = self.search_github(query, users=False, repos=True)
        elif search_type == "user":
            result = self.search_github(query, users=True, repos=False)
        elif search_type == "org":
            result = self.search_github_org(query)
        else:
            return
        run_on_ui_thread(lambda: self._send_search_result(params, result))

    # эта функция отправляет результаты поиска в чат
    def _send_search_result(self, params, result):
        message_to_send = {
            "peer": params.peer,
            "replyToMsg": getattr(params, "replyToMsg", None)
        }
        if isinstance(result, dict):
            message_to_send["message"] = result.get("text", "...")
            message_to_send["entities"] = result.get("entities", [])
        else:
            message_to_send["message"] = str(result)
        send_message(message_to_send)

    # эта функция возвращает заголовки для github api
    def _get_headers(self):
        pg_headers = {"Accept": "application/vnd.github.v3+json"}
        return pg_headers

    # эта функция форматирует дату в удобный вид
    def _format_date(self, date_str):
        from datetime import datetime
        if not date_str:
            return "N/A"
        try:
            dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
            return dt.strftime('%d.%m.%Y')
        except:
            return date_str[:10]

    # эта функция ищет репозитории или пользователей на github
    def search_github(self, query, users=False, repos=False):
        loc = get_locale_pg()
        headers = self._get_headers()
        try:
            if repos:
                r = requests.get(f"{GITHUB_API_URL}/search/repositories", params={"q": query}, headers=headers, timeout=10)
                if r.status_code == 200 and r.json().get("items"):
                    repo = r.json()["items"][0]
                    name, url = repo.get('full_name', ''), repo.get('html_url', '')
                    owner = repo.get('owner', {})
                    owner_login, owner_url, owner_type = owner.get('login', ''), owner.get('html_url', ''), owner.get('type', '')
                    stars, forks = repo.get('stargazers_count', 0), repo.get('forks_count', 0)
                    issues = repo.get('open_issues_count', 0)
                    updated_str = self._format_date(repo.get('updated_at', ''))
                    author_type_str = "Organization" if owner_type == "Organization" else "Author"
                    message_text = f"[{name}]\n{author_type_str}: [{owner_login}]\nLast update: {updated_str}\nStars: {stars}★\nForks: {forks}\nIssues: {issues}"
                    entities = []
                    repo_entity_pg = TLRPC.TL_messageEntityTextUrl()
                    repo_entity_pg.offset = 1
                    repo_entity_pg.length = len(name.encode('utf_16_le')) // 2
                    repo_entity_pg.url = url
                    entities.append(repo_entity_pg)
                    author_start = message_text.find(f"[{owner_login}]")
                    author_entity_pg = TLRPC.TL_messageEntityTextUrl()
                    author_entity_pg.offset = len(message_text[:author_start + 1].encode('utf_16_le')) // 2
                    author_entity_pg.length = len(owner_login.encode('utf_16_le')) // 2
                    author_entity_pg.url = owner_url
                    entities.append(author_entity_pg)
                    return {"text": message_text, "entities": entities}
            if users:
                r = requests.get(f"{GITHUB_API_URL}/search/users", params={"q": query}, headers=headers, timeout=10)
                if r.status_code == 200 and r.json().get("items"):
                    user_login = r.json()["items"][0].get('login', '')
                    user_profile_resp = requests.get(f"{GITHUB_API_URL}/users/{user_login}", headers=headers, timeout=10)
                    if user_profile_resp.status_code == 200:
                        profile = user_profile_resp.json()
                        login, url = profile.get('login', ''), profile.get('html_url', '')
                        desc = profile.get('bio', '') or ''
                        message_text = f"[{login}]\n"
                        entities = []
                        username_entity_pg = TLRPC.TL_messageEntityTextUrl()
                        username_entity_pg.offset = 1
                        username_entity_pg.length = len(login.encode('utf_16_le')) // 2
                        username_entity_pg.url = url
                        entities.append(username_entity_pg)
                        if desc:
                            message_text += f"> {desc}\n\n"
                        show_orgs_pg_setting = self.get_setting("show_organizations", True)
                        if show_orgs_pg_setting:
                            orgs_resp = requests.get(f"{GITHUB_API_URL}/users/{login}/orgs", headers=headers, timeout=10)
                            if orgs_resp.status_code == 200 and orgs_resp.json():
                                message_text += "Organizations:\n"
                                for org in orgs_resp.json():
                                    org_name = org.get('login', '')
                                    if not org_name:
                                        continue
                                    org_url = f"https://github.com/{org_name}"
                                    pg_org_start_char_pos = len(message_text)
                                    message_text += f"[{org_name}]\n"
                                    org_entity_pg = TLRPC.TL_messageEntityTextUrl()
                                    org_entity_pg.offset = len(message_text[:pg_org_start_char_pos + 1].encode('utf_16_le')) // 2
                                    org_entity_pg.length = len(org_name.encode('utf_16_le')) // 2
                                    org_entity_pg.url = org_url
                                    entities.append(org_entity_pg)
                                message_text += "\n"
                        message_text += "Repositories:\n"
                        sort_order_pg = self.get_setting("repo_sort_order", 0)
                        pg_repo_list = []
                        if sort_order_pg == 1:
                            repos_resp = requests.get(f"{GITHUB_API_URL}/search/repositories", headers=headers, timeout=10, params={"q": f"user:{login}", "sort": "stars", "order": "desc", "per_page": 5})
                            if repos_resp.status_code == 200 and repos_resp.json().get("items"):
                                pg_repo_list = repos_resp.json().get("items")
                        else:
                            repos_resp = requests.get(f"{GITHUB_API_URL}/users/{login}/repos", headers=headers, timeout=10, params={"per_page": 5, "sort": "updated"})
                            if repos_resp.status_code == 200 and repos_resp.json():
                                pg_repo_list = repos_resp.json()
                        if pg_repo_list:
                            for repo in pg_repo_list:
                                repo_name, repo_url = repo.get('name', ''), repo.get('html_url', '')
                                stars = repo.get('stargazers_count', 0)
                                updated_str = self._format_date(repo.get('updated_at', ''))
                                pg_repo_start_char_pos = len(message_text)
                                message_text += f"[{repo_name}]\n[{stars}★] [{updated_str}]\n"
                                repo_entity_pg = TLRPC.TL_messageEntityTextUrl()
                                repo_entity_pg.offset = len(message_text[:pg_repo_start_char_pos + 1].encode('utf_16_le')) // 2
                                repo_entity_pg.length = len(repo_name.encode('utf_16_le')) // 2
                                repo_entity_pg.url = repo_url
                                entities.append(repo_entity_pg)
                        else:
                            message_text += f"{loc['NOT_FOUND']}\n"
                        return {"text": message_text.strip(), "entities": entities}
            return loc["NOT_FOUND"]
        except Exception as e:
            return loc["ERROR"] + str(e)

    # эта функция ищет организации на github
    def search_github_org(self, query):
        loc = get_locale_pg()
        headers = self._get_headers()
        try:
            r = requests.get(f"{GITHUB_API_URL}/orgs/{query}", headers=headers, timeout=10)
            if r.status_code != 200:
                return loc["NOT_FOUND"]
            org = r.json()
            login, url = org.get('login', ''), org.get('html_url', '')
            desc = org.get('description', '') or ''
            public_repos = org.get('public_repos', 0)
            location = org.get('location', '') or None
            followers = org.get('followers', 0)
            email = org.get('email', '') or None
            blog = org.get('blog', '') or None
            message_text = f"[{login}]\n"
            entities = []
            org_entity_pg = TLRPC.TL_messageEntityTextUrl()
            org_entity_pg.offset = 1
            org_entity_pg.length = len(login.encode('utf_16_le')) // 2
            org_entity_pg.url = url
            entities.append(org_entity_pg)
            if desc:
                message_text += f"> {desc}\n\n"
            message_text += f"Public repos: {public_repos}\n"
            if location:
                message_text += f"Location: {location}\n"
            if followers is not None:
                message_text += f"Followers: {followers}\n"
            if email:
                message_text += f"Mail: {email}\n"
            if blog:
                pg_blog_start_char_pos = len(message_text)
                message_text += "Blog: [link]\n"
                blog_entity_pg = TLRPC.TL_messageEntityTextUrl()
                blog_entity_pg.offset = len(message_text[:pg_blog_start_char_pos + len('Blog: [')].encode('utf_16_le')) // 2
                blog_entity_pg.length = len("link".encode('utf_16_le')) // 2
                blog_entity_pg.url = blog if blog.startswith('http') else 'http://' + blog
                entities.append(blog_entity_pg)
            sort_order_pg = self.get_setting("repo_sort_order", 0)
            pg_repo_list = []
            if sort_order_pg == 1:
                repos_resp = requests.get(f"{GITHUB_API_URL}/search/repositories", headers=headers, timeout=10, params={"q": f"org:{query}", "sort": "stars", "order": "desc", "per_page": 5})
                if repos_resp.status_code == 200 and repos_resp.json().get("items"):
                    pg_repo_list = repos_resp.json().get("items")
            else:
                repos_resp = requests.get(f"{GITHUB_API_URL}/orgs/{query}/repos", headers=headers, timeout=10, params={"per_page": 5, "sort": "updated"})
                if repos_resp.status_code == 200 and repos_resp.json():
                    pg_repo_list = repos_resp.json()
            if pg_repo_list:
                message_text += "\nTop repositories:\n"
                for repo in pg_repo_list:
                    repo_name, repo_url = repo.get('name', ''), repo.get('html_url', '')
                    stars = repo.get('stargazers_count', 0)
                    updated_str = self._format_date(repo.get('updated_at', ''))
                    pg_repo_start_char_pos = len(message_text)
                    message_text += f"[{repo_name}]\n[{stars}★] [{updated_str}]\n"
                    repo_entity_pg = TLRPC.TL_messageEntityTextUrl()
                    repo_entity_pg.offset = len(message_text[:pg_repo_start_char_pos + 1].encode('utf_16_le')) // 2
                    repo_entity_pg.length = len(repo_name.encode('utf_16_le')) // 2
                    repo_entity_pg.url = repo_url
                    entities.append(repo_entity_pg)
            return {"text": message_text.strip(), "entities": entities}
        except Exception as e:
            return loc["ERROR"] + str(e)