__id__ = "ex_tool"
__name__ = "Ex Tool"
__description__ = "–ù–µ–±–æ–ª—å—à–∏–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è Telegram –æ—Ç Ex"
__author__ = "@oxd5f & @explugin"
__version__ = "1.2"
__icon__ = "pyDevSticker/2"
__min_version__ = "11.12.0"

from base_plugin import BasePlugin, HookStrategy, MenuItemData, MenuItemType, HookResult, MethodHook, MethodReplacement
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment, get_messages_controller, run_on_queue
from ui.bulletin import BulletinHelper
from ui.settings import Header, Switch, Input, Selector
from org.telegram.ui import ChatActivity
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import MessagesController, UserConfig
from java.util import Locale, ArrayList
from java.lang import Integer, Long as JLong, Boolean as JBoolean
from markdown_utils import parse_markdown
import re
import json
import requests
from typing import Any, Dict, List
from hook_utils import find_class, get_private_field, set_private_field
from android_utils import log
from java import jclass, jint

TRANSLATION_MAPS = {
	"small_caps": {
		"–∞": "·¥Ä", "–±": " ô", "–≤": "·¥†", "–≥": "…¢", "–¥": "·¥Ö", "–µ": "·¥á", "—ë": "·¥áÃà",
		"–∂": "·¥ä", "–∑": "·¥¢", "–∏": "…™", "–π": "…™ÃÜ", "–∫": "·¥ã", "–ª": " ü", "–º": "·¥ç",
		"–Ω": "…¥", "–æ": "·¥è", "–ø": "·¥ò", "—Ä": " Ä", "—Å": "Íú±", "—Ç": "·¥õ", "—É": "·¥ú",
		"—Ñ": "Íú∞", "—Ö": "x", "—Ü": "·¥Ñ", "—á": "·¥Ñ ú", "—à": "Íú± ú", "—â": "Íú±·¥Ñ ú",
		"—ä": "—ä", "—ã": " è", "—å": "—å", "—ç": "·¥á", "—é": " è·¥ú", "—è": " è·¥Ä"
	},
	"fraktur": {
		"–∞": "ùñÜ", "–±": "ùñá", "–≤": "ùñõ", "–≥": "ùñå", "–¥": "ùñâ", "–µ": "ùñä", "—ë": "ùñäÃà",
		"–∂": "ùñè", "–∑": "ùñü", "–∏": "ùñé", "–π": "ùñéÃÜ", "–∫": "ùñê", "–ª": "ùñë", "–º": "ùñí",
		"–Ω": "ùñì", "–æ": "ùñî", "–ø": "ùñï", "—Ä": "ùñó", "—Å": "ùñò", "—Ç": "ùñô", "—É": "ùñö",
		"—Ñ": "ùñã", "—Ö": "ùñù", "—Ü": "ùñà", "—á": "ùñàùñç", "—à": "ùñòùñç", "—â": "ùñòùñàùñç",
		"—ä": "—ä", "—ã": "ùñû", "—å": "—å", "—ç": "ùñä", "—é": "ùñûùñö", "—è": "ùñûùñÜ"
	},
	"special": {
		"–∞": "√•", "–±": "√ü", "–≤": "v", "–≥": "g", "–¥": "√ê", "–µ": "√™", "—ë": "√™Ãà",
		"–∂": "j", "–∑": "z", "–∏": "√Ø", "–π": "√ØÃÜ", "–∫": "k", "–ª": "l", "–º": "m",
		"–Ω": "√±", "–æ": "√∞", "–ø": "√æ", "—Ä": "r", "—Å": "¬ß", "—Ç": "‚Ä†", "—É": "¬µ",
		"—Ñ": "¬£", "—Ö": "x", "—Ü": "¬¢", "—á": "¬¢h", "—à": "¬ßh", "—â": "¬ß¬¢h",
		"—ä": "—ä", "—ã": "¬•", "—å": "—å", "—ç": "√™", "—é": "¬•¬µ", "—è": "¬•√•"
	},
	"standard": {
		"–∞": "a", "–±": "b", "–≤": "v", "–≥": "g", "–¥": "d", "–µ": "e", "—ë": "e",
		"–∂": "j", "–∑": "z", "–∏": "i", "–π": "i", "–∫": "k", "–ª": "l", "–º": "m",
		"–Ω": "n", "–æ": "o", "–ø": "p", "—Ä": "r", "—Å": "s", "—Ç": "t", "—É": "u",
		"—Ñ": "f", "—Ö": "x", "—Ü": "c", "—á": "ch", "—à": "sh", "—â": "sch",
		"—ä": "—ä", "—ã": "y", "—å": "—å", "—ç": "e", "—é": "yu", "—è": "ya"
	}
}

LANGUAGE_PACKS = {
	"en": {
		"title": "Ex Tool",
		"auto_translate": "Auto translate",
		"auto_translate_subtext": "Russian ‚Üí Ex Tool alphabet style",
		"translate_menu": "Translate / restore original",
		"style_header": "Alphabet Style",
		"alphabet_style_type": "Alphabet type",
		"use_small_caps": "Small Caps (·¥Ä ô·¥Ñ)",
		"use_fraktur": "Fraktur (ùñÜùñáùñà)",
		"use_special": "Special (√•√ü¬¢)",
		"use_standard": "Standard (abc)",
		"signature_header": "Auto Signature",
		"enable_signature": "Enable auto signature",
		"signature_subtext": "Add custom signature to messages",
		"signature_text": "Signature text",
		"signature_start": "Signature at start",
		"signature_end": "Signature at end",
		"enable_for_private": "Enable in private chats",
		"enable_for_groups": "Enable in groups",
		"enable_for_channels": "Enable in channels",
		"antispoiler_header": "Anti-Spoiler",
		"enable_antispoiler": "Remove spoilers",
		"antispoiler_subtext": "Auto-reveal spoilers from text and media",
		"link_cleaner_header": "Link Cleaner",
		"enable_link_cleaner": "Remove http(s)://",
		"link_cleaner_subtext": "Remove http:// and https:// prefixes",
		"enable_link_shortener": "Shorten links",
		"link_shortener_subtext": "Use TinyURL service",
		"enable_link_cleanup": "Clean tracking",
		"link_cleanup_subtext": "Remove utm and tracking parameters",
		"text_formatter_header": "Text Formatter",
		"enable_ai_correction": "AI correction",
		"ai_correction_subtext": "Fix grammar and punctuation",
		"enable_capitalize": "Auto capitalize",
		"capitalize_subtext": "First letter in sentences",
		"enable_final_symbol": "Add symbol",
		"final_symbol_subtext": "Add custom symbol at the end",
		"final_symbol_text": "Symbol to add",
		"writing_style_header": "Writing Style",
		"enable_writing_style": "Enable style conversion",
		"writing_style_subtext": "Convert text to selected style",
		"writing_style_type": "Style type",
		"style_business": "Business",
		"style_casual": "Casual",
		"style_official": "Official",
		"style_bydlo": "Street",
		"unlimited_pins_header": "Unlimited Pins",
		"enable_unlimited_pins": "Unlimited pins",
		"unlimited_pins_subtext": "Remove pinned chats limit",
		"unlimited_pins_max": "Max pinned count",
		"round_video_header": "Round Video Settings",
		"enable_round_video_settings": "Custom settings",
		"round_video_subtext": "Customize resolution and bitrate",
		"round_video_resolution": "Resolution, px",
		"round_video_bitrate": "Bitrate, kbit/s",
		"forward_limit_header": "Forward Limit",
		"enable_no_forward_limit": "Remove limit",
		"forward_limit_subtext": "Remove 100 messages forward limit",
		"unlimited_gifs_header": "Unlimited GIFs",
		"enable_unlimited_gifs": "Unlimited GIFs",
		"unlimited_gifs_subtext": "Remove saved GIFs limit",
		"noforwards_header": "Protected Content",
		"enable_noforwards_bypass": "Bypass NoForwards",
		"noforwards_subtext": "Allow copying protected content",
		"photo_quality_header": "Photo Quality",
		"enable_max_photo_quality": "Maximum quality",
		"photo_quality_subtext": "Send photos without compression (100%)",
		"video_quality_header": "Video Quality",
		"enable_enhanced_video_quality": "Enhanced quality",
		"video_quality_subtext": "Less compression, better quality",
		"success": "Translation successful",
		"error": "Translation failed"
	},
	"ru": {
		"title": "Ex Tool",
		"auto_translate": "–ê–≤—Ç–æ–ø–µ—Ä–µ–≤–æ–¥",
		"auto_translate_subtext": "–†—É—Å—Å–∫–∏–π ‚Üí —Å—Ç–∏–ª—å –∞–ª—Ñ–∞–≤–∏—Ç–∞ Ex Tool",
		"translate_menu": "–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ / –≤–µ—Ä–Ω—É—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª",
		"style_header": "–°—Ç–∏–ª—å –∞–ª—Ñ–∞–≤–∏—Ç–∞",
		"alphabet_style_type": "–¢–∏–ø –∞–ª—Ñ–∞–≤–∏—Ç–∞",
		"use_small_caps": "–ú–∞–ª—ã–µ –∑–∞–≥–ª–∞–≤–Ω—ã–µ (·¥Ä ô·¥Ñ)",
		"use_fraktur": "–§—Ä–∞–∫—Ç—É—Ä–∞ (ùñÜùñáùñà)",
		"use_special": "–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ (√•√ü¬¢)",
		"use_standard": "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π (abc)",
		"signature_header": "–ê–≤—Ç–æ–ø–æ–¥–ø–∏—Å—å",
		"enable_signature": "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–ø–æ–¥–ø–∏—Å—å",
		"signature_subtext": "–î–æ–±–∞–≤–ª—è—Ç—å –ø–æ–¥–ø–∏—Å—å –∫ —Å–æ–æ–±—â–µ–Ω–∏—è–º",
		"signature_text": "–¢–µ–∫—Å—Ç –ø–æ–¥–ø–∏—Å–∏",
		"signature_start": "–ü–æ–¥–ø–∏—Å—å –≤ –Ω–∞—á–∞–ª–µ",
		"signature_end": "–ü–æ–¥–ø–∏—Å—å –≤ –∫–æ–Ω—Ü–µ",
		"enable_for_private": "–í–∫–ª—é—á–∏—Ç—å –≤ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–∞—Ö",
		"enable_for_groups": "–í–∫–ª—é—á–∏—Ç—å –≤ –≥—Ä—É–ø–ø–∞—Ö",
		"enable_for_channels": "–í–∫–ª—é—á–∏—Ç—å –≤ –∫–∞–Ω–∞–ª–∞—Ö",
		"antispoiler_header": "–ê–Ω—Ç–∏—Å–ø–æ–π–ª–µ—Ä",
		"enable_antispoiler": "–£–±–∏—Ä–∞—Ç—å —Å–ø–æ–π–ª–µ—Ä—ã",
		"antispoiler_subtext": "–ê–≤—Ç–æ—Ä–∞—Å–∫—Ä—ã—Ç–∏–µ —Å–ø–æ–π–ª–µ—Ä–æ–≤ —Å —Ç–µ–∫—Å—Ç–∞ –∏ –º–µ–¥–∏–∞",
		"link_cleaner_header": "–û—á–∏—Å—Ç–∫–∞ —Å—Å—ã–ª–æ–∫",
		"enable_link_cleaner": "–£–±–∏—Ä–∞—Ç—å http(s)://",
		"link_cleaner_subtext": "–£–±–∏—Ä–∞—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å—ã http:// –∏ https://",
		"enable_link_shortener": "–°–æ–∫—Ä–∞—â–∞—Ç—å —Å—Å—ã–ª–∫–∏",
		"link_shortener_subtext": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å TinyURL",
		"enable_link_cleanup": "–û—á–∏—Å—Ç–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞",
		"link_cleanup_subtext": "–£–¥–∞–ª—è—Ç—å utm –∏ —Ç—Ä–µ–∫–∏–Ω–≥–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã",
		"text_formatter_header": "–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞",
		"enable_ai_correction": "–ò–ò –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ",
		"ai_correction_subtext": "–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ä—Ñ–æ–≥—Ä–∞—Ñ–∏–∏ –∏ –ø—É–Ω–∫—Ç—É–∞—Ü–∏–∏",
		"enable_capitalize": "–ê–≤—Ç–æ–∑–∞–≥–ª–∞–≤–Ω–∞—è",
		"capitalize_subtext": "–ü–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –≤ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è—Ö",
		"enable_final_symbol": "–î–æ–±–∞–≤–ª—è—Ç—å —Å–∏–º–≤–æ–ª",
		"final_symbol_subtext": "–î–æ–±–∞–≤–ª—è—Ç—å —Å–∏–º–≤–æ–ª –≤ –∫–æ–Ω—Ü–µ",
		"final_symbol_text": "–°–∏–º–≤–æ–ª –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è",
		"writing_style_header": "–°—Ç–∏–ª—å –ø–∏—Å—å–º–∞",
		"enable_writing_style": "–í–∫–ª—é—á–∏—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç–∏–ª—è",
		"writing_style_subtext": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç –≤ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å—Ç–∏–ª—å",
		"writing_style_type": "–¢–∏–ø —Å—Ç–∏–ª—è",
		"style_business": "–î–µ–ª–æ–≤–æ–π",
		"style_casual": "–†–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π",
		"style_official": "–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π",
		"style_bydlo": "–ë—ã–¥–ª–æ",
		"unlimited_pins_header": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω–æ–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ",
		"enable_unlimited_pins": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏—è",
		"unlimited_pins_subtext": "–£–±—Ä–∞—Ç—å –ª–∏–º–∏—Ç –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤",
		"unlimited_pins_max": "–ú–∞–∫—Å–∏–º—É–º –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã—Ö",
		"round_video_header": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫—Ä—É–≥–ª—ã—Ö –≤–∏–¥–µ–æ",
		"enable_round_video_settings": "–°–≤–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
		"round_video_subtext": "–ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∏ –±–∏—Ç—Ä–µ–π—Ç",
		"round_video_resolution": "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ, px",
		"round_video_bitrate": "–ë–∏—Ç—Ä–µ–π—Ç, –∫–±–∏—Ç/—Å",
		"forward_limit_header": "–õ–∏–º–∏—Ç –ø–µ—Ä–µ—Å—ã–ª–∫–∏",
		"enable_no_forward_limit": "–£–±—Ä–∞—Ç—å –ª–∏–º–∏—Ç",
		"forward_limit_subtext": "–£–±—Ä–∞—Ç—å –ª–∏–º–∏—Ç 100 —Å–æ–æ–±—â–µ–Ω–∏–π",
		"unlimited_gifs_header": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ GIF",
		"enable_unlimited_gifs": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ GIF",
		"unlimited_gifs_subtext": "–£–±—Ä–∞—Ç—å –ª–∏–º–∏—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö GIF",
		"noforwards_header": "–ó–∞—â–∏—â–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç",
		"enable_noforwards_bypass": "–û–±—Ö–æ–¥ NoForwards",
		"noforwards_subtext": "–†–∞–∑—Ä–µ—à–∏—Ç—å –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞—â–∏—â–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞",
		"photo_quality_header": "–ö–∞—á–µ—Å—Ç–≤–æ —Ñ–æ—Ç–æ",
		"enable_max_photo_quality": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ",
		"photo_quality_subtext": "–û—Ç–ø—Ä–∞–≤–∫–∞ –±–µ–∑ —Å–∂–∞—Ç–∏—è (100%)",
		"video_quality_header": "–ö–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ",
		"enable_enhanced_video_quality": "–£–ª—É—á—à–µ–Ω–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ",
		"video_quality_subtext": "–ú–µ–Ω—å—à–µ –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏, –ª—É—á—à–µ –∫–∞—á–µ—Å—Ç–≤–æ",
		"success": "–ü–µ—Ä–µ–≤–æ–¥ —É—Å–ø–µ—à–µ–Ω",
		"error": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ"
	},
	"de": {
		"title": "Ex Tool",
		"auto_translate": "Auto-√úbersetzung",
		"auto_translate_subtext": "Russisch ‚Üí Ex Tool Alphabetstil",
		"translate_menu": "√úbersetzen / Original wiederherstellen",
		"style_header": "Alphabetstil",
		"alphabet_style_type": "Alphabettyp",
		"use_small_caps": "Kapit√§lchen (·¥Ä ô·¥Ñ)",
		"use_fraktur": "Fraktur (ùñÜùñáùñà)",
		"use_special": "Spezial (√•√ü¬¢)",
		"use_standard": "Standard (abc)",
		"signature_header": "Auto-Signatur",
		"enable_signature": "Auto-Signatur aktivieren",
		"signature_subtext": "Signatur zu Nachrichten hinzuf√ºgen",
		"signature_text": "Signaturtext",
		"signature_start": "Signatur am Anfang",
		"signature_end": "Signatur am Ende",
		"enable_for_private": "In privaten Chats aktivieren",
		"enable_for_groups": "In Gruppen aktivieren",
		"enable_for_channels": "In Kan√§len aktivieren",
		"antispoiler_header": "Anti-Spoiler",
		"enable_antispoiler": "Spoiler entfernen",
		"antispoiler_subtext": "Spoiler automatisch von Text und Medien enth√ºllen",
		"link_cleaner_header": "Link-Reiniger",
		"enable_link_cleaner": "http(s):// entfernen",
		"link_cleaner_subtext": "http:// und https:// Pr√§fixe entfernen",
		"enable_link_shortener": "Links k√ºrzen",
		"link_shortener_subtext": "TinyURL-Dienst verwenden",
		"enable_link_cleanup": "Tracking bereinigen",
		"link_cleanup_subtext": "utm und Tracking-Parameter entfernen",
		"text_formatter_header": "Textformatierung",
		"enable_ai_correction": "KI-Korrektur",
		"ai_correction_subtext": "Grammatik und Zeichensetzung korrigieren",
		"enable_capitalize": "Auto-Gro√üschreibung",
		"capitalize_subtext": "Erster Buchstabe in S√§tzen",
		"enable_final_symbol": "Symbol hinzuf√ºgen",
		"final_symbol_subtext": "Benutzerdefiniertes Symbol am Ende hinzuf√ºgen",
		"final_symbol_text": "Hinzuzuf√ºgendes Symbol",
		"writing_style_header": "Schreibstil",
		"enable_writing_style": "Stilkonvertierung aktivieren",
		"writing_style_subtext": "Text in ausgew√§hlten Stil umwandeln",
		"writing_style_type": "Stiltyp",
		"style_business": "Gesch√§ftlich",
		"style_casual": "Umgangssprachlich",
		"style_official": "Offiziell",
		"style_bydlo": "Stra√üenslang",
		"unlimited_pins_header": "Unbegrenzte Pins",
		"enable_unlimited_pins": "Unbegrenzte Pins",
		"unlimited_pins_subtext": "Limit f√ºr angepinnte Chats entfernen",
		"unlimited_pins_max": "Maximale Anzahl angepinnter",
		"round_video_header": "Rundvideo-Einstellungen",
		"enable_round_video_settings": "Benutzerdefinierte Einstellungen",
		"round_video_subtext": "Aufl√∂sung und Bitrate anpassen",
		"round_video_resolution": "Aufl√∂sung, px",
		"round_video_bitrate": "Bitrate, kbit/s",
		"forward_limit_header": "Weiterleitungslimit",
		"enable_no_forward_limit": "Limit entfernen",
		"forward_limit_subtext": "100-Nachrichten-Weiterleitungslimit entfernen",
		"unlimited_gifs_header": "Unbegrenzte GIFs",
		"enable_unlimited_gifs": "Unbegrenzte GIFs",
		"unlimited_gifs_subtext": "Limit f√ºr gespeicherte GIFs entfernen",
		"noforwards_header": "Gesch√ºtzter Inhalt",
		"enable_noforwards_bypass": "NoForwards umgehen",
		"noforwards_subtext": "Kopieren gesch√ºtzter Inhalte erlauben",
		"photo_quality_header": "Fotoqualit√§t",
		"enable_max_photo_quality": "Maximale Qualit√§t",
		"photo_quality_subtext": "Ohne Kompression senden (100%)",
		"video_quality_header": "Videoqualit√§t",
		"enable_enhanced_video_quality": "Verbesserte Qualit√§t",
		"video_quality_subtext": "Weniger Kompression, bessere Qualit√§t",
		"success": "√úbersetzung erfolgreich",
		"error": "√úbersetzung fehlgeschlagen"
	}
}

ROUND_VIDEO_RESOLUTIONS = [128, 256, 384, 512, 640]
ROUND_VIDEO_BITRATES = [600, 800, 1000, 1200, 1400]

WRITING_STYLES = {
	"business": {
		"–ø—Ä–∏–≤–µ—Ç": "–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ",
		"—Å–ø–∞—Å–∏–±–æ": "–±–ª–∞–≥–æ–¥–∞—Ä—é",
		"–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "–±—É–¥—å—Ç–µ –ª—é–±–µ–∑–Ω—ã",
		"–¥–∞": "—Å–æ–≥–ª–∞—Å–µ–Ω",
		"–Ω–µ—Ç": "–Ω–µ –º–æ–≥—É —Å–æ–≥–ª–∞—Å–∏—Ç—å—Å—è",
		"—Ö–æ—Ä–æ—à–æ": "–ø—Ä–∏–µ–º–ª–µ–º–æ",
		"–ø–ª–æ—Ö–æ": "–Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ",
		"—Å–¥–µ–ª–∞—é": "–≤—ã–ø–æ–ª–Ω—é",
		"—Å–∫–∞–∂–∏": "—Å–æ–æ–±—â–∏—Ç–µ",
		"–Ω–∞–ø–∏—à–∏": "–Ω–∞–ø—Ä–∞–≤—å—Ç–µ",
		"–∂–¥–∏": "–æ–∂–∏–¥–∞–π—Ç–µ",
		"–±—ã—Å—Ç—Ä–æ": "–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ",
		"–º–µ–¥–ª–µ–Ω–Ω–æ": "–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å—Ä–æ–∫–∏",
		"–ø—Ä–æ–±–ª–µ–º–∞": "–∑–∞—Ç—Ä—É–¥–Ω–µ–Ω–∏–µ",
		"–æ—à–∏–±–∫–∞": "–Ω–µ–¥–æ—á–µ—Ç",
		"–¥–µ–Ω–µ–≥": "—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤",
		"—Ä–∞–±–æ—Ç–∞": "–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å",
		"–Ω—É–∂–Ω–æ": "–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ",
		"–Ω–∞–¥–æ": "—Ç—Ä–µ–±—É–µ—Ç—Å—è",
		"–º–æ–∂–Ω–æ": "–¥–æ–ø—É—Å—Ç–∏–º–æ",
		"–Ω–µ–ª—å–∑—è": "–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ",
		"–∫—É–ø–∏—Ç—å": "–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏",
		"–ø—Ä–æ–¥–∞—Ç—å": "—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å",
		"–≤—Å—Ç—Ä–µ—á–∞": "–¥–µ–ª–æ–≤–∞—è –≤—Å—Ç—Ä–µ—á–∞",
		"—Ä–∞–∑–≥–æ–≤–æ—Ä": "–±–µ—Å–µ–¥–∞",
		"–∑–≤–æ–Ω–æ–∫": "—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫",
		"–ø–∏—Å—å–º–æ": "–¥–µ–ª–æ–≤–æ–µ –ø–∏—Å—å–º–æ",
		"–¥—É–º–∞—é": "–ø–æ–ª–∞–≥–∞—é",
		"–∑–Ω–∞—é": "–æ—Å–≤–µ–¥–æ–º–ª–µ–Ω",
		"–ø–æ–Ω—è–ª": "—É—è—Å–Ω–∏–ª",
		"–ø–æ–º–æ–≥—É": "–æ–∫–∞–∂—É —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ",
		"–æ–±—ä—è—Å–Ω–∏": "—Ä–∞–∑—ä—è—Å–Ω–∏—Ç–µ",
		"—É–∑–Ω–∞–π": "—É—Ç–æ—á–Ω–∏—Ç–µ",
		"–ø–æ—Å–º–æ—Ç—Ä–∏": "–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å",
		"—Ä–∞—Å—Å–∫–∞–∂–∏": "–ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ",
		"–∂–¥—É": "–æ–∂–∏–¥–∞—é",
		"—Ö–æ—á—É": "–∂–µ–ª–∞—é",
		"–±—É–¥—É": "–Ω–∞–º–µ—Ä–µ–Ω",
		"–≤–æ–ø—Ä–æ—Å": "–≤–æ–ø—Ä–æ—Å",
		"–æ—Ç–≤–µ—Ç": "–æ—Ç–≤–µ—Ç",
		"–¥–æ–∫—É–º–µ–Ω—Ç": "–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è",
		"—Ñ–∞–π–ª": "—Ñ–∞–π–ª –¥–æ–∫—É–º–µ–Ω—Ç–∞",
		"–æ—Ç–ø—Ä–∞–≤—å": "–Ω–∞–ø—Ä–∞–≤—å—Ç–µ",
		"–ø–æ–ª—É—á–∏–ª": "–ø–æ–ª—É—á–µ–Ω–æ",
		"–ø–æ–Ω—è—Ç–Ω–æ": "—è—Å–Ω–æ"
	},
	"casual": {
		"–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ": "–ø—Ä–∏–≤–µ—Ç",
		"–±–ª–∞–≥–æ–¥–∞—Ä—é": "—Å–ø–∞—Å–∏–±–æ",
		"–±—É–¥—å—Ç–µ –ª—é–±–µ–∑–Ω—ã": "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞",
		"—Å–æ–≥–ª–∞—Å–µ–Ω": "–æ–∫",
		"–Ω–µ –º–æ–≥—É —Å–æ–≥–ª–∞—Å–∏—Ç—å—Å—è": "–Ω–µ",
		"–ø—Ä–∏–µ–º–ª–µ–º–æ": "–Ω–æ—Ä–º",
		"–Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ": "–Ω–µ –æ—á–µ–Ω—å",
		"–≤—ã–ø–æ–ª–Ω—é": "—Å–¥–µ–ª–∞—é",
		"—Å–æ–æ–±—â–∏—Ç–µ": "—Å–∫–∞–∂–∏",
		"–Ω–∞–ø—Ä–∞–≤—å—Ç–µ": "–æ—Ç–ø—Ä–∞–≤—å",
		"–æ–∂–∏–¥–∞–π—Ç–µ": "–ø–æ–¥–æ–∂–¥–∏",
		"–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ": "–±—ã—Å—Ç—Ä–æ",
		"–∑–∞—Ç—Ä—É–¥–Ω–µ–Ω–∏–µ": "–ø—Ä–æ–±–ª–µ–º–∞",
		"–Ω–µ–¥–æ—á–µ—Ç": "–∫–æ—Å—è–∫",
		"—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤": "–¥–µ–Ω–µ–≥",
		"–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å": "—Ä–∞–±–æ—Ç–∞",
		"–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ": "–Ω–∞–¥–æ",
		"—Ç—Ä–µ–±—É–µ—Ç—Å—è": "–Ω—É–∂–Ω–æ",
		"–¥–æ–ø—É—Å—Ç–∏–º–æ": "–º–æ–∂–Ω–æ",
		"–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ": "–Ω–µ–ª—å–∑—è",
		"–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏": "–∫—É–ø–∏—Ç—å",
		"—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å": "–ø—Ä–æ–¥–∞—Ç—å",
		"–¥–µ–ª–æ–≤–∞—è –≤—Å—Ç—Ä–µ—á–∞": "–≤—Å—Ç—Ä–µ—á–∞",
		"–±–µ—Å–µ–¥–∞": "—Ä–∞–∑–≥–æ–≤–æ—Ä",
		"—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫": "–∑–≤–æ–Ω–æ–∫",
		"–¥–µ–ª–æ–≤–æ–µ –ø–∏—Å—å–º–æ": "–ø–∏—Å—å–º–æ",
		"–ø–æ–ª–∞–≥–∞—é": "–¥—É–º–∞—é",
		"–æ—Å–≤–µ–¥–æ–º–ª–µ–Ω": "–∑–Ω–∞—é",
		"—É—è—Å–Ω–∏–ª": "–ø–æ–Ω—è–ª",
		"–æ–∫–∞–∂—É —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ": "–ø–æ–º–æ–≥—É",
		"—Ä–∞–∑—ä—è—Å–Ω–∏—Ç–µ": "–æ–±—ä—è—Å–Ω–∏",
		"—É—Ç–æ—á–Ω–∏—Ç–µ": "—É–∑–Ω–∞–π",
		"–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å": "–ø–æ—Å–º–æ—Ç—Ä–∏",
		"–ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ": "—Ä–∞—Å—Å–∫–∞–∂–∏",
		"–æ–∂–∏–¥–∞—é": "–∂–¥—É",
		"–∂–µ–ª–∞—é": "—Ö–æ—á—É",
		"–Ω–∞–º–µ—Ä–µ–Ω": "–±—É–¥—É",
		"—Ñ–∞–π–ª –¥–æ–∫—É–º–µ–Ω—Ç–∞": "—Ñ–∞–π–ª",
		"–ø–æ–ª—É—á–µ–Ω–æ": "–ø–æ–ª—É—á–∏–ª",
		"—è—Å–Ω–æ": "–ø–æ–Ω—è—Ç–Ω–æ"
	},
	"official": {
		"–ø—Ä–∏–≤–µ—Ç": "–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é",
		"—Å–ø–∞—Å–∏–±–æ": "–≤—ã—Ä–∞–∂–∞—é –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å",
		"–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "–ø—Ä–æ—à—É –í–∞—Å",
		"–¥–∞": "—É—Ç–≤–µ—Ä–¥–∏—Ç–µ–ª—å–Ω–æ",
		"–Ω–µ—Ç": "–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ",
		"—Ö–æ—Ä–æ—à–æ": "—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ",
		"–ø–ª–æ—Ö–æ": "–Ω–µ–ø—Ä–∏–µ–º–ª–µ–º–æ",
		"—Å–¥–µ–ª–∞—é": "–∏—Å–ø–æ–ª–Ω—é",
		"—Å–∫–∞–∂–∏": "–¥–æ–≤–µ–¥–∏—Ç–µ –¥–æ —Å–≤–µ–¥–µ–Ω–∏—è",
		"–Ω–∞–ø–∏—à–∏": "–ø—Ä–æ—Å–∏–º –Ω–∞–ø—Ä–∞–≤–∏—Ç—å",
		"–∂–¥–∏": "–ø—Ä–æ—Å–∏–º –æ–∂–∏–¥–∞—Ç—å",
		"–±—ã—Å—Ç—Ä–æ": "–≤ –∫—Ä–∞—Ç—á–∞–π—à–∏–µ —Å—Ä–æ–∫–∏",
		"–º–µ–¥–ª–µ–Ω–Ω–æ": "–≤ —Ç–µ—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞",
		"–ø—Ä–æ–±–ª–µ–º–∞": "–∑–∞—Ç—Ä—É–¥–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏—Ç—É–∞—Ü–∏—è",
		"–æ—à–∏–±–∫–∞": "–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ",
		"–¥–µ–Ω–µ–≥": "–¥–µ–Ω–µ–∂–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤",
		"—Ä–∞–±–æ—Ç–∞": "—Ç—Ä—É–¥–æ–≤–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å",
		"–Ω—É–∂–Ω–æ": "–Ω–∞–¥–ª–µ–∂–∏—Ç",
		"–Ω–∞–¥–æ": "—Å–ª–µ–¥—É–µ—Ç",
		"–º–æ–∂–Ω–æ": "–∏–º–µ–µ—Ç—Å—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å",
		"–Ω–µ–ª—å–∑—è": "–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤–æ–∑–º–æ–∂–Ω—ã–º",
		"–∫—É–ø–∏—Ç—å": "–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–∞–∫—É–ø–∫—É",
		"–ø—Ä–æ–¥–∞—Ç—å": "–æ—Å—É—â–µ—Å—Ç–≤–∏—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é",
		"–≤—Å—Ç—Ä–µ—á–∞": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –≤—Å—Ç—Ä–µ—á–∞",
		"—Ä–∞–∑–≥–æ–≤–æ—Ä": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –±–µ—Å–µ–¥–∞",
		"–∑–≤–æ–Ω–æ–∫": "—Ç–µ–ª–µ—Ñ–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
		"–ø–∏—Å—å–º–æ": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–µ –ø–æ—Å–ª–∞–Ω–∏–µ",
		"–¥—É–º–∞—é": "–ø–æ–ª–∞–≥–∞—é –≤–æ–∑–º–æ–∂–Ω—ã–º",
		"–∑–Ω–∞—é": "–∏–º–µ—é —Å–≤–µ–¥–µ–Ω–∏—è",
		"–ø–æ–Ω—è–ª": "—É—Å–≤–æ–∏–ª –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é",
		"–ø–æ–º–æ–≥—É": "–æ–∫–∞–∂—É –Ω–∞–¥–ª–µ–∂–∞—â–µ–µ —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ",
		"–æ–±—ä—è—Å–Ω–∏": "–ø—Ä–æ—Å–∏–º —Ä–∞–∑—ä—è—Å–Ω–∏—Ç—å",
		"—É–∑–Ω–∞–π": "–ø—Ä–æ—Å–∏–º –≤—ã—è—Å–Ω–∏—Ç—å",
		"–ø–æ—Å–º–æ—Ç—Ä–∏": "–ø—Ä–æ—Å–∏–º —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å",
		"—Ä–∞—Å—Å–∫–∞–∂–∏": "–ø—Ä–æ—Å–∏–º –ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å",
		"–∂–¥—É": "–Ω–∞—Ö–æ–∂—É—Å—å –≤ –æ–∂–∏–¥–∞–Ω–∏–∏",
		"—Ö–æ—á—É": "–∏–∑—ä—è–≤–ª—è—é –∂–µ–ª–∞–Ω–∏–µ",
		"–±—É–¥—É": "–Ω–∞–º–µ—Ä–µ–≤–∞—é—Å—å",
		"–≤–æ–ø—Ä–æ—Å": "–∑–∞–ø—Ä–æ—Å",
		"–æ—Ç–≤–µ—Ç": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç",
		"–¥–æ–∫—É–º–µ–Ω—Ç": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è",
		"—Ñ–∞–π–ª": "—ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç",
		"–æ—Ç–ø—Ä–∞–≤—å": "–ø—Ä–æ—Å–∏–º –Ω–∞–ø—Ä–∞–≤–∏—Ç—å",
		"–ø–æ–ª—É—á–∏–ª": "–ø–æ–ª—É—á–µ–Ω–æ –∫ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—é",
		"–ø–æ–Ω—è—Ç–Ω–æ": "–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø—Ä–∏–Ω—è—Ç–∞ –∫ —Å–≤–µ–¥–µ–Ω–∏—é"
	},
	"bydlo": {
		"–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ": "–∑–¥–∞—Ä–æ–≤–∞",
		"–ø—Ä–∏–≤–µ—Ç": "–∑–¥–∞—Ä–æ–≤–∞",
		"—Å–ø–∞—Å–∏–±–æ": "—Å–ø–∞—Å–∏–±–∫–∏",
		"–±–ª–∞–≥–æ–¥–∞—Ä—é": "–ø–∞—Å–∏–±",
		"–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "–Ω–µ –∑–∞ —á—Ç–æ",
		"–±—É–¥—å—Ç–µ –ª—é–±–µ–∑–Ω—ã": "–¥–∞–≤–∞–π",
		"–¥–∞": "–∞–≥–∞",
		"–Ω–µ—Ç": "–Ω–µ",
		"—Å–æ–≥–ª–∞—Å–µ–Ω": "–Ω–æ—Ä–º",
		"—Ö–æ—Ä–æ—à–æ": "—á–µ—Ç–∫–æ",
		"–ø–ª–æ—Ö–æ": "—Ö—Ä–µ–Ω–æ–≤–æ",
		"–æ—Ç–ª–∏—á–Ω–æ": "–æ–≥–æ–Ω—å",
		"–ø—Ä–∏–µ–º–ª–µ–º–æ": "–∫–∞–Ω–∞–µ—Ç",
		"–Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ": "–æ—Ç—Å—Ç–æ–π",
		"—Å–¥–µ–ª–∞—é": "—Å–¥–µ–ª–∞—é",
		"–≤—ã–ø–æ–ª–Ω—é": "–∑–∞–º—É—á—É",
		"—Å–∫–∞–∂–∏": "—Å–∫–∞–∂–∏",
		"—Å–æ–æ–±—â–∏—Ç–µ": "—Å–∫–∞–∂–∏",
		"–Ω–∞–ø–∏—à–∏": "–Ω–∞–ø–∏—à–∏",
		"–Ω–∞–ø—Ä–∞–≤—å—Ç–µ": "–∫–∏–Ω—å",
		"–∂–¥–∏": "–∂–¥–∏",
		"–æ–∂–∏–¥–∞–π—Ç–µ": "–ø–æ–≥–æ–¥–∏",
		"–±—ã—Å—Ç—Ä–æ": "—à—É—Å—Ç—Ä–æ",
		"–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ": "–∂–∏–≤–æ",
		"–º–µ–¥–ª–µ–Ω–Ω–æ": "–Ω–µ —Ç–æ—Ä–æ–ø—è—Å—å",
		"–ø—Ä–æ–±–ª–µ–º–∞": "–ø—Ä–æ–±–ª–µ–º–∞",
		"–∑–∞—Ç—Ä—É–¥–Ω–µ–Ω–∏–µ": "–∑–∞—Å–∞–¥–∞",
		"–æ—à–∏–±–∫–∞": "–∫–æ—Å—è–∫",
		"–Ω–µ–¥–æ—á–µ—Ç": "–Ω–∞–∫–æ—Å—è—á–∏–ª",
		"–¥–µ–Ω–µ–≥": "–±–∞–±–æ–∫",
		"–¥–µ–Ω—å–≥–∏": "–±–∞–±–∫–∏",
		"—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤": "–∫–∞–ø—É—Å—Ç—ã",
		"—Ä–∞–±–æ—Ç–∞": "—Ä–∞–±–æ—Ç–∞",
		"–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å": "–¥–≤–∏–∂—É—Ö–∞",
		"–Ω—É–∂–Ω–æ": "–Ω–∞–¥–∞",
		"–Ω–∞–¥–æ": "–Ω–∞–¥–∞",
		"–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ": "–Ω–∞–¥–∞",
		"—Ç—Ä–µ–±—É–µ—Ç—Å—è": "–Ω—É–∂–Ω–æ",
		"–º–æ–∂–Ω–æ": "–º–æ–∂–Ω–æ",
		"–¥–æ–ø—É—Å—Ç–∏–º–æ": "–∫–∞—Ç–∏—Ç",
		"–Ω–µ–ª—å–∑—è": "–Ω–∏–∑—è",
		"–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ": "–Ω–µ–ª—å–∑—è",
		"–∫—É–ø–∏—Ç—å": "–≤–∑—è—Ç—å",
		"–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏": "–≤–∑—è—Ç—å",
		"–ø—Ä–æ–¥–∞—Ç—å": "—Ç–æ–ª–∫–Ω—É—Ç—å",
		"—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å": "—Å–±—ã—Ç—å",
		"–≤—Å—Ç—Ä–µ—á–∞": "–≤—Å—Ç—Ä–µ—á–∞",
		"–¥–µ–ª–æ–≤–∞—è –≤—Å—Ç—Ä–µ—á–∞": "—Å—Ö–æ–¥–∫–∞",
		"—Ä–∞–∑–≥–æ–≤–æ—Ä": "–±–∞–∑–∞—Ä",
		"–±–µ—Å–µ–¥–∞": "—Ä–∞–∑–≥–æ–≤–æ—Ä",
		"–∑–≤–æ–Ω–æ–∫": "–∑–≤–æ–Ω–æ–∫",
		"—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫": "–ø–æ–∑–≤–æ–Ω",
		"–ø–∏—Å—å–º–æ": "–ø–∏—Å—å–º–æ",
		"–¥–µ–ª–æ–≤–æ–µ –ø–∏—Å—å–º–æ": "–ø–∏—Å—å–º–µ—Ü–æ",
		"–¥—É–º–∞—é": "–¥—É–º–∞—é",
		"–ø–æ–ª–∞–≥–∞—é": "–º–Ω–µ –∫–∞–∂–µ—Ç—Å—è",
		"–∑–Ω–∞—é": "–∑–Ω–∞—é",
		"–æ—Å–≤–µ–¥–æ–º–ª–µ–Ω": "–≤ –∫—É—Ä—Å–µ",
		"–ø–æ–Ω—è–ª": "–ø–æ–Ω—è–ª",
		"—É—è—Å–Ω–∏–ª": "–≤—Ä—É–±–∏–ª—Å—è",
		"–ø–æ–º–æ–≥—É": "–ø–æ–º–æ–≥—É",
		"–æ–∫–∞–∂—É —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ": "–ø–æ–¥—Å–æ–±–ª—é",
		"–æ–±—ä—è—Å–Ω–∏": "–æ–±—ä—è—Å–Ω–∏",
		"—Ä–∞–∑—ä—è—Å–Ω–∏—Ç–µ": "—Ä–∞—Å—Ç–æ–ª–∫—É–π",
		"—É–∑–Ω–∞–π": "—É–∑–Ω–∞–π",
		"—É—Ç–æ—á–Ω–∏—Ç–µ": "—Ä–∞–∑—É–∑–Ω–∞–π",
		"–ø–æ—Å–º–æ—Ç—Ä–∏": "–≥–ª—è–Ω—å",
		"–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å": "–ø–æ—Å–º–æ—Ç—Ä–∏",
		"—Ä–∞—Å—Å–∫–∞–∂–∏": "—Ä–∞—Å—Å–∫–∞–∂–∏",
		"–ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ": "–¥–æ–ª–æ–∂–∏",
		"–∂–¥—É": "–∂–¥—É",
		"–æ–∂–∏–¥–∞—é": "–∂–¥—É",
		"—Ö–æ—á—É": "—Ö–æ—á—É",
		"–∂–µ–ª–∞—é": "—Ö–æ—á—É",
		"–±—É–¥—É": "–±—É–¥—É",
		"–Ω–∞–º–µ—Ä–µ–Ω": "—Å–æ–±–∏—Ä–∞—é—Å—å",
		"–≤–æ–ø—Ä–æ—Å": "–≤–æ–ø—Ä–æ—Å",
		"–∑–∞–ø—Ä–æ—Å": "–≤–æ–ø—Ä–æ—Å–∏–∫",
		"–æ—Ç–≤–µ—Ç": "–æ—Ç–≤–µ—Ç",
		"–¥–æ–∫—É–º–µ–Ω—Ç": "–±—É–º–∞–≥–∞",
		"–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è": "–±—É–º–∞–∂–∫–∏",
		"—Ñ–∞–π–ª": "—Ñ–∞–π–ª",
		"–æ—Ç–ø—Ä–∞–≤—å": "–∫–∏–Ω—å",
		"–ø–æ–ª—É—á–∏–ª": "–ø–æ–ª—É—á–∏–ª",
		"–ø–æ–ª—É—á–µ–Ω–æ": "–ø—Ä–∏—à–ª–æ",
		"–ø–æ–Ω—è—Ç–Ω–æ": "–ø–æ–Ω—è—Ç–Ω–æ",
		"—è—Å–Ω–æ": "—è—Å–Ω–µ–Ω—å–∫–æ",
		"—á–µ–ª–æ–≤–µ–∫": "—á–µ–ª",
		"–ª—é–¥–∏": "–Ω–∞—Ä–æ–¥",
		"–¥—Ä—É–≥": "–∫–æ—Ä–µ—à",
		"—Ç–æ–≤–∞—Ä–∏—â": "–±—Ä–∞—Ç–∞–Ω",
		"–∫–æ–ª–ª–µ–≥–∞": "–∫–æ–ª–ª–µ–≥–∞",
		"–Ω–∞—á–∞–ª—å–Ω–∏–∫": "–Ω–∞—á–∞–ª—å–Ω–∏–∫",
		"—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å": "—à–µ—Ñ",
		"—Å–æ—Ç—Ä—É–¥–Ω–∏–∫": "—Ä–∞–±–æ—Ç–Ω–∏–∫",
		"–∫–ª–∏–µ–Ω—Ç": "–∫–ª–∏–µ–Ω—Ç",
		"–ø–∞—Ä—Ç–Ω–µ—Ä": "–ø–∞—Ä—Ç–Ω–µ—Ä",
		"–¥–æ–≥–æ–≤–æ—Ä": "–¥–æ–≥–æ–≤–æ—Ä",
		"–∫–æ–Ω—Ç—Ä–∞–∫—Ç": "–±—É–º–∞–≥–∏",
		"—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ": "–¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å",
		"–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ": "–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ",
		"–∑–∞–∫–∞–∑": "–∑–∞–∫–∞–∑",
		"—É—Å–ª—É–≥–∞": "—É—Å–ª—É–≥–∞",
		"—Ç–æ–≤–∞—Ä": "—Ç–æ–≤–∞—Ä",
		"–ø—Ä–æ–¥—É–∫—Ç": "–ø—Ä–æ–¥—É–∫—Ç",
		"—Ü–µ–Ω–∞": "—Ü–µ–Ω–∞",
		"—Å—Ç–æ–∏–º–æ—Å—Ç—å": "—Å—Ç–æ–∏–º–æ—Å—Ç—å",
		"–æ–ø–ª–∞—Ç–∞": "–æ–ø–ª–∞—Ç–∞",
		"–ø–ª–∞—Ç–µ–∂": "–ø–ª–∞—Ç–µ–∂",
		"—Å—á–µ—Ç": "—Å—á–µ—Ç"
	}
}

def get_locale(key):
	lang = Locale.getDefault().getLanguage()
	locale_dict = LANGUAGE_PACKS.get(lang, LANGUAGE_PACKS["en"])
	return locale_dict.get(key, key)

def translate_text(text, to_latin=True, style="small_caps"):
	if not text or not isinstance(text, str):
		return text
	
	translation_map = TRANSLATION_MAPS.get(style, TRANSLATION_MAPS["small_caps"])
	
	if not to_latin:
		translation_map = {v: k for k, v in translation_map.items()}
	
	sorted_map = dict(sorted(translation_map.items(), key=lambda x: len(x[0]), reverse=True))
	result = text
	
	for source, target in sorted_map.items():
		upper_source = source.upper()
		upper_target = translation_map.get(upper_source, target.upper())
		result = result.replace(upper_source, upper_target)
		result = result.replace(source, target)
	
	return result

def capitalize_first_letter(text):
	for i, char in enumerate(text):
		if char.isalpha():
			return text[:i] + text[i].upper() + text[i+1:]
	return text

def format_text_basic(text, capitalize=False, add_symbol=False, symbol="."):
	if not text or not isinstance(text, str):
		return text
	
	result = text
	
	if capitalize:
		sentence_pattern = re.compile(r'(?<=[\.\!\?])\s+')
		parts = sentence_pattern.split(result)
		formatted_parts = []
		for part in parts:
			stripped = part.lstrip()
			if not stripped:
				formatted_parts.append(part)
				continue
			leading_len = len(part) - len(stripped)
			leading = part[:leading_len]
			content = capitalize_first_letter(part[leading_len:])
			formatted_parts.append(leading + content)
		result = " ".join([p.strip() for p in formatted_parts]).strip()
	
	if add_symbol and result and symbol:
		if result[-1] not in ".!?":
			result = result + symbol
	
	return result

def apply_writing_style(text, style="business"):
	if not text or not isinstance(text, str):
		return text
	
	style_dict = WRITING_STYLES.get(style, {})
	if not style_dict:
		return text
	
	result = text.lower()
	
	sorted_replacements = sorted(style_dict.items(), key=lambda x: len(x[0]), reverse=True)
	
	for original, replacement in sorted_replacements:
		pattern = r'\b' + re.escape(original) + r'\b'
		result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)
	
	return result

def fix_text_with_ai(text):
	try:
		api_url = "https://keyboard.yandex.net/gpt/fix"
		payload = {"text": text}
		headers = {
			"Content-Type": "application/json; charset=utf-8",
			"User-Agent": "okhttp/4.12.0",
			"Connection": "Keep-Alive",
			"Accept-Encoding": "gzip"
		}
		
		response = requests.post(
			api_url,
			headers=headers,
			data=json.dumps(payload, ensure_ascii=False).encode("utf-8"),
			timeout=8
		)
		
		if response.status_code == 200:
			data = response.json()
			fixed = data.get("response", "").strip()
			if fixed:
				return fixed
	except Exception:
		pass
	
	return text

def shorten_links(text):
	url_pattern = re.compile(r'https?://[^\s]+')
	
	def shorten_url(match):
		original_url = match.group(0)
		try:
			response = requests.get(
				f"https://tinyurl.com/api-create.php?url={original_url}",
				timeout=5
			)
			if response.status_code == 200:
				shortened = response.text.strip()
				if shortened and shortened.startswith("http"):
					return shortened
		except Exception:
			pass
		return original_url
	
	return url_pattern.sub(shorten_url, text)

def cleanup_links(text):
	tracking_params = [
		'utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content',
		'fbclid', 'gclid', 'yclid', 'msclkid', '_ga', 'mc_cid', 'mc_eid',
		'ref', 'referrer', 'source', 'campaign', 'affiliate', 'click_id',
		'igshid', 'igsh', 'si', 'feature', 'app', 'track', 'tracking'
	]
	
	url_pattern = re.compile(r'https?://[^\s]+')
	
	def clean_url(match):
		url = match.group(0)
		if '?' not in url:
			return url
		
		try:
			base_url, query_string = url.split('?', 1)
			params = query_string.split('&')
			cleaned_params = []
			
			for param in params:
				if '=' in param:
					key = param.split('=', 1)[0].lower()
					if key not in tracking_params:
						cleaned_params.append(param)
				else:
					cleaned_params.append(param)
			
			if cleaned_params:
				return base_url + '?' + '&'.join(cleaned_params)
			else:
				return base_url
		except Exception:
			return url
	
	return url_pattern.sub(clean_url, text)

class _ExToolTextHook:
	def __init__(self, plugin: "ExToolPlugin"):
		self.plugin = plugin
		try:
			self.style_span_class = jclass("org.telegram.ui.Components.TextStyleSpan")
			self.spannable_class = jclass("android.text.Spannable")
		except Exception:
			self.style_span_class = None
			self.spannable_class = None

	def after_hooked_method(self, param: Any) -> None:
		if not self.plugin.get_setting("enable_antispoiler", True):
			return
		
		try:
			text_content = None
			try:
				text_content = param.args[0]
			except Exception:
				return

			if text_content is None:
				return

			try:
				if self.spannable_class is not None and not self.spannable_class.isInstance(text_content):
					return
			except Exception:
				pass

			if self.style_span_class is None:
				return

			content_length = 0
			try:
				content_length = text_content.length()
			except Exception:
				return

			text_spans = None
			try:
				text_spans = text_content.getSpans(0, content_length, self.style_span_class)
			except Exception:
				return

			if not text_spans:
				return

			for current_span in list(text_spans):
				try:
					if current_span is None:
						continue
					has_spoiler = False
					try:
						has_spoiler = bool(current_span.isSpoiler())
					except Exception:
						try:
							span_flags = int(getattr(current_span, "getStyleFlags")())
							has_spoiler = (span_flags & 256) != 0
						except Exception:
							has_spoiler = False

					if not has_spoiler:
						continue
					try:
						text_content.removeSpan(current_span)
					except Exception:
						pass
				except Exception:
					pass
		except Exception:
			pass


class _ForwardLimitHook(MethodHook):
	def __init__(self, plugin):
		self.plugin = plugin
		self.limit_reached_hooked = False
	
	def after_hooked_method(self, param):
		try:
			if self.limit_reached_hooked:
				return
			
			chat_list_view = get_private_field(param.thisObject, "chatListView")
			if not chat_list_view:
				return
			
			selection_listener = get_private_field(chat_list_view, "multiSelectionListener")
			if not selection_listener:
				return
			
			limit_method = selection_listener.getClass().getMethod("limitReached")
			if limit_method:
				self.plugin.hook_method(limit_method, _BypassLimitReachedHook())
				self.limit_reached_hooked = True
				log("[ExTool] Hooked limitReached method")
		except Exception as e:
			log(f"[ExTool] Failed to hook limitReached: {e}")


class _BypassLimitReachedHook:
	def replace_hooked_method(self, param):
		return False


class _RoundVideoResolutionHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		setting_index = self.plugin.get_setting("round_video_resolution", 2)
		resolution_value = ROUND_VIDEO_RESOLUTIONS[setting_index]
		return jint(resolution_value)


class _RoundVideoBitrateHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		setting_index = self.plugin.get_setting("round_video_bitrate", 2)
		bitrate_value = ROUND_VIDEO_BITRATES[setting_index]
		return jint(bitrate_value)


class _AddRecentGifReplacement(MethodReplacement):
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		try:
			this_obj = param.thisObject
			document = param.args[0]
			
			if document is None:
				return None
			
			recentGifs_field = this_obj.getClass().getDeclaredField("recentGifs")
			recentGifs_field.setAccessible(True)
			recentGifs = recentGifs_field.get(this_obj)
			
			i2 = 0
			while i2 < recentGifs.size():
				document2 = recentGifs.get(i2)
				if document2.id == document.id:
					recentGifs.remove(i2)
					recentGifs.add(0, document2)
					break
				i2 += 1
			else:
				recentGifs.add(0, document)
			
			arrayList = ArrayList()
			arrayList.add(document)
			
			try:
				from java.lang import Class
				J_Boolean = jclass("java.lang.Boolean")
				ArrayList_class = Class.forName("java.util.ArrayList")
				processMethod = this_obj.getClass().getDeclaredMethod(
					"processLoadedRecentDocuments",
					Integer.TYPE,
					ArrayList_class,
					J_Boolean.TYPE,
					Integer.TYPE,
					J_Boolean.TYPE
				)
				processMethod.setAccessible(True)
				processMethod.invoke(this_obj, 0, arrayList, True, param.args[1], False)
			except Exception as e:
				log(f"[ExTool] Error calling processLoadedRecentDocuments: {e}")
		except Exception as e:
			log(f"[ExTool] Error in GIF replacement: {e}")
		
		return None


class _MessagesControllerInitHook(MethodHook):
	def __init__(self, plugin):
		self.plugin = plugin
	
	def after_hooked_method(self, param):
		try:
			this_obj = param.thisObject
			if this_obj:
				this_obj.savedGifsLimitDefault = 999999
				this_obj.savedGifsLimitPremium = 999999
				log("[ExTool] GIF limits set to unlimited")
				
				if self.plugin.get_setting("enable_unlimited_pins", False):
					max_val = int(self.plugin.get_setting("unlimited_pins_max", 100000))
					this_obj.maxPinnedDialogsCountDefault = max_val
					this_obj.maxPinnedDialogsCountPremium = max_val
					this_obj.maxFolderPinnedDialogsCountDefault = max_val
					this_obj.maxFolderPinnedDialogsCountPremium = max_val
					this_obj.dialogFiltersPinnedLimitDefault = max_val
					this_obj.dialogFiltersPinnedLimitPremium = max_val
					log(f"[ExTool] Pin limits set to unlimited: {max_val}")
		except Exception as e:
			log(f"[ExTool] Error setting GIF limits: {e}")


class _NoForwardsHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		return False


class _PhotoQualityHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		return jint(100)


class _VideoQualityHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		return jint(0)


class ExToolPlugin(BasePlugin):
	def __init__(self):
		super().__init__()
		self.message_cache = {}
		self.hook_storage = []
		self._unlimited_pins_original_limits = []
	
	def _read_pin_limits(self) -> List[int]:
		controller = get_messages_controller()
		if controller is None:
			return []
		return [
			int(getattr(controller, "maxPinnedDialogsCountDefault", 0) or 0),
			int(getattr(controller, "maxPinnedDialogsCountPremium", 0) or 0),
			int(getattr(controller, "maxFolderPinnedDialogsCountDefault", 0) or 0),
			int(getattr(controller, "maxFolderPinnedDialogsCountPremium", 0) or 0),
			int(getattr(controller, "dialogFiltersPinnedLimitDefault", 0) or 0),
			int(getattr(controller, "dialogFiltersPinnedLimitPremium", 0) or 0),
		]
	
	def _apply_pin_limits(self, value: int) -> None:
		controller = get_messages_controller()
		if controller is None:
			return
		try:
			set_private_field(controller, "maxPinnedDialogsCountDefault", Integer(value))
			set_private_field(controller, "maxPinnedDialogsCountPremium", Integer(value))
			set_private_field(controller, "maxFolderPinnedDialogsCountDefault", Integer(value))
			set_private_field(controller, "maxFolderPinnedDialogsCountPremium", Integer(value))
			set_private_field(controller, "dialogFiltersPinnedLimitDefault", Integer(value))
			set_private_field(controller, "dialogFiltersPinnedLimitPremium", Integer(value))
			log(f"[ExTool] Applied unlimited pin limits: {value}")
		except Exception as e:
			log(f"[ExTool] Failed to apply pin limits: {e}")
	
	def _restore_pin_limits(self) -> None:
		if not self._unlimited_pins_original_limits:
			return
		controller = get_messages_controller()
		if controller is None:
			return
		try:
			d_def, d_pre, f_def, f_pre, df_def, df_pre = self._unlimited_pins_original_limits
			set_private_field(controller, "maxPinnedDialogsCountDefault", Integer(d_def))
			set_private_field(controller, "maxPinnedDialogsCountPremium", Integer(d_pre))
			set_private_field(controller, "maxFolderPinnedDialogsCountDefault", Integer(f_def))
			set_private_field(controller, "maxFolderPinnedDialogsCountPremium", Integer(f_pre))
			set_private_field(controller, "dialogFiltersPinnedLimitDefault", Integer(df_def))
			set_private_field(controller, "dialogFiltersPinnedLimitPremium", Integer(df_pre))
			log("[ExTool] Restored original pin limits")
		except Exception as e:
			log(f"[ExTool] Failed to restore pin limits: {e}")
	
	def _on_unlimited_pins_change(self, enabled: bool):
		try:
			if enabled:
				max_val = int(self.get_setting("unlimited_pins_max", 100000))
				self._apply_pin_limits(max_val)
				self._hook_unlimited_pins()
			else:
				self._restore_pin_limits()
		except Exception as e:
			log(f"[ExTool] unlimited_pins_change error: {e}")
	
	def _on_unlimited_pins_max_change(self, new_value: str):
		try:
			value = int(new_value)
			if value < 1:
				value = 100000
			if self.get_setting("enable_unlimited_pins", False):
				self._apply_pin_limits(value)
				
				mc = get_messages_controller()
				if mc:
					mc.maxPinnedDialogsCountDefault = value
					mc.maxPinnedDialogsCountPremium = value
					mc.maxFolderPinnedDialogsCountDefault = value
					mc.maxFolderPinnedDialogsCountPremium = value
					mc.dialogFiltersPinnedLimitDefault = value
					mc.dialogFiltersPinnedLimitPremium = value
					log(f"[ExTool] Updated pin limits to: {value}")
		except Exception as e:
			log(f"[ExTool] unlimited_pins_max_change error: {e}")
	
	def _on_round_video_settings_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_round_video_settings()
			else:
				for hook_item in list(self.hook_storage):
					try:
						self.unhook_method(hook_item)
					except Exception:
						pass
				self.hook_storage.clear()
		except Exception as e:
			log(f"[ExTool] round_video_settings_change error: {e}")
	
	def _on_unlimited_gifs_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_unlimited_gifs()
			else:
				mc = get_messages_controller()
				if mc:
					mc.savedGifsLimitDefault = 200
					mc.savedGifsLimitPremium = 400
					log("[ExTool] Restored default GIF limits")
		except Exception as e:
			log(f"[ExTool] unlimited_gifs_change error: {e}")
	
	def _on_noforwards_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_noforwards()
		except Exception as e:
			log(f"[ExTool] noforwards_change error: {e}")
	
	def _on_photo_quality_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_photo_quality()
		except Exception as e:
			log(f"[ExTool] photo_quality_change error: {e}")
	
	def _on_video_quality_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_video_quality()
		except Exception as e:
			log(f"[ExTool] video_quality_change error: {e}")
	
	def on_plugin_load(self):
		self._unlimited_pins_original_limits = self._read_pin_limits()
		
		if self.get_setting("enable_unlimited_pins", False):
			max_val = int(self.get_setting("unlimited_pins_max", 100000))
			self._apply_pin_limits(max_val)
			self._hook_unlimited_pins()
		
		if self.get_setting("enable_antispoiler", True):
			try:
				self._hook_add_entities_methods()
				self._hook_media_spoilers()
			except Exception:
				pass
		
		if self.get_setting("enable_round_video_settings", False):
			self._hook_round_video_settings()
		
		if self.get_setting("enable_no_forward_limit", True):
			self._hook_forward_limit()
		
		if self.get_setting("enable_unlimited_gifs", False):
			self._hook_unlimited_gifs()
		
		if self.get_setting("enable_noforwards_bypass", False):
			self._hook_noforwards()
		
		if self.get_setting("enable_max_photo_quality", False):
			self._hook_photo_quality()
		
		if self.get_setting("enable_enhanced_video_quality", False):
			self._hook_video_quality()
		
		self.add_menu_item(
			MenuItemData(
				menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
				text=get_locale("translate_menu"),
				on_click=self._process_menu_action,
				icon="msg_translate"
			)
		)
		
		self.add_on_send_message_hook()
	
	def _hook_forward_limit(self):
		try:
			chat_activity_class = find_class("org.telegram.ui.ChatActivity")
			if not chat_activity_class:
				return
			
			try:
				multi_selector_method = chat_activity_class.getClass().getDeclaredMethod("startMultiselect", Integer.TYPE)
				multi_selector_method.setAccessible(True)
				hook_ref = self.hook_method(multi_selector_method, _ForwardLimitHook(self))
				self.hook_storage.append(hook_ref)
				log("[ExTool] Hooked forward limit bypass")
			except Exception as e:
				log(f"[ExTool] Failed to hook forward limit: {e}")
		except Exception as e:
			log(f"[ExTool] Failed to setup forward limit hook: {e}")
	
	def _hook_round_video_settings(self):
		try:
			system_utils = find_class("com.exteragram.messenger.utils.SystemUtils")
			if not system_utils:
				return
			
			try:
				resolution_method = system_utils.getClass().getDeclaredMethod("getRoundVideoResolution")
				if resolution_method:
					hook_ref = self.hook_method(resolution_method, _RoundVideoResolutionHook(self))
					self.hook_storage.append(hook_ref)
			except Exception as e:
				log(f"[ExTool] Failed to hook round video resolution: {e}")
			
			try:
				bitrate_method = system_utils.getClass().getDeclaredMethod("getRoundVideoBitrate")
				if bitrate_method:
					hook_ref = self.hook_method(bitrate_method, _RoundVideoBitrateHook(self))
					self.hook_storage.append(hook_ref)
			except Exception as e:
				log(f"[ExTool] Failed to hook round video bitrate: {e}")
		except Exception as e:
			log(f"[ExTool] Failed to hook round video settings: {e}")
	
	def _hook_unlimited_gifs(self):
		try:
			mc = get_messages_controller()
			if mc:
				mc.savedGifsLimitDefault = 999999
				mc.savedGifsLimitPremium = 999999
				log("[ExTool] Set GIF limits immediately")
		except Exception as e:
			log(f"[ExTool] Could not set GIF limits immediately: {e}")
		
		try:
			MessagesController = find_class("org.telegram.messenger.MessagesController")
			if not MessagesController:
				log("[ExTool] MessagesController class not found!")
				return
			
			try:
				constructor = MessagesController.getClass().getDeclaredConstructor(Integer.TYPE)
				handler = _MessagesControllerInitHook(self)
				hook_ref = self.hook_method(constructor, handler)
				if hook_ref:
					self.hook_storage.append(hook_ref)
					log("[ExTool] Hooked MessagesController constructor for GIFs")
			except Exception as e:
				log(f"[ExTool] Error hooking MessagesController constructor: {e}")
			
			try:
				from java.lang import Class
				J_Boolean = jclass("java.lang.Boolean")
				MediaDataControllerClass = Class.forName("org.telegram.messenger.MediaDataController")
				TLRPCDocumentClass = Class.forName("org.telegram.tgnet.TLRPC$Document")
				
				add_gif_method = MediaDataControllerClass.getDeclaredMethod(
					"addRecentGif",
					TLRPCDocumentClass,
					Integer.TYPE,
					J_Boolean.TYPE
				)
				add_gif_method.setAccessible(True)
				
				gif_handler = _AddRecentGifReplacement(self)
				hook_ref = self.hook_method(add_gif_method, gif_handler)
				if hook_ref:
					self.hook_storage.append(hook_ref)
					log("[ExTool] Hooked addRecentGif method")
			except Exception as e:
				log(f"[ExTool] Error hooking addRecentGif: {e}")
		except Exception as e:
			log(f"[ExTool] Error in _hook_unlimited_gifs: {e}")
	
	def _hook_unlimited_pins(self):
		try:
			MessagesController = find_class("org.telegram.messenger.MessagesController")
			if not MessagesController:
				log("[ExTool] MessagesController class not found for pins!")
				return
			
			try:
				constructor = MessagesController.getClass().getDeclaredConstructor(Integer.TYPE)
				handler = _MessagesControllerInitHook(self)
				hook_ref = self.hook_method(constructor, handler)
				if hook_ref:
					self.hook_storage.append(hook_ref)
					log("[ExTool] Hooked MessagesController for unlimited pins")
			except Exception as e:
				log(f"[ExTool] Error hooking MessagesController for pins: {e}")
			
			mc = get_messages_controller()
			if mc:
				max_val = int(self.get_setting("unlimited_pins_max", 100000))
				mc.maxPinnedDialogsCountDefault = max_val
				mc.maxPinnedDialogsCountPremium = max_val
				mc.maxFolderPinnedDialogsCountDefault = max_val
				mc.maxFolderPinnedDialogsCountPremium = max_val
				mc.dialogFiltersPinnedLimitDefault = max_val
				mc.dialogFiltersPinnedLimitPremium = max_val
				log(f"[ExTool] Set pin limits immediately to: {max_val}")
		except Exception as e:
			log(f"[ExTool] Error in _hook_unlimited_pins: {e}")
	
	def _hook_noforwards(self):
		try:
			MessageObject = find_class("org.telegram.messenger.MessageObject")
			if not MessageObject:
				return
			
			try:
				noforwards_method = MessageObject.getClass().getDeclaredMethod("isNoForwards")
				if noforwards_method:
					noforwards_method.setAccessible(True)
					hook_ref = self.hook_method(noforwards_method, _NoForwardsHook(self))
					if hook_ref:
						self.hook_storage.append(hook_ref)
						log("[ExTool] Hooked NoForwards bypass")
			except Exception as e:
				log(f"[ExTool] Error hooking NoForwards: {e}")
		except Exception as e:
			log(f"[ExTool] Error in _hook_noforwards: {e}")
	
	def _hook_photo_quality(self):
		try:
			ImageLoader = find_class("org.telegram.messenger.ImageLoader")
			if not ImageLoader:
				return
			
			try:
				from java.lang import Class
				String_class = Class.forName("java.lang.String")
				
				quality_method = ImageLoader.getClass().getDeclaredMethod(
					"getHttpUrlLocationSize",
					String_class,
					Integer.TYPE
				)
				if quality_method:
					quality_method.setAccessible(True)
					hook_ref = self.hook_method(quality_method, _PhotoQualityHook(self))
					if hook_ref:
						self.hook_storage.append(hook_ref)
						log("[ExTool] Hooked photo quality")
			except Exception as e:
				log(f"[ExTool] Error hooking photo quality: {e}")
			
			try:
				SendMessagesHelper = find_class("org.telegram.messenger.SendMessagesHelper")
				if SendMessagesHelper:
					compress_method = SendMessagesHelper.getClass().getDeclaredMethod("shouldSendWebPAsSticker")
					if compress_method:
						compress_method.setAccessible(True)
						hook_ref = self.hook_method(compress_method, _NoForwardsHook(self))
						if hook_ref:
							self.hook_storage.append(hook_ref)
			except Exception as e:
				log(f"[ExTool] Error hooking compress: {e}")
		except Exception as e:
			log(f"[ExTool] Error in _hook_photo_quality: {e}")
	
	def _hook_video_quality(self):
		try:
			MediaController = find_class("org.telegram.messenger.MediaController")
			if not MediaController:
				return
			
			try:
				getVideoQuality_method = MediaController.getClass().getDeclaredMethod("getVideoQuality")
				if getVideoQuality_method:
					getVideoQuality_method.setAccessible(True)
					hook_ref = self.hook_method(getVideoQuality_method, _VideoQualityHook(self))
					if hook_ref:
						self.hook_storage.append(hook_ref)
						log("[ExTool] Hooked video quality (best)")
			except Exception as e:
				log(f"[ExTool] Error hooking video quality: {e}")
		except Exception as e:
			log(f"[ExTool] Error in _hook_video_quality: {e}")

	def on_plugin_unload(self):
		self._restore_pin_limits()
		
		try:
			for hook_item in list(self.hook_storage):
				try:
					self.unhook_method(hook_item)
				except Exception:
					pass
			self.hook_storage.clear()
		except Exception:
			pass

	def create_settings(self):
		return [
			Header(text=get_locale("title")),
			Switch(
				key="auto_translate_enabled",
				text=get_locale("auto_translate"),
				subtext=get_locale("auto_translate_subtext"),
				default=False
			),
			Header(text=get_locale("style_header")),
			Selector(
				key="alphabet_style_type",
				text=get_locale("alphabet_style_type"),
				items=[get_locale("use_small_caps"), get_locale("use_fraktur"), get_locale("use_special"), get_locale("use_standard")],
				default=0
			),
			
			Header(text=""),
			Header(text=get_locale("signature_header")),
			Switch(
				key="enable_signature",
				text=get_locale("enable_signature"),
				subtext=get_locale("signature_subtext"),
				default=False
			),
			Input(
				key="signature_line_1",
				text="–°—Ç—Ä–æ–∫–∞ 1",
				default=""
			),
			Input(
				key="signature_line_2",
				text="–°—Ç—Ä–æ–∫–∞ 2",
				default=""
			),
			Input(
				key="signature_line_3",
				text="–°—Ç—Ä–æ–∫–∞ 3",
				default=""
			),
			Input(
				key="signature_line_4",
				text="–°—Ç—Ä–æ–∫–∞ 4",
				default=""
			),
			Input(
				key="signature_line_5",
				text="–°—Ç—Ä–æ–∫–∞ 5",
				default=""
			),
			Switch(
				key="signature_at_start",
				text=get_locale("signature_start"),
				default=False
			),
			Switch(
				key="signature_at_end",
				text=get_locale("signature_end"),
				default=True
			),
			Switch(
				key="enable_for_private",
				text=get_locale("enable_for_private"),
				default=True
			),
			Switch(
				key="enable_for_groups",
				text=get_locale("enable_for_groups"),
				default=True
			),
			Switch(
				key="enable_for_channels",
				text=get_locale("enable_for_channels"),
				default=True
			),
			
			Header(text=""),
			Header(text=get_locale("antispoiler_header")),
			Switch(
				key="enable_antispoiler",
				text=get_locale("enable_antispoiler"),
				subtext=get_locale("antispoiler_subtext"),
				default=True
			),
			
			Header(text=""),
			Header(text=get_locale("link_cleaner_header")),
			Switch(
				key="enable_link_cleaner",
				text=get_locale("enable_link_cleaner"),
				subtext=get_locale("link_cleaner_subtext"),
				default=False
			),
			Switch(
				key="enable_link_shortener",
				text=get_locale("enable_link_shortener"),
				subtext=get_locale("link_shortener_subtext"),
				default=False
			),
			Switch(
				key="enable_link_cleanup",
				text=get_locale("enable_link_cleanup"),
				subtext=get_locale("link_cleanup_subtext"),
				default=False
			),
			
			Header(text=""),
			Header(text=get_locale("text_formatter_header")),
			Switch(
				key="enable_ai_correction",
				text=get_locale("enable_ai_correction"),
				subtext=get_locale("ai_correction_subtext"),
				default=False
			),
			Switch(
				key="enable_capitalize",
				text=get_locale("enable_capitalize"),
				subtext=get_locale("capitalize_subtext"),
				default=False
			),
			Switch(
				key="enable_final_symbol",
				text=get_locale("enable_final_symbol"),
				subtext=get_locale("final_symbol_subtext"),
				default=False
			),
			Input(
				key="final_symbol_text",
				text=get_locale("final_symbol_text"),
				default=".",
				subtext="."
			),
			
			Header(text=""),
			Header(text=get_locale("writing_style_header")),
			Switch(
				key="enable_writing_style",
				text=get_locale("enable_writing_style"),
				subtext=get_locale("writing_style_subtext"),
				default=False
			),
			Selector(
				key="writing_style_type",
				text=get_locale("writing_style_type"),
				items=[get_locale("style_business"), get_locale("style_casual"), get_locale("style_official"), get_locale("style_bydlo")],
				default=0
			),
			
			Header(text=""),
			Header(text=get_locale("unlimited_pins_header")),
			Switch(
				key="enable_unlimited_pins",
				text=get_locale("enable_unlimited_pins"),
				subtext=get_locale("unlimited_pins_subtext"),
				default=False,
				on_change=self._on_unlimited_pins_change
			),
			Input(
				key="unlimited_pins_max",
				text=get_locale("unlimited_pins_max"),
				default="100000",
				on_change=self._on_unlimited_pins_max_change
			),
			
			Header(text=""),
			Header(text=get_locale("round_video_header")),
			Switch(
				key="enable_round_video_settings",
				text=get_locale("enable_round_video_settings"),
				subtext=get_locale("round_video_subtext"),
				default=False,
				on_change=self._on_round_video_settings_change
			),
			Selector(
				key="round_video_resolution",
				text=get_locale("round_video_resolution"),
				items=[str(r) for r in ROUND_VIDEO_RESOLUTIONS],
				default=2
			),
			Selector(
				key="round_video_bitrate",
				text=get_locale("round_video_bitrate"),
				items=[str(b) for b in ROUND_VIDEO_BITRATES],
				default=2
			),
			
			Header(text=""),
			Header(text=get_locale("forward_limit_header")),
			Switch(
				key="enable_no_forward_limit",
				text=get_locale("enable_no_forward_limit"),
				subtext=get_locale("forward_limit_subtext"),
				default=True
			),
			
			Header(text=""),
			Header(text=get_locale("unlimited_gifs_header")),
			Switch(
				key="enable_unlimited_gifs",
				text=get_locale("enable_unlimited_gifs"),
				subtext=get_locale("unlimited_gifs_subtext"),
				default=False,
				on_change=self._on_unlimited_gifs_change
			),
			
			Header(text=""),
			Header(text=get_locale("noforwards_header")),
			Switch(
				key="enable_noforwards_bypass",
				text=get_locale("enable_noforwards_bypass"),
				subtext=get_locale("noforwards_subtext"),
				default=False,
				on_change=self._on_noforwards_change
			),
			
			Header(text=""),
			Header(text=get_locale("photo_quality_header")),
			Switch(
				key="enable_max_photo_quality",
				text=get_locale("enable_max_photo_quality"),
				subtext=get_locale("photo_quality_subtext"),
				default=False,
				on_change=self._on_photo_quality_change
			),
			
			Header(text=""),
			Header(text=get_locale("video_quality_header")),
			Switch(
				key="enable_enhanced_video_quality",
				text=get_locale("enable_enhanced_video_quality"),
				subtext=get_locale("video_quality_subtext"),
				default=False,
				on_change=self._on_video_quality_change
			)
		]
	
	def _hook_add_entities_methods(self) -> None:
		try:
			msg_obj_class = find_class("org.telegram.messenger.MessageObject")
			if msg_obj_class is None:
				return

			class_ref = msg_obj_class.getClass()
			method_list = []
			try:
				method_list = list(class_ref.getDeclaredMethods())
			except Exception:
				method_list = []

			hooks_installed = 0
			for method_item in method_list:
				try:
					if method_item is None:
						continue
					method_name = None
					try:
						method_name = method_item.getName()
					except Exception:
						method_name = None
					if method_name != "addEntitiesToText":
						continue
					method_item.setAccessible(True)
					hook_ref = self.hook_method(method_item, _ExToolTextHook(self))
					if hook_ref is not None:
						self.hook_storage.append(hook_ref)
						hooks_installed += 1
				except Exception:
					pass
		except Exception:
			pass

	def _hook_media_spoilers(self) -> None:
		try:
			msg_obj_class = find_class("org.telegram.messenger.MessageObject")
			if msg_obj_class is None:
				return
			class_ref = msg_obj_class.getClass()
			media_method = class_ref.getDeclaredMethod("hasMediaSpoilers")
			media_method.setAccessible(True)

			class _ExToolMediaHook:
				def __init__(self, plugin: "ExToolPlugin"):
					self.plugin = plugin

				def before_hooked_method(self, param: Any) -> None:
					if not self.plugin.get_setting("enable_antispoiler", True):
						return
					
					try:
						message_obj = param.thisObject
						msg_owner = None
						try:
							msg_owner = getattr(message_obj, "messageOwner")
						except Exception:
							msg_owner = None
						if msg_owner is None:
							msg_owner = get_private_field(message_obj, "messageOwner")
						if msg_owner is None:
							return

						msg_media = None
						try:
							msg_media = getattr(msg_owner, "media")
						except Exception:
							msg_media = None
						if msg_media is None:
							return

						has_spoiler_flag = False
						try:
							has_spoiler_flag = bool(getattr(msg_media, "spoiler"))
						except Exception:
							has_spoiler_flag = False

						if has_spoiler_flag:
							try:
								setattr(message_obj, "isMediaSpoilersRevealed", True)
							except Exception:
								pass
							try:
								setattr(message_obj, "isMediaSpoilersRevealedInSharedMedia", True)
							except Exception:
								pass
							try:
								setattr(message_obj, "revealingMediaSpoilers", False)
							except Exception:
								pass

							try:
								setattr(msg_media, "spoiler", False)
							except Exception:
								pass

							param.setResult(False)
					except Exception:
						pass

			hook_ref = self.hook_method(media_method, _ExToolMediaHook(self))
			if hook_ref is not None:
				self.hook_storage.append(hook_ref)
		except Exception:
			pass
	
	def _get_alphabet_style(self):
		style_index = self.get_setting("alphabet_style_type", 0)
		style_names = ["small_caps", "fraktur", "special", "standard"]
		if 0 <= style_index < len(style_names):
			return style_names[style_index]
		return "small_caps"
	
	def _determine_chat_type(self, peer_id):
		if peer_id > 0:
			return True, False, False
		
		try:
			msg_controller = get_messages_controller()
			chat_info = msg_controller.getChat(abs(peer_id))
			if chat_info:
				if isinstance(chat_info, TLRPC.TL_channel):
					if getattr(chat_info, "megagroup", False):
						return False, True, False
					else:
						return False, False, True
				if isinstance(chat_info, TLRPC.TL_chat):
					return False, True, False
		except:
			pass
		
		return False, False, False
	
	def _extract_peer_id(self, params_peer):
		try:
			if isinstance(params_peer, int):
				return params_peer
			return int(params_peer)
		except:
			pass
		
		try:
			msg_ctrl = get_messages_controller()
			if hasattr(msg_ctrl, "getPeerId"):
				peer_result = msg_ctrl.getPeerId(params_peer)
				if isinstance(peer_result, int):
					return peer_result
		except:
			pass
		
		try:
			if hasattr(params_peer, "user_id") and params_peer.user_id:
				return int(params_peer.user_id)
			if hasattr(params_peer, "chat_id") and params_peer.chat_id:
				return -int(abs(params_peer.chat_id))
			if hasattr(params_peer, "channel_id") and params_peer.channel_id:
				return int(f"-100{params_peer.channel_id}")
		except:
			pass
		
		return 0
	
	def _apply_signature(self, original_text, original_entities):
		enable_signature = self.get_setting("enable_signature", False)
		if not enable_signature:
			return original_text, original_entities
		
		signature_lines = []
		for i in range(1, 6):
			line = self.get_setting(f"signature_line_{i}", "").strip()
			if line:
				signature_lines.append(line)
		
		if not signature_lines:
			return original_text, original_entities
		
		signature_text = "\n".join(signature_lines)
		
		try:
			parsed = parse_markdown(signature_text)
			signature_plain = parsed.text
			signature_entities = parsed.entities
		except:
			signature_plain = signature_text
			signature_entities = []
		
		if not signature_plain:
			return original_text, original_entities
		
		signature_position_start = self.get_setting("signature_at_start", False)
		signature_position_end = self.get_setting("signature_at_end", True)
		
		combined_entities = ArrayList()
		
		def shift_entities(entity_list, source_list, text_offset):
			if not source_list:
				return
			for idx in range(source_list.size()):
				source_entity = source_list.get(idx)
				copied_entity = source_entity.getClass().getConstructor().newInstance()
				copied_entity.offset = source_entity.offset + text_offset
				copied_entity.length = source_entity.length
				if hasattr(source_entity, "url"):
					copied_entity.url = source_entity.url
				if hasattr(source_entity, "language"):
					copied_entity.language = source_entity.language
				if hasattr(source_entity, "user_id"):
					copied_entity.user_id = source_entity.user_id
				entity_list.add(copied_entity)
		
		def shift_parsed_entities(entity_list, parsed_list, text_offset):
			for parsed_item in parsed_list:
				tlrpc_entity = parsed_item.to_tlrpc_object()
				tlrpc_entity.offset += text_offset
				entity_list.add(tlrpc_entity)
		
		if signature_position_start and signature_position_end:
			result_text = f"{signature_plain}\n\n{original_text}\n\n{signature_plain}"
			shift_parsed_entities(combined_entities, signature_entities, 0)
			if original_entities:
				shift_entities(combined_entities, original_entities, len(signature_plain) + 2)
			shift_parsed_entities(combined_entities, signature_entities, len(signature_plain) + 2 + len(original_text) + 2)
		elif signature_position_start:
			result_text = f"{signature_plain}\n\n{original_text}"
			shift_parsed_entities(combined_entities, signature_entities, 0)
			if original_entities:
				shift_entities(combined_entities, original_entities, len(signature_plain) + 2)
		elif signature_position_end:
			result_text = f"{original_text}\n\n{signature_plain}"
			if original_entities:
				for idx in range(original_entities.size()):
					combined_entities.add(original_entities.get(idx))
			shift_parsed_entities(combined_entities, signature_entities, len(original_text) + 2)
		else:
			return original_text, original_entities
		
		return result_text, combined_entities

	def on_send_message_hook(self, account, params):
		if not hasattr(params, "message") or not params.message:
			return HookResult()
		
		stripped = params.message.lstrip()
		if stripped.startswith("/") or stripped.startswith("!"):
			return HookResult()
		
		target_peer = self._extract_peer_id(params.peer)
		is_private, is_group, is_channel = self._determine_chat_type(target_peer)
		
		private_enabled = self.get_setting("enable_for_private", True)
		groups_enabled = self.get_setting("enable_for_groups", True)
		channels_enabled = self.get_setting("enable_for_channels", True)
		
		chat_type_allowed = (is_private and private_enabled) or \
		                    (is_group and groups_enabled) or \
		                    (is_channel and channels_enabled)
		
		if chat_type_allowed:
			if self.get_setting("enable_writing_style", False):
				style_index = self.get_setting("writing_style_type", 0)
				style_names = ["business", "casual", "official", "bydlo"]
				if 0 <= style_index < len(style_names):
					params.message = apply_writing_style(params.message, style_names[style_index])
			
			if self.get_setting("enable_ai_correction", False):
				params.message = fix_text_with_ai(params.message)
			
			capitalize_enabled = self.get_setting("enable_capitalize", False)
			final_symbol_enabled = self.get_setting("enable_final_symbol", False)
			final_symbol = self.get_setting("final_symbol_text", ".")
			if capitalize_enabled or final_symbol_enabled:
				params.message = format_text_basic(params.message, capitalize_enabled, final_symbol_enabled, final_symbol)
			
			if self.get_setting("auto_translate_enabled", True):
				current_style = self._get_alphabet_style()
				params.message = translate_text(params.message, to_latin=True, style=current_style)
			
			params.message, params.entities = self._apply_signature(params.message, params.entities)
		
		if self.get_setting("enable_link_cleanup", False):
			params.message = cleanup_links(params.message)
		
		if self.get_setting("enable_link_shortener", False):
			params.message = shorten_links(params.message)
		
		if self.get_setting("enable_link_cleaner", False):
			params.message = params.message.replace("https://", "").replace("http://", "")
		
		return HookResult(strategy=HookStrategy.MODIFY, params=params)

	def _process_menu_action(self, context):
		target_message = context.get("message")
		if not target_message:
			return
		
		message_id = target_message.getId()
		message_text = target_message.messageText.toString()
		
		if not message_text:
			return
		
		current_fragment = get_last_fragment()
		
		if message_id in self.message_cache and self.message_cache[message_id][1] == current_fragment:
			restored_text = self.message_cache[message_id][0]
			del self.message_cache[message_id]
		else:
			active_style = self._get_alphabet_style()
			restored_text = translate_text(message_text, to_latin=False, style=active_style)
			self.message_cache[message_id] = (message_text, current_fragment)
		
		run_on_queue(lambda: self._refresh_message_view(target_message, restored_text))

	def _refresh_message_view(self, message, new_text):
		if not new_text or not isinstance(new_text, str) or not new_text.strip():
			BulletinHelper.show_error(get_locale("error"))
			return
		
		message.applyNewText(new_text)
		message.forceUpdate = True
		
		active_fragment = get_last_fragment()
		if isinstance(active_fragment, ChatActivity):
			message_cell = active_fragment.findMessageCell(message.getId(), False)
			if message_cell:
				message_cell.getMessageObject().applyNewText(new_text)
				message_cell.getMessageObject().forceUpdate = True
				message_cell.invalidate()
				BulletinHelper.show_success(get_locale("success"))
