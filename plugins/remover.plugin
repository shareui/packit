__id__ = "remover"
__name__ = "Продвинутый ластик"
__author__ = "@Sk0lovek_plugins"
__version__ = "3.3.1"
__description__ = """Автоматически удаляет указанные символы или целые слова из всех исходящих сообщений. Гибкая настройка черных и белых списков."""

# Совместимая версия
# -*- coding: utf-8 -*-

__icon__ = "Sk0lovekPlugins/2"
__min_version__ = "11.12.0"

import re
import string
from typing import Any
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from ui.settings import Switch, Header, Divider, Input
from android_utils import run_on_ui_thread
from client_utils import send_message, get_last_fragment
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from hook_utils import find_class

# Импорты, которые не вызовут ошибку в вашей версии приложения
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity

class SymbolEraserPlugin(BasePlugin):
    """
    Этот плагин удаляет или оставляет указанные пользователем символы/слова
    в отправляемых сообщениях, в зависимости от выбранного режима.
    """

    def _open_plugin_settings(self, context: dict):
        """
        Открытие настроек через 'context' для совместимости со старыми версиями.
        """
        @run_on_ui_thread
        def open_settings_action_pg():
            try:
                # сгенерировано в PluginGRT - @PluginIDEbot
                pg_java_plugin_instance = PluginsController.getInstance().plugins.get(self.id)
                pg_last_fragment = context.get('fragment')
                if pg_java_plugin_instance and pg_last_fragment:
                    pg_last_fragment.presentFragment(PluginSettingsActivity(pg_java_plugin_instance))
            except Exception as e:
                self.log(f"Не удалось открыть настройки плагина: {e}")

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text="Настройки Продвинутого ластика",
                icon="msg_settings_solar",
                on_click=self._open_plugin_settings
            )
        )

    def create_settings(self):
        """
        Создание страницы настроек плагина.
        """
        return [
            Header(text="Настройки Продвинутого ластика"),
            Switch(key="master_enabled", text="Включить плагин", subtext="Главный переключатель. Если выключен, фильтрация не работает.", default=True, icon="msg_power"),
            Switch(key="show_warning", text="Показывать предупреждение", subtext="Предупреждать перед отправкой, если сообщение будет изменено.", default=False, icon="msg_warning"),
            Divider(),
            Header(text="Фильтрация символов"),
            Switch(key="chars_enabled", text="Включить фильтрацию символов", subtext="Активирует удаление/сохранение отдельных символов.", default=False, icon="msg_delete"),
            Switch(key="chars_whitelist_mode", text="Режим белого списка для символов", subtext="Если включено, *только* указанные символы будут оставлены.", default=False, icon="filter_custom_solar"),
            Input(key="chars_to_filter", text="Символы для фильтрации", subtext="В черном списке: эти символы удалятся. В белом списке: только они останутся.", default="", icon="input_bot1_remix"),
            Switch(key="chars_case_insensitive", text="Игнорировать регистр для символов", subtext="Если включено, 'a' также обработает 'А' и наоборот.", default=False, icon="msg_text_check"),
            Divider(),
            Header(text="Фильтрация слов"),
            Switch(key="words_enabled", text="Включить фильтрацию слов", subtext="Активирует удаление/сохранение целых слов.", default=False, icon="msg_delete"),
            Switch(key="words_whitelist_mode", text="Режим белого списка для слов", subtext="Если включено, *только* указанные слова будут оставлены.", default=False, icon="filter_custom_solar"),
            Input(key="words_to_filter", text="Слова для фильтрации (через запятую)", subtext="Пример: слово1, другое слово, третье. Пунктуация по краям слов игнорируется.", default="", icon="input_bot1_remix"),
            Switch(key="words_case_insensitive", text="Игнорировать регистр для слов", subtext="Если включено, 'Слово' будет обработано так же, как 'слово'.", default=True, icon="msg_text_check"),
            Divider()
        ]

    def _show_confirmation_dialog(self, params: Any, original_text: str, final_text: str):
        """
        Показывает диалог подтверждения перед отправкой измененного сообщения.
        """
        @run_on_ui_thread
        def show_dialog_action():
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                send_message({"peer": params.peer, "message": final_text, "replyToMsg": getattr(params, 'replyToMsg', None)})
                return

            activity = fragment.getParentActivity()
            
            # Поиск необходимых Android классов
            TextUtils = find_class("android.text.TextUtils")
            Html = find_class("android.text.Html")
            Build = find_class("android.os.Build")
            AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")

            # Экранирование текста от пользователя для безопасной вставки в HTML
            escaped_original = TextUtils.htmlEncode(original_text)
            escaped_final = TextUtils.htmlEncode(final_text)

            html_message = (
                "Сообщение будет изменено:<br><br>"
                "<b>Было:</b><br><code>" + escaped_original + "</code><br><br>"
                "<b>Станет:</b><br><code>" + escaped_final + "</code><br><br>"
                "Отправить измененную версию?"
            )
            
            # Конвертация HTML в форматированный текст
            if Build.VERSION.SDK_INT >= 24: # Для Android N и выше
                formatted_message = Html.fromHtml(html_message, Html.FROM_HTML_MODE_LEGACY)
            else: # Для старых версий
                formatted_message = Html.fromHtml(html_message)

            builder = AlertDialogBuilder(activity)
            builder.set_title("Предупреждение")
            builder.set_message(formatted_message)

            def send_action(dialog, which):
                send_message({
                    "peer": params.peer, "message": final_text, "replyToMsg": getattr(params, 'replyToMsg', None)
                })
                dialog.dismiss()
            
            def cancel_action(dialog, which):
                # Копируем текст, чтобы пользователь его не потерял
                AndroidUtilities.addToClipboard(original_text)
                BulletinHelper.show_info("Текст скопирован в буфер обмена.", fragment)
                dialog.dismiss()

            builder.set_positive_button("Отправить", send_action)
            builder.set_negative_button("Отмена", cancel_action)
            builder.show()


    def _filter_characters(self, text: str) -> str:
        if not self.get_setting("chars_enabled", False): return text
        chars_to_filter = self.get_setting("chars_to_filter", "")
        if not chars_to_filter: return text
        is_case_insensitive = self.get_setting("chars_case_insensitive", False)
        is_whitelist_mode = self.get_setting("chars_whitelist_mode", False)
        effective_chars_set = set()
        if is_case_insensitive:
            for char in chars_to_filter:
                effective_chars_set.add(char.lower())
                effective_chars_set.add(char.upper())
        else:
            effective_chars_set.update(chars_to_filter)
        if is_whitelist_mode:
            return "".join([char for char in text if char in effective_chars_set])
        else:
            translation_table = str.maketrans('', '', "".join(effective_chars_set))
            return text.translate(translation_table)

    def _filter_words(self, text: str) -> str:
        if not self.get_setting("words_enabled", False): return text
        words_to_filter_str = self.get_setting("words_to_filter", "")
        if not words_to_filter_str: return text
        punctuation_to_strip = string.punctuation
        raw_words = words_to_filter_str.split(',')
        words_list = [word.strip().strip(punctuation_to_strip) for word in raw_words if word.strip()]
        if not words_list: return text
        is_whitelist_mode = self.get_setting("words_whitelist_mode", False)
        is_case_insensitive = self.get_setting("words_case_insensitive", True)
        words_to_process = []
        if is_whitelist_mode:
            all_words_in_text = re.findall(r'\b\w+\b', text)
            if is_case_insensitive:
                whitelist_set = {word.lower() for word in words_list}
                words_to_process = list({word for word in all_words_in_text if word.lower() not in whitelist_set})
            else:
                whitelist_set = set(words_list)
                words_to_process = list({word for word in all_words_in_text if word not in whitelist_set})
        else:
            words_to_process = words_list
        if not words_to_process: return text
        pattern = r'\b(' + '|'.join(re.escape(word) for word in words_to_process) + r')\b'
        flags = re.IGNORECASE if is_case_insensitive else 0
        modified_text = re.sub(pattern, '', text, flags=flags)
        return re.sub(r'\s{2,}', ' ', modified_text).strip()

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not self.get_setting("master_enabled", True): return HookResult()
        if not hasattr(params, 'message') or not isinstance(params.message, str): return HookResult()
        
        original_message = params.message
        filtered_text = self._filter_words(original_message)
        final_text = self._filter_characters(filtered_text)
        
        if original_message != final_text:
            if self.get_setting("show_warning", False):
                self._show_confirmation_dialog(params, original_message, final_text)
                return HookResult(strategy=HookStrategy.CANCEL)
            else:
                params.message = final_text
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
        return HookResult()