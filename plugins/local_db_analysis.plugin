__id__ = "local_db_analysis"
__name__ = "–ê–Ω–∞–ª–∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î"
__description__ = "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∞–Ω–∞–ª–∏–∑–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ, –ø–æ–∏—Å–∫, –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è, —ç–∫—Å–ø–æ—Ä—Ç [.localdb]"
__author__ = "@kaufapuk"
__version__ = "1.0.0"
__icon__ = "exteraPlugins/1"
__min_version__ = "12.2.10"

import os
import time
import re
from typing import Any, List, Dict, Set, Optional

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import (
    run_on_queue, send_document, send_text, 
    get_messages_controller, get_user_config, get_messages_storage,
    send_request, RequestCallback
)
from ui.settings import Switch, Selector, Input, Header, Divider
from ui.bulletin import BulletinHelper
from hook_utils import get_private_field
from file_utils import get_cache_dir, write_file
from android_utils import run_on_ui_thread, log
from org.telegram.tgnet import NativeByteBuffer, TLRPC
from java.lang import Exception as JavaException


class CursorContext:
    def __init__(self, database, query: str):
        self.database = database
        self.query = query
        self.cursor = None
    
    def __enter__(self):
        try:
            self.cursor = self.database.queryFinalized(self.query)
            return self.cursor
        except Exception as e:
            log(f"CursorContext error: {e}")
            return None
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.cursor:
            try:
                self.cursor.dispose()
            except:
                pass
        return False


class ReportBuilder:
    MAX_MESSAGE_LENGTH = 4000
    
    def __init__(self, title: str):
        self.lines = [
            f"üìä {title}",
            f"–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {time.strftime('%Y-%m-%d %H:%M:%S')}",
            "=" * 50,
            ""
        ]
    
    def add_section(self, header: str, items: List[str], limit: int = 100):
        display_items = items[:limit]
        overflow = len(items) - limit
        
        self.lines.extend([
            f"[{header}] ({len(items)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤)",
            "-" * 40
        ])
        self.lines.extend(display_items)
        
        if overflow > 0:
            self.lines.append(f"... –∏ –µ—â–µ {overflow} —ç–ª–µ–º–µ–Ω—Ç–æ–≤")
        self.lines.append("")
        return self
    
    def add_line(self, text: str):
        self.lines.append(text)
        return self
    
    def build(self) -> str:
        return "\n".join(self.lines)
    
    def build_chunks(self) -> List[str]:
        full_text = self.build()
        if len(full_text) <= self.MAX_MESSAGE_LENGTH:
            return [full_text]
        
        chunks = []
        current_chunk = []
        current_len = 0
        
        for line in full_text.split("\n"):
            line_len = len(line) + 1
            if current_len + line_len > self.MAX_MESSAGE_LENGTH:
                chunks.append("\n".join(current_chunk))
                current_chunk = [line]
                current_len = line_len
            else:
                current_chunk.append(line)
                current_len += line_len
        
        if current_chunk:
            chunks.append("\n".join(current_chunk))
        return chunks


class LocalDBAnalysisPlugin(BasePlugin):
    SQL_TABLES = [
        ("users", "uid"),
        ("dialogs", "did"),
        ("contacts", "uid"),
        ("channel_users_v2", "uid"),
        ("channel_admins_v3", "uid"),
        ("enc_chats", "user")
    ]
    
    MESSAGE_TABLES = ["messages_v2", "messages_topics"]
    
    def __init__(self):
        super().__init__()
        self._db_cache = None
        self._controller_cache = None
        self._config_cache = None
    
    def on_plugin_load(self):
        self.add_on_send_message_hook()
    
    def create_settings(self) -> List[Any]:
        return [
            Header(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∫–∞–Ω–µ—Ä–∞"),
            Switch(
                key="auto_export",
                text="–¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Ç–µ–∫—Å—Ç–æ–º",
                default=False
            ),
            Switch(
                key="deep_blob_parsing",
                text="–ì–ª—É–±–æ–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ BLOB (–º–µ–¥–ª–µ–Ω–Ω–æ, –Ω–æ —Ç—â–∞—Ç–µ–ª—å–Ω–æ)",
                default=False
            ),
            Input(
                key="max_msgs",
                text="–ú–∞–∫—Å. —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è",
                default="5000"
            ),
            Selector(
                key="scan_mode",
                text="–¶–µ–ª—å —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è",
                items=["–¢–æ–ª—å–∫–æ —É–¥–∞–ª–µ–Ω–Ω—ã–µ", "–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ", "–í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏"],
                default=2
            ),
            Divider(text="–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ"),
            Switch(
                key="check_server",
                text="–ü—Ä–æ–≤–µ—Ä—è—Ç—å —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä",
                default=True
            ),
            Switch(
                key="safe_mode",
                text="–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–µ–∂–∏–º (–≤–∞–ª–∏–¥–∞—Ü–∏—è SQL)",
                default=True
            )
        ]
    
    @property
    def _database(self):
        if self._db_cache is None:
            storage = get_messages_storage()
            self._db_cache = get_private_field(storage, "database")
        return self._db_cache
    
    @property
    def _controller(self):
        if self._controller_cache is None:
            self._controller_cache = get_messages_controller()
        return self._controller_cache
    
    @property
    def _config(self):
        if self._config_cache is None:
            self._config_cache = get_user_config()
        return self._config_cache
    
    def _sanitize_id(self, id_str: str) -> Optional[int]:
        try:
            uid = int(id_str.strip())
            return uid if uid > 0 else None
        except (ValueError, TypeError):
            return None
    
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not isinstance(params.message, str) or not params.message.startswith(".localdb"):
            return HookResult()
        
        cmd_part = params.message[8:].strip()
        parts = cmd_part.split(None, 1)
        command = parts[0].lower() if parts else "help"
        args = parts[1] if len(parts) > 1 else ""
        
        if command == "scan":
            run_on_queue(lambda: self._cmd_scan(args, params.peer, export_mode=False))
            return HookResult(strategy=HookStrategy.CANCEL)
        elif command == "export":
            run_on_queue(lambda: self._cmd_scan(args, params.peer, export_mode=True))
            return HookResult(strategy=HookStrategy.CANCEL)
        elif command == "search":
            run_on_queue(lambda: self._cmd_search(args, params.peer))
            return HookResult(strategy=HookStrategy.CANCEL)
        elif command == "whois":
            run_on_queue(lambda: self._cmd_whois(args, params.peer))
            return HookResult(strategy=HookStrategy.CANCEL)
        elif command == "msg":
            run_on_queue(lambda: self._cmd_send_msg(args, params.peer))
            return HookResult(strategy=HookStrategy.CANCEL)
        elif command == "lookup":
            run_on_queue(lambda: self._cmd_lookup(args, params.peer))
            return HookResult(strategy=HookStrategy.CANCEL)
        elif command == "help":
            self._cmd_help(args, params.peer)
            return HookResult(strategy=HookStrategy.CANCEL)
        else:
            params.message = "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: .localdb help"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
    
    def _cmd_scan(self, args: str, peer: Any, export_mode: bool = False):
        BulletinHelper.show_info("üîç –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö..." if not export_mode else "üì¶ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∞...")
        
        if not self._database:
            self._send_error(peer, "–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return
        
        scan_mode = int(self.get_setting("scan_mode", 2))
        my_id = self._config.getClientUserId()
        
        try:
            all_ids = self._collect_user_ids(my_id)
            deleted, active, unknown = [], [], []
            
            for uid in all_ids:
                try:
                    user = self._controller.getUser(uid)
                    if not user:
                        unknown.append(uid)
                        continue
                    
                    if self._is_deleted(user):
                        if scan_mode != 1:
                            deleted.append(self._format_user(user))
                    else:
                        if scan_mode != 0:
                            active.append(self._format_user(user))
                            
                except Exception as e:
                    log(f"Scan error for uid {uid}: {e}")
            
            if export_mode:
                builder = ReportBuilder("–≠–ö–°–ü–û–†–¢ –ë–ê–ó–´ –î–ê–ù–ù–´–•")
                if deleted:
                    builder.add_section("–£–î–ê–õ–ï–ù–ù–´–ï –ê–ö–ö–ê–£–ù–¢–´", deleted, limit=500)
                if active:
                    builder.add_section("–ê–ö–¢–ò–í–ù–´–ï –ê–ö–ö–ê–£–ù–¢–´", active, limit=500)
                if unknown:
                    unknown_formatted = [f"ID:{uid}" for uid in list(unknown)[:100]]
                    builder.add_section("–ù–ï–ò–ó–í–ï–°–¢–ù–´–ï –°–°–´–õ–ö–ò", unknown_formatted)
                
                mode_names = ["–¢–æ–ª—å–∫–æ —É–¥–∞–ª–µ–Ω–Ω—ã–µ", "–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ", "–í—Å–µ"]
                builder.add_line(f"\n–í—Å–µ–≥–æ: {len(all_ids)} | –†–µ–∂–∏–º: {mode_names[scan_mode]}")
                self._send_report(peer, f"export_{int(time.time())}.txt", builder)
                BulletinHelper.show_success(f"‚úÖ –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {len(deleted)}–£ {len(active)}–ê {len(unknown)}–ù")
            else:
                summary = f"""üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö:
‚Ä¢ –í—Å–µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö ID: {len(all_ids)}
‚Ä¢ –£–¥–∞–ª–µ–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã: {len(deleted)}
‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã: {len(active)}
‚Ä¢ –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ –∫–µ—à–µ: {len(unknown)}

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ .localdb export –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞ –≤ —Ñ–∞–π–ª–µ."""
                run_on_ui_thread(lambda: send_text(peer, summary))
                
        except Exception as e:
            log(f"Scan failed: {e}")
            self._send_error(peer, f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {str(e)}")
    
    def _cmd_search(self, query: str, peer: Any):
        if not query or len(query) < 2:
            self._send_error(peer, "–ó–∞–ø—Ä–æ—Å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 2 —Å–∏–º–≤–æ–ª–∞)")
            return
        
        if not self._database:
            self._send_error(peer, "–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return
        
        max_msgs = min(int(self.get_setting("max_msgs", "5000")), 20000)
        keywords = [q.lower().strip() for q in query.split() if len(q.strip()) >= 2]
        
        if not keywords:
            self._send_error(peer, "–ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤")
            return
        
        BulletinHelper.show_info(f"üîç –ü–æ–∏—Å–∫: {', '.join(keywords)}")
        
        results = []
        processed = 0
        
        try:
            for table in self.MESSAGE_TABLES:
                if processed >= max_msgs:
                    break
                
                limit = min(max_msgs - processed, 5000)
                sql = f"SELECT uid, date, data FROM {table} ORDER BY date DESC LIMIT {limit}"
                
                with CursorContext(self._database, sql) as cursor:
                    if not cursor:
                        continue
                    
                    while cursor.next() and processed < max_msgs:
                        try:
                            processed += 1
                            blob = cursor.byteArrayValue(2)
                            if not blob or len(blob) < 4:
                                continue
                            
                            buffer = NativeByteBuffer(len(blob))
                            buffer.writeBytes(blob)
                            buffer.position(0)
                            
                            msg = TLRPC.Message.TLdeserialize(buffer, buffer.readInt32(True), True)
                            if not msg or not msg.message:
                                continue
                            
                            if self._match_keywords(msg.message.lower(), keywords):
                                date_str = time.strftime('%Y-%m-%d %H:%M', time.localtime(cursor.intValue(1)))
                                chat_id = cursor.longValue(0)
                                preview = msg.message[:120].replace('\n', ' ')
                                results.append(f"[{date_str}] {chat_id}: {preview}...")
                                
                                if len(results) >= 100:
                                    break
                                    
                        except JavaException:
                            continue
                        except Exception as e:
                            log(f"Search parse error: {e}")
            
            builder = ReportBuilder(f"–ü–û–ò–°–ö: {' '.join(keywords)}")
            builder.add_section("–°–û–í–ü–ê–î–ï–ù–ò–Ø", results, limit=100)
            builder.add_line(f"\n–ü—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ: {processed} | –ù–∞–π–¥–µ–Ω–æ: {len(results)}")
            self._send_report(peer, f"search_{int(time.time())}.txt", builder)
            
        except Exception as e:
            log(f"Search error: {e}")
            self._send_error(peer, f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {str(e)}")
    
    def _cmd_whois(self, args: str, peer: Any):
        uid = self._sanitize_id(args.split()[0] if args else "")
        if not uid:
            self._send_error(peer, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .localdb whois <id_–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è>")
            return
        
        if not self._database:
            self._send_error(peer, "–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return
        
        lines = []
        user = self._controller.getUser(uid)
        
        if user:
            username = getattr(user, 'username', '–ù/–î') or '–ù/–î'
            first_name = getattr(user, 'first_name', '') or ''
            last_name = getattr(user, 'last_name', '') or ''
            full_name = f"{first_name} {last_name}".strip()
            phone = getattr(user, 'phone', '–°–∫—Ä—ã—Ç') or '–°–∫—Ä—ã—Ç'
            is_bot = "–î–∞" if getattr(user, 'bot', False) else "–ù–µ—Ç"
            is_deleted = "–î–∞" if self._is_deleted(user) else "–ù–µ—Ç"
            is_premium = "–î–∞" if getattr(user, 'premium', False) else "–ù–µ—Ç"
            has_access_hash = "–î–∞" if getattr(user, 'access_hash', None) else "–ù–µ—Ç"
            
            lines.extend([
                "[–õ–û–ö–ê–õ–¨–ù–´–ô –ö–ï–®]",
                f"–Æ–∑–µ—Ä–Ω–µ–π–º: @{username}",
                f"–ò–º—è: {full_name}",
                f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}",
                f"–ë–æ—Ç: {is_bot}",
                f"–£–¥–∞–ª–µ–Ω: {is_deleted}",
                f"–ü—Ä–µ–º–∏—É–º: {is_premium}",
                f"–•–µ—à –¥–æ—Å—Ç—É–ø–∞: {has_access_hash}",
                ""
            ])
        else:
            lines.extend(["[–õ–û–ö–ê–õ–¨–ù–´–ô –ö–ï–®] –ù–µ –Ω–∞–π–¥–µ–Ω–æ", ""])
        
        tables_found = []
        for table, field in self.SQL_TABLES:
            try:
                sql = f"SELECT 1 FROM {table} WHERE {field} = {uid} LIMIT 1"
                with CursorContext(self._database, sql) as cursor:
                    if cursor and cursor.next():
                        tables_found.append(table)
            except Exception:
                continue
        
        tables_str = ', '.join(tables_found) if tables_found else '–ù–µ—Ç'
        lines.extend([
            "[–°–°–´–õ–ö–ò –í –ë–ê–ó–ï –î–ê–ù–ù–´–•]",
            f"–ù–∞–π–¥–µ–Ω–æ –≤: {tables_str}",
            ""
        ])
        
        if self.get_setting("check_server", True) and user and getattr(user, 'access_hash', None):
            self._fetch_server_info(uid, user.access_hash, lines, peer)
            return
        
        builder = ReportBuilder(f"WHOIS {uid}")
        builder.add_section("–ê–ù–ê–õ–ò–ó", lines, limit=50)
        self._send_text_chunks(peer, builder.build())
    
    def _cmd_send_msg(self, args: str, peer: Any):
        match = re.match(r'(\d+)\s+(.+)', args.strip(), re.DOTALL)
        if not match:
            self._send_error(peer, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .localdb msg <id> <—Ç–µ–∫—Å—Ç>")
            return
        
        uid = int(match.group(1))
        text = match.group(2).strip()
        
        if len(text) > 4096:
            self._send_error(peer, "–°–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (–º–∞–∫—Å. 4096)")
            return
        
        user = self._controller.getUser(uid)
        if not user or not getattr(user, 'access_hash', None):
            self._send_error(peer, "–ù–µ—Ç —Ö–µ—à–∞ –¥–æ—Å—Ç—É–ø–∞ –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        try:
            input_peer = TLRPC.TL_inputPeerUser()
            input_peer.user_id = uid
            input_peer.access_hash = user.access_hash
            
            req = TLRPC.TL_messages_sendMessage()
            req.peer = input_peer
            req.message = text
            req.random_id = int(time.time() * 1000000)
            
            def callback(resp, err):
                if err:
                    msg = f"‚ùå –û—à–∏–±–∫–∞: {err.text}"
                else:
                    msg = f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {uid}"
                run_on_ui_thread(lambda: send_text(peer, msg))
            
            send_request(req, RequestCallback(callback))
            
        except Exception as e:
            self._send_error(peer, f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
    
    def _cmd_lookup(self, args: str, peer: Any):
        ids = re.findall(r'\d+', args)[:100]
        if not ids:
            self._send_error(peer, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .localdb lookup <id1> <id2>...")
            return
        
        results = []
        for sid in ids:
            uid = int(sid)
            user = self._controller.getUser(uid)
            
            if user:
                status = "–£–î–ê–õ–ï–ù" if self._is_deleted(user) else "–ê–ö–¢–ò–í–ï–ù"
                username = getattr(user, 'username', '-') or '-'
                first = getattr(user, 'first_name', '') or ''
                last = getattr(user, 'last_name', '') or ''
                name = f"{first} {last}".strip() or '-'
                results.append(f"{uid:<12} @{username:<15} {name:<25} [{status}]")
            else:
                results.append(f"{uid:<12} [–ù–µ—Ç –≤ –∫–µ—à–µ]")
        
        builder = ReportBuilder("–ú–ê–°–°–û–í–´–ô –ü–û–ò–°–ö")
        builder.add_section("–†–ï–ó–£–õ–¨–¢–ê–¢–´", results)
        self._send_report(peer, f"lookup_{int(time.time())}.txt", builder)
    
    def _cmd_help(self, args: str, peer: Any):
        help_text = """üìö –ö–æ–º–∞–Ω–¥—ã –∞–Ω–∞–ª–∏–∑–∞ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î:

.localdb scan - –ë—ã—Å—Ç—Ä–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (—Ç–æ–ª—å–∫–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞)
.localdb export - –ü–æ–ª–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —ç–∫—Å–ø–æ—Ä—Ç–æ–º —Ñ–∞–π–ª–∞
.localdb search <–∫–ª—é—á–µ–≤—ã–µ_—Å–ª–æ–≤–∞> - –ü–æ–∏—Å–∫ —Å–æ–æ–±—â–µ–Ω–∏–π
.localdb whois <id_–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è> - –ì–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
.localdb msg <id> <—Ç–µ–∫—Å—Ç> - –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ ID
.localdb lookup <id1> <id2>... - –ú–∞—Å—Å–æ–≤—ã–π –ø–æ–∏—Å–∫ (–º–∞–∫—Å. 100)
.localdb help - –≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ

‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏: —Ä–µ–∂–∏–º —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è, –ª–∏–º–∏—Ç—ã, —ç–∫—Å–ø–æ—Ä—Ç"""
        send_text(peer, help_text)
    
    def _collect_user_ids(self, exclude_id: int) -> Set[int]:
        ids = set()
        
        for table, field in self.SQL_TABLES:
            try:
                sql = f"SELECT DISTINCT {field} FROM {table} WHERE {field} > 0"
                with CursorContext(self._database, sql) as cursor:
                    if not cursor:
                        continue
                    while cursor.next():
                        try:
                            uid = cursor.longValue(0)
                            if uid != exclude_id:
                                ids.add(uid)
                        except:
                            continue
            except Exception as e:
                log(f"Collect error from {table}: {e}")
        
        return ids
    
    def _is_deleted(self, user) -> bool:
        if getattr(user, 'deleted', False):
            return True
        if hasattr(user, 'flags'):
            if (int(user.flags) & 0x400) != 0:
                return True
        if not getattr(user, 'first_name', None) and not getattr(user, 'last_name', None):
            return True
        return False
    
    def _format_user(self, user) -> str:
        uid = getattr(user, 'id', '–ù/–î')
        username = getattr(user, 'username', None) or "-"
        first = getattr(user, 'first_name', '') or ''
        last = getattr(user, 'last_name', '') or ''
        name = f"{first} {last}".strip() or "-"
        phone = getattr(user, 'phone', None)
        phone_str = f" | +{phone}" if phone else ""
        return f"ID:{uid} | @{username} | {name}{phone_str}"
    
    def _match_keywords(self, text: str, keywords: List[str]) -> bool:
        words = set(text.split())
        return any(kw in words for kw in keywords)
    
    def _fetch_server_info(self, uid: int, access_hash: int, lines: List[str], peer: Any):
        try:
            input_user = TLRPC.TL_inputUser()
            input_user.user_id = uid
            input_user.access_hash = access_hash
            
            req = TLRPC.TL_users_getFullUser()
            req.id = input_user
            
            def callback(resp, error):
                if error:
                    lines.append(f"[–°–ï–†–í–ï–†] –û—à–∏–±–∫–∞: {error.text}")
                elif resp:
                    if resp.users and resp.users.size() > 0:
                        u = resp.users.get(0)
                        u_username = getattr(u, 'username', '–ù/–î')
                        u_status = "–£–¥–∞–ª–µ–Ω" if self._is_deleted(u) else "–ê–∫—Ç–∏–≤–µ–Ω"
                        lines.extend([
                            "[–î–ê–ù–ù–´–ï –°–ï–†–í–ï–†–ê]",
                            f"–Æ–∑–µ—Ä–Ω–µ–π–º: @{u_username}",
                            f"–°—Ç–∞—Ç—É—Å: {u_status}",
                        ])
                    
                    full = getattr(resp, 'full_user', None)
                    if full:
                        about = getattr(full, 'about', None)
                        common_chats = getattr(full, 'common_chats_count', None)
                        if about:
                            lines.append(f"–û —Å–µ–±–µ: {about}")
                        if common_chats:
                            lines.append(f"–û–±—â–∏–µ –≥—Ä—É–ø–ø—ã: {common_chats}")
                
                builder = ReportBuilder(f"WHOIS {uid}")
                builder.add_section("–î–ê–ù–ù–´–ï", lines, limit=100)
                self._send_text_chunks(peer, builder.build())
            
            send_request(req, RequestCallback(callback))
            
        except Exception as e:
            lines.append(f"[–°–ï–†–í–ï–†] –ó–∞–ø—Ä–æ—Å –Ω–µ —É–¥–∞–ª—Å—è: {e}")
            builder = ReportBuilder(f"WHOIS {uid}")
            builder.add_section("–î–ê–ù–ù–´–ï", lines, limit=100)
            self._send_text_chunks(peer, builder.build())
    
    def _send_report(self, peer: Any, filename: str, builder: ReportBuilder):
        content = builder.build()
        filepath = None
        
        try:
            safe_filename = re.sub(r'[^\w.-]', '_', filename)
            filepath = os.path.join(get_cache_dir(), safe_filename)
            write_file(filepath, content)
            
            my_id = self._config.getClientUserId()
            run_on_ui_thread(lambda: send_document(my_id, filepath, caption=f"üìÑ {filename}"))
            
            if self.get_setting("auto_export", False):
                self._send_text_chunks(peer, content)
                
        except Exception as e:
            log(f"Export error: {e}")
            self._send_error(peer, f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç: {e}")
    
    def _send_text_chunks(self, peer: Any, text: str):
        chunks = [text[i:i+4000] for i in range(0, len(text), 4000)]
        for i, chunk in enumerate(chunks):
            if i > 0:
                time.sleep(0.1)
            run_on_ui_thread(lambda c=chunk: send_text(peer, c))
    
    def _send_error(self, peer: Any, message: str):
        run_on_ui_thread(lambda: send_text(peer, f"‚ùå {message}"))