"""
Если вы при разработке своего плагина использовали готовые фрагменты кода из моего, пожалуйста,
укажите в описании своего плагина @zwylair в качестве благодарности за вклад в разработку. Спасибо ♥

If you used code snippets from my plugin in the development of your own, please credit @zwylair
in your plugin’s description as a thank you for the contribution. Thanks ♥


⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣀⠀⠀⠀⠀⣀⣠⣤⣤⣤⣄⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠿⠛⠛⠛⠛⠛⢿⣷⣤⣾⠿⠛⠛⠙⠛⠛⠿⠗
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡿⠁⠀⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⠀⢀⣤⣀⠀⠀⢀⣤⣶⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣧⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠀⣿⣷⣄⣀⣤⡄⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⠷
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣁⣤⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠘⠛⠛⠛⠻⣿⣿⣿⠋⠉⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠹⣿⡟⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠟⢙⠛⠛⠀⠀⠀⠀⠀⠀⣀⣴⡿⠓⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠈⠻⢿⣦⣄⠀⣠⣾⡿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀
"""

from typing import Dict, Callable, List

from hook_utils import get_private_field, set_private_field
from client_utils import get_messages_controller
from base_plugin import BasePlugin, HookResult, XposedHook

from java.util import Locale, ArrayList
from java.lang import Boolean, Integer, Long
from android.view import View
from org.telegram.messenger import MessageObject
from org.telegram.ui import ChatActivity
from org.telegram.tgnet import TLRPC, TLObject

__name__ = "NoForwardLimit"
__description__ = "Removes the limit of 100 forward messages (requires zwylib)"
__icon__ = "zwyPluginsIcons/6"
__id__ = "zwyNoForwardLimit"
__version__ = "1.1.3"
__author__ = "@zwylair"
__min_version__ = "11.12.1"


def get_selected_msgs_array_index(param):
    message_object = param.args[0]
    current_dialog_id = get_private_field(param.thisObject, "dialog_id")
    return int(message_object.getDialogId() != current_dialog_id)


def update_reply_button_visibility(chat_activity, selected_only_one_message: bool):
    logger.info("updating reply button visibility")
    reply_button = get_private_field(chat_activity, "replyButton")
    if reply_button:
        reply_button.setVisibility(View.VISIBLE if selected_only_one_message else View.GONE)


def update_select_button_visibility(chat_activity):
    logger.info("updating select button visibility")

    java_msgs_sparse = get_private_field(chat_activity, "selectedMessagesIds")
    messages = get_private_field(chat_activity, "messages")
    select_button = get_private_field(chat_activity, "selectButton")

    if select_button is None or java_msgs_sparse is None:
        return

    java_msgs_main = java_msgs_sparse[0]
    new_select_visibility = View.GONE

    if java_msgs_main.size() > 1:
        all_selected_msg_ids = get_sparsearray_keys(java_msgs_main) + get_sparsearray_keys(java_msgs_sparse[1])
        all_selected_msg_ids.sort()

        if all_selected_msg_ids:
            begin = all_selected_msg_ids[0]
            end = all_selected_msg_ids[-1]

            for i in range(messages.size()):
                msg = messages.get(i)
                msg_id = msg.getId()

                is_in_bounds = begin < msg_id < end
                is_selected = java_msgs_main.indexOfKey(msg_id) >= 0

                if is_in_bounds and not is_selected and msg.contentType == 0:
                    new_select_visibility = View.VISIBLE
                    break

    select_button_animator = get_private_field(chat_activity, "selectButtonAnimation")
    if select_button_animator:
        select_button_animator.cancel()

    current_visibility = select_button.getVisibility()
    if current_visibility != new_select_visibility:
        if new_select_visibility == View.VISIBLE:
            select_button.setVisibility(View.VISIBLE)
            select_button.setAlpha(1.0)
            select_button.setScaleY(1.0)
        else:
            select_button.setAlpha(0.0)
            select_button.setScaleY(0.0)
            select_button.setVisibility(View.GONE)


def get_sparsearray_keys(sparse_array):
    if sparse_array is None:
        return []
    return [sparse_array.keyAt(i) for i in range(sparse_array.size())]


def cancel_selection_mode(chat_activity):
    hide_action_mode_method.invoke(chat_activity)
    update_pinned_msg_view_method.invoke(chat_activity, [True])


def split_list_into_chunks(lst: List[int], chunk_size: int) -> List[List[int]]:
    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]


def decrement_cant_forward_count(chat_activity):
    val = get_private_field(chat_activity, "cantForwardMessagesCount")
    val -= 2 
    
    logger.info(f"[after] decrementing cantForwardMessagesCount. new value: {val}")
    set_private_field(chat_activity, "cantForwardMessagesCount", Integer(val))

    if val == 0:
        forward_button = get_private_field(chat_activity, "forwardButton")
        if forward_button:
            forward_button.setEnabled(True)
            forward_button.setAlpha(1.0)


def decrement_cant_delete_count(chat_activity):
    val = get_private_field(chat_activity, "cantDeleteMessagesCount")
    val -= 2

    logger.info(f"[after] decrementing cantDeleteMessagesCount. new value: {val}")
    set_private_field(chat_activity, "cantDeleteMessagesCount", Integer(val))

    if val == 0:
        delete_item = get_private_field(chat_activity, "deleteItem")
        if delete_item:
            delete_item.setVisibility(View.VISIBLE)


class SelectorHook(XposedHook):
    def __init__(self):
        super().__init__()
        self.messages_array: Dict[int, MessageObject] = {}
        self.is_processing_msg_group = False
        self.is_last_in_group = False
        self.handle_end_of_select_msg_group_call = False

    def before_hooked_method(self, param):
        chat_activity = param.thisObject
        selected_msg_obj = param.args[0]
        tapped_outside: bool = param.args[1]
        is_last: bool = param.args[2]
        is_grouped = selected_msg_obj.getGroupId() != 0

        if self.is_processing_msg_group:
            self.is_last_in_group = is_last
            logger.info(f"[before] selected group member (msg_id={selected_msg_obj.getId()}, last={self.is_last_in_group})")
            return

        if tapped_outside and is_last and is_grouped:
            logger.info(f"[before] started selection of a group (with replaced array) (msg_id={selected_msg_obj.getId()})")
            self.is_processing_msg_group = True

        # replace selected messages array
        index = get_selected_msgs_array_index(param)
        java_msgs_sparse = get_private_field(chat_activity, "selectedMessagesIds")
        java_msgs_sparse[index] = param.thisObject.SparseArrayWithTouch()
        set_private_field(chat_activity, "selectedMessagesIds", java_msgs_sparse)

    def after_hooked_method(self, param):
        if self.handle_end_of_select_msg_group_call:
            self.handle_end_of_select_msg_group_call = False
            return

        if self.is_processing_msg_group:
            if not self.is_last_in_group:
                return

            logger.info("[after] ended selection of group")

            self.is_processing_msg_group = False
            self.is_last_in_group = False
            self.handle_end_of_select_msg_group_call = True

        chat_activity = param.thisObject
        index = get_selected_msgs_array_index(param)
        
        # Получаем актуальные ссылки
        java_msgs_sparse = get_private_field(chat_activity, "selectedMessagesIds")
        selected_msgs_array = java_msgs_sparse[index]
        
        chat_mode = get_private_field(chat_activity, "chatMode")
        current_chat = get_private_field(chat_activity, "currentChat")
        is_in_schedule_mode = chat_mode == 1

        # add/remove new messages from local db
        for index in reversed(range(selected_msgs_array.size())):
            message_id = selected_msgs_array.keyAt(index)
            message_object = selected_msgs_array.get(message_id)

            if message_id in self.messages_array.keys():
                logger.info(f"[after] unselecting message id: {message_id}")

                if not message_object.canForwardMessage():
                    decrement_cant_forward_count(chat_activity)

                if not message_object.canDeleteMessage(is_in_schedule_mode, current_chat):
                    decrement_cant_delete_count(chat_activity)

                self.messages_array.pop(message_id)
            else:
                logger.info(f"[after] selecting message id: {message_id}")
                self.messages_array[message_id] = message_object

        # restore selected messages
        selected_msgs_array.clear()
        for k, v in self.messages_array.items():
            selected_msgs_array.put(k, v)

        # handle no messages selected case
        if len(self.messages_array) == 0:
            cancel_selection_mode(chat_activity)
            return

        logger.info(f"[after] local db: {self.messages_array}")
        logger.info(f"[after] java db: {selected_msgs_array}")

        update_reply_button_visibility(chat_activity, len(self.messages_array) == 1)
        update_select_button_visibility(chat_activity)

        # separator
        for _ in range(3):
            logger.info("[after] \n")

    def clear_message_storage(self):
        logger.info("clearing local select db")
        self.messages_array.clear()


class ClearSelectionHook(XposedHook):
    def before_hooked_method(self, param):
        selector_hook.clear_message_storage()


class MultiSelectorHook(XposedHook):
    def __init__(self, hook_method: Callable):
        super().__init__()
        self.hook_method = hook_method

    def after_hooked_method(self, param):
        class BypassLimitReachedHook:
            def replace_hooked_method(self, _param):
                return False

        chat_list_view = get_private_field(param.thisObject, "chatListView")
        selection_listener = get_private_field(chat_list_view, "multiSelectionListener")
        method = selection_listener.getClass().getMethod("limitReached")
        self.hook_method(method, BypassLimitReachedHook())


class DeleteMessagesHook(XposedHook):
    chunk_size = 100

    def before_hooked_method(self, param):
        first_msg_array = param.args[0]
        second_msg_array = param.args[1]

        if first_msg_array.size() > 0:
            msgs = first_msg_array
            selected_msg_array_arg_index = 0
        else:
            msgs = second_msg_array
            selected_msg_array_arg_index = 1

        messages: List[int] = zwylib.arraylist_to_list(msgs)

        logger.info(f"got messages list (size={len(messages)})")

        if len(messages) <= self.chunk_size:
            logger.info(f"{len(messages)} <= {self.chunk_size}. split skipped.")

            # separator
            for _ in range(5):
                logger.info("")
            return

        message_ids_chunks: List[List[int]] = split_list_into_chunks(messages, self.chunk_size)
        last_chunk_index = len(message_ids_chunks) - 1

        logger.info(f"split to {len(message_ids_chunks)} chunks of ~{self.chunk_size}")

        for index, chunk in enumerate(message_ids_chunks):
            preview = ", ".join(map(str, chunk[:5]))
            logger.info(f"\t[chunk {index}] {preview}, ...")

            param.args[selected_msg_array_arg_index] = zwylib.list_to_arraylist(chunk)

            if index < last_chunk_index:
                param.method.invoke(param.thisObject, param.args)

        # separator
        for _ in range(5):
            logger.info("")


class Locales:
    en = {
        "zwylib_was_not_found": "ZwyLib plugin required for this plugin is not found!",
    }
    ru = {
        "zwylib_was_not_found": "Требуемый плагин ZwyLib не найден!",
    }
    uk = {
        "zwylib_was_not_found": "Не знайдено обов’язковий плагін ZwyLib!",
    }
    default = en


def localise(key: str) -> str:
    locale_dict = getattr(Locales, LOCALE, Locales.default)
    return locale_dict.get(key, key)


AUTOUPDATE_CHANNEL_ID = 2521243181
AUTOUPDATE_MSG_ID = 53
LOG_PREFIX = __name__
LOCALE = Locale.getDefault().getLanguage()

try:
    import zwylib
except (ImportError, ModuleNotFoundError):
    raise Exception(localise("zwylib_was_not_found"))

selector_hook = SelectorHook()
logger = zwylib.build_log(LOG_PREFIX)
BulletinHelper = zwylib.build_bulletin_helper(LOG_PREFIX)

# Optimization: Cache Reflection Objects (Safe)
ChatActivityClass = ChatActivity.getClass()
hide_action_mode_method = ChatActivityClass.getDeclaredMethod("hideActionMode")
update_pinned_msg_view_method = ChatActivityClass.getDeclaredMethod("updatePinnedMessageView", Boolean.TYPE)

hide_action_mode_method.setAccessible(True)
update_pinned_msg_view_method.setAccessible(True)

class NoForwardLimit(BasePlugin):
    def on_plugin_load(self):
        zwylib.add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)

        self.add_on_send_message_hook()
        self.add_hook("TL_messages_forwardMessages")

        selector_method = ChatActivityClass.getDeclaredMethod("addToSelectedMessages", MessageObject, Boolean.TYPE, Boolean.TYPE)
        selector_method.setAccessible(True)
        self.hook_method(selector_method, selector_hook)

        clear_selection_method = ChatActivityClass.getDeclaredMethod("hideActionMode")
        clear_selection_method.setAccessible(True)
        self.hook_method(clear_selection_method, ClearSelectionHook())

        multi_selector_method = ChatActivityClass.getDeclaredMethod("startMultiselect", Integer.TYPE)
        multi_selector_method.setAccessible(True)
        self.hook_method(multi_selector_method, MultiSelectorHook(self.hook_method))

        clazz = get_messages_controller().getClass()
        delete_messages_method = clazz.getDeclaredMethod("deleteMessages", ArrayList, ArrayList, TLRPC.EncryptedChat, Long.TYPE, Boolean.TYPE, Integer.TYPE, Boolean.TYPE, Long.TYPE, TLObject, Integer.TYPE, Boolean.TYPE, Integer.TYPE)
        self.hook_method(delete_messages_method, DeleteMessagesHook())

        logger.info("Loaded")

    def on_plugin_unload(self):
        zwylib.remove_autoupdater_task(__id__)
        logger.info("Unloaded")

    def pre_request_hook(self, req_name, account, req):
        if req_name == "TL_messages_forwardMessages":
            selector_hook.clear_message_storage()
        return HookResult()
