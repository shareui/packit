import threading
import time
import socket
from typing import Optional, List, Tuple
import requests
from java.util import Locale
from base_plugin import BasePlugin, AppEvent, MethodHook, MenuItemData, MenuItemType
from hook_utils import find_class
from android_utils import run_on_ui_thread
from ui.settings import Header, Switch, Selector, Text, Divider
from org.telegram.messenger import (
    ApplicationLoader,
    MessagesController,
    NotificationCenter,
    SharedConfig,
    UserConfig,
)
from org.telegram.tgnet import ConnectionsManager
from org.telegram.ui import LaunchActivity

__id__ = "exitfy"
__name__ = "exitFy"
__description__ = "Application download speed optimization"
__icon__ = "exitFy/0"
__author__ = "Community"
__version__ = "1.0.8"
__min_version__ = "12.1.1"

API_URLS = {
    0: ["https://exitfy.ishrimp.xyz/proxy/single/de/experimental"],
    1: ["https://exitfy.vpnetproxy.xyz/proxy/latest"],
    2: ["https://a.stemstep.cloud/proxy/socks"],
}

SPONSOR_TEXT = {
    0: "Sponsor by: @invisibleshrimp",
    1: "Sponsor by: @vpnetvpn",
    2: "Sponsor by: @sworklevpnbot",
}

TRANSLATIONS = {
    "settings_header": ("Настройки", "Settings"),
    "enable_plugin": ("Включить плагин", "Enable plugin"),
    "select_provider": ("Выбрать провайдера", "Select provider"),
    "auto_switch": ("Автопереключение", "Auto switch"),
    "refresh": ("Обновить", "Refresh"),
    "open_tg_settings": ("Открыть настройки Telegram", "Open Telegram settings"),
    "menu_settings": ("Настройки exitFy", "exitFy Settings"),
}


def Z(key: str):
    lang = Locale.getDefault().getLanguage()
    idx = 0 if str(lang).startswith("ru") else 1
    return TRANSLATIONS.get(key, (None, None))[idx]

CHECK_INTERVAL_SEC = 5

def _prefs():
    ctx = ApplicationLoader.applicationContext
    return ctx.getSharedPreferences("exitfy_prefs", 0)


def _get_selected_type() -> int:
    try:
        return int(_prefs().getInt("selected_type", 0))
    except:
        return 0


def _set_selected_type(t: int):
    try:
        ed = _prefs().edit()
        ed.putInt("selected_type", int(t))
        ed.commit()
    except:
        pass


def _get_last_fragment():
    try:
        return LaunchActivity.getSafeLastFragment()
    except:
        return None


def _force_show_dialogs_proxy_button(da) -> None:
    try:
        if da is None:
            return
        cls = None
        try:
            cls = da.getClass()
        except:
            cls = None

        proxy_item = None
        if cls is not None:
            try:
                f = cls.getDeclaredField("proxyItem")
                f.setAccessible(True)
                proxy_item = f.get(da)
            except:
                proxy_item = None

        if proxy_item is not None:
            from android.view import View
            try:
                proxy_item.setVisibility(View.VISIBLE)
            except:
                pass

        if cls is not None:
            try:
                vf = cls.getDeclaredField("proxyItemVisible")
                vf.setAccessible(True)
                try:
                    vf.setBoolean(da, True)
                except:
                    try:
                        vf.set(da, True)
                    except:
                        pass
            except:
                pass

        proxy_drawable = None
        if cls is not None:
            try:
                df = cls.getDeclaredField("proxyDrawable")
                df.setAccessible(True)
                proxy_drawable = df.get(da)
            except:
                proxy_drawable = None

        if proxy_drawable is not None:
            state = None
            if cls is not None:
                try:
                    sf = cls.getDeclaredField("currentConnectionState")
                    sf.setAccessible(True)
                    state = sf.getInt(da)
                except:
                    state = None

            try:
                proxy_enabled = bool(_tg_proxy_enabled())
            except:
                proxy_enabled = False

            connected = False
            try:
                connected = state == ConnectionsManager.ConnectionStateConnected or state == ConnectionsManager.ConnectionStateUpdating
            except:
                connected = False

            try:
                proxy_drawable.setConnected(proxy_enabled, bool(connected), False)
            except:
                pass
    except:
        pass


def _tg_proxy_enabled() -> bool:
    try:
        return bool(MessagesController.getGlobalMainSettings().getBoolean("proxy_enabled", False))
    except:
        return False


def _set_tg_proxy_enabled(enabled: bool):
    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putBoolean("proxy_enabled", bool(enabled))
        ed.commit()
    except:
        pass
    try:
        SharedConfig.proxyEnabled = bool(enabled)
        SharedConfig.saveConfig()
    except:
        pass
    try:
        for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
            try:
                cm = ConnectionsManager.getInstance(ac)
                if cm is not None:
                    if bool(enabled) and SharedConfig.currentProxy is not None:
                        p = SharedConfig.currentProxy
                        cm.setProxySettings(True, str(p.address), int(p.port), str(p.username or ""), str(p.password or ""), str(p.secret or ""))
                    else:
                        cm.setProxySettings(False, "", 0, "", "", "")
            except:
                pass
    except:
        pass
    try:
        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
    except:
        pass


def _get_last_applied_link() -> str:
    try:
        return str(_prefs().getString("last_applied_link", "") or "")
    except:
        return ""


def _set_last_applied_link(link: str):
    try:
        ed = _prefs().edit()
        ed.putString("last_applied_link", str(link or ""))
        ed.commit()
    except:
        pass


def _get_last_check_ts() -> int:
    try:
        return int(_prefs().getLong("last_check_ts", 0))
    except:
        return 0


def _set_last_check_ts(ts: int):
    try:
        ed = _prefs().edit()
        ed.putLong("last_check_ts", int(ts))
        ed.commit()
    except:
        pass


def _parse_proxy_link(link: str) -> Optional[SharedConfig.ProxyInfo]:
    try:
        if not isinstance(link, str):
            return None
        link = link.strip()
        if not link:
            return None

        from urllib.parse import urlparse, parse_qs
        if "tg://" not in link and "t.me/" not in link:
            return None

        parsed = urlparse(link)
        q = parse_qs(parsed.query)

        server = (q.get("server") or [""])[0]
        port_s = (q.get("port") or [""])[0]
        user = (q.get("user") or [""])[0]
        password = (q.get("pass") or [""])[0]
        secret = (q.get("secret") or [""])[0]

        if not server or not port_s:
            return None

        try:
            port = int(port_s)
        except:
            return None

        return SharedConfig.ProxyInfo(server, port, user, password, secret)
    except:
        return None


def _apply_proxy_info(info: SharedConfig.ProxyInfo):
    if info is None:
        return
    SharedConfig.loadProxyList()

    enabled_now = False
    try:
        enabled_now = bool(_tg_proxy_enabled())
    except:
        enabled_now = False

    added = None
    try:
        if hasattr(SharedConfig, "proxyList") and SharedConfig.proxyList is not None and SharedConfig.proxyList.size() > 0:
            try:
                first = SharedConfig.proxyList.get(0)
                first.address = info.address
                first.port = int(info.port)
                first.username = info.username
                first.password = info.password
                first.secret = info.secret
                added = first
                try:
                    SharedConfig.saveProxyList()
                except:
                    try:
                        SharedConfig.saveConfig()
                    except:
                        pass
            except:
                added = None
    except:
        added = None

    if added is None:
        added = SharedConfig.addProxy(info)

    try:
        SharedConfig.currentProxy = added
    except:
        SharedConfig.currentProxy = info

    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putString("proxy_ip", added.address)
        ed.putString("proxy_user", added.username)
        ed.putString("proxy_pass", added.password)
        ed.putInt("proxy_port", int(added.port))
        ed.putString("proxy_secret", added.secret)
        ed.putBoolean("proxy_enabled", bool(enabled_now))
        if added.secret and len(added.secret) > 0:
            ed.putBoolean("proxy_enabled_calls", False)
        else:
            ed.putBoolean("proxy_enabled_calls", True)
        ed.apply()
    except:
        pass

    try:
        if bool(enabled_now):
            ConnectionsManager.setProxySettings(True, added.address, int(added.port), added.username, added.password, added.secret)
        else:
            ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
    except:
        pass

    try:
        def _notify_proxy_changed():
            try:
                NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
            except:
                pass

        run_on_ui_thread(_notify_proxy_changed, 350)
    except:
        pass


def _fetch_links(proxy_type: int) -> List[str]:
    urls = API_URLS.get(proxy_type) or []
    out: List[str] = []
    for url in urls:
        try:
            r = requests.get(url, timeout=10)
            if r.status_code != 200:
                continue
            text = (r.text or "").strip()
            if not text:
                continue
            for line in str(text).splitlines():
                s = (line or "").strip()
                if not s:
                    continue
                out.append(s)
            if out:
                return out
        except:
            continue
    return out


def _proxy_link_latency(link: str) -> Optional[float]:
    if not link:
        return None
    try:
        info = _parse_proxy_link(str(link))
    except:
        info = None
    if info is None:
        return None

    host = None
    port = None
    try:
        host = str(info.address)
        port = int(info.port)
    except:
        host = None
        port = None

    if not host or not port:
        return None

    s = None
    try:
        start = time.monotonic()
        s = socket.create_connection((host, port), timeout=2)
        return float(time.monotonic() - start)
    except:
        return None
    finally:
        try:
            if s is not None:
                s.close()
        except:
            pass


def _pick_best_proxy_link(links: List[str]) -> Tuple[Optional[str], Optional[float]]:
    best_link = None
    best_dt = None
    for link in links or []:
        try:
            dt = _proxy_link_latency(link)
        except:
            dt = None
        if dt is None:
            continue
        if best_dt is None or dt < best_dt:
            best_dt = dt
            best_link = link
    return best_link, best_dt


def _measure_provider_latency(proxy_type: int) -> Optional[float]:
    try:
        links = _fetch_links(int(proxy_type))
    except:
        links = []
    if not links:
        return None
    try:
        _, best_dt = _pick_best_proxy_link(links)
        return best_dt
    except:
        return None


class ForceDialogsProxyButtonHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            da = param.thisObject
            _force_show_dialogs_proxy_button(da)
        except:
            pass


class _DialogsShowSearchForceProxyHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            da = param.thisObject
            _force_show_dialogs_proxy_button(da)
        except:
            pass


class _DialogsShowDoneItemForceProxyHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            da = param.thisObject
            _force_show_dialogs_proxy_button(da)
        except:
            pass


class _ProxySettingsChangedNotifyHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            if not param.args or len(param.args) < 1:
                return
            try:
                event_id = int(param.args[0])
            except:
                return

            try:
                proxy_changed_id = int(NotificationCenter.proxySettingsChanged)
            except:
                proxy_changed_id = -1

            if event_id != proxy_changed_id:
                return

            try:
                changed = self.p._sync_tg_proxy_setting(reload_settings=False)
            except:
                changed = False
            if changed:
                try:
                    self.p._reload_settings_ui()
                except:
                    pass
        except:
            pass


class _DialogsPresentFragmentRedirectHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def before_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            if self.p._allow_open_tg_proxy_screen:
                return
            if not param.args or len(param.args) < 1:
                return
            frag_to_present = param.args[0]
            if frag_to_present is None:
                return
            ProxyListActivity = find_class("org.telegram.ui.ProxyListActivity")
            if ProxyListActivity and isinstance(frag_to_present, ProxyListActivity):
                try:
                    PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                    if PC:
                        PC.openPluginSettings("exitfy")
                except:
                    pass
                try:
                    param.setResult(False)
                except:
                    pass
        except:
            pass


class ExitfyPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._refresh_lock = threading.Lock()
        self._watchdog_token = 0
        self._active = False
        self._hooks_installed = False
        self._sync_hooks_installed = False
        self._allow_open_tg_proxy_screen = False

    def on_plugin_load(self):
        self._active = True

        try:
            first_done = bool(_prefs().getBoolean("first_auto_enable_done", False))
            if not first_done:
                _set_tg_proxy_enabled(True)
                try:
                    self.set_setting("tg_proxy_enabled", True, reload_settings=False)
                except:
                    pass
                try:
                    ed = _prefs().edit()
                    ed.putBoolean("first_auto_enable_done", True)
                    ed.commit()
                except:
                    pass
        except:
            pass

        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                item_id="exitfy_proxy_open",
                text=Z("menu_settings"),
                icon="msg_settings",
                priority=1000,
                on_click=self._open_plugin_settings,
            )
        )

        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.DRAWER_MENU,
                item_id="exitfy_proxy_open_drawer",
                text=Z("menu_settings"),
                icon="msg_settings",
                priority=1000,
                on_click=self._open_plugin_settings,
            )
        )

        self._install_redirect_hooks()
        self._install_sync_hooks()
        try:
            auto_switch = bool(self.get_setting("auto_switch", True))
        except:
            auto_switch = True
        if auto_switch:
            self._select_best_provider_and_refresh(manual=True)
        else:
            self.refresh_proxy(manual=True)

    def on_plugin_unload(self):
        self._active = False

    def _get_any_connection_state(self) -> Optional[int]:
        try:
            for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    cm = ConnectionsManager.getInstance(ac)
                    if cm is None:
                        continue
                    return int(cm.getConnectionState())
                except:
                    continue
        except:
            pass
        return None

    def _apply_proxy_link(self, link: str):
        try:
            info = _parse_proxy_link(str(link))
        except:
            info = None
        if not info:
            return
        try:
            _apply_proxy_info(info)
        except:
            pass
        try:
            _set_last_applied_link(str(link))
        except:
            pass

    def _start_connect_watchdog(self, ordered_links: List[str], applied_link: str):
        try:
            self._watchdog_token = int(self._watchdog_token) + 1
            token = int(self._watchdog_token)
        except:
            token = 0

        def job():
            try:
                time.sleep(5)
            except:
                return

            try:
                if not self._active:
                    return
            except:
                return

            try:
                if int(self._watchdog_token) != int(token):
                    return
            except:
                return

            try:
                if not bool(_tg_proxy_enabled()):
                    return
            except:
                return

            state = None
            try:
                state = self._get_any_connection_state()
            except:
                state = None

            bad = False
            try:
                bad = state == ConnectionsManager.ConnectionStateConnecting or state == ConnectionsManager.ConnectionStateConnectingToProxy
            except:
                bad = False
            if not bad:
                return

            next_link = None
            try:
                for l in ordered_links or []:
                    if str(l) == str(applied_link):
                        continue
                    next_link = l
                    break
            except:
                next_link = None

            if not next_link:
                return

            try:
                run_on_ui_thread(lambda: self._apply_proxy_link(str(next_link)))
            except:
                try:
                    self._apply_proxy_link(str(next_link))
                except:
                    pass

        threading.Thread(target=job, daemon=True).start()

    def _select_best_provider_and_refresh(self, manual: bool = False):
        def job():
            if not manual:
                try:
                    now = int(time.time())
                    last = _get_last_check_ts()
                    if now - last < CHECK_INTERVAL_SEC:
                        return
                except:
                    pass

            try:
                providers = list((API_URLS or {}).keys())
            except:
                providers = []

            if not providers:
                self.refresh_proxy(manual=True)
                return

            best_t = None
            best_rtt = None
            results = {}
            lock = threading.Lock()

            def _worker(pt: int):
                try:
                    rtt = _measure_provider_latency(int(pt))
                except:
                    rtt = None
                try:
                    lock.acquire()
                    results[int(pt)] = rtt
                except:
                    pass
                finally:
                    try:
                        lock.release()
                    except:
                        pass

            threads = []
            for t in providers:
                try:
                    th = threading.Thread(target=_worker, args=(int(t),), daemon=True)
                    threads.append(th)
                    th.start()
                except:
                    continue

            deadline = time.time() + 6
            for th in threads:
                try:
                    remain = float(deadline - time.time())
                    if remain <= 0:
                        break
                    th.join(timeout=remain)
                except:
                    pass

            for t in providers:
                try:
                    rtt = results.get(int(t))
                except:
                    rtt = None
                if rtt is None:
                    continue
                if best_rtt is None or float(rtt) < float(best_rtt):
                    best_rtt = float(rtt)
                    best_t = int(t)

            if best_t is None:
                try:
                    best_t = int(_get_selected_type())
                except:
                    best_t = 0

            prev_t = None
            try:
                prev_t = int(_get_selected_type())
            except:
                prev_t = None

            try:
                _set_selected_type(int(best_t))
            except:
                pass
            try:
                self.set_setting("provider", int(best_t), reload_settings=False)
            except:
                pass

            try:
                if prev_t is None or int(prev_t) != int(best_t):
                    self._reload_settings_ui()
            except:
                pass

            self.refresh_proxy(manual=bool(manual))
        threading.Thread(target=job, daemon=True).start()

    def _reload_settings_ui(self):
        def _run():
            try:
                PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                if PC:
                    try:
                        inst = PC.getInstance()
                    except:
                        inst = None
                    if inst is not None:
                        try:
                            inst.loadPluginSettings("exitfy")
                        except:
                            pass
            except:
                pass

        try:
            run_on_ui_thread(_run)
        except:
            _run()

    def _on_tg_proxy_enabled_changed(self, v: bool):
        try:
            _set_tg_proxy_enabled(bool(v))
        except:
            pass
        try:
            self.set_setting("tg_proxy_enabled", bool(v), reload_settings=False)
        except:
            pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _on_auto_switch_changed(self, v: bool):
        try:
            self.set_setting("auto_switch", bool(v), reload_settings=False)
        except:
            pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _sync_tg_proxy_setting(self, reload_settings: bool = False) -> bool:
        tg_state = False
        try:
            tg_state = bool(_tg_proxy_enabled())
        except:
            tg_state = False

        cur = None
        try:
            cur = bool(self.get_setting("tg_proxy_enabled", tg_state))
        except:
            cur = None

        if cur is None or cur != tg_state:
            try:
                self.set_setting("tg_proxy_enabled", tg_state, reload_settings=bool(reload_settings))
            except:
                pass
            return True
        return False

    def _install_redirect_hooks(self):
        if self._hooks_installed:
            return
        try:
            DA = find_class("org.telegram.ui.DialogsActivity")
            if DA:
                try:
                    self.hook_all_methods(DA, "updateProxyButton", ForceDialogsProxyButtonHook(self))
                except:
                    pass
                try:
                    self.hook_all_methods(DA, "showSearch", _DialogsShowSearchForceProxyHook(self))
                except:
                    pass
                try:
                    self.hook_all_methods(DA, "showDoneItem", _DialogsShowDoneItemForceProxyHook(self))
                except:
                    pass
                try:
                    self.hook_all_methods(DA, "presentFragment", _DialogsPresentFragmentRedirectHook(self))
                except:
                    pass
            self._hooks_installed = True
        except:
            pass

    def _install_sync_hooks(self):
        if self._sync_hooks_installed:
            return
        try:
            NC = find_class("org.telegram.messenger.NotificationCenter")
            if NC:
                try:
                    self.hook_all_methods(NC, "postNotificationName", _ProxySettingsChangedNotifyHook(self))
                except:
                    pass
            self._sync_hooks_installed = True
        except:
            pass

    def _on_provider_changed(self, idx: int):
        try:
            i = int(idx)
        except:
            i = 0
        try:
            _set_selected_type(int(i))
        except:
            pass
        try:
            self.set_setting("provider", int(i), reload_settings=False)
        except:
            pass
        try:
            self.refresh_proxy(manual=True)
        except:
            pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _open_tg_proxy_screen(self):
        try:
            frag = _get_last_fragment()
            if frag is None:
                return
            ProxyListActivity = find_class("org.telegram.ui.ProxyListActivity")
            if not ProxyListActivity:
                return

            self._allow_open_tg_proxy_screen = True
            try:
                frag.presentFragment(ProxyListActivity())
            finally:
                def _reset():
                    try:
                        self._allow_open_tg_proxy_screen = False
                    except:
                        pass

                run_on_ui_thread(_reset, 500)
        except:
            try:
                self._allow_open_tg_proxy_screen = False
            except:
                pass

    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.START or event_type == AppEvent.RESUME:
            try:
                changed = self._sync_tg_proxy_setting(reload_settings=False)
                if changed:
                    self._reload_settings_ui()
            except:
                pass
            try:
                auto_switch = bool(self.get_setting("auto_switch", True))
            except:
                auto_switch = True
            if auto_switch:
                self._select_best_provider_and_refresh(manual=False)
            else:
                self.refresh_proxy(manual=False)

    def _open_plugin_settings(self, context):
        try:
            PC = find_class("com.exteragram.messenger.plugins.PluginsController")
            if PC:
                PC.openPluginSettings("exitfy")
        except:
            pass

    def create_settings(self):
        tg_state = False
        try:
            tg_state = bool(_tg_proxy_enabled())
        except:
            tg_state = False

        proxy_icon = "msg2_proxy_on" if bool(tg_state) else "msg2_proxy_off"

        try:
            t = int(self.get_setting("provider", _get_selected_type()))
        except:
            t = _get_selected_type()
        if t != _get_selected_type():
            try:
                _set_selected_type(t)
            except:
                pass
        sponsor = SPONSOR_TEXT.get(t, "")
        try:
            auto_switch = bool(self.get_setting("auto_switch", True))
        except:
            auto_switch = True
        return [
            Header(text=Z("settings_header")),
            Switch(
                key="tg_proxy_enabled",
                text=Z("enable_plugin"),
                default=bool(tg_state),
                subtext=None,
                icon=proxy_icon,
                on_change=self._on_tg_proxy_enabled_changed,
            ),
            Selector(
                key="provider",
                text=Z("select_provider"),
                default=int(t),
                items=["Shrimp", "VPNET", "Sworkle"],
                icon="msg_list",
                on_change=self._on_provider_changed,
            ),
            Divider(text=sponsor),
            Switch(
                key="auto_switch",
                text=Z("auto_switch"),
                default=bool(auto_switch),
                subtext=None,
                icon="media_flip",
                on_change=self._on_auto_switch_changed,
            ),
            Text(text=Z("refresh"), icon="msg_download", accent=True, on_click=lambda v: self.refresh_proxy(manual=True)),
            Divider(),
            Text(text=Z("open_tg_settings"), icon="msg_settings", on_click=lambda v: self._open_tg_proxy_screen()),
        ]

    def refresh_proxy(self, manual: bool = False):
        now = int(time.time())
        if not manual:
            last = _get_last_check_ts()
            if now - last < CHECK_INTERVAL_SEC:
                return
        _set_last_check_ts(now)

        def job():
            if not self._refresh_lock.acquire(False):
                return
            try:
                t = _get_selected_type()
                links = _fetch_links(t)
                if not links:
                    return

                scored: List[Tuple[float, str]] = []
                for l in links:
                    try:
                        dt = _proxy_link_latency(str(l))
                    except:
                        dt = None
                    if dt is None:
                        continue
                    scored.append((float(dt), str(l)))
                if not scored:
                    return
                scored.sort(key=lambda x: x[0])
                link = str(scored[0][1]).strip()
                ordered_links = [str(x[1]) for x in scored]

                prev = _get_last_applied_link()
                if (not manual) and prev and prev == link:
                    return

                def apply_on_ui():
                    self._apply_proxy_link(link)
                    try:
                        self._start_connect_watchdog(ordered_links, link)
                    except:
                        pass

                run_on_ui_thread(apply_on_ui)
            except Exception:
                pass
            finally:
                try:
                    self._refresh_lock.release()
                except:
                    pass

        threading.Thread(target=job, daemon=True).start()


class Hook(ExitfyPlugin):
    pass

__plugin__ = Hook
