__id__ = "crypto_analiz"
__name__ = "Crypto Analiz"
__version__ = "1.0"
__author__ = "@Snegovikio, @Exter_aP"
__description__ = "–ü–ª–∞–≥–∏–Ω –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∫—É—Ä—Å –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã .crypthelp"
__min_version__ = "11.9.0"
__icon__ = "cryptovalue/3"

import requests
import json
import os.path
from datetime import datetime, timedelta
from typing import Optional, Tuple
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log
from java.util import ArrayList
from org.telegram.tgnet import TLRPC
from ui.bulletin import BulletinHelper
from ui.settings import Divider, Header, Switch, Input
from android.content import ClipboardManager
from android.content import Context

class CryptoTracker(BasePlugin):
    def __init__(self):
        super().__init__()
        self.supported_currencies = [
            "USD", "RUB", "EUR", "UAH", "GBP", "JPY", "CNY",
            "AUD", "CAD", "CHF", "INR", "BRL", "MXN", "SGD",
            "HKD", "SEK", "NOK", "KRW", "TRY", "ZAR", "PLN",
            "THB", "IDR", "MYR", "PHP", "ILS", "AED", "SAR",
            "CLP", "COP", "PEN", "ARS", "VND", "NGN", "EGP"
        ]
        self.crypto_api_url = "https://api.coingecko.com/api/v3"
        self.cache_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache")
        self.config_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache/config_crypto_tracker.json")
        os.makedirs(self.cache_dir, exist_ok=True)
        self.lang = self.get_language()
        self.load_settings()

    def get_language(self) -> str:
        try:
            from org.telegram.messenger import LocaleController
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            if lang in ["ru", "uk", "be"]:
                return "ru"
            return "en"
        except:
            return "en"

    def get_text(self, key: str) -> str:
        texts = {
            "help": {
                "ru": (
                    "üìä Crypto Analyz\n\n"
                    "–ö–æ–º–∞–Ω–¥—ã:\n"
                    ".crypt [–∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞] - –ø–æ–∫–∞–∑–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã –∑–∞ 24 —á–∞—Å–∞\n"
                    ".crypthelp - –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ\n\n"
                    "–ü—Ä–∏–º–µ—Ä—ã:\n"
                    ".crypt btc - –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã Bitcoin\n"
                    ".crypt eth - –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã Ethereum\n"
                    ".crypt ton - –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã TON"
                ),
                "en": (
                    "üìä Crypto Analyz\n\n"
                    "Commands:\n"
                    ".crypt [crypto] - show price change for 24 hours\n"
                    ".crypthelp - show this help message\n\n"
                    "Examples:\n"
                    ".crypt btc - Bitcoin price change\n"
                    ".crypt eth - Ethereum price change\n"
                    ".crypt ton - TON price change"
                )
            },
            "usage": {
                "ru": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .crypt [–∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞]",
                "en": "Usage: .crypt [crypto]"
            },
            "crypto_not_found": {
                "ru": "‚ùå –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞ '{}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
                "en": "‚ùå Cryptocurrency '{}' not found"
            },
            "currency_not_supported": {
                "ru": "‚ùå –í–∞–ª—é—Ç–∞ {} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                "en": "‚ùå Currency {} not supported"
            },
            "currency_changed": {
                "ru": "‚úÖ –í–∞–ª—é—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ {}",
                "en": "‚úÖ Default currency changed to {}"
            },
            "error": {
                "ru": "‚ùå –û—à–∏–±–∫–∞: {}",
                "en": "‚ùå Error: {}"
            },
            "search_error": {
                "ru": "‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã: {}",
                "en": "‚ùå Cryptocurrency search error: {}"
            },
            "api_error": {
                "ru": "‚ùå –û—à–∏–±–∫–∞ API: {}",
                "en": "‚ùå API error: {}"
            },
            "network_error": {
                "ru": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É",
                "en": "‚ùå Network error: check your internet connection"
            }
        }
        return texts.get(key, {}).get(self.lang, texts.get(key, {}).get("en", key))

    def on_plugin_load(self):
        self.log(f"Plugin '{self.name}' loaded successfully.")
        self.add_on_send_message_hook()
        self.load_settings()

    def on_plugin_unload(self):
        self.log(f"Plugin '{self.name}' unloaded successfully.")

    def create_settings(self):
        return [
            Header("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∞–ª—é—Ç—ã" if self.lang == "ru" else "Currency Settings"),
            Input(
                "default_currency",
                "–í–∞–ª—é—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é" if self.lang == "ru" else "Default Currency",
                self.default_currency,
                "–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –≤–∞–ª—é—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, USD, RUB, EUR)" if self.lang == "ru" else "Enter currency code (e.g., USD, RUB, EUR)",
                on_change=lambda value: self.on_currency_change(value.upper())
            )
        ]

    def on_currency_change(self, value):
        if value.upper() in self.supported_currencies:
            self.default_currency = value.upper()
            self.save_settings()
            BulletinHelper.show(self.get_text("currency_changed").format(value.upper()))
        else:
            BulletinHelper.show(self.get_text("currency_not_supported").format(value))

    def copy_to_clipboard(self, text):
        try:
            context = self.get_context()
            clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
            clipboard.setText(text)
            BulletinHelper.show("–ê–¥—Ä–µ—Å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞" if self.lang == "ru" else "Address copied to clipboard")
        except Exception as e:
            self.log(f"Error copying to clipboard: {str(e)}")

    def load_settings(self):
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    settings = json.load(f)
                if "default_currency" in settings:
                    currency = settings["default_currency"]
                    if currency in self.supported_currencies:
                        self.default_currency = currency
                    else:
                        self.default_currency = "USD"
                        self.save_settings()
                else:
                    self.default_currency = "USD"
                    self.save_settings()
            else:
                self.default_currency = "USD"
                self.save_settings()
        except Exception as e:
            self.log(f"Error loading settings: {str(e)}")
            self.default_currency = "USD"
            self.save_settings()

    def save_settings(self):
        try:
            settings = {"default_currency": self.default_currency}
            with open(self.config_file, 'w') as f:
                json.dump(settings, f, indent=4)
        except Exception as e:
            self.log(f"Error saving settings: {str(e)}")

    def get_crypto_id(self, crypto: str) -> str:
        try:
            search_response = requests.get(f"{self.crypto_api_url}/search",
                                        params={"query": crypto}, timeout=10)

            if search_response.status_code != 200:
                raise Exception(self.get_text("network_error"))

            data = search_response.json()

            if "coins" not in data or not data["coins"]:
                raise Exception(self.get_text("crypto_not_found").format(crypto))

            return data["coins"][0]["id"]

        except requests.exceptions.RequestException:
            raise Exception(self.get_text("network_error"))
        except Exception as e:
            raise Exception(self.get_text("search_error").format(str(e)))

    def get_price_change_24h(self, crypto: str) -> dict:
        try:
            crypto_id = self.get_crypto_id(crypto)

            response = requests.get(f"{self.crypto_api_url}/simple/price",
                                  params={"ids": crypto_id,
                                         "vs_currencies": self.default_currency.lower(),
                                         "include_24hr_change": "true",
                                         "include_24hr_vol": "true",
                                         "include_market_cap": "true"},
                                  timeout=10)

            if response.status_code != 200:
                raise Exception(self.get_text("network_error"))

            data = response.json()

            if crypto_id not in data:
                raise Exception(self.get_text("crypto_not_found").format(crypto))

            crypto_data = data[crypto_id]
            current_price = crypto_data.get(self.default_currency.lower(), 0)
            price_change_24h = crypto_data.get(f"{self.default_currency.lower()}_24h_change", 0)
            market_cap = crypto_data.get(f"{self.default_currency.lower()}_market_cap", 0)
            volume_24h = crypto_data.get(f"{self.default_currency.lower()}_24h_vol", 0)

            price_change_absolute = (current_price * price_change_24h) / 100 if price_change_24h else 0
            price_24h_ago = current_price - price_change_absolute

            search_response = requests.get(f"{self.crypto_api_url}/search",
                                        params={"query": crypto}, timeout=10)
            if search_response.status_code == 200:
                search_data = search_response.json()
                if "coins" in search_data and search_data["coins"]:
                    coin_info = search_data["coins"][0]
                    name = coin_info.get("name", crypto.upper())
                    symbol = coin_info.get("symbol", "").upper()
                else:
                    name = crypto.upper()
                    symbol = crypto.upper()
            else:
                name = crypto.upper()
                symbol = crypto.upper()

            return {
                "name": name,
                "symbol": symbol,
                "current_price": current_price,
                "price_24h_ago": price_24h_ago,
                "price_change_percent": price_change_24h,
                "price_change_absolute": price_change_absolute,
                "market_cap": market_cap,
                "volume_24h": volume_24h,
                "currency": self.default_currency
            }

        except requests.exceptions.RequestException:
            raise Exception(self.get_text("network_error"))
        except Exception as e:
            raise Exception(self.get_text("error").format(str(e)))

    def on_send_message_hook(self, account, params):
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult()

        message = params.message.strip()

        if message.startswith(".crypt "):
            try:
                args = message.split()
                if len(args) != 2:
                    params.message = self.get_text("usage")
                    # –ü–æ–ø—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
                    try:
                        return HookResult(strategy=HookStrategy.REPLACE, params=params)
                    except:
                        try:
                            return HookResult(strategy=HookStrategy.MODIFY, params=params)
                        except:
                            return HookResult(True, params)

                crypto = args[1].lower()

                price_data = self.get_price_change_24h(crypto)

                current_price = price_data["current_price"]
                market_cap = price_data["market_cap"]
                volume_24h = price_data["volume_24h"]

                if current_price >= 1000:
                    price_format = "{:,.0f}"
                elif current_price >= 1:
                    price_format = "{:,.2f}"
                else:
                    price_format = "{:.6f}"

                if market_cap >= 1_000_000_000:
                    market_cap_str = f"{market_cap/1_000_000_000:.2f}B"
                elif market_cap >= 1_000_000:
                    market_cap_str = f"{market_cap/1_000_000:.2f}M"
                else:
                    market_cap_str = f"{market_cap:,.0f}"

                if volume_24h >= 1_000_000_000:
                    volume_str = f"{volume_24h/1_000_000_000:.2f}B"
                elif volume_24h >= 1_000_000:
                    volume_str = f"{volume_24h/1_000_000:.2f}M"
                else:
                    volume_str = f"{volume_24h:,.0f}"

                if self.lang == "ru":
                    change_emoji = "üìà" if price_data["price_change_percent"] >= 0 else "üìâ"
                    change_text = "—Ä–æ—Å—Ç" if price_data["price_change_percent"] >= 0 else "–ø–∞–¥–µ–Ω–∏–µ"
                    change_color = "üü¢" if price_data["price_change_percent"] >= 0 else "üî¥"

                    stats = (
                        f"{change_emoji} {price_data['name']} ({price_data['symbol']})\n\n"
                        f"üí∞ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {price_format.format(current_price)} {price_data['currency']}\n"
                        f"{change_color} –ò–∑–º–µ–Ω–µ–Ω–∏–µ –∑–∞ 24—á: {price_data['price_change_percent']:+.2f}% ({change_text})\n"
                        f"üíµ –ê–±—Å–æ–ª—é—Ç–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ: {price_data['price_change_absolute']:+.2f} {price_data['currency']}\n"
                        f"üè¶ –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è: {market_cap_str} {price_data['currency']}\n"
                        f"üìä –û–±—ä–µ–º –∑–∞ 24—á: {volume_str} {price_data['currency']}\n\n"
                        f"‚è∞ –û–±–Ω–æ–≤–ª–µ–Ω–æ: {datetime.now().strftime('%H:%M:%S')}"
                    )
                else:
                    change_emoji = "üìà" if price_data["price_change_percent"] >= 0 else "üìâ"
                    change_text = "increase" if price_data["price_change_percent"] >= 0 else "decrease"
                    change_color = "üü¢" if price_data["price_change_percent"] >= 0 else "üî¥"

                    stats = (
                        f"{change_emoji} {price_data['name']} ({price_data['symbol']})\n\n"
                        f"üí∞ Current Price: {price_format.format(current_price)} {price_data['currency']}\n"
                        f"{change_color} 24h Change: {price_data['price_change_percent']:+.2f}% ({change_text})\n"
                        f"üíµ Absolute Change: {price_data['price_change_absolute']:+.2f} {price_data['currency']}\n"
                        f"üè¶ Market Cap: {market_cap_str} {price_data['currency']}\n"
                        f"üìä 24h Volume: {volume_str} {price_data['currency']}\n\n"
                        f"‚è∞ Updated: {datetime.now().strftime('%H:%M:%S')}"
                    )

                params.message = stats
                try:
                    return HookResult(strategy=HookStrategy.REPLACE, params=params)
                except:
                    try:
                        return HookResult(strategy=HookStrategy.MODIFY, params=params)
                    except:
                        return HookResult(True, params)

            except Exception as e:
                params.message = self.get_text("error").format(str(e))
                try:
                    return HookResult(strategy=HookStrategy.REPLACE, params=params)
                except:
                    try:
                        return HookResult(strategy=HookStrategy.MODIFY, params=params)
                    except:
                        return HookResult(True, params)

        elif message == ".crypthelp":
            params.message = self.get_text("help")
            try:
                return HookResult(strategy=HookStrategy.REPLACE, params=params)
            except:
                try:
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                except:
                    return HookResult(True, params)

        return HookResult()