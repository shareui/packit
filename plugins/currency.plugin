import requests
from ui.settings import Header, Input, Divider
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log
from org.telegram.tgnet import TLRPC
from java.util import Locale

__id__ = "currency"
__name__ = "Currency Converter"
__description__ = "Converts currencies using the command .cr [amount] [currency code]"
__author__ = "exteraDev, @mgebrat228"
__min_version__ = "11.9.0"
__icon__ = "DMJDuckX2/45"

FLAGS = {
    "USD": "ğŸ‡ºğŸ‡¸", "RUB": "ğŸ‡·ğŸ‡º", "EUR": "ğŸ‡ªğŸ‡º",
    "UAH": "ğŸ‡ºğŸ‡¦", "UZS": "ğŸ‡ºğŸ‡¿", "BRL": "ğŸ‡§ğŸ‡·",
    "KZT": "ğŸ‡°ğŸ‡¿", "GBP": "ğŸ‡¬ğŸ‡§", "JPY": "ğŸ‡¯ğŸ‡µ",
    "CAD": "ğŸ‡¨ğŸ‡¦", "AUD": "ğŸ‡¦ğŸ‡º", "CHF": "ğŸ‡¨ğŸ‡­",
    "CNY": "ğŸ‡¨ğŸ‡³", "INR": "ğŸ‡®ğŸ‡³", "BYN": "ğŸ‡§ğŸ‡¾",
    "MXN": "ğŸ‡²ğŸ‡½", "TRY": "ğŸ‡¹ğŸ‡·", "ZAR": "ğŸ‡¿ğŸ‡¦",
    "PLN": "ğŸ‡µğŸ‡±", "SEK": "ğŸ‡¸ğŸ‡ª", "NOK": "ğŸ‡³ğŸ‡´",
    "DKK": "ğŸ‡©ğŸ‡°", "CZK": "ğŸ‡¨ğŸ‡¿", "SGD": "ğŸ‡¸ğŸ‡¬",
    "HKD": "ğŸ‡­ğŸ‡°", "KRW": "ğŸ‡°ğŸ‡·", "THB": "ğŸ‡¹ğŸ‡­",
    "IDR": "ğŸ‡®ğŸ‡©", "MYR": "ğŸ‡²ğŸ‡¾", "PHP": "ğŸ‡µğŸ‡­",
    "ILS": "ğŸ‡®ğŸ‡±", "SAR": "ğŸ‡¸ğŸ‡¦", "AED": "ğŸ‡¦ğŸ‡ª",
    "EGP": "ğŸ‡ªğŸ‡¬", "ARS": "ğŸ‡¦ğŸ‡·", "CLP": "ğŸ‡¨ğŸ‡±",
    "COP": "ğŸ‡¨ğŸ‡´", "VND": "ğŸ‡»ğŸ‡³", "TWD": "ğŸ‡¹ğŸ‡¼",
    "NZD": "ğŸ‡³ğŸ‡¿", "HUF": "ğŸ‡­ğŸ‡º", "RON": "ğŸ‡·ğŸ‡´",
    "BGN": "ğŸ‡§ğŸ‡¬", "HRK": "ğŸ‡­ğŸ‡·", "PKR": "ğŸ‡µğŸ‡°",
    "LKR": "ğŸ‡±ğŸ‡°", "BDT": "ğŸ‡§ğŸ‡©", "NGN": "ğŸ‡³ğŸ‡¬",
    "GHS": "ğŸ‡¬ğŸ‡­", "MAD": "ğŸ‡²ğŸ‡¦", "DZD": "ğŸ‡©ğŸ‡¿",
    "KWD": "ğŸ‡°ğŸ‡¼", "QAR": "ğŸ‡¶ğŸ‡¦", "JOD": "ğŸ‡¯ğŸ‡´",
    "OMR": "ğŸ‡´ğŸ‡²", "BHD": "ğŸ‡§ğŸ‡­", "TND": "ğŸ‡¹ğŸ‡³"
}

class CurrencyConverter(BasePlugin):
    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            header_text = "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚ĞµÑ€Ğ° Ğ²Ğ°Ğ»ÑÑ‚"
            input_text = "Ğ’Ğ°Ğ»ÑÑ‚Ğ° Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ"
            input_subtext = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ´ Ğ²Ğ°Ğ»ÑÑ‚Ñ‹ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, USD, EUR, RUB)"
            divider_text = "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: .cr [ÑÑƒĞ¼Ğ¼Ğ°] [ĞºĞ¾Ğ´ Ğ²Ğ°Ğ»ÑÑ‚Ñ‹]"
        elif lang.startswith("pt"):
            header_text = "ConfiguraÃ§Ãµes do Conversor de Moedas"
            input_text = "Moeda padrÃ£o"
            input_subtext = "Digite o cÃ³digo da moeda padrÃ£o (ex: USD, EUR, BRL)"
            divider_text = "Uso: .cr [quantia] [cÃ³digo da moeda]"
        else:
            header_text = "Currency Converter Settings"
            input_text = "Default Currency"
            input_subtext = "Enter the default currency code (e.g., USD, EUR, GBP)"
            divider_text = "Usage: .cr [amount] [currency code]"
        return [
            Header(text=header_text),
            Input(
                key="default_currency",
                text=input_text,
                default="USD",
                subtext=input_subtext
            ),
            Divider(text=divider_text)
        ]

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        log("Currency Converter plugin loaded")

    def on_plugin_unload(self):
        log("Currency Converter plugin unloaded")

    def on_send_message_hook(self, account, params):
        try:
            if not hasattr(params, "message") or not isinstance(params.message, str):
                return HookResult()

            if not params.message.startswith(".cr"):
                return HookResult()
                
            # Handle the case where only .cr is sent
            if params.message.strip() == ".cr":
                params.message = self._usage_message()
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

            parts = params.message.strip().split()
            if len(parts) < 2:
                params.message = self._usage_message()
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

            amount = float(parts[1])
            currency = parts[2].upper() if len(parts) > 2 else self.get_setting("default_currency", "USD").upper()

            if currency not in FLAGS:
                params.message = self._unsupported_currency_message(currency)
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

            # Try multiple exchange rate APIs with fallbacks
            api_endpoints = [
                f"https://api.exchangerate.host/latest?base={currency}",
                f"https://open.er-api.com/v6/latest/{currency}"
            ]
            
            rates = {}
            last_error = None
            
            for url in api_endpoints:
                try:
                    log(f"Trying API: {url}")
                    response = requests.get(url, timeout=10)
                    if response.status_code == 200:
                        data = response.json()
                        if 'rates' in data and data['rates']:
                            rates = data['rates']
                            log(f"Successfully got rates from {url}")
                            break
                        else:
                            raise Exception("No rates in response")
                except Exception as e:
                    last_error = str(e)
                    log(f"API error ({url}): {last_error}")
            
            if not rates:
                log(f"All API attempts failed. Last error: {last_error}")
                params.message = self._fetch_error_message(currency)
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            if not rates:
                params.message = self._no_rates_message(currency)
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

            header = [
                f"ğŸ’± {self._format_number(amount)} {FLAGS.get(currency, '')} {currency}",
                "-----------------------------------",
                self._conversions_label()
            ]
            header_text = "\n".join(header)

            conversions_list = []
            for target in FLAGS.keys():
                if target != currency and target in rates:
                    converted = amount * rates[target]
                    flag = FLAGS.get(target, '')
                    conversions_list.append(f"- {self._format_number(converted)} {flag} {target}")

            conversions_text = "\n".join(conversions_list)

            params.message = header_text + "\n" + conversions_text

            if not hasattr(params, "entities") or params.entities is None:
                params.entities = []

            offset = len(header_text) + 4

            entity = TLRPC.TL_messageEntityBlockquote()
            entity.collapsed = True
            entity.offset = offset
            entity.length = int(len(conversions_text.encode(encoding='utf_16_le')) / 2)

            if not hasattr(params, 'entities') or params.entities is None:
                from java.util import ArrayList
                params.entities = ArrayList()
            params.entities.add(entity)

            log(params.message)
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except ValueError:
            params.message = self._invalid_amount_message()
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            log(f"Currency Converter Error: {error_details}")
            params.message = f"{self._unexpected_error_message()}\n\nError: {str(e)}"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def _format_number(self, value):
        if value == int(value):
            return f"{int(value):,}"
        return f"{value:,.2f}"

    def _usage_message(self):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: .cr [ÑÑƒĞ¼Ğ¼Ğ°] [ĞºĞ¾Ğ´ Ğ²Ğ°Ğ»ÑÑ‚Ñ‹]"
        elif lang.startswith("pt"):
            return "Uso: .cr [quantia] [cÃ³digo da moeda]"
        else:
            return "Usage: .cr [amount] [currency code]"

    def _unsupported_currency_message(self, currency):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return f"ĞÑˆĞ¸Ğ±ĞºĞ°: ĞºĞ¾Ğ´ Ğ²Ğ°Ğ»ÑÑ‚Ñ‹ '{currency}' Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ."
        elif lang.startswith("pt"):
            return f"Erro: cÃ³digo de moeda '{currency}' nÃ£o suportado."
        else:
            return f"Error: Unsupported currency code '{currency}'."

    def _fetch_error_message(self, currency):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return f"ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ĞºÑƒÑ€ÑÑ‹ Ğ²Ğ°Ğ»ÑÑ‚ Ğ´Ğ»Ñ {currency}."
        elif lang.startswith("pt"):
            return f"Erro: nÃ£o foi possÃ­vel obter taxas de cÃ¢mbio para {currency}."
        else:
            return f"Error: Unable to fetch exchange rates for {currency}."

    def _no_rates_message(self, currency):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return f"ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… ĞºÑƒÑ€ÑĞ¾Ğ² Ğ²Ğ°Ğ»ÑÑ‚ Ğ´Ğ»Ñ {currency}."
        elif lang.startswith("pt"):
            return f"Erro: nÃ£o hÃ¡ taxas de cÃ¢mbio disponÃ­veis para {currency}."
        else:
            return f"Error: No exchange rates available for {currency}."

    def _invalid_amount_message(self):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return "ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾."
        elif lang.startswith("pt"):
            return "Erro: quantia invÃ¡lida. Por favor, forneÃ§a um nÃºmero vÃ¡lido."
        else:
            return "Error: Invalid amount. Please provide a valid number."

    def _unexpected_error_message(self):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return "ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ½ĞµĞ¿Ñ€ĞµĞ´Ğ²Ğ¸Ğ´ĞµĞ½Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ."
        elif lang.startswith("pt"):
            return "Erro: ocorreu um erro inesperado. Por favor, tente novamente mais tarde."
        else:
            return "Error: An unexpected error occurred. Please try again later."

    def _conversions_label(self):
        lang = Locale.getDefault().getLanguage()
        if lang.startswith("ru"):
            return "ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ğ¸:"
        elif lang.startswith("pt"):
            return "ConversÃµes:"
        else:
            return "Conversions:"