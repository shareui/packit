 

__id__ = "music_stats_v2"
__name__ = "Music Stats"
__description__ = "Detailed music statistics: time tracking, top tracks and artists. Customizable daily goal.\n\n–ü–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è –º—É–∑—ã–∫–∏, –ø–ª–µ–µ—Ä: –≤—Ä–µ–º—è, —Ç–æ–ø —Ç—Ä–µ–∫–æ–≤ –∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π. \n–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–∞—è –µ–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Ü–µ–ª—å."
__author__ = "@Vexmioplug"
__version__ = "2.3"
__icon__ = "icqkolobki/1"
__min_version__ = "12.0.1"


import threading
import json
import os
import datetime
import shutil
import random
import time
import math
import re

from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment, send_request
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity


from java.util import ArrayList
from java.io import File
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import MediaController, ApplicationLoader, AndroidUtilities, LocaleController, MessageObject, UserConfig, MessagesController


from android.content import Intent
from android.net import Uri
from android.os import StrictMode

try:
    from ui.settings import Header, Switch, Divider, Text, Input, Selector
    UI_IMPORTED = True
except:
    UI_IMPORTED = False

class MusicStatsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.db_path = None
        
        self.data = {
            "daily_time": {}, 
            "track_counts": {}, 
            "track_durations": {},
            "artist_counts": {}, 
            "daily_tracks": {}, 
            "hourly_stats": {}
        }
        
        self.session_start_ts = time.time()
        self.session_tracks_played = 0
        self.now_playing = None
        self.session_sec = 0
        self.total_track_dur = 0
        self.is_paused = False
        self.is_counted = False
        
        self.sleep_timer_end = None
        self.stop_flag = threading.Event()
        self.worker = None
        self.menu_ids = {}
        
        try: 
            self.current_account = UserConfig.selectedAccount
        except: 
            self.current_account = 0
        
        self.CACHE_DIR = "/storage/emulated/0/Android/data/com.exteragram.messenger/files/exteraGram/exteraGram Documents"
        
        self.LANGS = {
            "ru": {
                "root_stats": "üìä –û—Ç—á–µ—Ç—ã –∏ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
                "root_player": "üéß –ü–ª–µ–µ—Ä –∏ –§–∞–π–ª—ã",
                "root_settings": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
                "cat_stats": "–ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏",
                "b_short": "–ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞ (–°–µ–≥–æ–¥–Ω—è)",
                "b_full": "–î–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç (–ì—Ä–∞—Ñ–∏–∫–∏)",
                "b_top": "üèÜ –¢–æ–ø —Ç—Ä–µ–∫–æ–≤ (–ú–µ–Ω—é)",
                "b_session": "–¢–µ–∫—É—â–∞—è —Å–µ—Å—Å–∏—è (Live)",
                "cat_player": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–ª–µ–µ—Ä–æ–º",
                "b_lucky": "–ó–∞–ø—É—Å–∫ –ø–ª–µ–µ—Ä–∞ (–ø–æ —Ñ–∏–ª—å—Ç—Ä–∞–º)",
                "cache_btn": "üìÇ –û—Ç–∫—Ä—ã—Ç—å –ø–∞–ø–∫—É —Å –º—É–∑—ã–∫–æ–π",
                "timer_btn": "‚è± –¢–∞–π–º–µ—Ä —Å–Ω–∞",
                "player_settings": "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞",
                "lucky_source": "–ò—Å—Ç–æ—á–Ω–∏–∫ –ø–æ–∏—Å–∫–∞",
                "lucky_limit": "–ì–ª—É–±–∏–Ω–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è",
                "lucky_target_id": "ID –ß–∞—Ç–∞/–ö–∞–Ω–∞–ª–∞",
                "desc_source": "‚ùì –ì–¥–µ –∏—Å–∫–∞—Ç—å –º—É–∑—ã–∫—É? (–°–ø—Ä–∞–≤–∫–∞)",
                "desc_limit": "–°–∫–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏–π –ø—Ä–æ–≤–µ—Ä—è—Ç—å (500-5000)",
                "desc_id": "–í–≤–µ–¥–∏—Ç–µ ID (–Ω–∞–ø—Ä. -100123456789)",
                "mon_cat": "–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥",
                "mon_btn": "–ê–∫—Ç–∏–≤–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥",
                "smart_btn": "–£–º–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç (90%)",
                "notify_btn": "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
                "drawer_btn": "–ò–∫–æ–Ω–∫–∞ –≤ –º–µ–Ω—é",
                "data_cat": "–î–∞–Ω–Ω—ã–µ",
                "b_save": "–≠–∫—Å–ø–æ—Ä—Ç CSV",
                "b_wipe": "–°–±—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö",
                "param_cat": "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã",
                "goal": "–¶–µ–ª—å (–º–∏–Ω)",
                "cmd": "–ö–æ–º–∞–Ω–¥–∞",
                "blk": "–ò–≥–Ω–æ—Ä-–ª–∏—Å—Ç",
                "toast_wiped": "üóë –î–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã",
                "toast_saved": "üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –ó–∞–≥—Ä—É–∑–∫–∏",
                "lucky_toast": "üîé –ò—â—É: {}",
                "lucky_fail": "‚ùå –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∏—Å—Ç–æ—Ä–∏–∏",
                "lucky_play": "‚ñ∂Ô∏è –ù–∞—à–µ–ª: ",
                "err_folder": "‚ùå –ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
                "err_open": "‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è",
                "timer_set": "üí§ –¢–∞–π–º–µ—Ä: {} –º–∏–Ω",
                "timer_off": "üí§ –¢–∞–π–º–µ—Ä –æ—Ç–∫–ª—é—á–µ–Ω",
                "timer_sleep": "üò¥ –¢–∞–π–º–µ—Ä —Å–Ω–∞: –ü–∞—É–∑–∞",
                "timer_title": "–¢–∞–π–º–µ—Ä —Å–Ω–∞",
                "t_time": "–í—Ä–µ–º—è",
                "t_total": "–í—Å–µ–≥–æ",
                "t_act": "–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (7 –¥–Ω–µ–π)",
                "t_daytime": "–†–∏—Ç–º –¥–Ω—è",
                "t_tracks": "–¢–æ–ø —Ç—Ä–µ–∫–æ–≤",
                "t_artists": "–¢–æ–ø –∞—Ä—Ç–∏—Å—Ç–æ–≤",
                "t_all_time": "–ó–∞ –≤—Å–µ –≤—Ä–µ–º—è",
                "src_saved": "–ò–∑–±—Ä–∞–Ω–Ω–æ–µ",
                "src_global": "–í–µ–∑–¥–µ (–ì–ª–æ–±–∞–ª—å–Ω–æ)",
                "src_id": "–ü–æ ID (–ö–∞–Ω–∞–ª/–ß–∞—Ç)",
                "trend_up": "—Ä–æ—Å—Ç",
                "trend_down": "—Å–ø–∞–¥",
                "trend_new": "–Ω–æ–≤—ã–π –¥–µ–Ω—å",
                "nodata": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö",
                "session_title": "–¢–µ–∫—É—â–∞—è —Å–µ—Å—Å–∏—è",
                "session_uptime": "–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: ",
                "session_tracks": "–¢—Ä–µ–∫–æ–≤ –ø—Ä–æ—Å–ª—É—à–∞–Ω–æ: ",
                "play_click": "‚ñ∂Ô∏è –°–ª—É—à–∞—Ç—å",
                "top_header": "–¢–æ–ø 20 —Ç—Ä–µ–∫–æ–≤",
                "help_title": "–°–ø—Ä–∞–≤–∫–∞ –ø–æ –ø–æ–∏—Å–∫—É",
                "help_text": (
                    "üîç **–†–µ–∂–∏–º—ã –ø–æ–∏—Å–∫–∞:**\n\n"
                    "‚≠ê **–ò–∑–±—Ä–∞–Ω–Ω–æ–µ:** –ò—â–µ—Ç –º—É–∑—ã–∫—É –≤ 'Saved Messages'.\n\n"
                    "üåç **–í–µ–∑–¥–µ:** –ò—â–µ—Ç –ø–æ –≤—Å–µ–π –∏—Å—Ç–æ—Ä–∏–∏ (–≥–ª–æ–±–∞–ª—å–Ω–æ).\n\n"
                    "üì¢ **–ü–æ ID:** –ò—â–µ—Ç –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º –∫–∞–Ω–∞–ª–µ/—á–∞—Ç–µ.\n\n"
                    "‚ùì **–ö–∞–∫ —É–∑–Ω–∞—Ç—å ID?**\n"
                    "–û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –≤ ExteraGram. –¢–∞–º –±—É–¥–µ—Ç –ø–æ–ª–µ ID. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω–µ–≥–æ, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å."
                ),
                "vibes": ["üåÖ –£—Ç—Ä–æ", "‚òÄÔ∏è –î–µ–Ω—å", "üåÜ –í–µ—á–µ—Ä", "ü¶â –ù–æ—á—å"]
            },
            "en": {
                "root_stats": "Reports & Stats",
                "root_player": "Player & Files",
                "root_settings": "Settings",
                "cat_stats": "View Statistics",
                "b_short": "Daily Summary",
                "b_full": "Detailed Report",
                "b_top": "üèÜ Top Tracks (Menu)",
                "b_session": "Current Session (Live)",
                "cat_player": "Player Controls",
                "b_lucky": "Start Player (Filtered)",
                "cache_btn": "Open Music Folder",
                "timer_btn": "‚è± Sleep Timer",
                "player_settings": "Search Configuration",
                "lucky_source": "Search Source",
                "lucky_limit": "Scan Depth",
                "lucky_target_id": "Chat/Channel ID",
                "desc_source": "‚ùì Search Help (Tap)",
                "desc_limit": "Messages to scan (500-5000)",
                "desc_id": "Enter ID (e.g. -100123456789)",
                "mon_cat": "Monitoring",
                "mon_btn": "Active Monitoring",
                "smart_btn": "Smart Count (90%)",
                "notify_btn": "Notifications",
                "drawer_btn": "Drawer Icon",
                "data_cat": "Data",
                "b_save": "Export CSV",
                "b_wipe": "Reset Data",
                "param_cat": "Parameters",
                "goal": "Goal (min)",
                "cmd": "Command",
                "blk": "Blacklist",
                "toast_wiped": "üóë Data cleared",
                "toast_saved": "üíæ Saved to Downloads",
                "lucky_toast": "üîé Searching: {}",
                "lucky_fail": "‚ùå Track not found",
                "lucky_play": "‚ñ∂Ô∏è Found: ",
                "err_folder": "‚ùå Folder not found",
                "err_open": "‚ùå Open error",
                "timer_set": "üí§ Timer set for {} min",
                "timer_off": "üí§ Timer disabled",
                "timer_sleep": "üò¥ Sleep Timer: Paused",
                "timer_title": "Sleep Timer",
                "t_time": "Time",
                "t_total": "Total",
                "t_act": "Activity (7 days)",
                "t_daytime": "Daily Rhythm",
                "t_tracks": "Top Tracks",
                "t_artists": "Top Artists",
                "t_all_time": "All Time",
                "src_saved": "Saved Messages",
                "src_global": "Global (All Chats)",
                "src_id": "By ID (Channel/Chat)",
                "trend_up": "up",
                "trend_down": "down",
                "trend_new": "new day",
                "nodata": "No data",
                "session_title": "Current Session",
                "session_uptime": "Uptime: ",
                "session_tracks": "Tracks played: ",
                "play_click": "‚ñ∂Ô∏è Play",
                "top_header": "Top 20 Tracks",
                "help_title": "Search Help",
                "help_text": (
                    "üîç **Search Modes:**\n\n"
                    "‚≠ê **Saved:** Your Saved Messages.\n\n"
                    "üåç **Global:** All chats history.\n\n"
                    "üì¢ **By ID:** Specific channel/chat.\n\n"
                    "‚ùì **How to get ID?**\n"
                    "Open chat profile in ExteraGram. Tap on the ID field to copy it."
                ),
                "vibes": ["üåÖ Morning", "‚òÄÔ∏è Day", "üåÜ Evening", "ü¶â Night"]
            }
        }

    def t(self, key):
        try:
            sys_lang = LocaleController.getInstance().getCurrentLocale().getLanguage().lower()
            lang = "ru" if sys_lang.startswith("ru") else "en"
        except: lang = "en"
        return self.LANGS[lang].get(key, key)

    def is_ru(self):
        try:
            return LocaleController.getInstance().getCurrentLocale().getLanguage().lower().startswith("ru")
        except: return False

    def on_plugin_load(self):
        try:
            root = ApplicationLoader.getFilesDirFixed().getAbsolutePath()
            self.db_path = os.path.join(root, "plugins", f"{__id__}.json")
            self.data = self.load_db()
            
            self.add_on_send_message_hook()
            self.refresh_ui()
            self.start_worker()
        except: pass

    def on_plugin_unload(self):
        self.stop_worker()
        self.clear_ui()

    def refresh_ui(self):
        self.clear_ui()
        try:
            self.menu_ids['chat'] = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text="üìä Music Stats",
                icon="msg_stats",
                priority=100,
                on_click=self.open_summary
            ))
            if self.get_setting("show_drawer", True):
                self.menu_ids['drawer'] = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text="Music Stats",
                    icon="msg_channel_14", 
                    on_click=self.open_settings
                ))
        except: pass

    def clear_ui(self):
        for mid in self.menu_ids.values():
            try: self.remove_menu_item(mid)
            except: pass
        self.menu_ids.clear()

    def open_settings(self, view=None):
        try:
            p = PluginsController.getInstance().plugins.get(__id__)
            f = get_last_fragment()
            if p and f: run_on_ui_thread(lambda: f.presentFragment(PluginSettingsActivity(p)))
            else: self.open_summary()
        except: self.open_summary()

    def on_send_message_hook(self, account, params):
        if not params.message: return HookResult()
        trigger = self.get_setting("cmd_trigger", ".mstats").strip()
        if params.message.strip() == trigger:
            self.open_summary()
            return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()

    

    def create_settings(self):
        if not UI_IMPORTED: return []
        s = []
        
        s.append(Header("Music Stats v2.3"))
        s.append(Text(text=self.t("root_stats"), icon="msg_stats", create_sub_fragment=self.create_stats_menu))
        s.append(Text(text=self.t("root_player"), icon="bot_music", create_sub_fragment=self.create_player_menu))
        s.append(Text(text=self.t("root_settings"), icon="msg_settings_ny", create_sub_fragment=self.create_config_menu))
        s.append(Divider())
        s.append(Text(text=self.t("b_lucky"), icon="menu_random", on_click=self.play_lucky_track))
        
        return s

    def create_stats_menu(self):
        try:
            return [
                Header(self.t("cat_stats")),
                Text(text=self.t("b_short"), icon="msg_stats_remix", on_click=self.open_summary),
                Text(text=self.t("b_full"), icon="menu_intro_remix", on_click=self.open_detailed),
                Text(text=self.t("b_top"), icon="msg_allowspeak", create_sub_fragment=self.create_interactive_top_menu),
                Divider(),
                Text(text=self.t("b_session"), icon="menu_premium_clock", on_click=self.open_session_stats)
            ]
        except Exception as e:
            return [Header("Error"), Text(f"{e}")]

    
    def create_interactive_top_menu(self):
        try:
            s = [Header(self.t("top_header"))]
            top = sorted(self.data.get("track_durations", {}).items(), key=lambda x: x[1], reverse=True)[:20]
            
            if not top:
                s.append(Text(text=self.t("nodata"), icon="msg_info"))
                return s
                
            for i, (name, duration) in enumerate(top):
                count = self.data["track_counts"].get(name, 0)
                dur_str = self.fmt_time(duration)
                
                
                display_text = f"{i+1}. {name}\n‚îî {dur_str} ‚Ä¢ {count}x"
                
                s.append(Text(
                    text=display_text, 
                    icon="msg_played", 
                    on_click=lambda v, n=name: self.play_specific_track(n)
                ))
            return s
        except Exception as e:
            return [Header("Error"), Text(f"{e}")]

    def play_specific_track(self, full_track_name):
        run_on_ui_thread(lambda: BulletinHelper.show_info(self.t("lucky_toast").format(full_track_name[:20]+"..."), None))
        
        
        search_query = full_track_name.replace(" - ", " ")
        
        req = TLRPC.TL_messages_searchGlobal()
        req.folder_id = 0
        req.q = search_query
        req.filter = TLRPC.TL_inputMessagesFilterMusic()
        req.min_date = 0; req.max_date = 0; req.offset_rate = 0
        req.offset_peer = TLRPC.TL_inputPeerEmpty()
        req.offset_id = 0; req.limit = 100 
        
        send_request(req, lambda res, err: self._on_specific_track_result(res, err, full_track_name, attempt=1))

    def _on_specific_track_result(self, result, error, target_name, attempt):
        try:
            
            if (error or not result or result.messages.isEmpty()) and attempt == 1:
                if " - " in target_name:
                    parts = target_name.split(" - ", 1)
                    if len(parts) > 1:
                        title_only = parts[1].strip()
                        self._retry_search(title_only, target_name)
                        return
                
                run_on_ui_thread(lambda: BulletinHelper.show_error(self.t("lucky_fail"), None))
                return

            if error or not result or result.messages.isEmpty():
                run_on_ui_thread(lambda: BulletinHelper.show_error(self.t("lucky_fail"), None))
                return

            msgs_count = result.messages.size()
            found_msg = None
            
            
            def norm(s): return s.lower().replace(" ", "").replace("-", "") if s else ""
            target_norm = norm(target_name)
            
            
            for i in range(msgs_count):
                try:
                    msg = result.messages.get(i)
                    if not msg or not msg.media: continue
                    
                    if isinstance(msg.media, TLRPC.TL_messageMediaDocument):
                        doc = msg.media.document
                        is_voice = False
                        music_title = ""
                        music_artist = ""
                        
                        if doc.attributes:
                            for attr in doc.attributes:
                                if isinstance(attr, TLRPC.TL_documentAttributeAudio):
                                    if getattr(attr, 'voice', False): is_voice = True
                                    music_title = getattr(attr, 'title', "") or ""
                                    music_artist = getattr(attr, 'performer', "") or ""
                        
                        if not is_voice:
                            
                            full_meta = f"{music_artist} - {music_title}"
                            full_meta_norm = norm(full_meta)
                            title_norm = norm(music_title)
                            
                             
                            
                            
                            if target_norm in full_meta_norm or full_meta_norm in target_norm or \
                               target_norm in title_norm or title_norm in target_norm:
                                found_msg = msg
                                break
                            
                            
                            
                            if found_msg is None:
                                found_msg = msg
                                
                except: continue

            if found_msg:
                obj = MessageObject(self.current_account, found_msg, True, True)
                title = obj.getMusicTitle() or target_name
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"{self.t('lucky_play')}{title}", None))
                run_on_ui_thread(lambda: self._force_play_single(obj))
            else:
                
                if not result.messages.isEmpty():
                     msg = result.messages.get(0)
                     obj = MessageObject(self.current_account, msg, True, True)
                     run_on_ui_thread(lambda: self._force_play_single(obj))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(self.t("lucky_fail"), None))

        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Error: {e}", None))

    def _retry_search(self, query, original_target):
        req = TLRPC.TL_messages_searchGlobal()
        req.folder_id = 0
        req.q = query
        req.filter = TLRPC.TL_inputMessagesFilterMusic()
        req.min_date = 0; req.max_date = 0; req.offset_rate = 0
        req.offset_peer = TLRPC.TL_inputPeerEmpty()
        req.offset_id = 0; req.limit = 50
        send_request(req, lambda res, err: self._on_specific_track_result(res, err, original_target, attempt=2))

    def _force_play_single(self, msg_obj):
        try:
            mc = MediaController.getInstance()
            mc.cleanupPlayer(True, True)
            list_obj = ArrayList()
            list_obj.add(msg_obj)
            if mc.setPlaylist(list_obj, msg_obj, 0): return
            if mc.playMessage(msg_obj): return
        except: pass

    

    def create_player_menu(self):
        try:
            status_text = ""
            if self.sleep_timer_end:
                remaining = int((self.sleep_timer_end - time.time()) / 60)
                status_text = f" ({remaining}m)"

            return [
                Header(self.t("cat_player") + status_text),
                Text(text=self.t("b_lucky"), icon="msg_played_remix", on_click=self.play_lucky_track),
                Text(text=self.t("cache_btn"), icon="msg_folders", on_click=self.open_cache_folder),
                Text(text=self.t("timer_btn"), icon="filled_access_sleeping", on_click=self.open_sleep_timer_dialog),
                Divider(),
                
                Header(self.t("player_settings")),
                
                
                Text(text=self.t("desc_source"), icon="msg_info", on_click=self.show_search_help),
                
                Selector(
                    key="lucky_source_mode", 
                    text=self.t("lucky_source"), 
                    items=[self.t("src_saved"), self.t("src_global"), self.t("src_id")], 
                    default=0
                ),
                
                Input(key="target_chat_id", text=self.t("lucky_target_id"), default="", subtext=self.t("desc_id"), icon="msg_channel"),
                Input(key="lucky_limit", text=self.t("lucky_limit"), default="1000", subtext=self.t("desc_limit"), icon="msg_list")
            ]
        except Exception as e:
            return [Header("Error in Menu"), Text(f"Log: {e}")]

    def show_search_help(self, v=None):
        self.alert(self.t("help_title"), self.t("help_text"))

    def create_config_menu(self):
        try:
            return [
                Header(self.t("mon_cat")),
                Switch(key="is_monitoring", text=self.t("mon_btn"), default=True, icon="msg_emoji_flags"),
                Switch(key="show_drawer", text=self.t("drawer_btn"), default=True, icon="msg_list", on_change=lambda v: self.set_setting("show_drawer", v) or self.refresh_ui()),
                Switch(key="smart_mode", text=self.t("smart_btn"), default=False, icon="msg_customize"),
                Switch(key="notify_on_scrobble", text=self.t("notify_btn"), default=True, icon="msg_message"),
                
                Divider(),
                Header(self.t("param_cat")),
                Input(key="goal_min", text=self.t("goal"), default="120", icon="filled_boost_plus"),
                Input(key="cmd_trigger", text=self.t("cmd"), default=".mstats", icon="msg_cmd"),
                Input(key="blacklist", text=self.t("blk"), default="", icon="media_button_erase"),
                
                Divider(),
                Header(self.t("data_cat")),
                Text(text=self.t("b_save"), icon="msg_download_solar", on_click=self.do_backup),
                Text(text=self.t("b_wipe"), icon="msg_delete_solar", red=True, on_click=self.do_wipe)
            ]
        except Exception as e:
            return [Header("Error"), Text(f"{e}")]

    
    def open_session_stats(self, v=None):
        duration = time.time() - self.session_start_ts
        txt = f"‚ö° **{self.t('session_title')}**\n\n"
        txt += f"‚è≥ {self.t('session_uptime')} `{self.fmt_time(duration)}`\n"
        txt += f"üé∂ {self.t('session_tracks')} `{self.session_tracks_played}`\n\n"
        if self.now_playing:
            state = "‚è∏" if self.is_paused else "‚ñ∂Ô∏è"
            txt += f"{state} **Playing:**\n{self.now_playing}"
        
        self.alert("Session Stats", txt)

    
    def open_sleep_timer_dialog(self, v=None):
        frag = get_last_fragment()
        if not frag: return
        act = frag.getParentActivity()
        b = AlertDialogBuilder(act)
        b.set_title(self.t("timer_title"))
        options = ["15 min", "30 min", "45 min", "60 min", "OFF"]
        def on_click(dialog, which):
            if which == 0: self._set_timer(15)
            elif which == 1: self._set_timer(30)
            elif which == 2: self._set_timer(45)
            elif which == 3: self._set_timer(60)
            elif which == 4: self._set_timer(0)
            dialog.dismiss()
            self.refresh_ui() 
        b.set_items(options, on_click)
        b.show()

    def _set_timer(self, minutes):
        if minutes == 0:
            self.sleep_timer_end = None
            BulletinHelper.show_success(self.t("timer_off"), None)
        else:
            self.sleep_timer_end = time.time() + (minutes * 60)
            BulletinHelper.show_success(self.t("timer_set").format(minutes), None)

    
    def open_cache_folder(self, v=None):
        try:
            path = self.CACHE_DIR
            f = File(path)
            if not f.exists():
                try: f.mkdirs()
                except: pass
                if not f.exists():
                    BulletinHelper.show_error(self.t("err_folder") + f"\n{path}", None)
                    return
            try:
                builder = StrictMode.VmPolicy.Builder()
                StrictMode.setVmPolicy(builder.build())
            except: pass
            uri = Uri.fromFile(f)
            intent = Intent(Intent.ACTION_VIEW)
            intent.setDataAndType(uri, "*/*")
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            ApplicationLoader.applicationContext.startActivity(intent)
        except Exception as e:
            BulletinHelper.show_error(f"{self.t('err_open')}: {e}", None)

    
    def play_lucky_track(self, v=None):
        mode_idx = self.get_setting("lucky_source_mode", 0)
        try:
            limit = int(self.get_setting("lucky_limit", "1000"))
        except: 
            limit = 1000
        limit = max(limit, 100)

        run_on_ui_thread(lambda: BulletinHelper.show_info(self.t("lucky_toast").format(limit), None))

        if mode_idx == 0: 
            req = TLRPC.TL_messages_getHistory()
            req.peer = TLRPC.TL_inputPeerSelf()
            req.limit = limit
            req.offset_id = 0; req.offset_date = 0; req.add_offset = 0; req.max_id = 0; req.min_id = 0; req.hash = 0
            send_request(req, self._on_lucky_result)
            
        elif mode_idx == 1: 
            req = TLRPC.TL_messages_searchGlobal()
            req.folder_id = 0
            req.q = "" 
            req.filter = TLRPC.TL_inputMessagesFilterMusic()
            req.min_date = 0; req.max_date = 0; req.offset_rate = 0
            req.offset_peer = TLRPC.TL_inputPeerEmpty()
            req.offset_id = 0; req.limit = limit
            send_request(req, self._on_lucky_result)
            
        elif mode_idx == 2: 
            target_id_str = self.get_setting("target_chat_id", "").strip()
            if not target_id_str:
                BulletinHelper.show_error("‚ö†Ô∏è ID –Ω–µ —É–∫–∞–∑–∞–Ω!", None)
                return
            
            try:
                target_id = int(target_id_str)
                self._resolve_id_and_search(target_id, limit)
            except:
                BulletinHelper.show_error("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID", None)

    def _resolve_id_and_search(self, target_id, limit):
        try:
            ctrl = MessagesController.getInstance(self.current_account)
            peer = ctrl.getInputPeer(target_id)
            if peer:
                self._execute_history_req(peer, limit)
            else:
                raw_id = target_id
                if str(target_id).startswith("-100"):
                    raw_id = int(str(target_id)[4:])
                elif str(target_id).startswith("-"):
                    raw_id = int(str(target_id)[1:])
                inp = TLRPC.TL_inputChannel()
                inp.channel_id = raw_id
                inp.access_hash = 0 
                run_on_ui_thread(lambda: BulletinHelper.show_error("‚ö†Ô∏è –ß–∞—Ç –Ω–µ –≤ –∫—ç—à–µ. –û—Ç–∫—Ä–æ–π—Ç–µ –µ–≥–æ –≤—Ä—É—á–Ω—É—é.", None))
                self._execute_history_req(inp, limit)
        except Exception as e:
             BulletinHelper.show_error(f"Error: {e}", None)

    def _execute_history_req(self, input_peer, limit):
        req = TLRPC.TL_messages_getHistory()
        req.peer = input_peer
        req.limit = limit
        req.offset_id = 0; req.offset_date = 0; req.add_offset = 0; req.max_id = 0; req.min_id = 0; req.hash = 0
        send_request(req, self._on_lucky_result)

    def _on_lucky_result(self, result, error):
        try:
            if error or not result or not result.messages:
                run_on_ui_thread(lambda: BulletinHelper.show_error(self.t("lucky_fail"), None))
                return

            msgs_count = result.messages.size()
            music_list = []

            for i in range(msgs_count):
                try:
                    msg = result.messages.get(i)
                    if not msg or not msg.media: continue
                    
                    if isinstance(msg.media, TLRPC.TL_messageMediaDocument):
                        doc = msg.media.document
                        is_audio_attr = False
                        is_voice = False
                        is_round = False
                        if doc.attributes:
                            for j in range(doc.attributes.size()):
                                attr = doc.attributes.get(j)
                                if isinstance(attr, TLRPC.TL_documentAttributeAudio):
                                    is_audio_attr = True
                                    if getattr(attr, 'voice', False): is_voice = True
                                if isinstance(attr, TLRPC.TL_documentAttributeVideo):
                                    if getattr(attr, 'round_message', False): is_round = True
                        mime = str(doc.mime_type).lower()
                        is_mime_audio = mime.startswith("audio/")
                        if (is_audio_attr or is_mime_audio) and not is_voice and not is_round:
                            music_list.append(msg)
                except: continue

            if not music_list:
                run_on_ui_thread(lambda: BulletinHelper.show_error(self.t("lucky_fail"), None))
                return

            random.shuffle(music_list)
            max_playlist = 100
            if len(music_list) > max_playlist:
                music_list = music_list[:max_playlist]
            
            playlist_objects = ArrayList()
            for m in music_list:
                obj = MessageObject(self.current_account, m, True, True)
                playlist_objects.add(obj)
            
            first_track = playlist_objects.get(0)
            count = playlist_objects.size()
            title = first_track.getMusicTitle() or "Track"
            
            run_on_ui_thread(lambda: BulletinHelper.show_success(f"{self.t('lucky_play')}{count} tracks\n‚ñ∂Ô∏è {title}", None))
            run_on_ui_thread(lambda: self._start_playlist(playlist_objects, first_track))

        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Error: {e}", None))

    def _start_playlist(self, playlist, first_track):
        try:
            mc = MediaController.getInstance()
            mc.cleanupPlayer(True, True)
            if mc.setPlaylist(playlist, first_track, 0): return
            if mc.playMessage(first_track): return
        except: pass

    
    def open_summary(self, v=None): self.show_dialog("summary")
    def open_detailed(self, v=None): self.show_dialog("detailed")
    

    def show_dialog(self, mode):
        try:
            today = datetime.date.today().isoformat()
            
            if mode == "summary":
                sec = self.data["daily_time"].get(today, 0)
                yest = (datetime.date.today() - datetime.timedelta(days=1)).isoformat()
                y_sec = self.data["daily_time"].get(yest, 0)
                
                diff = sec - y_sec
                icon = "üìà" if diff >= 0 else "üìâ"
                txt_tr = self.t("trend_up") if diff >= 0 else self.t("trend_down")
                trend = f"({icon} {self.fmt_time(abs(diff))} {txt_tr})"

                player_ui = ""
                if self.now_playing:
                    state_icon = "‚è∏" if self.is_paused else "‚ñ∂Ô∏è"
                    prog_bar = ""
                    if self.total_track_dur > 0:
                        prog_bar = self.get_bar(self.session_sec, self.total_track_dur, length=12)
                    player_ui = f"{state_icon} **{self.now_playing}**\n‚îî `{prog_bar}` `{self.fmt_time(self.session_sec)}`\n\n"

                goal = int(self.get_setting("goal_min", "120")) * 60
                main_bar = self.get_bar(sec, goal, length=15)
                
                day_tracks = self.data.get("daily_tracks", {}).get(today, {})
                top = sorted(day_tracks.items(), key=lambda x: x[1], reverse=True)[:5]
                all_time_sec = sum(self.data["daily_time"].values())
                
                txt = f"**{self.t('b_short')}**\n\n{player_ui}"
                txt += f"üéØ **{self.t('goal')}** ({int(goal/60)}m)\n`{main_bar}`\n\n"
                txt += f"‚è± **{self.t('t_time')}:** `{self.fmt_time(sec)}` {trend}\n"
                txt += f"üìÖ **{self.t('t_all_time')}:** `{self.fmt_time(all_time_sec)}`\n\n"
                txt += f"üèÜ **{self.t('t_tracks')}:**\n"
                
                if not top: txt += f"_({self.t('nodata')})_"
                else:
                    for i, (n, t) in enumerate(top): 
                        txt += f"**{i+1}.** {n}\n   ‚îî `{self.fmt_time(t)}`\n"
                self.alert(self.t("b_short"), txt)

            elif mode == "detailed":
                cur = datetime.date.today()
                w_sec = sum(self.data["daily_time"].get((cur-datetime.timedelta(days=i)).isoformat(),0) for i in range(7))
                m_sec = sum(self.data["daily_time"].get((cur-datetime.timedelta(days=i)).isoformat(),0) for i in range(30))
                y_sec = sum(self.data["daily_time"].get((cur-datetime.timedelta(days=i)).isoformat(),0) for i in range(365))
                top_art = sorted(self.data.get("artist_counts", {}).items(), key=lambda x: x[1], reverse=True)[:5]

                txt = f"üìÖ **{self.t('t_act')}:**\n{self.build_graph()}\n\n"
                txt += f"{self.build_hourly_graph()}\n"
                txt += f"üìà **{self.t('t_total')}:**\n"
                txt += f"‚Ä¢ 7D: `{self.fmt_time(w_sec)}`\n‚Ä¢ 30D: `{self.fmt_time(m_sec)}`\n‚Ä¢ 365D: `{self.fmt_time(y_sec)}`\n\n"
                txt += f"üé§ **{self.t('t_artists')}:**\n"
                if not top_art: txt += f"_({self.t('nodata')})_"
                else:
                    for i, (a, c) in enumerate(top_art): txt += f"{i+1}. {a}: `{c} plays`\n"
                self.alert(self.t("b_full"), txt)

        except Exception as e:
            BulletinHelper.show_error(f"UI Error: {e}", None)

    def alert(self, title, text):
        f = get_last_fragment()
        if f: run_on_ui_thread(lambda: self._build(f.getParentActivity(), title, text))

    def _build(self, act, title, text):
        b = AlertDialogBuilder(act)
        b.set_title(title)
        b.set_message(text)
        b.set_positive_button(self.t("ok"), None)
        b.set_neutral_button(self.t("copy"), lambda d, w: self.copy_txt(text))
        b.show()

    def copy_txt(self, text):
        try:
            cln = text.replace("**", "").replace("`", "")
            AndroidUtilities.addToClipboard(cln)
            BulletinHelper.show_success(self.t("copied"), None)
        except: pass

    
    def get_bar(self, val, max_val, length=10):
        if max_val < 1: max_val = 1
        pct = min(1.0, val / max_val)
        blk = int(pct * length)
        vis = "‚ñ∞" * blk + "‚ñ±" * (length - blk)
        return f"{vis} {int(pct * 100)}%"

    def fmt_time(self, sec):
        if sec == 0: return "?.?" 
        m, s = divmod(sec, 60)
        h, m = divmod(m, 60)
        if self.is_ru():
            return f"{h}—á {m}–º" if h > 0 else f"{m}–º {s}—Å"
        else:
            return f"{h}h {m}m" if h > 0 else f"{m}m {s}s"

    def build_graph(self):
        today = datetime.date.today()
        if self.is_ru():
            d_map = ["–ü–Ω","–í—Ç","–°—Ä","–ß—Ç","–ü—Ç","–°–±","–í—Å"]
        else:
            d_map = ["Mo","Tu","We","Th","Fr","Sa","Su"]
            
        out = ""
        max_v = 1
        points = []
        for i in range(6, -1, -1):
            d = today - datetime.timedelta(days=i)
            val = self.data["daily_time"].get(d.isoformat(), 0)
            if val > max_v: max_v = val
            points.append((d_map[d.weekday()], val))

        for name, val in points:
            pct = val / max_v
            blk = int(pct * 8)
            chars = [" ", " ", "‚ñÇ", "‚ñÉ", "‚ñÑ", "‚ñÖ", "‚ñÜ", "‚ñá", "‚ñà"]
            vis = chars[blk] * 2
            if val == 0: vis = ".."
            
            t_str = f"{int(val/60)}m"
            if val > 3600: t_str = f"{round(val/3600, 1)}h"
            if val == 0: t_str = ""
            
            out += f"`{name} {vis} {t_str}`\n"
        return out

    def build_hourly_graph(self):
        periods = [0, 0, 0, 0] 
        vibes = self.LANGS["ru"]["vibes"] if self.is_ru() else self.LANGS["en"]["vibes"]
        
        if "hourly_stats" in self.data:
            for h_str, sec in self.data["hourly_stats"].items():
                h = int(h_str)
                if 6 <= h < 12: periods[0] += sec
                elif 12 <= h < 18: periods[1] += sec
                elif 18 <= h <= 23: periods[2] += sec
                else: periods[3] += sec
                
        out = f"üï∞ **{self.t('t_daytime')}:**\n"
        total = sum(periods) or 1
        for i, val in enumerate(periods):
            pct = int((val / total) * 100)
            if val > 0: out += f"{vibes[i]}: {self.get_bar(val, total, 6)}\n"
        return out

    
    def start_worker(self):
        self.stop_flag.clear()
        self.worker = threading.Thread(target=self.work_loop, daemon=True)
        self.worker.start()

    def stop_worker(self):
        self.stop_flag.set()
        if self.worker: self.worker.join(1)

    def work_loop(self):
        while not self.stop_flag.is_set():
            try:
                if self.get_setting("is_monitoring", True):
                    self.check_playback()
            except: pass
            if self.stop_flag.wait(5): break

    def check_playback(self):
        try:
            mc = MediaController.getInstance()
            obj = mc.getPlayingMessageObject()
            
            if self.sleep_timer_end and time.time() > self.sleep_timer_end:
                self.sleep_timer_end = None
                if obj and not mc.isMessagePaused():
                    run_on_ui_thread(lambda: mc.pauseMessage(obj))
                    run_on_ui_thread(lambda: BulletinHelper.show_info(self.t("timer_sleep"), None))

            if not obj or not obj.isMusic(): 
                self.now_playing = None
                return
            
            self.is_paused = mc.isMessagePaused()

            title = obj.getMusicTitle()
            artist = obj.getMusicAuthor() or "Unknown"
            dur = 0
            try: dur = obj.getDuration()
            except: pass
            
            self.process_track(f"{artist} - {title}", artist, dur)
        except: pass

    def process_track(self, full_name, artist, total_dur):
        bl = self.get_setting("blacklist", "").lower().split(",")
        if any(b.strip() == artist.lower().strip() for b in bl if b.strip()): return

        today = datetime.date.today().isoformat()
        hour = str(datetime.datetime.now().hour) 

        for k in ["daily_time", "track_counts", "track_durations", "artist_counts", "daily_tracks", "hourly_stats"]:
            if k not in self.data: self.data[k] = {}

        if full_name != self.now_playing:
            self.now_playing = full_name
            self.session_sec = 0
            self.total_track_dur = total_dur
            self.is_counted = False

        if self.is_paused: return

        self.data["daily_time"][today] = self.data["daily_time"].get(today, 0) + 5
        
        
        if total_dur > 0:
            self.data["track_durations"][full_name] = total_dur
            
        self.data["daily_tracks"].setdefault(today, {})[full_name] = self.data["daily_tracks"].setdefault(today, {}).get(full_name, 0) + 5
        self.data["hourly_stats"][hour] = self.data["hourly_stats"].get(hour, 0) + 5
        
        self.session_sec += 5

        if not self.is_counted:
            ready = False
            if self.get_setting("smart_mode", False):
                if total_dur > 0 and self.session_sec >= (total_dur * 0.9): ready = True
                elif total_dur == 0 and self.session_sec >= 30: ready = True
            elif self.session_sec >= 5: ready = True

            if ready:
                self.data["track_counts"][full_name] = self.data["track_counts"].get(full_name, 0) + 1
                aname = artist
                akey = artist.lower().strip()
                for ex in self.data["artist_counts"]:
                    if ex.lower().strip() == akey: aname = ex; break
                self.data["artist_counts"][aname] = self.data["artist_counts"].get(aname, 0) + 1
                self.is_counted = True
                self.session_tracks_played += 1
                self.save_db()
                if self.get_setting("notify_on_scrobble", True):
                    run_on_ui_thread(lambda: BulletinHelper.show_success(f"‚úÖ {full_name}", None))

        if self.data["daily_time"][today] % 60 == 0:
            self.save_db()

    def do_wipe(self, v=None):
        self.data = {"daily_time": {}, "track_counts": {}, "track_durations": {}, "artist_counts": {}, "daily_tracks": {}, "hourly_stats": {}}
        self.save_db()
        BulletinHelper.show_success(self.t("toast_wiped"), None)

    def do_backup(self, v=None):
        try:
            self.save_db()
            csv_content = "Type,Name,Value\n"
            for k, v in self.data["artist_counts"].items(): csv_content += f"Artist,{k},{v}\n"
            for k, v in self.data["track_durations"].items(): csv_content += f"Track,{k},{v}\n"
            for k, v in self.data["daily_time"].items(): csv_content += f"Day,{k},{v}\n"
            
            dest = os.path.join(os.environ["EXTERNAL_STORAGE"], "Download", f"MusicStats_Export.csv")
            with open(dest, "w", encoding="utf-8") as f:
                f.write(csv_content)
            BulletinHelper.show_success(self.t("toast_saved"), None)
        except Exception as e:
            BulletinHelper.show_error(f"Error: {e}", None)

    def save_db(self):
        if not self.db_path: return
        try:
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            with open(self.db_path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False)
        except: pass

    def load_db(self):
        if self.db_path and os.path.exists(self.db_path):
            try:
                with open(self.db_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except: pass
        return {"daily_time": {}, "track_counts": {}, "track_durations": {}, "artist_counts": {}, "daily_tracks": {}, "hourly_stats": {}}