import traceback
import time
import json
import os
import threading
import re
import random
from typing import Optional
from datetime import datetime, timedelta
from java.util import Locale
from org.telegram.ui import DialogsActivity, LaunchActivity
from android.os import Bundle
from java import dynamic_proxy
from com.exteragram.messenger.utils import ChatUtils
from org.telegram.messenger import UserConfig, AndroidUtilities
from base_plugin import BasePlugin, HookResult
from android_utils import log as _log, run_on_ui_thread
from client_utils import send_message, get_last_fragment, get_messages_controller
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Switch, Divider, Text
from ui.alert import AlertDialogBuilder

__name__ = "Bots AutoFarm"
__description__ = "Автофарминг с гибкими настройками для различных фарм-ботов."
__icon__ = "UtyaDuckFull/93"
__id__ = "botsautofarm"
__version__ = "3.0"
__author__ = "@n1ksly, @podyshka1, @bleizix"
__min_version__ = "12.2.3"

cache: Optional['JsonCacheFile'] = None
cache_lock = threading.Lock()
DB_FILE = "autofarm_db.json"
DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"
HEARTBEAT_INTERVAL = 10 

class Locales:
    default = {
        "settings_header": "Settings",
        "message_label": "Message to send",
        "interval_label": "Send interval",
        "subtext1": "For example:\n\nFarm\nRob the treasury\nWater the garden\nShare food @user\nFeed the toad\n/dick\netc.\n\nMaximum 30 characters, anything longer will be cut off!",
        "subtext2": "The sending interval is how often the message should be sent.\n\nThe following values are supported:\n\nSecond (s)\nMinute (m)\nHour (h)\n\nThat is, for example:\n\n12 minutes > 12m\n5 hours > 5h\n54 seconds > 54s\n\nCombinations are also supported:\n\n1h37m31s = 1 hour, 37 min. and 31 sec.\nAnd so on.",
        "subtext3": "Randomization interval to avoid a ban in Iris.",
        "random_label": "Randomize (1-30 min)", # <-- ДОБАВЛЕНО
        "simvols_limit": "Maximum 30 characters.\nPart of the text was cut off",
        "enabled_label": "Enable auto-sending",
        "usage_text": "Configure the message, interval and target chat in settings, then enable auto-sending.",
        "select_chat_text": "Select target chat",
        "no_chat_selected": "No chat selected",
        "error_sending": "Error sending message",
        "invalid_interval": "Invalid interval format",
        "start_sending": "Auto-sending started",
        "stop_sending": "Auto-sending stopped",
        "empty_message_error": "Message field cannot be empty!",
        "active_form": "Active",
        "add_form": "Add form",
        "remove_form": "Remove form",
        "form_header": "Form",
        "examples_header": "Examples",
        "example_message": "Example: Farm, Rob the treasury.",
        "example_interval": "Example: 1s, 2m, 3h, 4d, 1h30m.",
        "current_chat": "Current chat",
        "chat_not_selected": "Not selected"
    }
    ru = {
        "settings_header": "Настройки",
        "message_label": "Сообщение для отправки",
        "interval_label": "Интервал отправки",
        "random_label": "Рандомизация (1-30м.)", # <-- ДОБАВЛЕНО
        "subtext1": "Например:\n\nФарма (Фармить)\nОграбить казну\nСад полить\nПоделиться едой @user\nПокормить жабу\n/dick\nи т.д.\n\nМаксимум 30 символов, всё, что больше — будет обрезано!",
        "subtext2": "Интервал отправки — это через через сколько нужно отправлять сообщение.\n\nПоддерживаются следующие значения:\n\nСекунда (s)\nМинута (m)\nЧас (h)\n\nТо есть, например:\n\n12 минут > 12m\n5 часов > 5h\n54 секунды > 54s\n\nТак же поддерживаются комбинации:\n\n1h37m31s = 1 час, 37 мин. и 31 сек.\nИ т.д.",
        "subtext3": "Рандомизирует интервал, чтобы избежать бана в ирисе.",
        "simvols_limit": "Максимум 30 символов.\nЧасть текста была обрезана.",
        "enabled_label": "Включить автоотправку",
        "usage_text": "Настройте сообщение, интервал и целевой чат в настройках, затем включите автоотправку.",
        "select_chat_text": "Выбран целевой чат",
        "no_chat_selected": "Чат не выбран",
        "error_sending": "Ошибка отправки сообщения",
        "invalid_interval": "Неверный формат интервала",
        "start_sending": "Автоотправка запущена",
        "stop_sending": "Автоотправка остановлена",
        "empty_message_error": "Поле сообщения не может быть пустым!",
        "active_form": "Активна",
        "add_form": "Добавить форму",
        "remove_form": "Удалить форму",
        "form_header": "Форма",
        "examples_header": "Примеры",
        "example_message": "Пример: Фармить, Ограбить казну.",
        "example_interval": "Пример: 1s, 2m, 3h, 4d, 1h30m.",
        "current_chat": "Текущий чат",
        "chat_not_selected": "Не выбран"
    }
    uk = default 
    en = default

def localise(key: str) -> str:
    locale = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, locale, Locales.default)
    return locale_dict.get(key, key)

def log(obj):
    _log(f"{__name__}: " + str(obj))

class JsonCacheFile:
    """Управление кэшем форм в отдельном файле."""
    def __init__(self, plugin_dir: str, filename, default_content):
        self.cache_dir = plugin_dir
        self.filename = filename
        self.path = os.path.join(self.cache_dir, filename)
        self.content = default_content
        os.makedirs(self.cache_dir, exist_ok=True) 
        self._load()


    def _load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.content = json.load(f)
                    if not isinstance(self.content, dict):
                        self.content = {"forms": {}}
            except Exception as e:
                log(f"JsonCacheFile: Не удалось загрузить кэш: {e}")
                self.content = {"forms": {}}
        else:
            self.content = {"forms": {}}
            self.write()

    def write(self):
        try:
            tmp_path = self.path + ".tmp"
            with open(tmp_path, "w", encoding="utf-8") as f:
                json.dump(self.content, f, ensure_ascii=False, indent=2)
            os.replace(tmp_path, self.path)
        except Exception as e:
            log(f"JsonCacheFile: Не удалось сохранить кэш: {e}")

    def get_forms(self):
        return self.content.get("forms", {})

    def get_form(self, form_id):
        return self.content.get("forms", {}).get(form_id)

    def set_form(self, form_id, data):
        if "forms" not in self.content:
            self.content["forms"] = {}
        self.content["forms"][form_id] = data
        self.write()

    def remove_form(self, form_id):
        if "forms" in self.content and form_id in self.content["forms"]:
            del self.content["forms"][form_id]
            self.write()

class DialogsDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
    def __init__(self, fn: callable):
        super().__init__()
        self._fn = fn
    def didSelectDialogs(self, fragment, dids, message, param, notify: bool, scheduleDate: int, topicsFragment):
        try:
            self._fn(fragment, dids, message, param, notify, scheduleDate, topicsFragment)
        except Exception as e:
            BulletinHelper.show_error(f"{e}")

    def set_global(self, key, value):
        with self.lock:
            if "global" not in self.db:
                self.db["global"] = {}
            self.db["global"][key] = value
            self._save()

    def get_global(self, key):
        with self.lock:
            return self.db.get("global", {}).get(key)

class AutoMessagePlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.running_checker = False
        self.check_thread = None
        self.selected_chat_id = None
        self.selected_chat_title = None
        self.alert_manager = AlertManager() 
        self.start_checker() 


    def on_plugin_load(self):
        global cache
        plugin_dir = os.path.dirname(os.path.realpath(__file__))
        cache = JsonCacheFile(plugin_dir, DB_FILE, {"forms": {}})
        log("Cache initialized using file-based path.")

        saved_chat_id = self.get_setting("selected_chat_id", "")
        saved_chat_title = self.get_setting("selected_chat_title", "")
        if saved_chat_id:
            try:
                self.selected_chat_id = int(saved_chat_id)
                self.selected_chat_title = saved_chat_title
            except ValueError:
                self.selected_chat_id = None
                self.selected_chat_title = None

        farms = self.get_farms()
        now = datetime.now()
        with cache_lock:
            for farm in farms:
                if not farm.get("id"):
                    continue
                form_id = farm["id"]
                cached = cache.get_form(form_id) or {}
                
                if farm.get("enabled"):
                    interval_sec = self._parse_interval(farm.get("interval", ""))
                    if interval_sec > 0:
                        if not cached.get("next_send"):
                            next_time = (now + timedelta(seconds=interval_sec)).strftime(DATETIME_FORMAT)
                            cached["next_send"] = next_time
                        
                    cached["message"] = farm.get("message", cached.get("message", ""))
                    cached["chat_id"] = farm.get("chat_id", cached.get("chat_id", ""))
                    
                cached["message"] = farm.get("message", cached.get("message", ""))
                cached["chat_id"] = farm.get("chat_id", cached.get("chat_id", ""))
                cache.set_form(form_id, cached)

        self.start_checker()
        log("AutoMessagePlugin loaded")

    def on_plugin_unload(self):
        self.stop_checker()
        log("AutoMessagePlugin unloaded")
    
    def _protected_enable_switch(self, idx, new_value):
        farms = self.get_farms()
        if idx >= len(farms):
            return

        farm = farms[idx]

        if not farm.get("message", "").strip():
            BulletinHelper.show_error(localise("empty_message_error"))
            self.set_setting(f"enabled_{farm['id']}", False, reload_settings=False)
            return

        if not farm.get("chat_id", "").strip() or farm.get("chat_title") == localise("chat_not_selected"):
            BulletinHelper.show_error(localise("no_chat_selected"))
            self.set_setting(f"enabled_{farm['id']}", False, reload_settings=False)
            return

        if self._parse_interval(farm.get("interval", "").strip()) <= 0:
            BulletinHelper.show_error(localise("invalid_interval"))
            self.set_setting(f"enabled_{farm['id']}", False, reload_settings=False)
            return

        self._on_enabled_change(new_value, idx)

    def on_settings_reset(self) -> None:
        global cache
        
        if cache is not None and hasattr(cache, 'path') and os.path.exists(cache.path):
            try:
                os.remove(cache.path)
                log(f"Cache file {cache.filename} successfully deleted.")
            except Exception as e:
                log(f"Error deleting cache file {cache.filename}: {e}")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка сброса данных: {e}"))
        
        cache = None
        log("In-memory cache set to None.")
        
        super().on_settings_reset()
        
        run_on_ui_thread(lambda: BulletinHelper.show_info("Настройки и данные AutoFarm полностью сброшены!"))
        
        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllItems"):
            run_on_ui_thread(lambda: fragment.rebuildAllItems())

    def _parse_interval(self, interval_str: str) -> int:
        s = str(interval_str).strip().lower().replace(" ", "")
        total_seconds = 0
        
        try:
            if not s:
                return 0
     
            matches = re.findall(r'(\d+)([hmds])', s)
            
            # --- ИЗМЕНЕНИЕ ЛОГИКИ ПАРСИНГА ---
            
            # Проверяем, есть ли совпадения с указанием единицы измерения (s, m, h, d)
            if not matches:
                # Если совпадений нет, но строка не пуста (т.е. просто число),
                # возвращаем 0, что вызовет ошибку "invalid_interval" в _on_enabled_change.
                if s:
                    return 0 
                # Если строка пуста, возвращаем 0 (но это уже обработано в начале)
                return 0 
            
            # Если совпадения есть, суммируем секунды
            for value_str, unit in matches:
                value = int(value_str)
                if unit == 'd':
                    total_seconds += value * 86400
                elif unit == 'h':
                    total_seconds += value * 3600
                elif unit == 'm':
                    total_seconds += value * 60
                elif unit == 's':
                    total_seconds += value
            
            return total_seconds

            # УДАЛЕНА СТАРАЯ ЛОГИКА:
            # if s.isdigit():
            #     return int(s) * 60 # Раньше тут возвращалось число * 60 (минуты)
                
        except Exception as e:
            log(f"Error parsing interval '{s}': {e}")
            
        return 0

# Добавьте эти три метода в класс BotsAutoFarmPlugin:

    def _show_version_dialog(self, view):
        # Используем данные из метаданных вашего плагина
        self._show_info("История изменений", f"Версия: 3.0:\n- Исправлен баг с обновлением интерфейса настроек\n- Требуемая версия повышена до 12.2.3\n- Полностью исправлена отправка (теперь точно). Отправка может прекратиться при плохом интернете либо частых вылетах клиента\n- Теперь максимальная длина текста для отправки - 30 символов. Всё, что больше - будет обрезано\n- Добавлена рандомизация времени. К интервалу отправки будет добавлено от 1 до 30 минут рандомно (чтобы избежать бана в ирисе\n- Теперь в названии каждой формы показывается время до следующей отправки (пока работает плохо)", "Закрыть")

    def _show_help_dialog(self, view):
        text = ("Чтобы ореинтироваться по справочнику - листайте вверх и вних по тексту.\n\nПочему у меня обрезается текст сообщения для отправки? Как это выключить?\n\nВ обновлении 3.0 мы ввели ограничение на длину сообщения для отправки, которое составляет 30 символов максимально. При попытке ввести больше символов текст будет обрезан до 30 символов. Эта мера была введена для предотвращения использования плагина для спам-рассылок, по этому выключить это невозможно. Извините.\n\nПри каких сценариях отправка может не работать?\n\nПри плохом соединении с интернетом сообщение может просто не отправиться и при частых вылетах без перезахода в приложение отправка работать не будет. Это ограничение самой телеги и исправить это никак нельзя. Следите за тем, чтобы экстера/аю не вылетали.\n\nЕсть ли шанс бана в ботах по типу Ириса?\n\nДля того, чтобы этого избежать, для подобных ботов включайте рандомизацию. Она добавляет к интервалу отправки от 1 до 30 минут рандомно, соответственно сообщение будет отправляться в разное время, минимизируя риск бана.\n\nПочему время до следующей отправки зависло и не меняется?\n\nЭто связано с обновлением методов касаемо UI настроек, из-за этого мы пока не знаем, как исправить зависания. Единственное, что мы можем посоветовать на данный момент - это свернуть и развернуть форму, это должно обновить таймер.\n\nПочему нет поддержки инлайн-кнопок у ботов и мультиаккаунта?\n\nНа данный момент мы не знаем методов, позволяющих реализовать такой функционал. Да и решения спорные. В ближайших обновах не ждите подобного (поверьте, мы пытались такое реализовать).\n\nКакие знаяения могут быть в в сообщение для отправки и интервале?\n\nЯ каждый пункт подписал, просто нажмите на один из них и откроется их описание.")
        self._show_info("FAQ", text, "Закрыть")

    def _show_info(self, title, text, positive_button="Закрыть"):
        """Показывает информационный диалог с помощью AlertManager."""
        # Эта проверка теперь будет успешной
        if hasattr(self, 'alert_manager'):
            self.alert_manager.show_info_alert(title, text, positive_button)
        else:
            # На всякий случай, если ошибка инициализации:
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Сбой инициализации AlertManager: {title}"))

    def create_settings(self):
        farms = self.get_farms()
        if not farms:
            self.add_farm()
            farms = self.get_farms()

        settings = [Header(text=localise("settings_header"))]
        settings.append(Text(
            text=localise("add_form"),
            icon="msg_addbot",
            on_click=lambda view: self.add_farm()
        ))
        settings.append(Divider())

        def make_on_change(field, i):
            return lambda value: self.update_farm_field(i, field, value)
        def make_on_click_dialog(i):
            return lambda view: self.showDialogsActivity(i)
        def make_on_enabled(i):
            return lambda enabled: self._on_enabled_change(enabled, i)
        def make_on_remove(i):
            return lambda view: self.remove_farm(i)
        def make_on_toggle_collapse(i):
            def toggle(view):
                farms = self.get_farms()
                if i < len(farms):
                    farms[i]['collapsed'] = not farms[i].get('collapsed', False)
                    self.set_farms(farms)
                    self.create_settings()
            return toggle

        for idx, farm in enumerate(farms):
            is_active = farm.get("enabled", False)
            is_collapsed = farm.get("collapsed", False)
            form_id = farm["id"] # <-- ДОБАВЛЕНО для доступа к кэшу
            
            # --- НАЧАЛО: ЛОГИКА ОТОБРАЖЕНИЯ СЛЕДУЮЩЕГО ВРЕМЕНИ ОТПРАВКИ И ОСТАТКА ЧАСОВ/МИНУТ ---
            next_send_time_str = ""
            if cache and form_id: 
                with cache_lock:
                    cached = cache.get_form(form_id) or {}
                next_send_str = cached.get("next_send")

                if next_send_str:
                    try:
                        scheduled_time = datetime.strptime(next_send_str, DATETIME_FORMAT)
                        now = datetime.now()
                        
                        if scheduled_time > now:
                            
                            time_remaining = scheduled_time - now
                            total_seconds = time_remaining.total_seconds()
                            
                            time_part = f" в {scheduled_time.strftime('%H:%M')}"
                            
                            minutes_part = ""
                            
                            if total_seconds < 60:
                                minutes_part = " (скоро)"
                            else:
                                hours = int(total_seconds // 3600)
                                minutes = int((total_seconds % 3600) // 60)
                                
                                if hours > 0:
                                    minutes_part = f" ({hours}ч {minutes}м)"
                                else:
                                    minutes_part = f" ({minutes} мин)"
                                
                            next_send_time_str = time_part + minutes_part
                    except Exception:
                        pass
            # --- КОНЕЦ: ЛОГИКА ОТОБРАЖЕНИЯ СЛЕДУЮЩЕГО ВРЕМЕНИ ОТПРАВКИ И ОСТАТКА ЧАСОВ/МИНУТ ---
            
            header_text = f"{localise('form_header')} #{idx+1}"
            
            if is_active:
                # Присоединяем статус "Активна" и время (ЧЧ:ММ)
                header_text += f"{next_send_time_str}" # <-- ИЗМЕНЕНИЕ ФОРМАТА

            collapse_icon = "msg_go_up" if not is_collapsed else "arrow_more_solar"
            settings.append(Text(
                text=header_text,
                icon=collapse_icon,
                accent=is_active,
                on_click=make_on_toggle_collapse(idx)
            ))

            if not is_collapsed:
                if len(farms) > 1:
                    settings.append(Text(
                        text=localise("remove_form"),
                        icon="msg_filled_blocked_solar",
                        accent=False,
                        red=True,
                        on_click=make_on_remove(idx)
                    ))
                settings.extend([
                    Switch(
                        key=f"enabled_{farm['id']}",
                        text=localise("enabled_label"),
                        default=farm.get("enabled", False),
                        icon="attach_send_solar",
                        on_change=lambda value, i=idx: self._protected_enable_switch(i, value)
                    ),
                    Input(
                        key=f"message_{farm['id']}",
                        text=localise("message_label"),
                        default=farm["message"],
                        subtext=localise("subtext1"), # <-- ДОБАВЛЕНО
                        icon="fab_compose_small_solar",
                        on_change=make_on_change("message", idx)
                    ),
                    Input(
                        key=f"interval_{farm['id']}",
                        text=localise("interval_label"),
                        default=farm["interval"],
                        subtext=localise("subtext2"), # <-- ДОБАВЛЕНО
                        icon="input_schedule_solar",
                        on_change=make_on_change("interval", idx)
                    ),
                    Switch(
                        key=f"random_enabled_{farm['id']}",
                        text=localise("random_label"),
                        subtext=localise("subtext3"),
                        default=farm.get("random_enabled", False),
                        icon="msg_current_location_solar", # Иконка из Triggers/TextManager
                        on_change=make_on_change("random_enabled", idx)
                    ),
                    Text(
                        text=f"{localise('current_chat')}: {farm['chat_title']}",
                        icon="ic_chatlist_add_2_solar",
                        on_click=make_on_click_dialog(idx)
                    )
                ])
            settings.append(Divider())
        if settings and isinstance(settings[-1], Divider):
            settings.pop()

        info_settings = [
            Divider(text=""),
            Header(text="Информация"),
            Text(text=f"О версии {__version__}", icon="msg_info", on_click=self._show_version_dialog),
            Text(text="FAQ", icon="msg_help_14", on_click=self._show_help_dialog),
            Text(
                text="Канал создателей",
                icon="msg_channel",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("nikslybio", get_last_fragment(), 1))
            )
        ]
        settings.extend(info_settings)
        settings.append(Divider()) 
        
        # Здесь должен быть ваш последний элемент с текстом версии, если он был:
        # settings.append(Text(text=f"{__name__} v{__version__}"))


        return [s for s in settings if s is not None]

    def get_farms(self):
        farms_json = self.get_setting("multi_farms", "[]")
        try:
            farms = json.loads(farms_json)
            if not isinstance(farms, list):
                return []
            return farms
        except Exception:
            return []

    def set_farms(self, farms):
        self.set_setting("multi_farms", json.dumps(farms), reload_settings=True)

    def add_farm(self):
        farms = self.get_farms()
        form_id = datetime.now().strftime("%Y.%m.%d %H:%M:%S.%f")
        new_form = {
            "id": form_id,
            "message": "",
            "interval": "",
            "chat_id": "",
            "chat_title": localise("chat_not_selected"),
            "enabled": False,
            "collapsed": False,
            "random_enabled": False # <-- ДОБАВЛЕНО
        }

        farms.append(new_form)
        self.set_farms(farms)

        with cache_lock:
            cf = {"next_send": None, "message": "", "chat_id": ""}
            cache.set_form(form_id, cf) 

        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllItems"):
            fragment.rebuildAllItems()

    def remove_farm(self, idx):
        farms = self.get_farms()
        if idx < 0 or idx >= len(farms):
            return

        form = farms.pop(idx)
        form_id = form.get("id")
        self.set_farms(farms)

        if form_id:
            with cache_lock:
                cache.remove_form(form_id)

        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllItems"):
            fragment.rebuildAllItems()

    def update_cache_for_form(self, farm):
        form_id = farm.get("id")
        if not form_id:
            return
        with cache_lock:
            existing = cache.get_form(form_id) or {}
            existing["message"] = farm.get("message", existing.get("message", ""))
            existing["chat_id"] = farm.get("chat_id", existing.get("chat_id", ""))

            interval_sec = self._parse_interval(farm.get("interval", ""))
            if interval_sec > 0 and farm.get("enabled"):
                existing["next_send"] = (datetime.now() + timedelta(seconds=interval_sec)).strftime(DATETIME_FORMAT)
            
            cache.set_form(form_id, existing)

    def start_checker(self):
        if self.running_checker:
            return
        self.running_checker = True

        def loop():
            while self.running_checker:
                try:
                    self.check_forms()
                except Exception as e:
                    log(f"Error in checker loop: {e}\n{traceback.format_exc()}")
                time.sleep(HEARTBEAT_INTERVAL)

        self.check_thread = threading.Thread(target=loop, daemon=True)
        self.check_thread.start()

    def stop_checker(self):
        self.running_checker = False
        if self.check_thread:
            self.check_thread = None

    def check_forms(self):
        now = datetime.now()
        with cache_lock:
            forms = dict(cache.get_forms()) 
            ui_forms = {f.get("id"): f for f in self.get_farms()}

        for form_id, data in list(forms.items()):
            next_send_str = data.get("next_send")
            
            if not next_send_str:
                continue
            try:
                scheduled_time = datetime.strptime(next_send_str, DATETIME_FORMAT)
            except Exception:
                with cache_lock:
                    cf = cache.get_form(form_id) or {}
                    cf["next_send"] = None 
                    cache.set_form(form_id, cf)
                continue

            farm = ui_forms.get(form_id)
            if not farm or not farm.get("enabled"):
                if scheduled_time > now: continue
                with cache_lock:
                    cf = cache.get_form(form_id) or {}
                    cf["next_send"] = None
                    cache.set_form(form_id, cf)
                continue


            if now >= scheduled_time:
                log(f"[Checker] Time to send message for form {form_id}.")
                
                chat_id = data.get("chat_id")
                message = data.get("message")
                
                if chat_id and message:
                    try:
                        self._send_message(chat_id, message)
                        log(f"[Checker] Successfully sent message for form {form_id}")
                    except Exception as e:
                        log(f"Error sending message for form {form_id}: {e}")

                # --- ИЗМЕНЕНИЕ: ЛОГИКА РАНДОМИЗАЦИИ ---
                interval_sec = self._parse_interval(farm.get("interval", ""))
                if interval_sec > 0:
                    
                    # Проверяем, включен ли рандом для этой формы
                    if farm.get("random_enabled", False):
                        random_addition = random.randint(60, 1800) # 1-30 минут
                        log(f"[Checker] Adding random time for {form_id}: {random_addition}s")
                        interval_sec += random_addition
                        
                    new_time = (now + timedelta(seconds=interval_sec)).strftime(DATETIME_FORMAT)
                    with cache_lock:
                        cf = cache.get_form(form_id) or {}
                        cf["next_send"] = new_time
                        cf["last_heartbeat"] = now.strftime(DATETIME_FORMAT) # <-- ДОБАВЛЕНИЕ: Сохраняем время Heartbeat
                        cache.set_form(form_id, cf)
                else:
                    with cache_lock:
                        cf = cache.get_form(form_id) or {}
                        cf["next_send"] = None
                        cf["last_heartbeat"] = now.strftime(DATETIME_FORMAT) # <-- ДОБАВЛЕНИЕ: Сохраняем время Heartbeat
                        cache.set_form(form_id, cf)
            
            # --- ДОБАВЛЕНИЕ: Сохранение heartbeat, даже если отправка не нужна ---
            # Это происходит при каждом успешном цикле, пока форма включена и есть next_send
            elif farm.get("enabled"): 
                 with cache_lock:
                    cf = cache.get_form(form_id) or {}
                    cf["last_heartbeat"] = now.strftime(DATETIME_FORMAT)
                    cache.set_form(form_id, cf)
        # --- ЛОГИКА ПЕРЕРИСОВКИ UI ---
        if should_update_ui:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "rebuildAllItems"):
                run_on_ui_thread(lambda: fragment.rebuildAllItems())
                # Обновляем время последней перерисовки
                cache.set_global("last_ui_update", now.strftime(DATETIME_FORMAT))
                log("[Checker] UI rebuilt to show updated time.")
        # --- КОНЕЦ ЛОГИКИ ПЕРЕРИСОВКИ UI ---

    def showDialogsActivity(self, idx):
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("checkCanWrite", True)
        args.putInt("dialogsType", 0)
        args.putBoolean("allowGlobalSearch", True)

        activity = DialogsActivity(args)
        delegate = DialogsDelegate(
            lambda fragment, dids, message, param, notify, scheduleDate, topicsFragment:
            self.processDialogs(idx, activity, fragment, dids, message, param, notify, scheduleDate, topicsFragment)
        )
        activity.setDelegate(delegate)

        last_fragment = LaunchActivity.getLastFragment()
        if last_fragment:
            last_fragment.presentFragment(activity)

    def processDialogs(self, idx, activity, fragment, dids, message, param, notify, scheduleDate, topicsFragment):
        activity.finishFragment()
        if dids.isEmpty():
            return
        selected_id = dids.get(0).dialogId
        peer_id = str(selected_id)
        chatUtils = ChatUtils.getInstance(UserConfig.selectedAccount)
        current_target_name = chatUtils.getName(selected_id)

        farms = self.get_farms()
        if idx < len(farms):
            farms[idx]["chat_id"] = peer_id
            farms[idx]["chat_title"] = current_target_name
            self.set_farms(farms)

            form_id = farms[idx].get("id")
            if form_id:
                with cache_lock:
                    cf = cache.get_form(form_id) or {}
                    cf["chat_id"] = peer_id
                    cf["message"] = farms[idx].get("message", cf.get("message", ""))
                    cache.set_form(form_id, cf)

        BulletinHelper.show_success(f"{localise('select_chat_text')}: {current_target_name}")
        self.create_settings()

    def update_farm_field(self, idx, field, value):
        farms = self.get_farms()
        if idx < len(farms):
            
            # --- ДОБАВЛЕНИЕ: ОГРАНИЧЕНИЕ НА СООБЩЕНИЕ ---
            if field == "message" and isinstance(value, str):
                MAX_CHARS = 30
                if len(value) > MAX_CHARS:
                    # Обрезаем текст до 30 символов
                    original_value = value
                    value = value[:MAX_CHARS]
                    
                    # Показываем уведомление
                    run_on_ui_thread(lambda: BulletinHelper.show_error(
                        f"{localise('simvols_limit')}"
                    ))
                    # Перезагружаем настройки, чтобы поле ввода обновилось обрезанным текстом
                    self.set_setting(f"message_{farms[idx]['id']}", value, reload_settings=True)
            # --- КОНЕЦ ДОБАВЛЕНИЯ ---
            
            farms[idx][field] = value.strip() if isinstance(value, str) else value
            self.set_farms(farms)
            self.update_cache_for_form(farms[idx])

# Замените ВЕСЬ метод _on_enabled_change на этот:

    def _on_enabled_change(self, enabled: bool, idx: int):
        farms = self.get_farms()
        if idx >= len(farms):
            return

        farm = farms[idx]
        form_id = farm["id"]

        def _reset_farm_state():
            with cache_lock:
                cf = cache.get_form(form_id) or {}
                cf["next_send"] = None
                cache.set_form(form_id, cf)
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "rebuildAllItems"):
                run_on_ui_thread(lambda: fragment.rebuildAllItems())

        if not enabled:
            farm["enabled"] = False
            self.set_farms(farms)
            _reset_farm_state()
            run_on_ui_thread(lambda: BulletinHelper.show_info(localise("stop_sending")))
            return

        # ENABLED (TRUE)
        # 1. Активируем форму
        farm["enabled"] = True
        self.set_farms(farms)

        interval_sec = self._parse_interval(farm.get("interval", ""))
        
        # 2. Устанавливаем время отправки
        with cache_lock:
            cf = cache.get_form(form_id) or {}
            cf["message"] = farm.get("message", cf.get("message", ""))
            cf["chat_id"] = farm.get("chat_id", cf.get("chat_id", ""))
            
            if interval_sec > 0:
                # !!! КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Устанавливаем next_send на ТЕКУЩЕЕ время
                # Это заставит фоновую задачу отправить сообщение немедленно.
                cf["next_send"] = datetime.now().strftime(DATETIME_FORMAT)
            
            cache.set_form(form_id, cf)
            
        # 3. Обновляем UI и выводим уведомление
        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllItems"):
            run_on_ui_thread(lambda: fragment.rebuildAllItems())
        run_on_ui_thread(lambda: BulletinHelper.show_success(localise("start_sending")))

        def _reset_farm_state():
            with cache_lock:
                cf = cache.get_form(farm_id) or {}
                cf["next_send"] = None
                cache.set_form(farm_id, cf)
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "rebuildAllItems"):
                run_on_ui_thread(lambda: fragment.rebuildAllItems())

        if not enabled:
            farm["enabled"] = False
            self.set_farms(farms)
            _reset_farm_state()
            run_on_ui_thread(lambda: BulletinHelper.show_info(localise("stop_sending")))
            return

        # ENABLED (TRUE)
        farm["enabled"] = True
        self.set_farms(farms)

        interval_sec = self._parse_interval(farm.get("interval", ""))
        
        # --- ДОБАВЛЕННАЯ ЛОГИКА РАНДОМИЗАЦИИ ---
        if farm.get("random_enabled", False):
            # Добавляем рандомное время от 1 до 30 минут (60 - 1800 секунд)
            random_addition = random.randint(60, 1800)
            log(f"[Enabled Change] Adding random time for {farm_id}: {random_addition}s")
            interval_sec += random_addition
        # --- КОНЕЦ ДОБАВЛЕННОЙ ЛОГИКИ РАНДОМИЗАЦИИ ---
        
        with cache_lock:
            cf = cache.get_form(farm_id) or {}
            cf["message"] = farm.get("message", cf.get("message", ""))
            cf["chat_id"] = farm.get("chat_id", cf.get("chat_id", ""))
            if interval_sec > 0:
                cf["next_send"] = (datetime.now() + timedelta(seconds=interval_sec)).strftime(DATETIME_FORMAT)
            cache.set_form(farm_id, cf)
        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllItems"):
            run_on_ui_thread(lambda: fragment.rebuildAllItems())
        run_on_ui_thread(lambda: BulletinHelper.show_success(localise("start_sending")))

    def _send_message(self, chat_id, message: str):
        try:
            if not chat_id:
                log("No chat selected for sending message")
                return
            peer_id = int(chat_id)
            log(f"Attempting to send message to chat ID: {peer_id}")
            params = {
                "peer": peer_id,
                "message": message
            }
            send_message(params)
            log(f"Successfully sent message to chat {peer_id}")
        except Exception as e:
            log(f"Error in _send_message: {e}\n{traceback.format_exc()}")
            BulletinHelper.show_error(localise("error_sending"))

    def on_send_message_hook(self, account, params):
        return HookResult()
        
        # --- Вспомогательный класс для всплывающих окон (скопировано из CustomItеmМеnu.plugin) ---

# --- Вспомогательный класс для всплывающих окон (КОПИЯ ИЗ CustomItеmМеnu.plugin) ---
class AlertManager:
    def __init__(self):
        self.alert_builder_instance: Optional[AlertDialogBuilder] = None

    def show_info_alert(self, title: str, message: str, positive_button: str):
        fragment = get_last_fragment()
        if not fragment or not fragment.getParentActivity():
            return
        context = fragment.getParentActivity()
        # Используем AlertDialogBuilder для создания диалогового окна
        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE) 
        self.alert_builder_instance = builder
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda d, w: self.dismiss_dialog())
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        run_on_ui_thread(builder.show)

    def dismiss_dialog(self):
        if self.alert_builder_instance and self.alert_builder_instance.get_dialog() and self.alert_builder_instance.get_dialog().isShowing():
            self.alert_builder_instance.dismiss()
            self.alert_builder_instance = None
