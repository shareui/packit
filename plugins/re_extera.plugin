import math
from typing import Any, Callable, Dict, Tuple

from android.content import Context, Intent
from android.net import Uri as AndroidUri
from android.os import Handler, HandlerThread, Process
from android.text import SpannableStringBuilder, Spanned, TextUtils
from android.text.style import ForegroundColorSpan
from android.view import View, ViewGroup, Window, WindowManager, WindowManagerImpl
from androidx.collection import LongSparseArray

from java import cast, dynamic_proxy, jint, jlong
from java.lang import Boolean, Integer, Long, Math, String, System
from java.util import ArrayList
from java.util.concurrent import CountDownLatch

from com.exteragram.messenger.utils import ChatUtils

from org.telegram.messenger import (AndroidUtilities, ChatObject, ContactsController,
                                     DialogObject, FileLoader, FlagSecureReason,
                                     LocaleController, NotificationCenter, R,
                                     SendMessagesHelper)
from org.telegram.messenger import LocaleController
from org.telegram.messenger import (DownloadController, MessageObject,
                                     MessagesController, MessagesStorage,
                                     NotificationCenter, NotificationsController,
                                     UserConfig)
from org.telegram.messenger.browser import Browser
from org.telegram.tgnet import TLRPC
from org.telegram.tgnet.tl import TL_account
from org.telegram.ui import ChatActivity, LaunchActivity, PhotoViewer, ProfileActivity
from org.telegram.ui.ActionBar import AlertDialog, Theme
from org.telegram.ui.Cells import ChatMessageCell, EmptyCell

from android_utils import R, log, run_on_ui_thread
from base_plugin import (BasePlugin, HookResult, HookStrategy, MenuItemData,
                         MenuItemType, MethodHook, MethodReplacement)

import client_utils
from client_utils import (get_connections_manager, get_last_fragment,
                          get_messages_controller, get_messages_storage,
                          run_on_queue, send_request)

from hook_utils import get_private_field
from ui.bulletin import BulletinHelper
from ui.settings import Divider, Header, Input, Switch

__id__ = "reExtera"
__name__ = "re:extera"
__description__ = "Just a plugin with ToS breaking features."
__author__ = "@bleizix"
__min_version__ = "11.14.1"
__icon__ = "fuki_dum_pjsk_pack/3"
__version__ = "1.4"

FLAG_SECURE = WindowManager.LayoutParams.FLAG_SECURE
FLAG_DELETED = 1 << 16

readReqs = ["TL_messages_readHistory", "TL_messages_readEncryptedHistory", "TL_messages_readDiscussion",
            "TL_messages_readMessageContents", "TL_channels_readHistory", "TL_channels_readMessageContents",
            "TL_messages_markDialogUnread"]
typingReqs = ["TL_messages_setTyping", "TL_messages_setEncryptedTyping"]
storiesReqs = ["TL_stories_readStories", "TL_stories_incrementStoryViews"]
sendMsgReqs = ["TL_messages_sendMessage",
               "TL_messages_sendMedia",
               "TL_messages_sendMultiMedia",
               "TL_messages_forwardMessage",
               "TL_messages_forwardMessages",
               "TL_messages_sendInlineBotResult",
               "TL_messages_sendEncrypted",
               "TL_messages_sendEncryptedFile",
               "TL_messages_sendEncryptedMultiMedia",
               "TL_messages_sendEncryptedService"]
onlineReqs = [*sendMsgReqs,
              *readReqs,
              "TL_messages_editMessage",
              "TL_messages_createChat",
              "TL_channels_createChannel",
              "TL_channels_createForumTopic",
              "TL_channels_leaveChannel",
              "TL_channels_deleteTopicHistory",
              "TL_channels_editForumTopic",
              "TL_messages_updatePinnedMessage",
              "requestCall",
              "acceptCall",
              "confirmCall",
              "TL_stories_sendStory",
              "TL_stories_sendReaction",
              "TL_stories_readStories"]


class IntCb(dynamic_proxy(MessagesStorage.IntCallback)):
    def __init__(self, fn):
        super().__init__()
        self._fn = fn

    def run(self, param):
        try:
            self._fn(param)
        except Exception as e:
            BulletinHelper.show_info(f"Error in int callback: {e}")
            log(str(e))


NOTIFICATION_DELETED = 6969


def getUser(userId, callback):
    req = TLRPC.TL_users_getUsers()
    req.id.add(get_messages_controller().getInputUser(userId))
    send_request(req, callback)


def getScheduleTime(photo, document):
    time = 10.0 + 2.0
    if (document is not None and document.access_hash != 0 and (
            MessageObject.isStickerDocument(document) or MessageObject.isAnimatedStickerDocument(document, True))):
        return math.ceil(time)
    if (document is not None and document.access_hash != 0 and MessageObject.isGifDocument(document)):
        return math.ceil(time)

    photoFileSize = 0
    if (photo is not None):
        maybeSize = FileLoader.getClosestPhotoSizeWithSize(photo.sizes, AndroidUtilities.getPhotoSize())
        if maybeSize is not None:
            photoFileSize = maybeSize.size

    documentFileSize = 0
    if document is not None:
        documentFileSize = document.size
    if (photoFileSize != 0):
        time += max(6, math.ceil(photoFileSize / 1024.0 / 1024.0 * 4.5))
    if (documentFileSize != 0):
        time += max(6, math.ceil(documentFileSize / 1024.0 / 1024.0 * 4.5))

    return math.ceil(time)


def process(response, error):
    if error is None and response is not None:
        if isinstance(response, TLRPC.TL_messages_affectedMessages):
            get_messages_controller().processNewDifferenceParams(-1, response.pts, -1, response.pts_count)


def markReadOnServer(messageId, readMedia, peer):
    req = None

    if isinstance(peer, TLRPC.TL_inputPeerChannel):
        request = TLRPC.TL_channels_readHistory()
        request.channel = MessagesController.getInputChannel(peer)
        request.max_id = int(messageId)

        req = request
    else:
        request = TLRPC.TL_messages_readHistory()
        request.peer = peer
        request.max_id = int(messageId)

        req = request
    req.networkType = int(1337)
    send_request(req, process)


def getMessageId(object):
    messageId = None
    if isinstance(object, TLRPC.TL_messages_sendReaction):
        messageId = object.msg_id
    elif isinstance(object, TLRPC.TL_messages_sendVote):
        messageId = object.msg_id
    return messageId


def getDialogId(peer):
    dialogId = 0
    if peer.chat_id != 0:
        dialogId = -peer.chat_id
    elif peer.channel_id != 0:
        dialogId = -peer.channel_id
    else:
        dialogId = peer.user_id
    return dialogId


def extractPeer(object):
    peer = None
    if isinstance(object, TLRPC.TL_messages_sendMessage):
        peer = object.peer
    elif isinstance(object, TLRPC.TL_messages_sendMedia):
        peer = object.peer
    elif isinstance(object, TLRPC.TL_messages_sendMultiMedia):
        peer = object.peer
    elif isinstance(object, TLRPC.TL_messages_forwardMessages):
        peer = object.to_peer
    elif isinstance(object, TLRPC.TL_messages_sendInlineBotResult):
        peer = object.peer
    if isinstance(object, TLRPC.TL_messages_sendReaction):
        peer = object.peer
    elif isinstance(object, TLRPC.TL_messages_sendVote):
        peer = object.peer
    return peer


class DeletedMessageInfo:
    def __init__(self, selectedAccount: int, channelId: int, messageIds, messageId: int = 0):
        self.selectedAccount = selectedAccount
        self.channelId = channelId
        if (messageIds):
            self.messageIds = messageIds
        else:
            self.messageIds = ArrayList()
            self.messageIds.add(messageId)


class ReExtera(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hook_cache = {}
        self.cachedDeleted = set()
        self.allowedToDelete = set()

    def isCachedDeleted(self, did, msg):
        return str(did) + "_" + str(msg) in self.cachedDeleted

    @staticmethod
    def isMessageDeleted(msgStorage, dialog_id, message_id):
        db = get_private_field(msgStorage, "database")
        query = "SELECT data FROM messages_v2 WHERE uid = ? AND mid = ?"

        cursor = None
        try:

            cursor = db.queryFinalized(query, dialog_id, message_id)
            if cursor.next():
                data = cursor.byteBufferValue(0)
                if data:
                    data.position(8)
                    flags2 = data.readInt32(True)

                    return (flags2 & FLAG_DELETED) != 0

        except Exception as e:
            log(f"fucked up: {e}")
        finally:
            if cursor:
                cursor.dispose()

        return False


    @staticmethod
    def reallyDeleteMessage(msgStorage, dialog_id, message_id):
        log("really deleting message!!!")
        db = get_private_field(msgStorage, "database")
        statement = None
        try:
            statement = db.executeFast("DELETE FROM messages_v2 WHERE uid = ? AND mid = ?")

            statement.bindLong(1, dialog_id)
            statement.bindInteger(2, message_id)
            statement.step()
        except Exception as e:
            log(f"Error removing message from database: {e}")
        finally:
            if statement:
                statement.dispose()

    def markMessagesDeletedInternal(self, msgStorage, dialogId: int, delMsgReal: ArrayList):
        def runnable():
            log("delMsgReal" + str(delMsgReal))


            delMsg = ArrayList()
            for msgId in delMsgReal.toArray():
                if self.isCachedDeleted(dialogId, msgId) or self.isMessageDeleted(msgStorage, dialogId, msgId):
                    self.reallyDeleteMessage(msgStorage, dialogId, msgId)
                delMsg.add(msgId)

            log("delMsg" + str(delMsg))

            db = get_private_field(msgStorage, "database")

            select_sql = f"SELECT data FROM messages_v2 WHERE uid = ? AND mid = ?"
            update_sql = "UPDATE messages_v2 SET data = ? WHERE uid = ? AND mid = ?"

            db.beginTransaction()
            try:
                selectStatement = db.executeFast(select_sql)
                updateStatement = db.executeFast(update_sql)

                for msg_id in delMsg.toArray():
                    self.cachedDeleted.add(f"{dialogId}_{msg_id}")

                    cursor = selectStatement.query([dialogId, msg_id])
                    if not cursor.next():
                        cursor.dispose()
                        continue

                    data = cursor.byteBufferValue(0)
                    cursor.dispose()

                    if not data:
                        continue

                    data.position(8)
                    flags2 = data.readInt32(True)
                    if (flags2 & FLAG_DELETED) == 0:
                        flags2 |= FLAG_DELETED
                        data.position(8)
                        data.writeInt32(flags2)
                        data.position(0)

                        updateStatement.requery()
                        updateStatement.bindByteBuffer(1, data)
                        updateStatement.bindLong(2, dialogId)
                        updateStatement.bindInteger(3, msg_id)
                        updateStatement.step()

                    data.reuse()

                db.commitTransaction()

            finally:
                if selectStatement:
                    selectStatement.dispose()
                if updateStatement:
                    updateStatement.dispose()


        try:
            run_on_queue(lambda: runnable(), client_utils.PLUGINS_QUEUE)
        except Exception as e:
            log(f"deleted msgs: {e}")
    def markMessagesDeleted(self, dialogId: int, delMsg: ArrayList):
        self.markMessagesDeletedInternal(get_messages_storage(), dialogId, delMsg)



    def _get_hook_method(self, class_obj, method_name, *param_types):
        key = f"{class_obj.getName()}.{method_name}"
        if key in self.hook_cache:
            return self.hook_cache[key]
        try:
            method = class_obj.getDeclaredMethod(method_name, *param_types)
            self.hook_cache[key] = method
            return method
        except Exception as e:
            log(f"wtf! failed to find hook {key}: {e}")
            return None

    def handle_message_click(self, context: Dict[str, Any]):
        message = context.get("message")
        readMedia = (message.messageOwner.media and (
                    message.messageOwner.media.round or message.messageOwner.media.voice) and message.messageOwner.media.ttl_seconds == 0)

        if message:
            markReadOnServer(message.getId(), readMedia, get_messages_controller().getInputPeer(message.getSenderId()))
            message.setIsRead()

            if (readMedia):
                get_messages_controller().markMessageContentAsRead(message)
                message.setContentIsRead()


    def isGhostModeActive(self):
        def isOn(key):
            return self.get_setting(key, True)
        return isOn("dontRead") or isOn("dontType") or isOn("dontOnline") or isOn("dontReadStories") or isOn("immediateOffline")

    def toggleGhostMode(self, not_used: bool):
        state = self.isGhostModeActive()
        def onUi():
            NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(43) # NotificationCenter.mainUserInfoChanged
            NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(284) # NotificationCenter.currentUserPremiumStatusChanged

        self.set_setting("dontRead", not state)
        self.set_setting("dontType", not state)
        self.set_setting("dontOnline", not state)
        self.set_setting("dontReadStories", not state)
        self.set_setting("immediateOffline", not state)

        if (state): 
            self.sendOffline()

        run_on_ui_thread(lambda: onUi())

    def on_plugin_load(self):

        if (self.get_setting("dontRead", True)):
            self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                    text="Read Message",
                    on_click=self.handle_message_click,
                    icon="msg_view_file"
                )
            )
        state = "Enable Ghost" if self.isGhostModeActive() else "Disable Ghost"

        # IDK HOW TO UPDATE THIS THING'S STATE
        # ITS JUST STAY "Enable Ghost" OR "Disable Ghost"

        # self.add_menu_item(
        #     MenuItemData(
        #         menu_type=MenuItemType.DRAWER_MENU,
        #         text=state,
        #         on_click=self.toggleGhostMode,
        #         icon="ghost" # looks terrible to be honest
        #     )
        # )



        for hook in typingReqs:
            self.add_hook(hook)
        for hook in storiesReqs:
            self.add_hook(hook)
        for hook in onlineReqs:
            self.add_hook(hook)
        self.add_hook("updateStatus")

        class FixMsgsController(MethodReplacement):
            def callback(self, response, error):
                if not error and response:
                    MessagesController.processNewDifferenceParams(-1, response.pts, -1, response.pts_count)

            def handle(self, param):
                messageObject = param.args[0]
                if messageObject.scheduled:
                    return

                arrayList = ArrayList()
                if messageObject.messageOwner.mentioned:
                    get_messages_storage().markMentionMessageAsRead(-messageObject.messageOwner.peer_id.channel_id,
                                                                    messageObject.getId(), messageObject.getDialogId())

                arrayList.add(messageObject.getId())
                dialogId = messageObject.getDialogId()
                get_messages_storage().markMessagesContentAsRead(dialogId, arrayList, 0, 0)
                # NotificationCenter.messagesReadContent = 62
                run_on_ui_thread(lambda: NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(62, dialogId, arrayList))


                if messageObject.getId() < 0:
                    MessagesController.markMessageAsRead(messageObject.getDialogId(),
                                                         messageObject.messageOwner.random_id, Integer.MIN_VALUE)
                else:
                    if (messageObject.messageOwner.peer_id.channel_id != 0):
                        req = TLRPC.TL_channels_readMessageContents()
                        req.channel = MessagesController.getInputChannel(
                            get_messages_controller().getChat(Long(messageObject.messageOwner.peer_id.channel_id)))
                        if req.channel is None:
                            return
                        req.id.add(Integer(messageObject.getId()))
                        send_request(req, None)
                    else:
                        req = TLRPC.TL_messages_readMessageContents()
                        req.id.add(Integer(messageObject.getId()))
                        send_request(req, self.callback)

            def replace_hooked_method(self, param):
                try:
                    self.handle(param)
                except Exception as e:
                    log(str(e))
                    BulletinHelper.show_info(str(e))

        method = self._get_hook_method(MessagesController.getClass(), "markMessageContentAsRead", MessageObject)
        if method:
            self.hook_method(method, FixMsgsController())

        class markMentionMessageAsRead(MethodReplacement):

            def handle(self, param):
                def callback(self, response, error):
                    if error is None and response is not None:
                        get_messages_controller().processNewDifferenceParams(-1, response.pts, -1, response.pts_count)

                mid = param.args[0]
                channelId = param.args[1]
                did = param.args[2]

                def test(r, e):
                    log(f"error: {e}")
                    log(f"response: {r}")

                get_messages_storage().markMentionMessageAsRead(-channelId, mid, did)
                if channelId != 0:
                    req = TLRPC.TL_channels_readMessageContents()
                    req.channel = get_messages_controller().getInputChannel(channelId)

                    if req.channel is None:
                        return
                    req.id.add(Integer(mid))
                    req.networkType = 1337
                    send_request(req, test)
                else:
                    req = TLRPC.TL_messages_readMessageContents()
                    req.id.add(Integer(mid))
                    req.networkType = 1337
                    send_request(req, callback)


            def replace_hooked_method(self, param):
                try:
                    self.handle(param)
                except Exception as e:
                    log(str(e))
                    BulletinHelper.show_info(str(e))

        method = self._get_hook_method(MessagesController.getClass(), "markMentionMessageAsRead", Integer.TYPE,
                                       Long.TYPE,
                                       Long.TYPE)
        if method:
            self.hook_method(method, markMentionMessageAsRead())

        # flag secure remover
        class Remove(MethodHook):
            def before_hooked_method(self, param):
                flags_arg_index = 0
                mask_arg_index = 1
                original_flags = int(param.args[flags_arg_index])
                original_mask = int(param.args[mask_arg_index])

                if (original_mask & FLAG_SECURE) != 0:
                    modified_flags = original_flags & ~FLAG_SECURE
                    param.args[flags_arg_index] = Integer(modified_flags)
                    param.args[mask_arg_index] = Integer(original_mask)

        class Remove2(MethodHook):
            def before_hooked_method(self, param):
                params = param.args[1]
                if (params.flags & 0x00002000) != 0:
                    params.flags &= int(~0x00002000)

        class Remove3(MethodReplacement):
            def replace_hooked_method(self, param):
                return

        if (self.get_setting("removeFlagSecure", True)):
            method1 = self._get_hook_method(Window.getClass(), "setFlags", Integer.TYPE, Integer.TYPE)
            if method1:
                self.hook_method(method1, Remove())

            method2 = self._get_hook_method(WindowManagerImpl.getClass(), "addView", View, ViewGroup.LayoutParams)
            if method2:
                self.hook_method(method2, Remove2())

            method3 = self._get_hook_method(FlagSecureReason.getClass(), "attach")
            if method3:
                self.hook_method(method3, Remove3())

        class ScheduleHelper(MethodHook):
            def __init__(self, pl):
                self.plugin = pl
                self.hooked = None

            @staticmethod
            def pseudoReply(message: str, caption: str, photo: TLRPC.TL_photo, peer: int,
                            replyQuote: ChatActivity.ReplyQuote, replyToMsg: MessageObject, entities: ArrayList):


                def getLengthOfTheString(string : str) -> int:
                    # since python is bullshit
                    # and counts 1 emoji as 2 symbols

                    return int(len(string.encode(encoding='utf_16_le')) / 2)
                if (TextUtils.isEmpty(message) and TextUtils.isEmpty(caption) and photo is None) or TextUtils.isEmpty(
                        replyToMsg.messageText):
                    return [message, caption]

                fromPeer = replyToMsg.getFromPeerObject()
                name = ""
                if (not DialogObject.isUserDialog(peer) or abs(replyToMsg.getDialogId()) != abs(peer)):
                    if (isinstance(fromPeer, TLRPC.Chat)):
                        name = fromPeer.title
                    elif (isinstance(fromPeer, TLRPC.User)):
                        name = ContactsController.formatName(fromPeer.first_name, fromPeer.last_name)

                if (not TextUtils.isEmpty(name)):
                    name += "\n"

                replyToPeer = replyQuote.peerId if replyQuote else replyToMsg.getSenderId()
                msgText = replyQuote.getText() if replyQuote else replyToMsg.messageText
                pref = str(msgText)




                # python moment
                if (msgText.length() > 100):
                    pref = str(msgText.subSequence(0, 100)) + str("...")

                prefix = str(name) + pref
                prefixLength = 0
                if (not TextUtils.isEmpty(message)):
                    message = prefix + "\n" + message
                    prefixLength = getLengthOfTheString(prefix) + 1
                elif (not TextUtils.isEmpty(caption)):
                    caption = prefix + "\n" + caption
                    prefixLength = getLengthOfTheString(prefix) + 1
                elif (photo):
                    caption = prefix
                    prefixLength = getLengthOfTheString(prefix)

                if (entities and entities.size() > 0 and prefixLength != 0):
                    for entity in entities.toArray():
                        entity.offset += prefixLength

                bold = TLRPC.TL_messageEntityBold()
                bold.length = getLengthOfTheString(name)
                entities.add(bold)

                mention = TLRPC.TL_inputMessageEntityMentionName()
                mention.user_id = get_messages_controller().getInputUser(replyToPeer)
                mention.length = getLengthOfTheString(name)
                entities.add(mention)

                quote = TLRPC.TL_messageEntityBlockquote()
                quote.length = getLengthOfTheString(prefix)
                entities.add(quote)

                return [message, caption]

            def before_hooked_method(self, param):
                params = param.args[0]
                if params.scheduleDate == 0 and self.plugin.get_setting("useScheduled", False):
                    self.hooked = self.plugin.hook_method(
                        self.plugin._get_hook_method(ChatActivity.getClass(), "openScheduledMessages", Integer.TYPE,
                                                     Boolean.TYPE),
                        Remove3())

                    param.args[0].scheduleDate = get_connections_manager().getCurrentTime() + getScheduleTime(
                        params.photo, params.document)

                    method = self.plugin._get_hook_method(ChatActivity.getClass(), "updateBottomOverlay")
                    if method:
                        method.setAccessible(True)
                        fragment = get_last_fragment()
                        method.invoke(fragment)

                if (params.replyToMsg and params.replyToMsg.messageOwner and (
                        (params.replyToMsg.messageOwner.flags2 & FLAG_DELETED) != 0
                        or self.plugin.isCachedDeleted(MessageObject.getPeerId(params.replyToMsg.messageOwner.from_id),
                                                       params.replyToMsg.messageOwner.id))):

                    if (params.entities is None):
                        params.entities = ArrayList()
                    pair = ["", ""]
                    try:
                        pair = self.pseudoReply(params.message, params.caption, params.photo, params.peer,
                                                params.replyQuote, params.replyToMsg, params.entities)
                    except Exception as e:
                        log(f"dw[ad;aw: {e}")

                    params.message = pair[0]
                    params.caption = pair[1]
                    if (params.replyToMsg.messageOwner.flags2 & FLAG_DELETED) != 0:
                        params.replyToMsg = params.replyToTopMsg
                        params.replyQuote = None


            def after_hooked_method(self, param):
                if self.plugin.get_setting("useScheduled", False):
                    try:
                        run_on_queue(lambda: self.plugin.unhook_method(self.hooked), "externalNetworkQueue", 650)
                    except Exception as e:
                        BulletinHelper.show_info(f"e {e}")

        method = self._get_hook_method(SendMessagesHelper.getClass(), "sendMessage",
                                       SendMessagesHelper.SendMessageParams)
        if method:
            self.hook_method(method, ScheduleHelper(self))

        class ScheduleHelper2(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                messages = param.args[0]
                peer = param.args[1]
                scheduleDateOrig = param.args[5]
                if scheduleDateOrig == 0 and not DialogObject.isEncryptedDialog(peer) and self.plugin.get_setting(
                        "useScheduled", False):
                    param.args[5] = Integer(get_connections_manager().getCurrentTime() + 12)
                    method = self.plugin._get_hook_method(ChatActivity.getClass(), "updateBottomOverlay")
                    if method:
                        method.setAccessible(True)
                        fragment = get_last_fragment()
                        method.invoke(fragment)

                    did = messages.get(0).getDialogId()
                    noForwardsChat = False
                    chat = get_messages_controller().getChat(-did)
                    if (not chat):
                        chat = get_messages_controller().getChat(did)

                    if (not chat):
                        return

                    if (chat.migrated_to):
                        migrated = get_messages_controller().getChat(chat.migrated_to.channel_id)
                        if (migrated):
                            noForwardsChat = migrated.noforwards
                    noForwardsChat = chat.noforwards

                    if (noForwardsChat):
                        def runnable():
                            for message in messages.toArray():
                                extractedText = ChatUtils.getInstance().getMessageText(message, None)
                                params = SendMessagesHelper.SendMessageParams.of(extractedText if extractedText else "",
                                                                                 peer,
                                                                                 param.args[6],  # replyToTopMsg
                                                                                 param.args[6],  # replyToTopMsg
                                                                                 None,
                                                                                 False,
                                                                                 message.messageOwner.entities,
                                                                                 None,
                                                                                 None,
                                                                                 param.args[4],  # notify
                                                                                 0,  # scheduleDate
                                                                                 None,  # sendAnimationDate
                                                                                 False,  # updateStickersOrder
                                                                                 )
                                run_on_ui_thread(
                                    lambda: SendMessagesHelper.getInstance(UserConfig.selectedAccount).sendMessage(
                                        params))

                        try:
                            run_on_queue(lambda: runnable(), "externalNetworkQueue")
                        except Exception as e2:
                            log(f"caught e2 while processing forward: {e2}")
                            BulletinHelper.show_info(f"caught e2 while processing forward: {e2}")
                        param.setResult(jint(0))
                        return

        try:
            method = self._get_hook_method(SendMessagesHelper.getClass(), "sendMessage", ArrayList, Long.TYPE,
                                           Boolean.TYPE,
                                           Boolean.TYPE, Boolean.TYPE, Integer.TYPE, MessageObject,
                                           Integer.TYPE, Long.TYPE)
            if method:
                self.hook_method(method, ScheduleHelper2(self))
        except Exception as e:
            BulletinHelper.show_info(f"errored: {e}")
            log("errored" + str(e))

        class LastSeenProfileActivity(MethodHook):
            def __init__(self, pl):
                self.plugin = pl
                self.lastStatusUpdate = 0
                self.overridenValue = ""

            def setText(self, text: str, param):
                try:
                    field = ProfileActivity.getClass().getDeclaredField("onlineTextView")
                    field.setAccessible(True)
                    textViews = field.get(param.thisObject)
                    run_on_ui_thread(lambda: textViews[0].setText(text))
                    run_on_ui_thread(lambda: textViews[1].setText(text))
                    run_on_ui_thread(lambda: textViews[2].setText(text))
                    run_on_ui_thread(lambda: textViews[3].setText(text))
                except Exception as e:
                    AndroidUtilities.addToClipboard("blya " + str(e))

            def processTime(self, time, param):
                try:
                    formatted = ""
                    if (time < get_connections_manager().getCurrentTime()):
                        formatted = LocaleController.formatDateTime(time, True)
                    else:
                        formatted = LocaleController.getString(R.string.Online)

                    self.plugin.sendOffline()
                    run_on_queue(lambda: self.update(param, True), "externalNetworkQueue", 1800)
                    self.overridenValue = formatted
                    self.setText(formatted, param)
                except Exception as e:
                    AndroidUtilities.addToClipboard(e)

            def update(self, param, force):
                field = ProfileActivity.getClass().getDeclaredField("userId")
                field.setAccessible(True)
                userId = field.get(param.thisObject)
                if (int(userId) != UserConfig.getInstance(UserConfig.selectedAccount).clientUserId):
                    return
                if (System.currentTimeMillis() - self.lastStatusUpdate <= 10000 and not force):
                    if (self.overridenValue is not None and len(self.overridenValue) != 0):
                        self.setText(self.overridenValue, param)
                    return
                self.lastStatusUpdate = System.currentTimeMillis()
                getUser(int(userId), lambda resp, error: self.processTime(resp.objects.get(0).status.expires, param))

            def after_hooked_method(self, param):
                if self.plugin.get_setting("dontOnline", True) or self.plugin.get_setting("immediateOffline", True):
                    self.update(param, False)

        updProfData = self._get_hook_method(ProfileActivity.getClass(), "updateProfileData", Boolean.TYPE)
        if updProfData:
            updProfData.setAccessible(True)
            self.hook_method(updProfData, LastSeenProfileActivity(self))

        class resFalse(MethodHook):
            def before_hooked_method(self, param):
                param.setResult(False)

        class resTrue(MethodHook):
            def before_hooked_method(self, param):
                param.setResult(True)

        if (self.get_setting("removeNoForward", True)):
            method1 = self._get_hook_method(MessageObject.getClass(), "canForwardMessage")
            if method1:
                self.hook_method(method1, resTrue())

            method2 = self._get_hook_method(ChatActivity.getClass(), "hasSelectedNoforwardsMessage")
            if method2:
                self.hook_method(method2, resFalse())

            method3 = self._get_hook_method(MessagesController.getClass(), "isChatNoForwards", TLRPC.Chat)
            if method3:
                self.hook_method(method3, resFalse())

        class Trollas(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                intent = param.args[0]
                data = intent.getData()
                url = data.toString()
                if (url.startswith("tg://re")):
                    path = url.replace("tg://re", "")
                    if (path == ("/augh")):
                        audioManager = LaunchActivity.getLastFragment().getContext().getSystemService(
                            Context.AUDIO_SERVICE)
                        for i in range(25):
                            audioManager.adjustVolume(1, 4)  # AudioManager.ADJUST_RAISE & AudioManager.FLAG_PLAY_SOUND

                        def runAfterEnd(dialog, chat):
                            log("hel nah")
                            dialog.dismiss()
                            PhotoViewer.getInstance().closePhoto(True, False)
                            run_on_ui_thread(lambda: chat.finishFragment(True))

                        def run():
                            chatActivity = LaunchActivity.getLastFragment()
                            cell = chatActivity.findMessageCell(2, False)
                            method = self.plugin._get_hook_method(ChatActivity.getClass(), "openPhotoViewerForMessage",
                                                                  ChatMessageCell, MessageObject)
                            if method:
                                method.setAccessible(True)
                                method.invoke(chatActivity, cell, cell.getMessageObject())

                            duration = cell.getMessageObject().getDuration()
                            progressDialog = AlertDialog(chatActivity.getContext(), 2)  # AlertDialog.ALERT_TYPE_LOADING
                            progressDialog.setCanceledOnTouchOutside(False)
                            progressDialog.setCancelable(False)
                            progressDialog.setCanCancel(False)
                            progressDialog.setContentView(EmptyCell(chatActivity.getContext()))
                            progressDialog.show()
                            progressDialog.setContentView(EmptyCell(chatActivity.getContext()))
                            run_on_ui_thread(lambda: runAfterEnd(progressDialog, chatActivity),
                                             jlong(duration * 1000 * 500))

                        browserProgress = Browser.Progress()
                        field = Browser.Progress.getClass().getDeclaredField("onEndListener")
                        field.setAccessible(True)

                        field.set(browserProgress, R(run_on_ui_thread(run, 700)))

                        Browser.openUrl(LaunchActivity.getLastFragment().getContext(),
                                        AndroidUri.parse("https://t.me/exteraGramEasters/2"), False, False,
                                        browserProgress)

        try:
            method = self._get_hook_method(LaunchActivity.getClass(), "handleIntent", Intent, Boolean.TYPE,
                                           Boolean.TYPE,
                                           Boolean.TYPE, Browser.Progress, Boolean.TYPE, Boolean.TYPE)
            if method:
                self.hook_method(method, Trollas(self))
        except Exception as e:
            log(f"caught in handleIntent! {e}")

        class MessagesStorageHook(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                original = param.args[1]  # ArrayList<Integer>
                if (original is None or original.isEmpty()):
                    return

                channel_id = param.args[0]
                if (channel_id > 0):
                    channel_id = 0

                self.plugin.markMessagesDeletedInternal(param.thisObject, channel_id, original)
                param.setResult(None)

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(MessagesStorage.getClass(), "markMessagesAsDeletedInternal", Long.TYPE,
                                               ArrayList,
                                               Boolean.TYPE, Integer.TYPE, Integer.TYPE)
                if method:
                    self.hook_method(method, MessagesStorageHook(self))
        except Exception as e:
            log("exception in messagesStorage: " + str(e))
            BulletinHelper.show_error("markMessagesAsDeletedInternal: " + str(e))

        class UpdDialogsHook(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                channelId = -param.args[1]
                if channelId > 0:
                    channelId = 0
                msgIds = param.args[2]
                if (msgIds and not msgIds.isEmpty()):
                    self.plugin.markMessagesDeletedInternal(param.thisObject, channelId, msgIds)
                param.setResult(None)

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(MessagesStorage.getClass(), "updateDialogsWithDeletedMessages",
                                               Long.TYPE,
                                               Long.TYPE,
                                               ArrayList, ArrayList, Boolean.TYPE)
                if method:
                    self.hook_method(method, UpdDialogsHook(self))
        except Exception as e:
            log("exception in updateDialogsWithDeletedMessages: " + str(e))
            BulletinHelper.show_error("updateDialogsWithDeletedMessages: " + str(e))

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(MessagesStorage.getClass(), "updateDialogsWithDeletedMessagesInternal",
                                               Long.TYPE,
                                               Long.TYPE, ArrayList, ArrayList)
                if method:
                    self.hook_method(method, UpdDialogsHook(self))
        except Exception as e:
            log("exception in updateDialogsWithDeletedMessagesInternal: " + str(e))
            BulletinHelper.show_error("updateDialogsWithDeletedMessagesInternal: " + str(e))

        class NotificationsHook(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                isReact = param.args[1]
                if (self.plugin.get_setting("antiRecall", True) and not isReact):
                    param.setResult(None)

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(NotificationsController.getClass(),
                                               "removeDeletedMessagesFromNotifications",
                                               LongSparseArray, Boolean.TYPE)
                if method:
                    self.hook_method(method, NotificationsHook(self))
        except Exception as e:
            log("exception in NotificationsHook: " + str(e))
            BulletinHelper.show_error("NotificationsHook: " + str(e))

        class DownloaderHook(MethodHook):
            def before_hooked_method(self, param):
                msg = param.args[0]
                if (msg.flags2 & FLAG_DELETED) != 0:
                    param.setResult(False)

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(DownloadController.getClass(), "canDownloadMedia", TLRPC.Message)
                if method:
                    self.hook_method(method, DownloaderHook())
        except Exception as e:
            log("exception in DownloaderHook: " + str(e))
            BulletinHelper.show_error("DownloaderHook: " + str(e))

        # MessagesController hooks
        class processUpdateArray(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            # TODO: refactor as on_update_hook
            def before_hooked_method(self, param):
                lst = param.args[0]
                if (lst is None or lst.isEmpty()):
                    return None
                newUpdates = ArrayList()

                for upd in lst.toArray():
                    if (not upd.getClass().equals(TLRPC.TL_updateDeleteMessages)
                            and not upd.getClass().equals(TLRPC.TL_updateDeleteChannelMessages)):
                        newUpdates.add(upd)
                        continue

                    if (upd.getClass().equals(TLRPC.TL_updateDeleteMessages)):
                        update = cast(TLRPC.TL_updateDeleteMessages, upd)
                        messages = update.messages
                        field = MessagesController.getClass().getDeclaredField("dialogMessagesByIds")
                        dialogMessages = field.get(param.thisObject)
                        for msgId in messages.toArray():
                            msgObj = dialogMessages.get(msgId)
                            if (msgObj is None):
                                break  # ????
                            else:
                                messageOwner = msgObj.messageOwner
                                messageOwner.flags2 = messageOwner.flags2 | FLAG_DELETED
                        self.plugin.markMessagesDeleted(0, messages)
                    elif (upd.getClass().equals(TLRPC.TL_updateDeleteChannelMessages)):
                        update = cast(TLRPC.TL_updateDeleteChannelMessages, upd)
                        messages = update.messages
                        field = MessagesController.getClass().getDeclaredField("dialogMessage")
                        dialogMessage = field.get(param.thisObject)
                        dialogMessages = dialogMessage.get(-update.channel_id)
                        for msgObj in dialogMessages.toArray():
                            messageOwner = msgObj.messageOwner
                            if (messages.contains(messageOwner.id)):
                                messageOwner.flags2 = messageOwner.flags2 | FLAG_DELETED
                        self.plugin.markMessagesDeleted(-update.channel_id, messages)

                param.args[0] = newUpdates

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(MessagesController.getClass(), "processUpdateArray", ArrayList,
                                               ArrayList, ArrayList,
                                               Boolean.TYPE, Integer.TYPE)
                if method:
                    self.hook_method(method, processUpdateArray(self))
        except Exception as e:
            log(str(e))
            BulletinHelper.show_error("update array: " + str(e))

        class CheckChannelError(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                if (self.plugin.get_setting("antiRecall", True)):
                    param.setResult(None)

        try:
            method = self._get_hook_method(MessagesController.getClass(), "checkChannelError", String, Long.TYPE)
            if method:
                method.setAccessible(True)
                self.hook_method(method, CheckChannelError(self))
        except Exception as e:
            log(str(e))
            BulletinHelper.show_error("CheckChannelError: " + str(e))

        # MessagesController hooks end

        # ChatObject hooks
        class ChatObjectHook(MethodHook):
            def __init__(self, pl):
                self.plugin = pl

            def before_hooked_method(self, param):
                if (self.plugin.get_setting("antiRecall", True)):
                    chat = param.args[0]
                    param.setResult(chat is None or chat.left)

        try:
            method1 = self._get_hook_method(ChatObject.getClass(), "isLeftFromChat", TLRPC.Chat)
            if method1:
                self.hook_method(method1, ChatObjectHook(self))

            method2 = self._get_hook_method(ChatObject.getClass(), "isKickedFromChat", TLRPC.Chat)
            if method2:
                self.hook_method(method2, ChatObjectHook(self))

            method3 = self._get_hook_method(ChatObject.getClass(), "isNotInChat", TLRPC.Chat)
            if method3:
                self.hook_method(method3, ChatObjectHook(self))
        except Exception as e:
            log(str(e))
            BulletinHelper.show_error("ChatObjectHook: " + str(e))

        # ChatObject hooks end

        # UI (deleted mark)

        class ChatMsgCell(MethodHook):
            def __init__(self, pl):
                self.plugin = pl


                self.field_currentTimeString = None
                self.field_timeTextWidth = None
                self.field_timeWidth = None

                try:
                    chat_message_cell_class = ChatMessageCell.getClass()

                    self.field_currentTimeString = chat_message_cell_class.getDeclaredField("currentTimeString")
                    self.field_timeTextWidth = chat_message_cell_class.getDeclaredField("timeTextWidth")
                    self.field_timeWidth = chat_message_cell_class.getDeclaredField("timeWidth")

                    self.field_currentTimeString.setAccessible(True)
                    self.field_timeTextWidth.setAccessible(True)
                    self.field_timeWidth.setAccessible(True)

                except Exception as e:
                    log(f"ChatMsgCell hook failed to initialize fields, hell naaah: {e}")
            def process(self, param):
                log("process mesmfsioefjse idk")
                if not self.field_currentTimeString:
                    return

                messageObject = param.args[0]
                if not messageObject:
                    return

                owner = messageObject.messageOwner
                if not owner:
                    return

                flags2 = owner.flags2
                is_deleted_locally = (flags2 & FLAG_DELETED) != 0
                is_cached_deleted = self.plugin.isCachedDeleted(MessageObject.getPeerId(owner.from_id), owner.id)

                if not is_deleted_locally and not is_cached_deleted:
                    return

                cell = param.thisObject
                currTimeString = self.field_currentTimeString.get(cell)
                if not currTimeString:
                    return

                text = self.plugin.get_setting("deletedMark", "deleted")
                spannable = SpannableStringBuilder(text)

                if self.plugin.get_setting("useRed", False):
                    color = ForegroundColorSpan(cell.getThemedColor(Theme.key_color_red))
                    spannable.setSpan(color, 0, spannable.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

                spannable.append(" ")
                currTimeString.insert(0, spannable)
                self.field_currentTimeString.set(cell, currTimeString)

                paint = Theme.chat_timePaint
                if paint:
                    added_width = int(Math.ceil(paint.measureText(spannable, 0, spannable.length())))

                    timeTextWidth = self.field_timeTextWidth.get(cell)
                    timeWidth = self.field_timeWidth.get(cell)

                    self.field_timeTextWidth.set(cell, jint(timeTextWidth + added_width))
                    self.field_timeWidth.set(cell, jint(timeWidth + added_width))

            def after_hooked_method(self, param):
                # many deleted messages lead to lags
                # tried to run_on_ui_thread, traceback:

                # Error in runnable: 'NoneType' object is not callable
                # File ".../android_utils.py", line 56, in run
                # self._fn()

                # \_()_/

                # so tried to fix using caching of hooks
                # need to test on supporters
                try:
                    self.process(param)
                except Exception as e:
                    log(f"caught in cell: {e}")

        try:
            if (self.get_setting("antiRecall", True)):
                method = self._get_hook_method(ChatMessageCell.getClass(), "measureTime", MessageObject)
                if method:
                    self.hook_method(method, ChatMsgCell(self))
        except Exception as e:
            log("chat msg cell exception!" + str(e))


        # updating message with "deleted" mark
        # TODO: implement: posting notification, handling it(updating msg)
        # currently too lazy for this

        # class ChatActivityOnFragmentCreate(MethodHook):
        #     def __init__(self, pl):
        #         self.plugin = pl
        #     def after_hooked_method(self, param):
        #         if (self.plugin.get_setting("keepDeletedInCache", True)):
        #             this = param.thisObject
        #             this.getNotificationCenter().addObserver(this, NOTIFICATION_DELETED)
        # try:
        #     self.hook_method(
        #         ChatActivity.getClass().getDeclaredMethod("onFragmentCreate"),
        #         ChatActivityOnFragmentCreate(self)
        #     )
        # except Exception as e:
        #     log(f"hell naaah {e}")

    # END ANTI-RECALL HOOKS

    def create_settings(self):
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        mark = self.get_setting("deletedMark", "deleted")

        strings = {
            'ru': {
                'dontRead': "  ",
                'dontType': "  ",
                'dontOnline': "  ",
                'dontReadStories': "  ",
                'immediateOffline': " ",
                'readOnInteract': "  ",
                'useScheduled': " ",
                'antiRecall': "  ",
                'antiRecallHeader': " ",
                'GhostHeader': " ",
                'Misk': "",
                'removeFlagSecure': " FlagSecure",
                'red': "  ",
                'deletedMark': " ",
                'removeNoForward': "   ",
                "noForwardInfo": "   "
            },
            'en': {
                'dontRead': "Don't Read Messages",
                'dontType': "Don't Send Typing",
                'dontOnline': "Don't Send Online",
                'dontReadStories': "Don't Read Stories",
                'immediateOffline': "Go Offline Automatically",
                'readOnInteract': "Read on Interact",
                'useScheduled': "Schedule Messages",
                'antiRecall': "Save Deleted Messages",
                'antiRecallHeader': "Anti Recall",
                'GhostHeader': "Ghost Mode",
                'Misk': "Misc",
                'removeFlagSecure': "Remove FlagSecure",
                'red': " will be red",
                'deletedMark': "Deleted Mark",
                'removeNoForward': "Remove Copy And Save Restrics",
                "noForwardInfo" : "You anyway won't be able to forward messages"
            }
        }

        lang_key = 'ru' if lang.startswith('ru') else 'en'
        s = strings[lang_key]


        return [
            Header(text=s['GhostHeader']),
            Switch(
                key="dontRead",
                text=s['dontRead'],
                default=True
            ),
            Switch(
                key="dontReadStories",
                text=s['dontReadStories'],
                default=True
            ),
            Switch(
                key="dontOnline",
                text=s['dontOnline'],
                default=True
            ),
            Switch(
                key="dontType",
                text=s['dontType'],
                default=True
            ),
            Switch(
                key="immediateOffline",
                text=s['immediateOffline'],
                default=True
            ),
            Divider(),
            Switch(
                key="readOnInteract",
                text=s['readOnInteract'],
                default=True,
                icon="input_mic",
                on_change=lambda enabled: self.handleReadOnInteractEvent(enabled)
            ),
            Switch(
                key="useScheduled",
                text=s['useScheduled'],
                default=False,
                on_change=lambda enabled: self.handleScheduledEvent(enabled)
            ),
            Divider(),
            Header(text=s['Misk']),
            Switch(
                key="removeFlagSecure",
                text=s['removeFlagSecure'],
                default=True
            ),
            Switch(
                key="removeNoForward",
                text=s['removeNoForward'],
                subtext=s["noForwardInfo"],
                default=True
            ),
            Divider(),
            Header(text=s['antiRecallHeader']),
            Switch(
                key="antiRecall",
                text=s['antiRecall'],
                default=True
            ),
            Switch(
                key="useRed",
                text=f"\"{mark}\"" + s['red'],
                default=True
            ),
            Input(
                key="deletedMark",
                text=s['deletedMark'],
                default="deleted"
            )

        ]

    def pre_request_hook(self, request_name, account, request):
        if request.networkType == 1337:
            # this is "whitelisted" request
            # skip checks
            # log(f"sending as normal req: {request_name}")
            # if ("readMessageContents" in request_name):
            #     log(f"req id : {request.id}")
            # request.networkType = 0
            return HookResult(strategy=HookStrategy.DEFAULT)

        if request_name in readReqs and self.get_setting("dontRead", True):
            return HookResult(strategy=HookStrategy.CANCEL)
        if request_name in typingReqs and self.get_setting("dontType", True):
            return HookResult(strategy=HookStrategy.CANCEL)
        if request_name in storiesReqs and self.get_setting("dontReadStories", True):
            return HookResult(strategy=HookStrategy.CANCEL)
        if request_name == "updateStatus" and self.get_setting("dontOnline", True):
            request.offline = True
            return HookResult(strategy=HookStrategy.MODIFY, request=request)

        maybePeer = extractPeer(request)
        if ((
                request_name in sendMsgReqs or request_name == "TL_messages_sendReaction" or request_name == "TL_messages_sendVote")
                and maybePeer and self.get_setting("readOnInteract", True)):
            dialogId = getDialogId(maybePeer)
            messageId = getMessageId(request)
            try:
                # ne rabotaet anyway
                callback = IntCb(lambda maxId: markReadOnServer(maxId, False, maybePeer))
                if messageId is None:
                    get_messages_storage().getDialogMaxMessageId(dialogId, callback)
                else:
                    markReadOnServer(messageId, False, maybePeer)
            except Exception as e:
                log(f"caught: {e}")

    def post_request_hook(self, request_name: str, account: int, response: Any, error: Any):
        if request_name in onlineReqs and self.get_setting("immediateOffline", True):
            run_on_queue(lambda: self.sendOffline(), "externalNetworkQueue", 1000)

    def sendOffline(self):
        def h(r, e):
            pass

        req = TL_account.updateStatus()
        req.offline = True
        send_request(req, h)

    def handleReadOnInteractEvent(self, enabled: bool):
        if (enabled and self.get_setting("useScheduled", False)):
            BulletinHelper.show_info("Schedule Messages cannot be used with Read on Interact")
            self.set_setting("useScheduled", False)

    def handleScheduledEvent(self, enabled: bool):
        if (enabled and self.get_setting("readOnInteract", True)):
            BulletinHelper.show_info("Read On Interact cannot be used with Schedule Messages")
            self.set_setting("readOnInteract", False)