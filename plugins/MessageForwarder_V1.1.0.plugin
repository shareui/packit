__id__ = "MessageForwarder"
__name__ = "Message Forwarder"
__author__ = "@Nikita218000 || @RooniPlugin (оригинальная идея и реализация)"
__version__ = "1.1.0"
__description__ = "Пересылает все сообщения из одного чата в другой, с сохранением авторства или без, частями и с задержками.\n\n*Примечание:\nНе работает в каналах где запрещена пересылка.\n\nЧто добавили в 1.1.0?\n1. Совместимость с новой версией\n2. Пофикшена нерабочий переключатель для скрытия имя отправителя\n3. Исправление множества прочих багов\n\n\n⛔️ВНИМАНИЕ!!!⛔️\n⚠️ При пересылке большого количества сообщений возможен бан аккаунта!"
__icon__ = "IconForPlugins_by_TgEmodziBot/7"
__min_version__ = "12.1.1"

import threading
import time
import traceback
from typing import Any, List

from android.os import Bundle
from android.text import InputType
from android.view import Gravity
from android.widget import LinearLayout, TextView, Switch, EditText, SeekBar, ProgressBar
from java import dynamic_proxy
from java.lang import Integer as JInteger
from java.util import ArrayList
from org.telegram.messenger import (MessagesController, LocaleController, SendMessagesHelper, MessageObject,
                                    NotificationCenter, UserConfig, AndroidUtilities, Utilities, R, ApplicationLoader)
from org.telegram.tgnet import TLRPC
from org.telegram.ui import DialogsActivity, LaunchActivity
from org.telegram.ui.ActionBar import BaseFragment, Theme, AlertDialog
from hook_utils import find_class

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import (get_last_fragment, get_messages_controller,
                          send_request, RequestCallback)
from android_utils import run_on_ui_thread, log
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper

class DialogsDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback

    def didSelectDialogs(self, fragment, dialogs, message, param, notify, scheduleDate, topicsFragment):
        try:
            self.callback(fragment, dialogs, message, param, notify, scheduleDate, topicsFragment)
        except Exception as e:
            log(f"[Forwarder] Ошибка в didSelectDialogs: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка выбора чата"))

class MessagesForwarderPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.is_running = False
        self.is_paused = False
        self.is_in_background = False
        self.stop_event = threading.Event()
        self.current_account = -1

        self.progress_dialog_builder = None
        self.progress_bar = None
        self.status_text = None
        self.pause_button = None
        self.notification_id = hash(f"{__name__}_notification") & 0x7FFFFFFF
        
        self.R_attr = None
        self.broadcast_receiver = None
        
        self.ACTION_SHOW = f"com.pi.forwarder.{id(self)}.ACTION_SHOW_DIALOG"
        
        try:
            self.R_attr = find_class("android.R$attr")
        except Exception as e:
            log(f"[Forwarder] Не удалось найти системный класс android.R$attr: {e}")

    def on_plugin_load(self):
        self._create_notification_channel()
        self._register_broadcast_receiver()
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text="Переслать сообщения",
            icon="msg_forward",
            on_click=self.on_forward_history_click
        ))

    def on_forward_history_click(self, context: dict):
        if self.is_running:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Процесс пересылки уже запущен."))
            self._show_progress_dialog()
            return
            
        def action():
            try:
                log("[Forwarder] Кнопка нажата.")
                if not context or not hasattr(context, 'containsKey'):
                    BulletinHelper.show_error("Ошибка: не удалось получить контекст меню.")
                    return

                self.current_account = context.get("account") if context.containsKey("account") else UserConfig.selectedAccount
                source_dialog_id = context.get("dialog_id") if context.containsKey("dialog_id") else None
                
                if not source_dialog_id:
                    BulletinHelper.show_error("Не удалось определить исходный чат.")
                    return
                self.open_chat_selection(source_dialog_id)
            except Exception as e:
                log(f"[Forwarder] Критическая ошибка: {e}\n{traceback.format_exc()}")
        run_on_ui_thread(action)

    def open_chat_selection(self, source_dialog_id: int):
        last_fragment = LaunchActivity.getLastFragment()
        if not last_fragment:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось открыть список чатов"))
            return

        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("checkCanWrite", True)
        args.putInt("dialogsType", 0)
        args.putBoolean("allowGlobalSearch", True)
        args.putBoolean("destroyAfterSelect", True)

        dialogs_activity = DialogsActivity(args)
        dialogs_activity.setDelegate(DialogsDelegate(
            lambda fragment, dialogs, message, param, notify, scheduleDate, topicsFragment:
                self._on_dialog_selected(source_dialog_id, dialogs_activity, fragment, dialogs, message, param, notify, scheduleDate, topicsFragment)
        ))

        try:
            last_fragment.presentFragment(dialogs_activity)
        except Exception as e:
            log(f"[Forwarder] Ошибка presentFragment: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось открыть выбор чата"))

    def _on_dialog_selected(self, source_dialog_id: int, activity, fragment, dialogs, message, param, notify, scheduleDate, topicsFragment):
        activity.finishFragment()
        if dialogs.isEmpty():
            return
        target_dialog_id = dialogs.get(0).dialogId
        run_on_ui_thread(lambda: self.show_settings_dialog(source_dialog_id, target_dialog_id))

    def show_settings_dialog(self, source_dialog_id: int, target_dialog_id: int):
        fragment = get_last_fragment(); activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        builder = AlertDialogBuilder(activity); builder.set_title("Настройки пересылки")
        layout = LinearLayout(activity); layout.setOrientation(LinearLayout.VERTICAL)
        pad = AndroidUtilities.dp(24); layout.setPadding(pad, AndroidUtilities.dp(16), pad, AndroidUtilities.dp(16))
        textColor = Theme.getColor(Theme.key_dialogTextBlack); hintColor = Theme.getColor(Theme.key_dialogTextHint)

        def add_view(view, top=16):
            params = LinearLayout.LayoutParams(-1, -2)
            params.topMargin = AndroidUtilities.dp(top)
            layout.addView(view, params)

        # 1. Количество сообщений
        limit_label = TextView(activity)
        limit_label.setText("Количество сообщений")
        limit_label.setTextColor(textColor)
        add_view(limit_label, 0)

        limit_input = EditText(activity)
        limit_input.setHint("Пусто = вся история")
        limit_input.setInputType(InputType.TYPE_CLASS_NUMBER)
        limit_input.setTextColor(textColor)
        limit_input.setHintTextColor(hintColor)
        add_view(limit_input, 4)

        # 2. Размер куска
        chunk_size_label = TextView(activity)
        chunk_size_label.setText("Размер куска: 50")
        chunk_size_label.setGravity(Gravity.CENTER_HORIZONTAL)
        chunk_size_label.setTextColor(textColor)
        add_view(chunk_size_label, 16)

        chunk_seekbar = SeekBar(activity)
        chunk_seekbar.setMax(99)
        chunk_seekbar.setProgress(49)
        add_view(chunk_seekbar, 4)

        class SeekBarListener(dynamic_proxy(SeekBar.OnSeekBarChangeListener)):
            def __init__(self, label): super().__init__(); self.label = label
            def onProgressChanged(self, s, p, f): self.label.setText(f"Размер куска: {p + 1}")
            def onStartTrackingTouch(self, s): pass
            def onStopTrackingTouch(self, s): pass
        chunk_seekbar.setOnSeekBarChangeListener(SeekBarListener(chunk_size_label))

        # 3. Задержка
        delay_label = TextView(activity)
        delay_label.setText("Задержка между кусками (сек)")
        delay_label.setTextColor(textColor)
        add_view(delay_label, 16)

        delay_input = EditText(activity)
        delay_input.setText("10")
        delay_input.setInputType(InputType.TYPE_CLASS_NUMBER)
        delay_input.setTextColor(textColor)
        delay_input.setHintTextColor(hintColor)
        add_view(delay_input, 4)

        # 4. Скрыть имя отправителя
        hide_author_switch = Switch(activity)
        hide_author_switch.setText("Скрыть имя отправителя")
        hide_author_switch.setChecked(False)
        hide_author_switch.setTextColor(textColor)
        add_view(hide_author_switch, 16)

        builder.set_view(layout)

        def on_start_click(bld, which):
            self.stop_event.clear()
            delay_str = str(delay_input.getText())
            delay = int(delay_str) if delay_str.isdigit() and int(delay_str) > 0 else 10
            chunk_size = chunk_seekbar.getProgress() + 1
            
            hide_author = hide_author_switch.isChecked()

            limit_str = str(limit_input.getText()).strip()
            limit = int(limit_str) if limit_str.isdigit() and int(limit_str) > 0 else 0

            self._start_forwarding_process(source_dialog_id, target_dialog_id, hide_author, delay, chunk_size, limit)
            bld.dismiss()

        builder.set_positive_button("Начать", on_start_click)
        builder.set_negative_button("Отмена", lambda b, w: b.dismiss())
        builder.show()

    def _start_forwarding_process(self, source_id, target_id, hide_author, delay, chunk_size, limit: int):
        self.is_running = True; self.is_paused = False; self.is_in_background = False; self.stop_event.clear()
        self._show_progress_dialog()
        threading.Thread(target=self._forwarding_worker, args=(source_id, target_id, hide_author, delay, chunk_size, limit), daemon=True).start()

    def _forwarding_worker(self, source_id, target_id, hide_author, delay, chunk_size, limit: int):
        # Здесь мы храним полные объекты сообщений (TLRPC.Message)
        all_messages = [] 
        try:
            offset_id = 0
            total_to_fetch = limit if limit > 0 else float('inf')

            # 1. Сбор сообщений
            while len(all_messages) < total_to_fetch and not self.stop_event.is_set():
                while self.is_paused and not self.stop_event.is_set():
                    time.sleep(0.5)
                    self._update_progress_ui(len(all_messages), int(total_to_fetch) if total_to_fetch != float('inf') else 0, "На паузе...")

                status_msg = f"Собираю историю... ({len(all_messages)})"
                self._update_progress_ui(len(all_messages), int(total_to_fetch) if total_to_fetch != float('inf') else 0, status_msg)

                history_event = threading.Event(); message_chunk = []
                def on_history_loaded(msgs): nonlocal message_chunk; message_chunk = msgs; history_event.set()
                
                # Получаем объекты сообщений
                self.get_message_history_objects_async(source_id, offset_id, 100, on_history_loaded)
                history_event.wait(20)

                if not message_chunk:
                    break

                all_messages.extend(message_chunk)
                # Берем ID последнего сообщения для следующего запроса
                offset_id = message_chunk[-1].id 

                if limit > 0 and len(all_messages) >= limit:
                    all_messages = all_messages[:limit]
                    break

            if self.stop_event.is_set():
                raise InterruptedError()

            # Разворачиваем, чтобы отправлять от старых к новым
            all_messages.reverse()
            total_messages = len(all_messages)

            # 2. Отправка сообщений
            if hide_author:
                # отправляем по одному, используя SendMessagesHelper.processForwardFromMyName (ну это когда режим скрыть автора)
                for i, message in enumerate(all_messages):
                    if self.stop_event.is_set(): break
                    while self.is_paused and not self.stop_event.is_set():
                        time.sleep(0.5)
                        self._update_progress_ui(i, total_messages, f"На паузе ({i}/{total_messages})")

                    self._update_progress_ui(i + 1, total_messages, f"Копирую {i + 1} из {total_messages}...")

                    msg_obj = MessageObject(self.current_account, message, False, False)
                    
                    # Вызываем processForwardFromMyName
                    run_on_ui_thread(lambda: SendMessagesHelper.getInstance(self.current_account).processForwardFromMyName(msg_obj, target_id, 0, 0, None))
                    
                    # Небольшая задержка между сообщениями, чтобы сохранить порядок (проблема аю вроде)
                    # (тк processForwardFromMyName асинхронный внутри, но ставит в очередь)
                    time.sleep(delay if delay > 0.5 else 0.5) 

            else:
                # Используем forwardMessages пачками (во время обыч пересылки кто не понял)
                all_message_ids = [msg.id for msg in all_messages]
                
                for i in range(0, total_messages, chunk_size):
                    if self.stop_event.is_set(): break
                    while self.is_paused and not self.stop_event.is_set():
                        time.sleep(0.5)
                        self._update_progress_ui(i, total_messages, f"На паузе ({i}/{total_messages})")

                    current_chunk = all_message_ids[i:i + chunk_size]
                    status_msg = f"Пересылаю {i + len(current_chunk)} из {total_messages}..."
                    self._update_progress_ui(i + len(current_chunk), total_messages, status_msg)

                    req = TLRPC.TL_messages_forwardMessages()
                    req.from_peer = get_messages_controller().getInputPeer(source_id)
                    req.to_peer = get_messages_controller().getInputPeer(target_id)
                    req.flags = 0

                    id_list, random_id_list = ArrayList(), ArrayList()
                    for msg_id in current_chunk:
                        id_list.add(JInteger(msg_id))
                        random_id_list.add(Utilities.random.nextLong())
                    req.id = id_list
                    req.random_id = random_id_list

                    fwd_event = threading.Event()
                    send_request(req, RequestCallback(lambda r, e: fwd_event.set()))
                    fwd_event.wait(60)

                    if i + chunk_size < total_messages and not self.stop_event.is_set():
                        time.sleep(delay)

            if not self.stop_event.is_set():
                run_on_ui_thread(lambda: BulletinHelper.show_success("Пересылка завершена!"))

        except InterruptedError:
            run_on_ui_thread(lambda: BulletinHelper.show_info("Пересылка отменена."))
        except Exception as e:
            log(f"[Forwarder] Ошибка: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка: {e}"))
        finally:
            self.is_running = False; self.is_paused = False
            run_on_ui_thread(lambda: self._cleanup_ui())

    def _update_progress_ui(self, current, total, status_msg):
        def action():
            dialog = self.progress_dialog_builder.get_dialog() if self.progress_dialog_builder else None
            if dialog and dialog.isShowing():
                self.status_text.setText(status_msg)
                if total > 0:
                    self.progress_bar.setMax(total)
                    self.progress_bar.setProgress(current)
                self.pause_button.setText("Продолжить" if self.is_paused else "Пауза")
            if self.is_in_background:
                self._update_notification(current, total if total > 0 else 1, status_msg)
        run_on_ui_thread(action)

    def _show_progress_dialog(self):
        self.is_in_background = False
        if self.progress_dialog_builder and self.progress_dialog_builder.get_dialog() and self.progress_dialog_builder.get_dialog().isShowing():
            return
        self._cancel_notification()

        fragment = get_last_fragment(); activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        builder = AlertDialogBuilder(activity); builder.set_title("Пересылка сообщений")
        layout = LinearLayout(activity); layout.setOrientation(LinearLayout.VERTICAL)
        pad = AndroidUtilities.dp(24); layout.setPadding(pad, pad, pad, pad)
        self.status_text = TextView(activity); self.status_text.setText("Подготовка..."); self.status_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack)); self.status_text.setTextSize(16); layout.addView(self.status_text)

        if self.R_attr:
            self.progress_bar = ProgressBar(activity, None, self.R_attr.progressBarStyleHorizontal)
        else:
            self.progress_bar = ProgressBar(activity)
        params = LinearLayout.LayoutParams(-1, -2); params.topMargin = AndroidUtilities.dp(16); layout.addView(self.progress_bar, params)
        builder.set_view(layout)

        def handle_pause(b, w): self.is_paused = not self.is_paused
        def handle_cancel(b, w): self.stop_event.set(); b.dismiss()
        def handle_background(b, w):
            self.is_in_background = True
            b.get_dialog().dismiss()
            status = str(self.status_text.getText()) if self.status_text else "Пересылка в фоне..."
            self._show_notification(self.progress_bar.getProgress(), self.progress_bar.getMax(), status)

        builder.set_neutral_button("В фон", handle_background)
        builder.set_negative_button("Отмена", handle_cancel)
        builder.set_positive_button("Пауза", handle_pause)

        self.progress_dialog_builder = builder.show()
        self.progress_dialog_builder.set_cancelable(False)
        self.pause_button = self.progress_dialog_builder.get_button(AlertDialog.BUTTON_POSITIVE)

    def _create_notification_channel(self):
        try:
            Build = find_class("android.os.Build")
            if Build.VERSION.SDK_INT >= Build.VERSION_CODES.O:
                NotificationManager = find_class("android.app.NotificationManager")
                NotificationChannel = find_class("android.app.NotificationChannel")
                app_context = ApplicationLoader.applicationContext
                channel = NotificationChannel("forwarder_channel", "Пересылка сообщений", NotificationManager.IMPORTANCE_LOW)
                app_context.getSystemService("notification").createNotificationChannel(channel)
        except Exception as e: log(f"[Forwarder] Ошибка канала уведомлений: {e}")

    def _show_notification(self, current, total, text):
        try:
            NotificationManagerCompat = find_class("androidx.core.app.NotificationManagerCompat")
            NotificationCompat_Builder = find_class("androidx.core.app.NotificationCompat$Builder")
            Intent = find_class("android.content.Intent")
            PendingIntent = find_class("android.app.PendingIntent")
            app_context = ApplicationLoader.applicationContext

            return_intent = Intent(self.ACTION_SHOW); return_intent.setPackage(app_context.getPackageName())
            pending_return = PendingIntent.getBroadcast(app_context, 1, return_intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE)

            builder = NotificationCompat_Builder(app_context, "forwarder_channel")
            builder.setSmallIcon(R.drawable.msg_forward)
            builder.setContentTitle("Пересылка истории")
            builder.setContentText(text)
            builder.setProgress(total, current, False)
            builder.setContentIntent(pending_return)
            builder.setOngoing(True)

            NotificationManagerCompat.from_(app_context).notify(self.notification_id, builder.build())
        except Exception as e: log(f"[Forwarder] Ошибка уведомления: {e}")

    def _update_notification(self, current, total, text):
        if self.is_in_background: self._show_notification(current, total, text)

    def _cancel_notification(self):
        try:
            NotificationManagerCompat = find_class("androidx.core.app.NotificationManagerCompat")
            NotificationManagerCompat.from_(ApplicationLoader.applicationContext).cancel(self.notification_id)
        except Exception as e: log(f"[Forwarder] Ошибка отмены уведомления: {e}")

    def _cleanup_ui(self):
        if self.progress_dialog_builder and self.progress_dialog_builder.get_dialog() and self.progress_dialog_builder.get_dialog().isShowing():
            self.progress_dialog_builder.get_dialog().dismiss()
        self.progress_dialog_builder = None
        self._cancel_notification()

    def get_message_history_objects_async(self, dialog_id, offset_id, limit, callback):
        request = TLRPC.TL_messages_getHistory()
        request.peer = get_messages_controller().getInputPeer(dialog_id)
        if not request.peer:
            callback([])
            return
        request.offset_id = offset_id
        request.limit = limit

        def on_response(response, error):
            if error:
                log(f"[Forwarder] Ошибка getHistory: {error.text}")
                callback([])
                return
            # Возвращаем список объектов TLRPC.Message
            messages = list(response.messages.toArray()) if hasattr(response, 'messages') else []
            callback(messages)

        send_request(request, RequestCallback(on_response))

    def _register_broadcast_receiver(self):
        try:
            IntentFilter = find_class("android.content.IntentFilter")
            BroadcastReceiver = find_class("android.content.BroadcastReceiver")
            app_context = ApplicationLoader.applicationContext

            class ForwarderNotificationReceiver(dynamic_proxy(BroadcastReceiver)):
                def __init__(self, plugin_instance): super().__init__(); self.plugin = plugin_instance
                def onReceive(self, context, intent):
                    if intent.getAction() == self.plugin.ACTION_SHOW:
                        run_on_ui_thread(self.plugin._show_progress_dialog)

            self.broadcast_receiver = ForwarderNotificationReceiver(self)
            intent_filter = IntentFilter(self.ACTION_SHOW)
            app_context.registerReceiver(self.broadcast_receiver, intent_filter)
            log("[Forwarder] Broadcast receiver зарегистрирован.")
        except Exception as e:
            log(f"[Forwarder] Ошибка регистрации ресивера: {e}")

    def _unregister_broadcast_receiver(self):
        if self.broadcast_receiver:
            try:
                ApplicationLoader.applicationContext.unregisterReceiver(self.broadcast_receiver)
                self.broadcast_receiver = None
            except Exception as e:
                log(f"[Forwarder] Ошибка снятия ресивера: {e}")

    def on_plugin_unload(self):
        self.stop_event.set()
        self._unregister_broadcast_receiver()
        #log("[Forwarder] Плагин выгружен.")