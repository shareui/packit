import time
from base_plugin import BasePlugin, hook_filters, HookFilter
from hook_utils import find_class, get_private_field
from java import jclass, dynamic_proxy
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment, get_messages_controller, send_request, RequestCallback, run_on_queue
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper

from org.telegram.messenger import R as R_tg

__id__ = "summarize_chat"
__name__ = "Summarize Chat"
__type__ = "plugin"
__description__ = "Summarize recent chat messages using AI"
__version__ = "1.0.0"
__author__ = "@luvztroy"
__min_version__ = "12.1.1"


class ChatActionBarItemsHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            activity_id = id(chat_activity)
            
            if activity_id not in self.plugin.chat_action_bar_hooked_activities:
                self.plugin.chat_action_bar_hooked_activities.add(activity_id)
                self.add_summarize_menu_item(chat_activity)
        except Exception as e:
            self.plugin.log(f"Error in Chat Action Bar Items Hook: {e}")
    
    def add_summarize_menu_item(self, chat_activity):
        try:
            AiController = self.plugin._get_class("com.exteragram.messenger.ai.AiController")
            if not AiController:
                return

            if hasattr(AiController, 'canUseAI') and not AiController.canUseAI():
                return
            
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = self.plugin._get_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                ai_icon = R.drawable.ai_chat
                summarize_text = "Summarize"
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    def find_position(target):
                        if target is not None:
                            for i in range(lazy_list.size()):
                                if lazy_list.get(i) == target:
                                    return i
                        return None

                    plugins_item = get_private_field(chat_activity, "pluginsMenuItem")
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = find_position(plugins_item) or find_position(admin_gap) or lazy_list.size()
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(self.plugin.ai_summarize_menu_id),
                        Integer(ai_icon),
                        None,
                        summarize_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(self.plugin.ai_summarize_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        self.plugin.ai_summarize_menu_id,
                        ai_icon,
                        summarize_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                self.plugin.log(f"Error adding AI Summarize menu item: {e}")
                
        except Exception as e:
            self.plugin.log(f"Error in add_summarize_menu_item: {e}")
    
    def hook_action_bar_callback(self, chat_activity):
        try:
            action_bar = get_private_field(chat_activity, "actionBar")
            if action_bar is None:
                return
            
            current_callback = get_private_field(action_bar, "actionBarMenuOnItemClick")
            if current_callback is None:
                return
            
            callback_class = current_callback.getClass()
            jint = jclass("java.lang.Integer").TYPE
            
            onItemClickMethod = callback_class.getDeclaredMethod("onItemClick", jint)
            onItemClickMethod.setAccessible(True)
            
            hook_handler = ChatActionBarMenuItemClickHook(self.plugin, chat_activity)
            
            if self.plugin.hook_ai_summarize_item_click_ref:
                self.plugin.unhook_method(self.plugin.hook_ai_summarize_item_click_ref)
            
            self.plugin.hook_ai_summarize_item_click_ref = self.plugin.hook_method(
                onItemClickMethod,
                hook_handler
            )
            
        except Exception as e:
            self.plugin.log(f"Error hooking AI Summarize action bar callback: {e}")


class ChatActionBarMenuItemClickHook:
    def __init__(self, plugin, chat_activity):
        self.plugin = plugin
        self.chat_activity = chat_activity
    
    def get_unread_count(self, chat_activity):
        try:
            mc = get_messages_controller()
            dialog = mc.getDialog(chat_activity.getDialogId()) if mc else None
            if dialog:
                unread_count = getattr(dialog, 'unread_count', 0) or 0
                return unread_count if unread_count > 0 else 200
        except Exception:
            pass
        return 200
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            item_id = int(param.args[0])
            
            if item_id == self.plugin.ai_summarize_menu_id:
                self.open_summarize_view(self.chat_activity)
                param.setResult(None)
                
        except Exception as e:
            self.plugin.log(f"Error in Chat Action Bar Menu Item Click Hook: {e}")
    
    def open_summarize_view(self, chat_activity):
        GenerateFromMessageBottomSheet = self.plugin._get_class("com.exteragram.messenger.ai.ui.GenerateFromMessageBottomSheet")
        if not GenerateFromMessageBottomSheet:
            return
        
        LocaleController = self.plugin._get_class("org.telegram.messenger.LocaleController")
        R = self.plugin._get_class("org.telegram.messenger.R")
        
        if LocaleController and R:
            getStringMethod = LocaleController.getClass().getDeclaredMethod("getString", jclass("java.lang.Integer").TYPE)
            
            class LocaleHook:
                def __init__(self):
                    self.role_prompt_id = R.string.RolePrompt
                    self.proceed_id = R.string.Proceed
                    self.generate_id = R.string.Generate
                
                def after_hooked_method(self, param):
                    string_id = param.args[0]
                    if string_id == self.role_prompt_id:
                        param.setResult("Message Count")
                    elif string_id == self.proceed_id:
                        param.setResult("Summarize")
                    elif string_id == self.generate_id:
                        param.setResult("Summarize")
            
            unhook_locale = self.plugin.hook_method(getStringMethod, LocaleHook())
        
        Callback = jclass("org.telegram.messenger.Utilities$Callback")
        
        class DataCallback(dynamic_proxy(Callback)):
            def __init__(self, plugin_ref, activity_ref):
                super().__init__()
                self.plugin = plugin_ref
                self.activity = activity_ref
            
            def run(self, data):
                default_count = ChatActionBarMenuItemClickHook(self.plugin, self.activity).get_unread_count(self.activity)
                count = int(str(data.prompt() or str(default_count)).strip())
                count = max(1, count)
                self.fetch_and_summarize(self.activity, count)
            
            def fetch_and_summarize(self, chat_activity, count):
                loading = AlertDialogBuilder(chat_activity.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                loading.show()
                loading.set_cancelable(False)
                
                def process():
                    try:
                        messages = ChatActionBarMenuItemClickHook.get_messages(chat_activity, count, self.plugin)
                        run_on_ui_thread(loading.dismiss)
                        
                        if messages:
                            run_on_ui_thread(lambda: ChatActionBarMenuItemClickHook(self.plugin, chat_activity).show_alert(chat_activity, messages))
                        else:
                            run_on_ui_thread(lambda: BulletinHelper.of(chat_activity).createErrorBulletin("No messages to summarize").show())
                    except Exception as e:
                        self.plugin.log(f"Error fetching messages for summarization: {e}")
                        run_on_ui_thread(loading.dismiss)
                
                run_on_queue(process)
        
        callback = DataCallback(self.plugin, chat_activity)
        
        unread_count = self.get_unread_count(chat_activity)
        
        sheet = GenerateFromMessageBottomSheet(
            str(unread_count),
            None,
            chat_activity,
            chat_activity.getContext(),
            callback,
            False
        )
        sheet.show()
        
        if 'unhook_locale' in locals():
            self.plugin.unhook_method(unhook_locale)
    
    def show_alert(self, chat_activity, messages):
        try:
            AiConfig = self.plugin._get_class("com.exteragram.messenger.ai.AiConfig")
            if AiConfig:
                AiConfig.showResponseOnly = True
            
            context = self.build_message_context(messages)
            full_prompt = context
            
            AiController = self.plugin._get_class("com.exteragram.messenger.ai.AiController")
            controller = AiController.getInstance()
            
            summarizer_role = None
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == "Quanta!":
                        summarizer_role = role
                        break
            
            client_builder = self.plugin._get_class("com.exteragram.messenger.ai.network.Client").Builder()
            if summarizer_role:
                client_builder.roleOverride(summarizer_role)
            client = client_builder.build()
            
            if not client:
                return
            
            current_chat = get_private_field(chat_activity, "currentChat")
            MessagesController = self.plugin._get_class("org.telegram.messenger.MessagesController")
            no_forwards = MessagesController.getInstance(0).isChatNoForwards(current_chat) if current_chat else False
            
            setText = jclass("android.widget.TextView").getClass().getDeclaredMethod("setText", jclass("java.lang.CharSequence"))
            
            class TextViewHook:
                def __init__(self, full_text, display_text):
                    self.full_text = full_text
                    self.display_text = display_text
                    self.hooked = False
                
                def before_hooked_method(self, param):
                    if not self.hooked:
                        text = str(param.args[0]) if param.args[0] else ""
                        if self.full_text in text:
                            param.args[0] = self.display_text
                            self.hooked = True
            
            unhook = self.plugin.hook_method(setText, TextViewHook(full_prompt, "Summarizing..."))
            
            Callback2 = jclass("org.telegram.messenger.Utilities$Callback2")
            class InsertCallback(dynamic_proxy(Callback2)):
                def run(self_cb, prompt, response):
                    chatActivityEnterView = get_private_field(chat_activity, "chatActivityEnterView")
                    if chatActivityEnterView:
                        AiConfig = find_class("com.exteragram.messenger.ai.AiConfig")
                        if AiConfig and AiConfig.insertAsQuote:
                            editField = chatActivityEnterView.getEditField()
                            editField.setText(str(response) + "\n")
                            QuoteSpan = find_class("org.telegram.ui.Components.QuoteSpan")
                            if QuoteSpan:
                                QuoteSpan.putQuoteToEditable(chatActivityEnterView.getEditText(), 0, len(str(response)), True)
                        else:
                            chatActivityEnterView.getEditField().setText(str(response))
                        chatActivityEnterView.getEditField().setSelection(chatActivityEnterView.getEditText().length())
                        chatActivityEnterView.openKeyboard()
            
            self.plugin._get_class("com.exteragram.messenger.ai.ui.ResponseAlert").showAlert(
                chat_activity,
                client,
                full_prompt,
                True,
                no_forwards,
                None,
                None,
                InsertCallback()
            )
            
            if unhook:
                self.plugin.unhook_method(unhook)
            
        except Exception as e:
            self.plugin.log(f"Error opening AI Summarize view: {e}")
    
    @staticmethod
    def get_messages(chat_activity, count, plugin):
        try:
            from org.telegram.tgnet import TLRPC
            
            dialog_id = get_private_field(chat_activity, "dialog_id")
            if dialog_id is None:
                return []
            
            result_container = {'messages': [], 'done': False, 'offset_id': 0}
            
            def fetch_batch():
                remaining = count - len(result_container['messages'])
                if remaining <= 0:
                    result_container['done'] = True
                    return
                
                batch_size = min(100, remaining)
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = get_messages_controller().getInputPeer(dialog_id)
                req.offset_id = result_container['offset_id']
                req.limit = batch_size
                req.add_offset = 0
                req.max_id = 0
                req.min_id = 0
                req.hash = 0
                
                def handle_response(response, error):
                    if error or not response or not hasattr(response, 'messages'):
                        result_container['done'] = True
                        return
                    
                    messages_count = response.messages.size()
                    if messages_count == 0:
                        result_container['done'] = True
                        return
                    
                    last_id = result_container['offset_id']
                    for i in range(messages_count):
                        msg = response.messages.get(i)
                        if msg and hasattr(msg, 'message') and msg.message:
                            result_container['messages'].append(msg)
                            if hasattr(msg, 'id'):
                                last_id = msg.id
                    
                    result_container['offset_id'] = last_id
                    
                    if len(result_container['messages']) >= count or messages_count < batch_size:
                        result_container['done'] = True
                    else:
                        fetch_batch()
                
                callback = RequestCallback(handle_response)
                send_request(req, callback)
            
            fetch_batch()
            
            timeout = 30
            start_time = time.time()
            while not result_container['done'] and (time.time() - start_time) < timeout:
                time.sleep(0.1)
            
            messages = result_container['messages'][:count]
            messages.reverse()
            return messages
            
        except Exception as e:
            plugin.log(f"Error getting messages for summarization: {e}")
            return []
    
    def build_message_context(self, messages):
        try:
            mc = get_messages_controller()
            parts = []
            
            for msg in messages:
                if not (hasattr(msg, 'message') and msg.message):
                    continue
                
                text = str(msg.message).strip()
                if not text:
                    continue
                
                sender = "User"
                
                if hasattr(msg, 'post_author') and msg.post_author:
                    if hasattr(msg, 'peer_id') and msg.peer_id and hasattr(msg.peer_id, 'channel_id'):
                        if hasattr(msg, 'from_id') and msg.from_id and hasattr(msg.from_id, 'channel_id'):
                            if msg.peer_id.channel_id == msg.from_id.channel_id:
                                sender = str(msg.post_author).strip()
                                chat = mc.getChat(msg.peer_id.channel_id)
                                if chat and hasattr(chat, 'title'):
                                    sender = f"{chat.title} ({sender})"
                        else:
                            sender = str(msg.post_author).strip()
                elif hasattr(msg, 'from_id') and msg.from_id:
                    fid = msg.from_id
                    if hasattr(fid, 'user_id'):
                        user = mc.getUser(fid.user_id)
                        if user:
                            name = f"{user.first_name or ''} {user.last_name or ''}".strip()
                            sender = name or "User"
                    elif hasattr(fid, 'channel_id'):
                        chat = mc.getChat(fid.channel_id)
                        if chat and hasattr(chat, 'title'):
                            sender = str(chat.title)
                
                parts.append(f"{sender}: {text}")
            
            return "\n".join(parts)
        except Exception as e:
            self.plugin.log(f"Error building AI Summarize context: {e}")
            return ""


class SummarizeChatPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._class_cache = {}
        self.ai_summarize_menu_id = 99998
        self.chat_action_bar_hooked_activities = set()
        self.hook_ai_summarize_create_view_ref = None
        self.hook_ai_summarize_item_click_ref = None
    
    def _get_class(self, class_name):
        if class_name not in self._class_cache:
            self._class_cache[class_name] = find_class(class_name)
        return self._class_cache[class_name]
    
    def on_plugin_load(self):
        self._create_summarizer_role()
        self._hook_chat_action_bar_items()
    
    def on_plugin_unload(self):
        if self.hook_ai_summarize_create_view_ref:
            try:
                self.unhook_method(self.hook_ai_summarize_create_view_ref)
            except:
                pass
            self.hook_ai_summarize_create_view_ref = None
        if self.hook_ai_summarize_item_click_ref:
            try:
                self.unhook_method(self.hook_ai_summarize_item_click_ref)
            except:
                pass
            self.hook_ai_summarize_item_click_ref = None
        self.chat_action_bar_hooked_activities.clear()
    
    def _create_summarizer_role(self):
        try:
            AiController = self._get_class("com.exteragram.messenger.ai.AiController")
            Role = self._get_class("com.exteragram.messenger.ai.data.Role")
            
            if not AiController or not Role:
                return
            
            controller = AiController.getInstance()
            
            role_name = "Quanta!"
            existing_role = None
            
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == role_name:
                        existing_role = role
                        break
            
            if existing_role is None:
                default_prompt = """You are an expert at summarizing chat conversations. Analyze the messages and create a concise summary using paragraphs with bold headings for different topics. Do not use bullet points. Keep it clear and organized, highlighting key points, decisions, and action items. Mention important participants when relevant. Keep the summary within 3-5 paragraphs."""
                
                new_role = Role(role_name, default_prompt)
                controller.addRole(new_role)
        except:
            pass
    
    def _hook_chat_action_bar_items(self):
        if hasattr(self, 'hook_ai_summarize_create_view_ref') and self.hook_ai_summarize_create_view_ref:
            self.chat_action_bar_hooked_activities.clear()
            return
        
        try:
            ChatActivity = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                return
            
            createViewMethod = ChatActivity.getClass().getDeclaredMethod("createView", jclass("android.content.Context"))
            createViewMethod.setAccessible(True)
            self.hook_ai_summarize_create_view_ref = self.hook_method(createViewMethod, ChatActionBarItemsHook(self))
        except Exception as e:
            self.log(f"Error hooking Chat Action Bar Items: {e}")
