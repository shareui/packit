import json
import threading
from com.exteragram.messenger.plugins import PluginsController
from base_plugin import BasePlugin, AppEvent
from android_utils import log, run_on_ui_thread
from ui.settings import Header, Input, Divider
from java.util import Locale

__id__ = "shareui_exterium"
__name__ = "Exterium Reborn"
__description__ = "Minor optimization: When the app is in the background, it disables plugins and enables them upon login. [You can add exceptions by ID.]"
__author__ = "@shareui"
__version__ = "1.1.0"
__min_version__ = "11.12.0"
__icon__ = "plugin232/6"

LANG_STRINGS = {
    "ru": {
        "SETTINGS_HEADER": "Настройки оптимизации Exterium",
        "EXCLUDED_PLUGINS_INPUT": "Исключения плагинов (ID)",
        "EXCLUDED_PLUGINS_SUBTEXT": "Введите ID плагинов через запятую (например: id1, id2), которые не будут отключаться.",
        "APP_PAUSING_LOG": "Приложение приостанавливается. Отключение фоновых плагинов...",
        "APP_RESUMING_LOG": "Приложение возобновлено. Восстановление состояний плагинов...",
        "PLUGIN_DISABLED_LOG": "Отключен плагин: {name} ({id})",
        "PLUGIN_REENABLED_LOG": "Включен плагин: {name} ({id})",
        "DISABLE_ERROR_LOG": "Ошибка при отключении плагинов: {error}",
        "RESTORE_ERROR_LOG": "Ошибка при восстановлении плагинов: {error}",
        "RESTORED_AFTER_KILL_LOG": "Обнаружено некорректное завершение. Восстановлено плагинов: {count}",
        "COPY": "Копировать ошибку"
    },
    "en": {
        "SETTINGS_HEADER": "Exterium Optimization Settings",
        "EXCLUDED_PLUGINS_INPUT": "Excluded Plugins (IDs)",
        "EXCLUDED_PLUGINS_SUBTEXT": "Enter comma-separated plugin IDs (e.g., id1, id2) that should not be disabled.",
        "APP_PAUSING_LOG": "Application paused. Disabling background plugins...",
        "APP_RESUMING_LOG": "Application resumed. Restoring plugin states...",
        "PLUGIN_DISABLED_LOG": "Disabled plugin: {name} ({id})",
        "PLUGIN_REENABLED_LOG": "Re-enabled plugin: {name} ({id})",
        "DISABLE_ERROR_LOG": "Error while disabling plugins: {error}",
        "RESTORE_ERROR_LOG": "Error while restoring plugins: {error}",
        "RESTORED_AFTER_KILL_LOG": "Detected improper shutdown. Restored plugins: {count}",
        "COPY": "Copy Error"
    }
}

class PluginRestorer(BasePlugin):
    def __init__(self):
        super().__init__()
        self.plugin_states = {}
        self.tag = "ExteriumOptimization"
        self.storage_key = "exterium_opt_plugin_states"
        self.restoration_flag_key = "exterium_opt_restoration_needed"
        self.timestamp_key = "exterium_opt_timestamp"

    def tr(self, key, *args, **kwargs):
        lang = Locale.getDefault().getLanguage()
        if lang not in LANG_STRINGS:
            lang = "en"
        return LANG_STRINGS[lang].get(key, key).format(*args, **kwargs)

    def on_plugin_load(self):
        log(f"[{self.tag}] Plugin loaded. Monitoring AppEvents.")
        self._check_and_restore_on_startup()

    def on_plugin_unload(self):
        log(f"[{self.tag}] Plugin unloaded. Restoring states...")
        self._restore_plugin_states()
        self._clear_persistent_storage()

    def create_settings(self):
        return [
            Header(text=self.tr("SETTINGS_HEADER")),
            Input(
                key="excluded_plugins_ids",
                text=self.tr("EXCLUDED_PLUGINS_INPUT"),
                default="",
                subtext=self.tr("EXCLUDED_PLUGINS_SUBTEXT"),
                on_change=lambda val: self.set_setting("excluded_plugins_ids", val)
            ),
            Divider()
        ]

    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.PAUSE:
            log(f"[{self.tag}] {self.tr('APP_PAUSING_LOG')}")
            threading.Thread(target=self._disable_plugins, daemon=True).start()
        elif event_type == AppEvent.RESUME:
            log(f"[{self.tag}] {self.tr('APP_RESUMING_LOG')}")
            threading.Thread(target=self._restore_plugin_states, daemon=True).start()

    def _get_excluded_plugin_ids(self):
        excluded_ids_str = self.get_setting("excluded_plugins_ids", "")
        if not excluded_ids_str:
            return []
        return [id.strip() for id in excluded_ids_str.split(',') if id.strip()]

    def _save_to_persistent_storage(self, data):
        try:
            json_data = json.dumps(data)
            self.set_setting(self.storage_key, json_data)
            log(f"[{self.tag}] Saved {len(data)} plugin states to persistent storage")
        except Exception as e:
            log(f"[{self.tag}] Error saving to persistent storage: {e}")

    def _load_from_persistent_storage(self):
        try:
            json_data = self.get_setting(self.storage_key, "{}")
            data = json.loads(json_data)
            log(f"[{self.tag}] Loaded {len(data)} plugin states from persistent storage")
            return data
        except Exception as e:
            log(f"[{self.tag}] Error loading from persistent storage: {e}")
            return {}

    def _set_restoration_flag(self, needed):
        self.set_setting(self.restoration_flag_key, "true" if needed else "false")
        if needed:
            import time
            self.set_setting(self.timestamp_key, str(int(time.time())))

    def _get_restoration_flag(self):
        return self.get_setting(self.restoration_flag_key, "false") == "true"

    def _clear_persistent_storage(self):
        self.set_setting(self.storage_key, "{}")
        self._set_restoration_flag(False)
        self.set_setting(self.timestamp_key, "0")
        log(f"[{self.tag}] Cleared persistent storage")

    def _check_and_restore_on_startup(self):
        if self._get_restoration_flag():
            log(f"[{self.tag}] Restoration flag detected. Restoring plugin states from persistent storage...")
            saved_states = self._load_from_persistent_storage()
            
            if saved_states:
                threading.Thread(
                    target=self._restore_from_saved_states,
                    args=(saved_states,),
                    daemon=True
                ).start()
            else:
                log(f"[{self.tag}] No saved states found")
                self._set_restoration_flag(False)

    def _restore_from_saved_states(self, saved_states):
        import time
        time.sleep(2)
        
        restored_count = 0
        try:
            all_plugins = PluginsController.getInstance().plugins
            keys = all_plugins.keySet().toArray()
            
            for i in range(len(keys)):
                plugin_id = keys[i]
                plugin_instance = all_plugins.get(plugin_id)
                
                if plugin_id in saved_states and saved_states[plugin_id]:
                    if hasattr(plugin_instance, 'isEnabled') and not plugin_instance.isEnabled():
                        plugin_instance.setEnabled(True)
                        restored_count += 1
                        log(f"[{self.tag}] {self.tr('PLUGIN_REENABLED_LOG', name=plugin_instance.getName(), id=plugin_id)}")
            
            log(f"[{self.tag}] {self.tr('RESTORED_AFTER_KILL_LOG', count=restored_count)}")
        except Exception as e:
            self._handle_error(e, self.tr("RESTORE_ERROR_LOG", error=str(e)))
        finally:
            self._clear_persistent_storage()

    def _disable_plugins(self):
        excluded_ids = self._get_excluded_plugin_ids()
        try:
            all_plugins = PluginsController.getInstance().plugins
            keys = all_plugins.keySet().toArray()
            
            for i in range(len(keys)):
                plugin_id = keys[i]
                plugin_instance = all_plugins.get(plugin_id)
                
                if plugin_id == __id__ or plugin_id in excluded_ids:
                    continue
                
                if hasattr(plugin_instance, 'isEnabled') and plugin_instance.isEnabled():
                    if plugin_id not in self.plugin_states:
                        self.plugin_states[plugin_id] = True
                        plugin_instance.setEnabled(False)
                        log(f"[{self.tag}] {self.tr('PLUGIN_DISABLED_LOG', name=plugin_instance.getName(), id=plugin_id)}")
            
            if self.plugin_states:
                self._save_to_persistent_storage(self.plugin_states)
                self._set_restoration_flag(True)
                
        except Exception as e:
            self._handle_error(e, self.tr("DISABLE_ERROR_LOG", error=str(e)))

    def _restore_plugin_states(self):
        if not self.plugin_states:
            return
        
        try:
            all_plugins = PluginsController.getInstance().plugins
            keys = all_plugins.keySet().toArray()
            
            for i in range(len(keys)):
                plugin_id = keys[i]
                plugin_instance = all_plugins.get(plugin_id)
                
                if plugin_id in self.plugin_states:
                    if hasattr(plugin_instance, 'isEnabled') and not plugin_instance.isEnabled():
                        plugin_instance.setEnabled(True)
                        log(f"[{self.tag}] {self.tr('PLUGIN_REENABLED_LOG', name=plugin_instance.getName(), id=plugin_id)}")
            
            self._clear_persistent_storage()
            
        except Exception as e:
            self._handle_error(e, self.tr("RESTORE_ERROR_LOG", error=str(e)))
        finally:
            self.plugin_states.clear()

    def _handle_error(self, e, msg):
        import traceback
        full_error = f"{msg}\n\n{traceback.format_exc()}"
        log(f"[{self.tag}] CRITICAL: {full_error}")
        
        try:
            from ui.bulletin import BulletinHelper
            from android_utils import set_clipboard_text
            
            def copy_err(text=full_error):
                set_clipboard_text(text)
            
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                msg,
                self.tr("COPY"),
                lambda t=full_error: copy_err(t)
            ))
        except:
            pass