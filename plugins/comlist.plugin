"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                              ‚ïë
‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó            ‚ïë
‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó           ‚ïë
‚ïë  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë           ‚ïë
‚ïë  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë           ‚ïë
‚ïë  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù           ‚ïë
‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù            ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                          ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó                        ‚ïë
‚ïë                          ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù                        ‚ïë
‚ïë                          ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë                           ‚ïë
‚ïë                          ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë                           ‚ïë
‚ïë                          ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë                           ‚ïë
‚ïë                          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù                           ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                      Command List Plugin                                     ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  ‚ö†Ô∏è  –í–ê–ñ–ù–û: –ü—Ä–∏ —Ñ–æ—Ä–∫–µ –∏–ª–∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ —ç—Ç–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ              ‚ïë
‚ïë      —É–∫–∞–∑—ã–≤–∞–π—Ç–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∞–≤—Ç–æ—Ä–∞: @mihailkotovski & @mishabotov          ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  ‚ö†Ô∏è  IMPORTANT: When forking or modifying this plugin, please                ‚ïë
‚ïë      credit the original author: @mihailkotovski & @mishabotov               ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""

import os
import ast
import re
import traceback
from com.exteragram.messenger.plugins import PluginsController
import time
import json
from typing import Set, Dict, List, Any, Optional
from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Input, Switch, Text, Selector
from markdown_utils import parse_markdown
from ui.bulletin import BulletinHelper
from android_utils import run_on_ui_thread
from java.util import ArrayList, Locale
from org.telegram.tgnet import TLRPC

__id__ = "command_list_by_mihailkotovski"
__name__ = "Command List"
__version__ = "3.0 [fixed]"
__description__ = "Command list with search, filtering, caching, statistics and export features. Use .cmdstats to view command usage statistics."
__author__ = "@mihailkotovski & @mishabotov"
__min_version__ = "11.9.0"
__icon__ = "DMJDuckX2/10"

AUTOUPDATE_CHANNEL_ID = 2349438816
AUTOUPDATE_CHANNEL_USERNAME = "mishabotov"
AUTOUPDATE_MESSAGE_ID = 65

zwylib: Optional[Any] = None
DEFAULT_CMD = ".cmds"

class CommandCache:
    def __init__(self):
        self.cache_data = {}
        self.cache_timestamp = 0
        self.cache_duration = 300

    def is_cache_valid(self) -> bool:
        return time.time() - self.cache_timestamp < self.cache_duration

    def get_cached_commands(self) -> Optional[Dict[str, Dict[str, Any]]]:
        if self.is_cache_valid():
            return self.cache_data
        return None

    def cache_commands(self, commands: Dict[str, Dict[str, Any]]):
        self.cache_data = commands
        self.cache_timestamp = time.time()

    def invalidate_cache(self):
        self.cache_data = {}
        self.cache_timestamp = 0

class CommandStatistics:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.stats = self._load_stats()

    def _load_stats(self) -> Dict[str, int]:
        try:
            if is_zwylib_present():
                cache_file = zwylib.JsonCacheFile("command_stats.json", {})
                return cache_file.content
            else:
                return self.plugin.get_setting("command_stats", {})
        except:
            return {}

    def _save_stats(self):
        try:
            if is_zwylib_present():
                cache_file = zwylib.JsonCacheFile("command_stats.json", {})
                cache_file.content = self.stats
                cache_file.write()
            else:
                self.plugin.set_setting("command_stats", self.stats)
        except:
            pass

    def increment_usage(self, command: str):
        self.stats[command] = self.stats.get(command, 0) + 1
        self._save_stats()

    def get_usage_count(self, command: str) -> int:
        return self.stats.get(command, 0)

    def get_popular_commands(self, limit: int = 10) -> List[tuple]:
        return sorted(self.stats.items(), key=lambda x: x[1], reverse=True)[:limit]

    def get_total_usage(self) -> int:
        return sum(self.stats.values())

    def get_total_commands(self) -> int:
        return len(self.stats)

    def get_stats_summary(self) -> Dict[str, Any]:
        if not self.stats:
            return {
                "total_commands": 0,
                "total_usage": 0,
                "most_used": None,
                "least_used": None,
                "popular_commands": []
            }

        sorted_stats = sorted(self.stats.items(), key=lambda x: x[1], reverse=True)
        return {
            "total_commands": len(self.stats),
            "total_usage": sum(self.stats.values()),
            "most_used": sorted_stats[0] if sorted_stats else None,
            "least_used": sorted_stats[-1] if sorted_stats else None,
            "popular_commands": sorted_stats[:10]
        }



class LocalizationManager:
    strings = {
        "ru": {
            "zwylib_not_found": "–î–ª—è —Ä–∞–±–æ—Ç—ã –ø–ª–∞–≥–∏–Ω–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è ZwyLib!",
            "settings_header": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ Command List",
            "cmd_alias_title": "–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤—ã–∑–æ–≤–∞",
            "cmd_alias_subtitle": "–ö–æ–º–∞–Ω–¥–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –≤—ã–≤–æ–¥–∏—Ç—å—Å—è —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥.",
            "blockquote_title": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–∏—Ç–∞—Ç—É",
            "blockquote_subtitle": "–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ –≤ –≤–∏–¥–µ —Å–≤–æ—Ä–∞—á–∏–≤–∞–µ–º–æ–π —Ü–∏—Ç–∞—Ç—ã.",
            "debug_header": "–û—Ç–ª–∞–¥–∫–∞",
            "debug_mode_title": "–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏",
            "debug_mode_subtitle": "–í—ã–≤–æ–¥–∏—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ logcat.",
            "cache_header": "–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ",
            "enable_cache_title": "–í–∫–ª—é—á–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ",
            "enable_cache_subtitle": "–ö—ç—à–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã.",
            "cache_duration_title": "–í—Ä–µ–º—è –∫—ç—à–∞ (–º–∏–Ω)",
            "cache_duration_subtitle": "–í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫—ç—à–∞ –≤ –º–∏–Ω—É—Ç–∞—Ö (1-60).",
            "display_header": "–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
            "sort_mode_title": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥",
            "sort_mode_subtitle": "–°–ø–æ—Å–æ–± —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –∫–æ–º–∞–Ω–¥ –≤ —Å–ø–∏—Å–∫–µ.",
            "show_descriptions_title": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏—è",
            "show_descriptions_subtitle": "–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã.",
            "show_plugin_stats_title": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
            "show_plugin_stats_subtitle": "–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–∞–Ω–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞.",
            "info_divider": "–≠—Ç–æ—Ç –ø–ª–∞–≥–∏–Ω –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–¥ –¥—Ä—É–≥–∏—Ö –ø–ª–∞–≥–∏–Ω–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.",
            "cmd_list_header": "üìú **–°–ø–∏—Å–æ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ ({plugin_count} –ø–ª–∞–≥–∏–Ω–æ–≤, {command_count} –∫–æ–º–∞–Ω–¥):**\n\n",
            "plugin_status_on": "–í–∫–ª—é—á–µ–Ω",
            "plugin_status_off": "–í—ã–∫–ª—é—á–µ–Ω",
            "cmd_note": "*‚ö†Ô∏è –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–æ–º–∞–Ω–¥—ã –º–æ–≥—É—Ç –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∏ –Ω–µ –ø–æ–∫–∞–∑–∞–Ω—ã –∑–¥–µ—Å—å.*",
            "error_collecting_cmds": "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –∫–æ–º–∞–Ω–¥:\n\n",
            "no_cmds_found": "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–æ–º–∞–Ω–¥—ã –≤ –¥—Ä—É–≥–∏—Ö –ø–ª–∞–≥–∏–Ω–∞—Ö.",
            "dir_error": "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø–ª–∞–≥–∏–Ω–æ–≤.",
            "cache_cleared": "–ö—ç—à –∫–æ–º–∞–Ω–¥ –æ—á–∏—â–µ–Ω!",
            "clear_cache_title": "–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à",
            "clear_cache_subtitle": "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥.",
            "cached_data_info": "üìä –î–∞–Ω–Ω—ã–µ –∏–∑ –∫—ç—à–∞ (–æ–±–Ω–æ–≤–ª–µ–Ω–æ {time_ago} –Ω–∞–∑–∞–¥)",
            "sort_alphabetical": "–ü–æ –∞–ª—Ñ–∞–≤–∏—Ç—É",
            "sort_by_plugin": "–ü–æ –ø–ª–∞–≥–∏–Ω–∞–º",
            "sort_by_usage": "–ü–æ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏",
            "search_results": "üîç **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è '{query}':**\n\n",
            "search_no_results": "üîç **–ü–æ–∏—Å–∫ '{query}':** –ö–æ–º–∞–Ω–¥—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
            "search_help": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {cmd} [–ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å] –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥",
            "stats_unavailable": "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–º–∞–Ω–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞**\n\n–°–∏—Å—Ç–µ–º–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.",
            "stats_no_usage": "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–º–∞–Ω–¥**\n\n*–ö–æ–º–∞–Ω–¥—ã –µ—â–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å.*",
            "stats_header": "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥**",
            "stats_general": "**–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**",
            "stats_unique_commands": "‚Ä¢ –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–æ–º–∞–Ω–¥:",
            "stats_total_usage": "‚Ä¢ –í—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π:",
            "stats_most_popular": "**–°–∞–º–∞—è –ø–æ–ø—É–ª—è—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞:**",
            "stats_top_commands": "**–¢–æ–ø-{count} –∫–æ–º–∞–Ω–¥:**",
            "stats_error": "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ–º–∞–Ω–¥:"
        },
        "en": {
            "zwylib_not_found": "ZwyLib is required for this plugin to work!",
            "settings_header": "Command List Settings",
            "cmd_alias_title": "Trigger Command",
            "cmd_alias_subtitle": "The command to show the list of all commands.",
            "blockquote_title": "Use blockquote",
            "blockquote_subtitle": "Display the command list as a collapsible blockquote.",
            "debug_header": "Debugging",
            "debug_mode_title": "Debug Mode",
            "debug_mode_subtitle": "Prints detailed information to logcat.",
            "cache_header": "Caching",
            "enable_cache_title": "Enable caching",
            "enable_cache_subtitle": "Cache scan results for better performance.",
            "cache_duration_title": "Cache time (min)",
            "cache_duration_subtitle": "Cache lifetime in minutes (1-60).",
            "display_header": "Display",
            "sort_mode_title": "Command sorting",
            "sort_mode_subtitle": "How to sort commands in the list.",
            "show_descriptions_title": "Show descriptions",
            "show_descriptions_subtitle": "Display command descriptions if available.",
            "show_plugin_stats_title": "Show statistics",
            "show_plugin_stats_subtitle": "Display command count for each plugin.",
            "info_divider": "This plugin analyzes the code of other plugins to find commands.",
            "cmd_list_header": "üìú **Discovered Commands ({plugin_count} plugins, {command_count} commands):**\n\n",
            "plugin_status_on": "Enabled",
            "plugin_status_off": "Disabled",
            "cmd_note": "*‚ö†Ô∏è Note: Some commands might be defined dynamically and not shown here.*",
            "error_collecting_cmds": "An error occurred while collecting commands:\n\n",
            "no_cmds_found": "Could not find commands in other plugins.",
            "dir_error": "Could not determine the plugins directory.",
            "cache_cleared": "Command cache cleared!",
            "clear_cache_title": "Clear cache",
            "clear_cache_subtitle": "Force refresh command list.",
            "cached_data_info": "üìä Cached data (updated {time_ago} ago)",
            "sort_alphabetical": "Alphabetical",
            "sort_by_plugin": "By plugin",
            "sort_by_usage": "By popularity",
            "search_results": "üîç **Search results for '{query}':**\n\n",
            "search_no_results": "üîç **Search '{query}':** No commands found.",
            "search_help": "Use {cmd} [search query] to search commands",
            "stats_unavailable": "üìä **Command statistics unavailable**\n\nStatistics system is not initialized.",
            "stats_no_usage": "üìä **Command Statistics**\n\n*No commands have been used yet.*",
            "stats_header": "üìä **Command Usage Statistics**",
            "stats_general": "**General Statistics:**",
            "stats_unique_commands": "‚Ä¢ Unique commands:",
            "stats_total_usage": "‚Ä¢ Total usage:",
            "stats_most_popular": "**Most popular command:**",
            "stats_top_commands": "**Top {count} commands:**",
            "stats_error": "An error occurred while getting command statistics:"
        },
        "uk": {
            "zwylib_not_found": "–î–ª—è —Ä–æ–±–æ—Ç–∏ –ø–ª–∞–≥—ñ–Ω–∞ –ø–æ—Ç—Ä—ñ–±–µ–Ω ZwyLib!",
            "settings_header": "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è Command List",
            "cmd_alias_title": "–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤–∏–∫–ª–∏–∫—É",
            "cmd_alias_subtitle": "–ö–æ–º–∞–Ω–¥–∞, –∑–∞ —è–∫–æ—é –±—É–¥–µ –≤–∏–≤–æ–¥–∏—Ç–∏—Å—å —Å–ø–∏—Å–æ–∫ —É—Å—ñ—Ö –∫–æ–º–∞–Ω–¥.",
            "blockquote_title": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Ü–∏—Ç–∞—Ç—É",
            "blockquote_subtitle": "–í—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ —É –≤–∏–≥–ª—è–¥—ñ —Ü–∏—Ç–∞—Ç–∏, —â–æ –∑–≥–æ—Ä—Ç–∞—î—Ç—å—Å—è.",
            "debug_header": "–ù–∞–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è",
            "debug_mode_title": "–†–µ–∂–∏–º –Ω–∞–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è",
            "debug_mode_subtitle": "–í–∏–≤–æ–¥–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –≤ logcat.",
            "cache_header": "–ö–µ—à—É–≤–∞–Ω–Ω—è",
            "enable_cache_title": "–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∫–µ—à—É–≤–∞–Ω–Ω—è",
            "enable_cache_subtitle": "–ö–µ—à—É–≤–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è –¥–ª—è –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è —Ä–æ–±–æ—Ç–∏.",
            "cache_duration_title": "–ß–∞—Å –∫–µ—à—É (—Ö–≤)",
            "cache_duration_subtitle": "–ß–∞—Å –∂–∏—Ç—Ç—è –∫–µ—à—É –≤ —Ö–≤–∏–ª–∏–Ω–∞—Ö (1-60).",
            "display_header": "–í—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è",
            "sort_mode_title": "–°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∫–æ–º–∞–Ω–¥",
            "sort_mode_subtitle": "–°–ø–æ—Å—ñ–± —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∫–æ–º–∞–Ω–¥ —É —Å–ø–∏—Å–∫—É.",
            "show_descriptions_title": "–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –æ–ø–∏—Å–∏",
            "show_descriptions_subtitle": "–í—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –æ–ø–∏—Å–∏ –∫–æ–º–∞–Ω–¥, —è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω—ñ.",
            "show_plugin_stats_title": "–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
            "show_plugin_stats_subtitle": "–í—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ–º–∞–Ω–¥ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø–ª–∞–≥—ñ–Ω–∞.",
            "info_divider": "–¶–µ–π –ø–ª–∞–≥—ñ–Ω –∞–Ω–∞–ª—ñ–∑—É—î –∫–æ–¥ —ñ–Ω—à–∏—Ö –ø–ª–∞–≥—ñ–Ω—ñ–≤ –¥–ª—è –ø–æ—à—É–∫—É –∫–æ–º–∞–Ω–¥.",
            "cmd_list_header": "üìú **–°–ø–∏—Å–æ–∫ –∑–Ω–∞–π–¥–µ–Ω–∏—Ö –∫–æ–º–∞–Ω–¥ ({plugin_count} –ø–ª–∞–≥—ñ–Ω—ñ–≤, {command_count} –∫–æ–º–∞–Ω–¥):**\n\n",
            "plugin_status_on": "–£–≤—ñ–º–∫–Ω–µ–Ω–æ",
            "plugin_status_off": "–í–∏–º–∫–Ω–µ–Ω–æ",
            "cmd_note": "*‚ö†Ô∏è –ü—Ä–∏–º—ñ—Ç–∫–∞: –î–µ—è–∫—ñ –∫–æ–º–∞–Ω–¥–∏ –º–æ–∂—É—Ç—å –±—É—Ç–∏ –≤–∏–∑–Ω–∞—á–µ–Ω—ñ –¥–∏–Ω–∞–º—ñ—á–Ω–æ —ñ –Ω–µ –ø–æ–∫–∞–∑–∞–Ω—ñ —Ç—É—Ç.*",
            "error_collecting_cmds": "–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –∑–±–æ—Ä—É –∫–æ–º–∞–Ω–¥:\n\n",
            "no_cmds_found": "–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ–º–∞–Ω–¥–∏ –≤ —ñ–Ω—à–∏—Ö –ø–ª–∞–≥—ñ–Ω–∞—Ö.",
            "dir_error": "–ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—é –ø–ª–∞–≥—ñ–Ω—ñ–≤.",
            "cache_cleared": "–ö–µ—à –∫–æ–º–∞–Ω–¥ –æ—á–∏—â–µ–Ω–æ!",
            "clear_cache_title": "–û—á–∏—Å—Ç–∏—Ç–∏ –∫–µ—à",
            "clear_cache_subtitle": "–ü—Ä–∏–º—É—Å–æ–≤–æ –æ–Ω–æ–≤–∏—Ç–∏ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥.",
            "cached_data_info": "üìä –î–∞–Ω—ñ –∑ –∫–µ—à—É (–æ–Ω–æ–≤–ª–µ–Ω–æ {time_ago} —Ç–æ–º—É)",
            "sort_alphabetical": "–ó–∞ –∞–ª—Ñ–∞–≤—ñ—Ç–æ–º",
            "sort_by_plugin": "–ó–∞ –ø–ª–∞–≥—ñ–Ω–∞–º–∏",
            "sort_by_usage": "–ó–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ñ—Å—Ç—é",
            "search_results": "üîç **–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—à—É–∫—É –¥–ª—è '{query}':**\n\n",
            "search_no_results": "üîç **–ü–æ—à—É–∫ '{query}':** –ö–æ–º–∞–Ω–¥–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.",
            "search_help": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ {cmd} [–ø–æ—à—É–∫–æ–≤–∏–π –∑–∞–ø–∏—Ç] –¥–ª—è –ø–æ—à—É–∫—É –∫–æ–º–∞–Ω–¥",
            "stats_unavailable": "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–º–∞–Ω–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞**\n\n–°–∏—Å—Ç–µ–º–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞.",
            "stats_no_usage": "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–º–∞–Ω–¥**\n\n*–ö–æ–º–∞–Ω–¥–∏ —â–µ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–ª–∏—Å—å.*",
            "stats_header": "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∫–æ–º–∞–Ω–¥**",
            "stats_general": "**–ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**",
            "stats_unique_commands": "‚Ä¢ –£–Ω—ñ–∫–∞–ª—å–Ω–∏—Ö –∫–æ–º–∞–Ω–¥:",
            "stats_total_usage": "‚Ä¢ –í—Å—å–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—å:",
            "stats_most_popular": "**–ù–∞–π–ø–æ–ø—É–ª—è—Ä–Ω—ñ—à–∞ –∫–æ–º–∞–Ω–¥–∞:**",
            "stats_top_commands": "**–¢–æ–ø-{count} –∫–æ–º–∞–Ω–¥:**",
            "stats_error": "–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ–º–∞–Ω–¥:"
        }
    }

    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self.strings else "en"

    def get_string(self, key: str) -> str:
        return self.strings[self.language].get(key, self.strings["en"].get(key, key))

locali = LocalizationManager()

def _pluralize_commands(count: int) -> str:
    if count % 10 == 1 and count % 100 != 11:
        return f"{count} –∫–æ–º–∞–Ω–¥–∞"
    elif count % 10 in [2, 3, 4] and count % 100 not in [12, 13, 14]:
        return f"{count} –∫–æ–º–∞–Ω–¥—ã"
    else:
        return f"{count} –∫–æ–º–∞–Ω–¥"

def _pluralize_usages(count: int) -> str:
    if count % 10 == 1 and count % 100 != 11:
        return f"{count} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ"
    elif count % 10 in [2, 3, 4] and count % 100 not in [12, 13, 14]:
        return f"{count} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è"
    else:
        return f"{count} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π"

def import_zwylib(show_bulletin: bool = True):
    global zwylib
    try:
        import zwylib
    except ImportError:
        if show_bulletin:
            BulletinHelper.show_error(locali.get_string("zwylib_not_found"))

def is_zwylib_present() -> bool:
    return zwylib is not None

class CommandVisitor(ast.NodeVisitor):
    VALID_COMMAND_RE = re.compile(r"^\.[\w-]{1,20}$")
    INVALID_PATTERNS = [
        r"^\._-$",
        r"^\.[\w-]*\*[\w-]*$",
        r"^\.[\w-]*\+[\w-]*$",
        r"^\.[\w-]*\?[\w-]*$",
    ]

    def __init__(self):
        self.commands: Set[str] = set()
        self.command_descriptions: Dict[str, str] = {}
        self.variables: Dict[str, Any] = {}
        self.current_function = None
        self.has_dynamic_commands = False
        self.default_commands = []

    def visit_Assign(self, node: ast.Assign):
        if len(node.targets) == 1 and isinstance(node.targets[0], ast.Name):
            try:
                value = ast.literal_eval(node.value)
                var_name = node.targets[0].id
                self.variables[var_name] = value

                if var_name == "DEFAULT_COMMANDS" and isinstance(value, list):
                    self.default_commands = value
                    for cmd in value:
                        if isinstance(cmd, str) and self.VALID_COMMAND_RE.match(cmd):
                            self.commands.add(cmd)

            except (ValueError, TypeError, AttributeError, SyntaxError):
                pass
        self.generic_visit(node)

    def _add_command(self, value: Any, description: str = None, context: str = None):
        if isinstance(value, str):
            commands_to_check = []

            if context == "startswith_check":
                commands_to_check = [value.strip()]
            elif "/" in value and "." in value:
                parts = value.split("/")
                for part in parts:
                    part = part.strip()
                    if part.startswith("."):
                        commands_to_check.append(part.split()[0])
            else:
                command = value.strip().split(" ")[0]
                if command.startswith("."):
                    commands_to_check.append(command)

            for command in commands_to_check:
                if self.VALID_COMMAND_RE.match(command):
                    is_invalid = any(re.match(pattern, command) for pattern in self.INVALID_PATTERNS)

                    if not is_invalid and not self._is_likely_false_positive(command):
                        self.commands.add(command)
                        if description and command not in self.command_descriptions:
                            self.command_descriptions[command] = description

    def _is_likely_false_positive(self, command: str) -> bool:
        false_positive_patterns = [
            r"^\.up$",

            r"^\.wav$", r"^\.mp3$", r"^\.ogg$", r"^\.opus$", r"^\.m4a$",
            r"^\.gif$", r"^\.jpg$", r"^\.jpeg$", r"^\.png$", r"^\.webp$",
            r"^\.mp4$", r"^\.avi$", r"^\.mkv$", r"^\.webm$", r"^\.mov$",

            r"^\.blockquote$", r"^\.bold$", r"^\.chat_photos$", r"^\.code$",
            r"^\.contacts$", r"^\.custom_emoji$", r"^\.document$", r"^\.empty$",
            r"^\.geo$", r"^\.italic$", r"^\.music$", r"^\.my_mentions$",
            r"^\.phone_calls$", r"^\.photo_video$", r"^\.photo_video_document$",
            r"^\.photos$", r"^\.pinned$", r"^\.pre$", r"^\.round_video$",
            r"^\.round_voice$", r"^\.spoiler$", r"^\.strikethrough$",
            r"^\.text_link$", r"^\.underline$", r"^\.url$", r"^\.video$", r"^\.voice$",

            r"^\.html$", r"^\.css$", r"^\.js$", r"^\.json$", r"^\.xml$",
            r"^\.txt$", r"^\.log$", r"^\.tmp$", r"^\.bak$",
        ]

        return any(re.match(pattern, command) for pattern in false_positive_patterns)

    def _extract_description_from_comment(self, node) -> Optional[str]:
        try:
            if hasattr(node, 'lineno'):
                return None
        except:
            return None

    def _is_in_startswith_context(self, node) -> bool:
        parent = getattr(node, 'parent', None)
        if parent and isinstance(parent, ast.Call):
            if isinstance(parent.func, ast.Attribute) and parent.func.attr == 'startswith':
                return True
        return False

    def visit_Compare(self, node: ast.Compare):
        op = node.ops[0]
        if isinstance(op, (ast.Eq, ast.In)):
            description = self._extract_description_from_comment(node)
            for item in [node.left] + node.comparators:
                if isinstance(item, ast.Constant):
                    if not self._is_in_extension_context(item.value):
                        self._add_command(item.value, description)
                elif isinstance(item, ast.Name) and item.id in self.variables:
                    if not self._is_in_extension_context(self.variables[item.id]):
                        self._add_command(self.variables[item.id], description)
                elif isinstance(item, (ast.List, ast.Tuple)):
                    for element in item.elts:
                        if isinstance(element, ast.Constant):
                            if not self._is_in_extension_context(element.value):
                                self._add_command(element.value, description)
        self.generic_visit(node)

    def _is_in_extension_context(self, value: Any) -> bool:
        if isinstance(value, str):
            if value.startswith(".") and len(value) <= 5 and value.count(".") == 1:
                extension = value[1:].lower()
                common_extensions = {
                    "mp3", "wav", "ogg", "opus", "m4a", "gif", "jpg", "jpeg",
                    "png", "mp4", "avi", "mkv", "webm", "flac", "aac", "wma"
                }
                return extension in common_extensions
        return False

    def visit_BoolOp(self, node: ast.BoolOp):
        if isinstance(node.op, ast.Or):
            startswith_commands = []
            for value in node.values:
                if (isinstance(value, ast.Call) and
                    isinstance(value.func, ast.Attribute) and
                    value.func.attr == 'startswith' and
                    value.args and
                    isinstance(value.args[0], ast.Constant)):
                    cmd_value = value.args[0].value
                    if isinstance(cmd_value, str) and cmd_value.endswith(" "):
                        startswith_commands.append(cmd_value.rstrip())

            for cmd in startswith_commands:
                self._add_command(cmd, None, context="startswith_check")

        self.generic_visit(node)

    def visit_Call(self, node: ast.Call):
        if isinstance(node.func, ast.Attribute) and node.func.attr == 'startswith':
            if node.args:
                description = self._extract_description_from_comment(node)
                arg = node.args[0]
                if isinstance(arg, ast.Constant):
                    self._add_command(arg.value, description, context="startswith_check")
                elif isinstance(arg, ast.Name) and arg.id in self.variables:
                    self._add_command(self.variables[arg.id], description, context="startswith_check")

        elif isinstance(node.func, ast.Attribute) and node.func.attr == 'startswith' and hasattr(node, 'parent'):
            parent = node.parent
            if isinstance(parent, ast.BoolOp) and isinstance(parent.op, ast.Or):
                for value in parent.values:
                    if isinstance(value, ast.Call) and isinstance(value.func, ast.Attribute) and value.func.attr == 'startswith':
                        if value.args and isinstance(value.args[0], ast.Constant):
                            cmd_value = value.args[0].value
                            if isinstance(cmd_value, str) and cmd_value.endswith(" "):
                                self._add_command(cmd_value.rstrip(), None, context="startswith_check")

        elif (isinstance(node.func, ast.Attribute) and
              node.func.attr == 'get_setting' and
              node.args and
              isinstance(node.args[0], ast.Constant)):
            setting_key = node.args[0].value
            if setting_key in ["custom_command", "command_alias"]:
                self.has_dynamic_commands = True
                if len(node.args) > 1 and isinstance(node.args[1], ast.Constant):
                    default_cmd = node.args[1].value
                    if isinstance(default_cmd, str) and self.VALID_COMMAND_RE.match(default_cmd):
                        self.commands.add(default_cmd)

        self.generic_visit(node)

    def visit_ClassDef(self, node: ast.ClassDef):
        is_enum = False
        for base in node.bases:
            if isinstance(base, ast.Name) and 'Enum' in base.id:
                is_enum = True
                break

        if is_enum and self._is_command_enum(node):
            for item in node.body:
                if isinstance(item, ast.Assign) and len(item.targets) == 1:
                    if isinstance(item.value, ast.Constant) and isinstance(item.value.value, str):
                        command_stem = item.value.value
                        full_command = f".{command_stem}"
                        if not self._is_likely_false_positive(full_command):
                            self.commands.add(full_command)

        self.generic_visit(node)

    def _is_command_enum(self, node: ast.ClassDef) -> bool:
        class_name = node.name.lower()

        non_command_enum_patterns = [
            'searchfilter', 'tlentitytype', 'entitytype', 'filter', 'type',
            'status', 'state', 'mode', 'level', 'priority', 'category'
        ]

        if any(pattern in class_name for pattern in non_command_enum_patterns):
            return False

        command_like_values = 0
        total_values = 0

        for item in node.body:
            if isinstance(item, ast.Assign) and len(item.targets) == 1:
                if isinstance(item.value, ast.Constant) and isinstance(item.value.value, str):
                    total_values += 1
                    value = item.value.value
                    if len(value) <= 15 and re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', value):
                        command_like_values += 1

        if total_values > 0 and command_like_values / total_values < 0.7:
            return False

        return True


class CommandHarvesterPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.command_cache = CommandCache()
        self.command_stats = None

    def on_plugin_load(self):
        try:
            self.add_on_send_message_hook()
            self.command_stats = CommandStatistics(self)

            import_zwylib()
            if is_zwylib_present():
                zwylib.add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_CHANNEL_USERNAME, AUTOUPDATE_MESSAGE_ID)
        except Exception:
            pass

    def on_plugin_unload(self):
        if is_zwylib_present():
            zwylib.remove_autoupdater_task(__id__)

    def create_settings(self) -> List[Any]:
        try:
            return [
                Header(text="Command List"),
                Input(
                    key="command_alias",
                    text="–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤—ã–∑–æ–≤–∞",
                    icon="msg_edit",
                    default=DEFAULT_CMD,
                    subtext="–ö–æ–º–∞–Ω–¥–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –≤—ã–≤–æ–¥–∏—Ç—å—Å—è —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥"
                ),
                Switch(
                    key="use_blockquote",
                    text="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–∏—Ç–∞—Ç—É",
                    icon="menu_quote_specific",
                    subtext="–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ –≤ –≤–∏–¥–µ —Å–≤–æ—Ä–∞—á–∏–≤–∞–µ–º–æ–π —Ü–∏—Ç–∞—Ç—ã",
                    default=True
                ),
                Divider(),
                Header(text="–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ"),
                Switch(
                    key="enable_cache",
                    text="–í–∫–ª—é—á–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ",
                    icon="menu_storage_path",
                    subtext="–ö—ç—à–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã",
                    default=True
                ),
                Input(
                    key="cache_duration",
                    text="–í—Ä–µ–º—è –∫—ç—à–∞ (–º–∏–Ω)",
                    icon="menu_views_recent",
                    default="5",
                    subtext="–í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫—ç—à–∞ –≤ –º–∏–Ω—É—Ç–∞—Ö (1-60)"
                ),
                Text(
                    text="–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à",
                    icon="msg_delete",
                    on_click=self._clear_cache_setting
                ),
                Divider(),
                Header(text="–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ"),
                Selector(
                    key="sort_mode",
                    text="–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥",
                    icon="menu_tag_filter",
                    default=0,
                    items=["–ü–æ –∞–ª—Ñ–∞–≤–∏—Ç—É", "–ü–æ –ø–ª–∞–≥–∏–Ω–∞–º", "–ü–æ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏"]
                ),
                Switch(
                    key="show_descriptions",
                    text="–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏—è",
                    icon="msg_info",
                    subtext="–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã",
                    default=False
                ),
                Switch(
                    key="show_plugin_stats",
                    text="–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
                    icon="msg_stats",
                    subtext="–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–∞–Ω–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞",
                    default=True
                ),
                Switch(
                    key="debug_mode",
                    text="–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏",
                    icon="msg_log",
                    subtext="–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥",
                    default=False
                ),
                Divider(text="–≠—Ç–æ—Ç –ø–ª–∞–≥–∏–Ω –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–¥ –¥—Ä—É–≥–∏—Ö –ø–ª–∞–≥–∏–Ω–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥")
            ]
        except Exception:
            return [Divider(text="–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫")]

    def _toggle_cache(self, new_value: bool):
        if not new_value:
            self.command_cache.invalidate_cache()

    def _update_cache_duration(self, new_value: str):
        try:
            duration = int(new_value)
            if 1 <= duration <= 60:
                self.command_cache.cache_duration = duration * 60
        except ValueError:
            pass

    def _clear_cache_setting(self, view):
        self.command_cache.invalidate_cache()
        run_on_ui_thread(lambda: BulletinHelper.show_success("–ö—ç—à –æ—á–∏—â–µ–Ω"))

    def _get_plugin_id_from_file(self, file_path: str) -> Optional[str]:
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
            tree = ast.parse(content, filename=file_path)
            for node in ast.walk(tree):
                if (isinstance(node, ast.Assign) and len(node.targets) == 1 and
                        isinstance(node.targets[0], ast.Name) and node.targets[0].id == '__id__'):
                    return ast.literal_eval(node.value)
        except Exception:
            pass
        return None

    def _get_all_commands(self) -> Dict[str, Dict[str, Any]]:
        if self.get_setting("enable_cache", True):
            cached_commands = self.command_cache.get_cached_commands()
            if cached_commands:
                return cached_commands
        plugin_data: Dict[str, Dict[str, Any]] = {}
        plugins_controller = PluginsController.getInstance()
        loaded_plugins = list(plugins_controller.plugins.values().toArray())
        loaded_plugins_map = {p.getId(): p for p in loaded_plugins}
        
        plugins_dir = plugins_controller.pluginsDir
        if not plugins_dir:
            raise ValueError(locali.get_string("dir_error"))
        plugins_dir = plugins_dir.getAbsolutePath()

        for filename in os.listdir(plugins_dir):
            if not filename.endswith(('.py', '.plugin')):
                continue

            file_path = os.path.join(plugins_dir, filename)

            try:
                plugin_id_from_file = self._get_plugin_id_from_file(file_path)
                if not plugin_id_from_file or plugin_id_from_file not in loaded_plugins_map:
                    continue
                if plugin_id_from_file == __id__:
                    continue

                plugin_obj = loaded_plugins_map[plugin_id_from_file]
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()

                tree = ast.parse(content, filename=file_path)
                visitor = CommandVisitor()
                visitor.visit(tree)

                dynamic_commands = self._get_dynamic_commands(plugin_obj, visitor)
                all_commands = visitor.commands.union(dynamic_commands)

                if self.get_setting("debug_mode", False) and plugin_obj.getName() == "Media Downloader":
                    debug_info = f"üîç –û—Ç–ª–∞–¥–∫–∞ –¥–ª—è {plugin_obj.getName()}:\n"
                    debug_info += f"  –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã: {sorted(list(visitor.commands))}\n"
                    debug_info += f"  –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã: {sorted(list(dynamic_commands))}\n"
                    debug_info += f"  –ò—Ç–æ–≥–æ –∫–æ–º–∞–Ω–¥: {len(all_commands)}\n"

                if all_commands:
                    plugin_data[plugin_obj.getName()] = {
                        "commands": sorted(list(all_commands)),
                        "descriptions": visitor.command_descriptions,
                        "enabled": plugin_obj.isEnabled(),
                        "has_dynamic": visitor.has_dynamic_commands or bool(dynamic_commands)
                    }
            except Exception:
                continue

        if self.get_setting("enable_cache", True):
            self.command_cache.cache_commands(plugin_data)

        return plugin_data

    def _get_dynamic_commands(self, plugin_obj, visitor) -> Set[str]:
        dynamic_commands = set()

        try:
            if hasattr(plugin_obj, '_get_commands_list'):
                try:
                    commands_list = plugin_obj._get_commands_list()
                    if isinstance(commands_list, list):
                        for cmd in commands_list:
                            if isinstance(cmd, str) and CommandVisitor.VALID_COMMAND_RE.match(cmd):
                                is_invalid = any(re.match(pattern, cmd) for pattern in CommandVisitor.INVALID_PATTERNS)
                                if not is_invalid:
                                    dynamic_commands.add(cmd)
                    elif not commands_list and hasattr(plugin_obj, 'get_setting'):
                        no_command_mode = plugin_obj.get_setting("no_command_mode", False)
                        if no_command_mode:
                            dynamic_commands.add("*–±–µ–∑ –∫–æ–º–∞–Ω–¥*")
                        else:
                            custom_cmd = plugin_obj.get_setting("custom_command", ".ai")
                            if custom_cmd and CommandVisitor.VALID_COMMAND_RE.match(custom_cmd):
                                is_invalid = any(re.match(pattern, custom_cmd) for pattern in CommandVisitor.INVALID_PATTERNS)
                                if not is_invalid:
                                    dynamic_commands.add(custom_cmd)
                except:
                    pass

            if hasattr(plugin_obj, 'get_setting'):
                try:
                    custom_cmd = plugin_obj.get_setting("custom_command", None)
                    if custom_cmd and isinstance(custom_cmd, str) and CommandVisitor.VALID_COMMAND_RE.match(custom_cmd):
                        is_invalid = any(re.match(pattern, custom_cmd) for pattern in CommandVisitor.INVALID_PATTERNS)
                        if not is_invalid:
                            dynamic_commands.add(custom_cmd)
                except:
                    pass

                try:
                    command_alias = plugin_obj.get_setting("command_alias", None)
                    if command_alias and isinstance(command_alias, str) and CommandVisitor.VALID_COMMAND_RE.match(command_alias):
                        is_invalid = any(re.match(pattern, command_alias) for pattern in CommandVisitor.INVALID_PATTERNS)
                        if not is_invalid:
                            dynamic_commands.add(command_alias)
                except:
                    pass

            if visitor.default_commands:
                for cmd in visitor.default_commands:
                    if isinstance(cmd, str) and CommandVisitor.VALID_COMMAND_RE.match(cmd):
                        is_invalid = any(re.match(pattern, cmd) for pattern in CommandVisitor.INVALID_PATTERNS)
                        if not is_invalid:
                            dynamic_commands.add(cmd)

        except Exception:
            pass

        return dynamic_commands

    def _format_command_list(self, all_commands: Dict[str, Dict[str, Any]]) -> str:
        if not all_commands:
            return locali.get_string("no_cmds_found")

        total_plugins = len(all_commands)
        total_commands = sum(len(data["commands"]) for data in all_commands.values())

        cache_info = ""
        if self.get_setting("enable_cache", True) and self.command_cache.is_cache_valid():
            time_ago = int((time.time() - self.command_cache.cache_timestamp) / 60)
            if locali.language == "ru":
                time_unit = "–º–∏–Ω"
            elif locali.language == "uk":
                time_unit = "—Ö–≤"
            else:
                time_unit = "min"
            cache_info = f"\n{locali.get_string('cached_data_info').format(time_ago=f'{time_ago} {time_unit}')}\n"

        if locali.language == "ru":
            message = f"üìú **–°–ø–∏—Å–æ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ ({total_plugins} –ø–ª–∞–≥–∏–Ω–æ–≤, {_pluralize_commands(total_commands)}):**\n\n" + cache_info
        else:
            message = locali.get_string("cmd_list_header").format(plugin_count=total_plugins, command_count=total_commands) + cache_info

        sort_mode = self.get_setting("sort_mode", 0)
        show_stats = self.get_setting("show_plugin_stats", True)

        if sort_mode == 0:
            sorted_plugins = sorted(all_commands.items(), key=lambda item: item[0].lower())
        elif sort_mode == 1:
            sorted_plugins = sorted(all_commands.items(), key=lambda item: (not item[1]["enabled"], item[0].lower()))
        else:
            if self.command_stats:
                def get_plugin_usage(plugin_data):
                    plugin_name, data = plugin_data
                    total_usage = sum(self.command_stats.get_usage_count(cmd) for cmd in data["commands"])
                    return total_usage
                sorted_plugins = sorted(all_commands.items(), key=get_plugin_usage, reverse=True)
            else:
                sorted_plugins = sorted(all_commands.items(), key=lambda item: item[0].lower())

        show_descriptions = self.get_setting("show_descriptions", False)

        for plugin_name, data in sorted_plugins:
            commands = data["commands"]
            descriptions = data.get("descriptions", {})
            is_enabled = data["enabled"]
            has_dynamic = data.get("has_dynamic", False)
            status_icon = "‚úÖ" if is_enabled else "‚ùå"
            status_text = locali.get_string("plugin_status_on") if is_enabled else locali.get_string("plugin_status_off")
            status_str = f"||[{status_icon} {status_text}]||"

            dynamic_indicator = " üîÑ" if has_dynamic else ""
            plugin_header = f"**üß© {plugin_name}**{dynamic_indicator} {status_str}"

            if show_stats:
                cmd_count = len(commands)
                plugin_header += f" `({_pluralize_commands(cmd_count)})`"

            message += f"{plugin_header}\n"

            formatted_commands = []
            for cmd in commands:
                if cmd == "*–±–µ–∑ –∫–æ–º–∞–Ω–¥*":
                    formatted_commands.append("*—Ä–µ–∂–∏–º –±–µ–∑ –∫–æ–º–∞–Ω–¥*")
                else:
                    formatted_commands.append(cmd)

            if sort_mode == 2 and self.command_stats:
                cmd_usage = [(cmd, self.command_stats.get_usage_count(cmd)) for cmd in formatted_commands]
                cmd_usage.sort(key=lambda x: x[1], reverse=True)
                if show_descriptions:
                    commands_with_info = []
                    for cmd, usage in cmd_usage:
                        cmd_str = f"{cmd}"
                        if cmd in descriptions:
                            cmd_str += f" - {descriptions[cmd]}"
                        commands_with_info.append(cmd_str)
                    commands_str = '` `'.join(commands_with_info)
                else:
                    commands_sorted_by_usage = [cmd for cmd, usage in cmd_usage]
                    commands_str = '` `'.join(commands_sorted_by_usage)
            else:
                if show_descriptions:
                    commands_with_desc = []
                    for cmd in sorted(formatted_commands):
                        cmd_str = cmd
                        if cmd in descriptions:
                            cmd_str += f" - {descriptions[cmd]}"
                        commands_with_desc.append(cmd_str)
                    commands_str = '` `'.join(commands_with_desc)
                else:
                    commands_str = '` `'.join(sorted(formatted_commands))

            message += f"`{commands_str}`\n\n"

        message += locali.get_string("cmd_note")
        if locali.language == "ru":
            message += f"\n*üîÑ –ü–ª–∞–≥–∏–Ω—ã —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏ –º–æ–≥—É—Ç –∏–∑–º–µ–Ω—è—Ç—å –∫–æ–º–∞–Ω–¥—ã –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.*"
        elif locali.language == "uk":
            message += f"\n*üîÑ –ü–ª–∞–≥—ñ–Ω–∏ –∑ –¥–∏–Ω–∞–º—ñ—á–Ω–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏ –º–æ–∂—É—Ç—å –∑–º—ñ–Ω—é–≤–∞—Ç–∏ –∫–æ–º–∞–Ω–¥–∏ –≤ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö.*"
        else:
            message += f"\n*üîÑ Plugins with dynamic commands can change commands in settings.*"

        if self.get_setting("debug_mode", False):
            message += f"\n\nüîß **–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏ –≤–∫–ª—é—á–µ–Ω** - —É–ª—É—á—à–µ–Ω–Ω–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥ –∞–∫—Ç–∏–≤–Ω–æ"

        message += f"\n\n{locali.get_string('search_help').format(cmd=self.get_setting('command_alias', DEFAULT_CMD))}"

        if locali.language == "ru":
            message += f"\n*–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `.cmdstats` –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥.*"
        elif locali.language == "uk":
            message += f"\n*–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `.cmdstats` –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∫–æ–º–∞–Ω–¥.*"
        else:
            message += f"\n*Use `.cmdstats` to view command usage statistics.*"

        return message

    def _format_command_stats(self) -> str:
        if not self.command_stats:
            return locali.get_string("stats_unavailable")

        stats_summary = self.command_stats.get_stats_summary()

        if stats_summary["total_commands"] == 0:
            return locali.get_string("stats_no_usage")

        message = locali.get_string("stats_header") + "\n\n"

        total_commands = stats_summary["total_commands"]
        total_usage = stats_summary["total_usage"]

        message += locali.get_string("stats_general") + "\n"

        if locali.language == "ru":
            message += f"{locali.get_string('stats_unique_commands')} {_pluralize_commands(total_commands)}\n"
            message += f"{locali.get_string('stats_total_usage')} {_pluralize_usages(total_usage)}\n\n"
        else:
            message += f"{locali.get_string('stats_unique_commands')} {total_commands}\n"
            message += f"{locali.get_string('stats_total_usage')} {total_usage}\n\n"

        if stats_summary["most_used"]:
            most_used_cmd, most_used_count = stats_summary["most_used"]
            message += locali.get_string("stats_most_popular") + "\n"
            message += f"`{most_used_cmd}`\n\n"

        popular_commands = stats_summary["popular_commands"]
        if popular_commands:
            count = min(10, len(popular_commands))
            message += locali.get_string("stats_top_commands").format(count=count) + "\n"

            for i, (cmd, count) in enumerate(popular_commands, 1):
                message += f"{i}) `{cmd}`\n"

        return message

    def _handle_search_command(self, params: Any, search_query: str) -> HookResult:
        try:
            all_commands = self._get_all_commands()
            search_results = {}

            search_lower = search_query.lower()

            for plugin_name, data in all_commands.items():
                matching_commands = []
                for cmd in data["commands"]:
                    if (search_lower in cmd.lower() or
                        search_lower in plugin_name.lower()):
                        matching_commands.append(cmd)

                if matching_commands:
                    search_results[plugin_name] = {
                        "commands": matching_commands,
                        "descriptions": data.get("descriptions", {}),
                        "enabled": data["enabled"]
                    }

            if search_results:
                response_text = locali.get_string("search_results").format(query=search_query)
                response_text += self._format_command_list(search_results)
            else:
                response_text = locali.get_string("search_no_results").format(query=search_query)

            if not hasattr(params, "entities") or params.entities is None:
                params.entities = ArrayList()
            else:
                params.entities.clear()

            if self.get_setting("use_blockquote", True):
                parsed_for_quote = parse_markdown(response_text)
                params.message = parsed_for_quote.text

                entity = TLRPC.TL_messageEntityBlockquote()
                entity.collapsed = True
                entity.offset = 0
                entity.length = len(params.message.encode('utf_16_le')) // 2
                params.entities.add(entity)
            else:
                parsed = parse_markdown(response_text)
                params.message = parsed.text
                for entity in parsed.entities:
                    params.entities.add(entity.to_tlrpc_object())

            return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

        except Exception:
            return HookResult()

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        message_text = params.message.strip()

        if self.command_stats and message_text.startswith('.'):
            command = message_text.split()[0]
            if re.match(r"^\.[\w-]+$", command):
                self.command_stats.increment_usage(command)

        trigger_command = self.get_setting("command_alias", DEFAULT_CMD)

        if message_text == ".cmdstats":
            try:
                if not hasattr(params, "entities") or params.entities is None:
                    params.entities = ArrayList()
                else:
                    params.entities.clear()

                response_text = self._format_command_stats()

                if self.get_setting("use_blockquote", True):
                    parsed_for_quote = parse_markdown(response_text)
                    params.message = parsed_for_quote.text

                    entity = TLRPC.TL_messageEntityBlockquote()
                    entity.collapsed = True
                    entity.offset = 0
                    entity.length = len(params.message.encode('utf_16_le')) // 2
                    params.entities.add(entity)
                else:
                    parsed = parse_markdown(response_text)
                    params.message = parsed.text
                    for entity in parsed.entities:
                        params.entities.add(entity.to_tlrpc_object())

                return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

            except Exception:
                error_text = locali.get_string("stats_error") + "\n\n" + f"```\n{traceback.format_exc()}\n```"
                parsed_error = parse_markdown(error_text)
                params.message = parsed_error.text
                if hasattr(params, "entities") and params.entities is not None:
                    params.entities.clear()
                for entity in parsed_error.entities:
                    params.entities.add(entity.to_tlrpc_object())
                return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

        if message_text.startswith(f"{trigger_command} "):
            search_query = message_text[len(trigger_command):].strip()
            if search_query:
                return self._handle_search_command(params, search_query)

        if message_text == trigger_command:
            try:
                all_commands = self._get_all_commands()

                if not hasattr(params, "entities") or params.entities is None:
                    params.entities = ArrayList()
                else:
                    params.entities.clear()
                
                response_text = self._format_command_list(all_commands)

                if self.get_setting("use_blockquote", True):
                    parsed_for_quote = parse_markdown(response_text)
                    params.message = parsed_for_quote.text

                    entity = TLRPC.TL_messageEntityBlockquote()
                    entity.collapsed = True
                    entity.offset = 0
                    entity.length = len(params.message.encode('utf_16_le')) // 2
                    params.entities.add(entity)
                else:
                    parsed = parse_markdown(response_text)
                    params.message = parsed.text
                    for entity in parsed.entities:
                        params.entities.add(entity.to_tlrpc_object())

                return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

            except Exception:
                error_text = locali.get_string("error_collecting_cmds") + f"```\n{traceback.format_exc()}\n```"
                parsed_error = parse_markdown(error_text)
                params.message = parsed_error.text
                if hasattr(params, "entities") and params.entities is not None:
                    params.entities.clear()
                for entity in parsed_error.entities:
                    params.entities.add(entity.to_tlrpc_object())
                return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

        return HookResult()

plugin_instance = CommandHarvesterPlugin()