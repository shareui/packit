import json
import os
import threading
import time
import urllib.request
from base_plugin import BasePlugin, MethodHook
from android_utils import log, run_on_ui_thread
from hook_utils import find_class
from org.telegram.messenger import ApplicationLoader, UserObject, LocaleController
from ui.settings import Header, Switch, Text
from ui.bulletin import BulletinHelper
from java.util import Locale

__id__ = "Cherry_Badges"
__name__ = "Cherry Badges"
__description__ = "Integration of Cherrygram badges into exteraGram."
__author__ = "@kvucoPlugins, @logicPlugins"
__min_version__ = "12.1.1"
__icon__ = "cherrybadges/0"
__version__ = "1.0"

EXTERA_API_URL = "https://api.exteragram.app/api/v1/profiles"
CHERRY_TIER1_URL = "https://gitlab.com/arslan4k1390/Cherrygram-IDS/-/raw/main/donates.txt"
CHERRY_TIER2_URL = "https://gitlab.com/arslan4k1390/Cherrygram-IDS/-/raw/main/donates_marketplace.txt"

EMOJI_CHERRY_DEV = 5285294339646328611
EMOJI_CHERRY_2 = 5285439990577268512
EMOJI_CHERRY_5 = 5285250281871805026
EMOJI_DUAL_2 = 5285158494125720908
EMOJI_DUAL_5 = 5285001744999288188

DEFAULT_EXTERA_BADGE_ID = 5391059537102927631
CHERRY_DEV_ID = 282287840

REFRESH_INTERVAL = 3600
CACHE_FILE_NAME = "cherry_badges_cache.json"

class BadgeHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self.plugin.badges_data: return
            tl_object = param.args[0]
            obj_id = int(getattr(tl_object, "id", 0))
            
            if obj_id in self.plugin.badges_data:
                badge_info = self.plugin.badges_data[obj_id]
                raw_text = self.plugin.get_badge_text(badge_info["type"])
                final_text = self.plugin.format_text(raw_text, tl_object)
                
                badge_dto = self.plugin.BadgeDTO(int(badge_info["emoji"]), final_text)
                param.setResult(badge_dto)
        except Exception:
            pass

class CherryBadges(BasePlugin):
    def __init__(self):
        super().__init__()
        self.badges_data = {} 
        self.BadgeDTO = None
        self.hook_ref = None
        self._stop_event = threading.Event()
        self.cache_path = ""
        self.is_updating = False
        self.strings = {}

    def on_plugin_load(self):
        try:
            self.BadgeDTO = find_class("com.exteragram.messenger.api.dto.BadgeDTO")
            try:
                context = ApplicationLoader.applicationContext
                files_dir = context.getExternalFilesDir(None)
                if files_dir:
                    self.cache_path = os.path.join(str(files_dir.getAbsolutePath()), CACHE_FILE_NAME)
                else:
                    self.cache_path = f"/sdcard/{CACHE_FILE_NAME}"
            except:
                self.cache_path = f"/sdcard/{CACHE_FILE_NAME}"

            self._update_strings()
            self._load_cache()
            self._setup_hook()
            self._stop_event.clear()
            threading.Thread(target=self._update_loop, daemon=True).start()
            self.log("CherryBadges loaded")
        except Exception as e:
            self.log(f"Load error: {e}")

    def on_plugin_unload(self):
        try:
            self._stop_event.set()
            if self.hook_ref:
                self.unhook_method(self.hook_ref)
        except Exception as e:
            self.log(f"Unload error: {e}")

    def _update_strings(self):
        try:
            lang_code = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
        except:
            lang_code = "en"
        
        is_ru = lang_code.startswith("ru")

        self.strings = {
            "conf_header": "Дополнительно" if is_ru else "Additionally",
            "dual_badges": "Двойные значки" if is_ru else "Dual badges",
            "dual_sub": "Особый значок для тех, кто поддержал оба проекта" if is_ru else "Special badge for users who support both projects",
            "act_header": "Действия" if is_ru else "Actions",
            "check_updates": "Проверить обновления" if is_ru else "Check for updates",
            "checking": "Проверка обновлений..." if is_ru else "Checking updates...",
            "no_updates": "Обновлений нет" if is_ru else "No updates found",
            "updated": "Обновлено! Всего: {}" if is_ru else "Updated! Total: {}",
            "update_fail": "Ошибка обновления" if is_ru else "Update failed",
            "already_updating": "Обновление уже идет..." if is_ru else "Update already in progress...",
            "clear_cache": "Очистить кэш" if is_ru else "Clear cache",
            "cache_cleared": "Кэш очищен! Скачиваю данные..." if is_ru else "Cache cleared! Downloading fresh data...",
            "cache_fail": "Ошибка очистки: {}" if is_ru else "Failed to clear cache: {}",
            "show_count": "Показать кол-во значков в кэше" if is_ru else "Show cached badges count",
            "loaded_count": "Загружено значков: {}" if is_ru else "Loaded badges: {}",
            
            "badge_dev": "**{user}** является разработчиком **Cherrygram**" if is_ru else "**{user}** is a developer of **Cherrygram**",
            "badge_cherry": "**{user}** поддержал(а) разработку **Cherrygram** и получил(а) уникальный значок" if is_ru else "**{user}** supported **Cherrygram** development and received a unique badge",
            "badge_dual": "**{user}** поддержал(а) разработку **exteraGram** и **Cherrygram** и получил(а) уникальный значок" if is_ru else "**{user}** supported **exteraGram** and **Cherrygram** development and received a unique badge"
        }

    def get_badge_text(self, badge_type):
        self._update_strings()
        if badge_type == "DEV": return self.strings["badge_dev"]
        if badge_type == "DUAL": return self.strings["badge_dual"]
        return self.strings["badge_cherry"]

    def create_settings(self):
        try:
            self._update_strings()
            return [
                Header(text=self.strings.get("conf_header", "Configuration")),
                Switch(
                    key="enable_dual", 
                    text=self.strings.get("dual_badges", "Dual Badges"), 
                    default=True,
                    subtext=self.strings.get("dual_sub", ""),
                    on_change=lambda *args: self._force_update(silent=True)
                ),
                Header(text=self.strings.get("act_header", "Actions")),
                Text(
                    text=self.strings.get("check_updates", "Check updates"), 
                    icon="msg_download", 
                    on_click=lambda *args: self._force_update()
                ),
                Text(
                    text=self.strings.get("clear_cache", "Clear Cache"), 
                    icon="msg_delete", 
                    on_click=lambda *args: self._clear_cache(),
                    red=True
                ),
                Text(
                    text=self.strings.get("show_count", "Show Count"), 
                    icon="msg_info", 
                    on_click=lambda *args: self._show_count()
                )
            ]
        except Exception as e:
            self.log(f"Settings crash: {e}")
            return [Header(text=f"Settings Error: {e}")]

    def _show_count(self):
        count = len(self.badges_data)
        run_on_ui_thread(lambda: BulletinHelper.show_info(self.strings["loaded_count"].format(count)))

    def _force_update(self, silent=False):
        if self.is_updating:
            if not silent:
                BulletinHelper.show_error(self.strings["already_updating"])
            return
        
        if not silent:
            BulletinHelper.show_info(self.strings["checking"])
        
        def task():
            try:
                if not silent: time.sleep(0.5)
                self._fetch_and_process(notify=not silent)
            except Exception as e:
                if not silent:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(self.strings["update_fail"]))
        
        threading.Thread(target=task, daemon=True).start()

    def _clear_cache(self):
        try:
            if os.path.exists(self.cache_path):
                os.remove(self.cache_path)
            
            self.badges_data = {}
            run_on_ui_thread(lambda: BulletinHelper.show_success(self.strings["cache_cleared"]))
            self._force_update(silent=True)
        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(self.strings["cache_fail"].format(e)))

    def format_text(self, template: str, tl_object) -> str:
        try:
            name = "User"
            if hasattr(tl_object, "first_name"): 
                name = UserObject.getUserName(tl_object)
            elif hasattr(tl_object, "title"):
                name = tl_object.title
            return template.replace("{user}", name)
        except:
            return template.replace("{user}", "User")

    def _setup_hook(self):
        try:
            BadgesController = find_class("com.exteragram.messenger.badges.BadgesController")
            if BadgesController:
                TLObject = find_class("org.telegram.tgnet.TLObject")
                method = BadgesController.getClass().getDeclaredMethod("getBadge", TLObject)
                method.setAccessible(True)
                self.hook_ref = self.hook_method(method, BadgeHook(self))
        except Exception as e:
            self.log(f"Hook setup error: {e}")

    def _update_loop(self):
        while not self._stop_event.is_set():
            try:
                if not self.is_updating:
                    self._fetch_and_process(notify=False)
            except Exception as e:
                self.log(f"Update loop error: {e}")
            self._stop_event.wait(REFRESH_INTERVAL)

    def _load_cache(self):
        try:
            if os.path.exists(self.cache_path):
                with open(self.cache_path, "r", encoding="utf-8") as f:
                    raw_data = json.load(f)
                    
                    if "badges" in raw_data:
                        badges = raw_data.get("badges", {})
                        self.badges_data = {int(k): v for k, v in badges.items()}
                    else:
                        self.badges_data = {int(k): v for k, v in raw_data.items()}
                        
                self.log(f"Loaded {len(self.badges_data)} badges from cache")
        except:
            pass

    def _save_cache(self):
        try:
            os.makedirs(os.path.dirname(self.cache_path), exist_ok=True)
            with open(self.cache_path, "w", encoding="utf-8") as f:
                json.dump(self.badges_data, f)
        except:
            pass

    def _fetch_url(self, url: str) -> str:
        req = urllib.request.Request(url)
        req.add_header('User-Agent', 'exteraGram-Plugin/1.0')
        req.add_header('Cache-Control', 'no-cache')
        with urllib.request.urlopen(req, timeout=20) as response:
            return response.read().decode('utf-8')

    def _fetch_and_process(self, notify=False):
        self._update_strings()
        self.is_updating = True
        try:
            self.log("Starting update...")
            
            extera_json = self._fetch_url(EXTERA_API_URL)
            extera_data = json.loads(extera_json)
            
            extera_exceptions = set() 
            extera_supporters = set()
            
            if isinstance(extera_data, list):
                for profile in extera_data:
                    try:
                        uid = int(profile.get("id", 0))
                        if uid == 0: continue
                        status = str(profile.get("status", "")).upper()
                        
                        badge_obj = profile.get("badge")
                        resolved_id = 0
                        if isinstance(badge_obj, dict):
                             val = badge_obj.get("documentId")
                             if val: resolved_id = int(val)
                        else:
                             val = profile.get("badge_id")
                             if val: resolved_id = int(val)

                        is_dev = "DEVELOPER" in status
                        is_custom = (resolved_id != 0) and (resolved_id != DEFAULT_EXTERA_BADGE_ID)
                        
                        if is_dev: extera_exceptions.add(uid)
                        elif is_custom: extera_exceptions.add(uid)
                        elif resolved_id == DEFAULT_EXTERA_BADGE_ID or "SUPPORTER" in status:
                            extera_supporters.add(uid)
                    except: continue

            cherry_2_raw = self._fetch_url(CHERRY_TIER1_URL)
            cherry_5_raw = self._fetch_url(CHERRY_TIER2_URL)
            cherry_2_ids = {int(l.strip()) for l in cherry_2_raw.splitlines() if l.strip().isdigit()}
            cherry_5_ids = {int(l.strip()) for l in cherry_5_raw.splitlines() if l.strip().isdigit()}

            new_badges = {}
            use_dual = self.get_setting("enable_dual", True)
            
            new_badges[CHERRY_DEV_ID] = {"emoji": EMOJI_CHERRY_DEV, "type": "DEV"}

            def process(id_set, c_emo, d_emo):
                for uid in id_set:
                    if uid == CHERRY_DEV_ID: continue
                    if uid in extera_exceptions: continue 
                    
                    is_dual = (uid in extera_supporters) and use_dual
                    
                    if is_dual:
                        new_badges[uid] = {"emoji": d_emo, "type": "DUAL"}
                    else:
                        new_badges[uid] = {"emoji": c_emo, "type": "CHERRY"}

            process(cherry_5_ids, EMOJI_CHERRY_5, EMOJI_DUAL_5)
            for uid in cherry_2_ids:
                if uid not in new_badges and uid not in extera_exceptions:
                    if uid == CHERRY_DEV_ID: continue
                    is_dual = (uid in extera_supporters) and use_dual
                    if is_dual:
                         new_badges[uid] = {"emoji": EMOJI_DUAL_2, "type": "DUAL"}
                    else:
                        new_badges[uid] = {"emoji": EMOJI_CHERRY_2, "type": "CHERRY"}

            is_changed = (new_badges != self.badges_data)
            
            self.badges_data = new_badges
            self._save_cache()

            if not is_changed:
                self.log("No updates found")
                if notify:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(self.strings["no_updates"]))
            else:
                msg = self.strings["updated"].format(len(new_badges))
                self.log(msg)
                if notify:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(msg))

        except Exception as e:
            self.log(f"Fetch failed: {e}")
            if notify:
                run_on_ui_thread(lambda: BulletinHelper.show_error(self.strings["update_fail"]))
        finally:
            self.is_updating = False