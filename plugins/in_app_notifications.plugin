from typing import Any, Callable

from base_plugin import BasePlugin, hook_filters, HookFilter, MethodReplacement, MethodHook, AppEvent
from android_utils import log, run_on_ui_thread
from client_utils import get_last_fragment, get_messages_controller, get_user_config, get_messages_storage
from hook_utils import find_class
from ui.bulletin import BulletinHelper
from ui.settings import Switch, Header, Divider, Selector, Input

from java import jclass, dynamic_proxy #type: ignore
from java.lang.reflect import Array #type: ignore
from java.util import ArrayList, Arrays, Locale #type: ignore
from java.lang import Class, Integer, Object, Boolean, Runnable, CharSequence #type: ignore

from android.util import TypedValue #type: ignore
from android.os import Bundle, VibrationEffect #type: ignore
from android.graphics.drawable import BitmapDrawable #type: ignore
from android.text import TextUtils, SpannableString, Spanned #type: ignore
from android.view import View, ViewGroup #type: ignore

from de.robv.android.xposed import XC_MethodReplacement #type: ignore

from org.telegram.messenger import MessageObject, NotificationCenter, R, ChatObject, AndroidUtilities, ImageLocation, MessagesController, AccountInstance, LocaleController as TgLocale, ImageReceiver #type: ignore
from org.telegram.ui.Components import BulletinFactory, Bulletin, Text, LinkSpanDrawable, LayoutHelper, ViewHelper #type: ignore
from org.telegram.ui.Components.Forum import ForumUtilities #type: ignore
from org.telegram.ui import ChatActivity, LaunchActivity #type: ignore
from org.telegram.ui.ActionBar import Theme #type: ignore
from org.telegram.tgnet import TLRPC #type: ignore

from com.exteragram.messenger import ExteraConfig  # type: ignore
from com.exteragram.messenger.utils import AppUtils # type: ignore
from com.exteragram.messenger.utils.system import VibratorUtils # type: ignore


__id__ = 'in_app_notifications'
__name__ = 'In-App Notifications'
__icon__ = 'remusic/6'
__description__ = 'ÐŸÐ»Ð°Ð³Ð¸Ð½ Ñ Ð³Ð¸Ð±ÐºÐ¸Ð¼Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ð¼Ð¸ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÑŽÑ‰Ð¸Ð¹ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Telegram Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ.'
__author__ = '@meeowPlugins'
__version__ = '1.2.1'
__min_version__ = '12.0.1'


def logcat(text: Any) -> None:
    log(f'[{__id__}] {text}')


def get_list(java_values):
    java_list = ArrayList(Arrays.asList(java_values))
    py_list = list(java_list.toArray())
    if py_list:
        return py_list
    else:
        return []


def to_json(obj: Any): return AppUtils.getGson().toJson(obj)


def show_bulletin(title: str, subtitle: str, top: bool, blur_animation: bool):
    last_fragment = get_last_fragment()
    if last_fragment is None:
        return

    factory = BulletinFactory.of(last_fragment)
    bulletin = factory.createSimpleBulletin(title, subtitle)

    if blur_animation:
        bulletin.allowBlur()

    run_on_ui_thread(lambda: bulletin.show(top))


class Runnable1(dynamic_proxy(Runnable)):
    def __init__(self, fn: Callable[[Any], None]):
        super().__init__()
        self._fn = fn

    def run(self):
        try:
            self._fn(None)
        except:
            from traceback import format_exc
            logcat(f"Error in Runnable: {format_exc()}.")


class OnNotifyClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, dialog_id: int, account_id: int, topic_id: int | None = None, message_id: int | None = None):
        super().__init__()
        self.dialog_id: int = dialog_id
        self.account_id: int = account_id
        self.topic_id: int | None = topic_id
        self.message_id: int | None = message_id

    def onClick(self, view):
        if self.dialog_id is 0 or None:
            return

        open_chat_or_topic(self.dialog_id, self.account_id, self.topic_id, self.message_id)


def create_users_bulletin(users, text, subtitle):
    fragment = get_last_fragment()
    has_subtitle = subtitle is not None and subtitle != ""
    layout = Bulletin.UsersLayout(
        fragment.getContext(),
        has_subtitle,
        fragment.getResourceProvider()
    )
    count = 0
    uc = get_user_config()

    if users is not None:
        for i in range(len(users)):
            if count >= 3:
                break
            user = users[i]
            if user is not None:
                count += 1
                layout.avatarsImageView.setCount(count)
                layout.avatarsImageView.setObject(count - 1, uc.selectedAccount, user)

        if len(users) == 1:
            layout.avatarsImageView.setTranslationX(AndroidUtilities.dp(4))
            layout.avatarsImageView.setScaleX(1.2)
            layout.avatarsImageView.setScaleY(1.2)
        else:
            layout.avatarsImageView.setScaleX(1.0)
            layout.avatarsImageView.setScaleY(1.0)

    layout.avatarsImageView.commitTransition(False)

    if has_subtitle:
        if not hasattr(layout, 'linearLayout'):
            params = layout.getChildAt(1).getLayoutParams()
        else:
            params = layout.linearLayout.getLayoutParams()
    else:
        params = layout.textView.getLayoutParams()

    if subtitle is not None:
        layout.textView.setSingleLine(True)
        layout.textView.setMaxLines(1)
        layout.textView.setText(text)

        layout.subtitleView.setText(subtitle)
        layout.subtitleView.setSingleLine(False)
        layout.subtitleView.setMaxLines(3)

        if isinstance(params, ViewGroup.MarginLayoutParams):
            margin = AndroidUtilities.dp(12 + 56 + 2 - (3 - count) * 12)
            if count == 1:
                margin += AndroidUtilities.dp(4)

            if TgLocale.isRTL:
                params.rightMargin = margin
            else:
                params.leftMargin = margin
    else:
        layout.textView.setSingleLine(False)
        layout.textView.setMaxLines(4)
        layout.textView.setText(text)

        if isinstance(params, ViewGroup.MarginLayoutParams):
            margin = AndroidUtilities.dp(12 + 56 + 2 - (3 - count) * 12)
            if count == 1:
                layout.textView.setTranslationY(-AndroidUtilities.dp(1))
                margin += AndroidUtilities.dp(4)

            if TgLocale.isRTL:
                params.rightMargin = margin
            else:
                params.leftMargin = margin

    return layout


def create_chats_bulletin(objects, text, subtitle):
    fragment = get_last_fragment()
    has_subtitle = subtitle is not None and subtitle != ""
    layout = Bulletin.UsersLayout(
        fragment.getContext(),
        has_subtitle,
        fragment.getResourceProvider()
    )
    count = 0
    uc = get_user_config()

    if objects is not None:
        for i in range(len(objects)):
            if count >= 3:
                break
            obj = objects[i]
            if obj is not None:
                count += 1
                layout.avatarsImageView.setCount(count)
                layout.avatarsImageView.setObject(count - 1, uc.selectedAccount, obj)

        if len(objects) == 1:
            layout.avatarsImageView.setTranslationX(AndroidUtilities.dp(4))
            layout.avatarsImageView.setScaleX(1.2)
            layout.avatarsImageView.setScaleY(1.2)
        else:
            layout.avatarsImageView.setScaleX(1.0)
            layout.avatarsImageView.setScaleY(1.0)

    layout.avatarsImageView.commitTransition(False)

    if has_subtitle:
        if not hasattr(layout, 'linearLayout'):
            params = layout.getChildAt(1).getLayoutParams()
        else:
            params = layout.linearLayout.getLayoutParams()
    else:
        params = layout.textView.getLayoutParams()

    if subtitle is not None:
        layout.textView.setSingleLine(True)
        layout.textView.setMaxLines(1)
        layout.textView.setText(text)

        layout.subtitleView.setText(subtitle)
        layout.subtitleView.setSingleLine(True)
        layout.subtitleView.setMaxLines(1)

        if isinstance(params, ViewGroup.MarginLayoutParams):
            margin = AndroidUtilities.dp(12 + 56 + 6 - (3 - count) * 12)
            if TgLocale.isRTL:
                params.rightMargin = margin
            else:
                params.leftMargin = margin
    else:
        layout.textView.setSingleLine(False)
        layout.textView.setMaxLines(2)
        layout.textView.setText(text)

        if isinstance(params, ViewGroup.MarginLayoutParams):
            margin = AndroidUtilities.dp(12 + 56 + 6 - (3 - count) * 12)
            if TgLocale.isRTL:
                params.rightMargin = margin
            else:
                params.leftMargin = margin

    if TgLocale.isRTL:
        layout.avatarsImageView.setTranslationX(AndroidUtilities.dp(32 - (count - 1) * 12))

    return layout


def create_button():
    ctx = get_last_fragment().getContext()
    btn = Bulletin.UndoButton(ctx, True, get_last_fragment().getResourceProvider())
    btn.undoTextView = None
    btn.undoTextView = LinkSpanDrawable.LinksTextView(ctx)
    logcat(type(btn.undoTextView))
    btn.undoTextView.setText('text')
    logcat(btn.undoTextView.getText())
    return btn


def get_id_from_peer(peer) -> int:
    peer_id = 0
    if peer.chat_id is not None and peer.chat_id != 0:
        peer_id = -peer.chat_id
    elif peer.user_id is not None and peer.user_id != 0:
        peer_id = peer.user_id
    elif peer.channel_id is not None and peer.channel_id != 0:
        peer_id = peer.channel_id
    return peer_id


def open_chat_or_topic(dialog_id: int, account_id: int, topic_id: int | None = None, message_id: int | None = None):
    mc = get_messages_controller2(account_id)
    last_fragment = get_last_fragment()

    uc = get_user_config()
    parent_activity = last_fragment.getParentActivity()
    if isinstance(parent_activity, LaunchActivity):
        if account_id != uc.getProductionAccount():
            parent_activity.switchToAccount(account_id, True)

    if dialog_id > 0:
        open_chat_with_message(dialog_id, message_id)
    else:
        chat = mc.getChat(-dialog_id)
        if ChatObject.isForum(chat):
            if (topic_id is not 0 and not None) and (message_id is not 0 and not None):
                topic = mc.getTopicsController().findTopic(-dialog_id, topic_id)
                if topic is not None:
                    ForumUtilities.openTopic(last_fragment, -dialog_id, topic, message_id)
            else:
                open_chat_with_message(dialog_id, message_id)
        else:
            open_chat_with_message(dialog_id, message_id)


def open_chat_with_message(dialog_id: int, message_id: int | None = None):
    bundle = Bundle()

    if dialog_id > 0:
        bundle.putLong("user_id", dialog_id)
    else:
        bundle.putLong("chat_id", -dialog_id)

    if message_id is not None and message_id != 0:
        bundle.putInt("message_id", message_id)

    get_last_fragment().presentFragment(ChatActivity(bundle))


def is_channel(chat) -> bool:
    return isinstance(chat, TLRPC.TL_channel) and not chat.megagroup


def is_group(chat) -> bool:
    return isinstance(chat, TLRPC.TL_chat)


def get_messages_controller2(account_id: int | None = None):
    if account_id is None:
        return get_messages_controller()
    elif account_id == get_user_config().currentAccount:
        return get_messages_controller()
    else:
        return AccountInstance.getInstance(account_id).getMessagesController()


def get_chat_title(from_id, dialog_id: int, account_id: int | None = None) -> str:
    mc = get_messages_controller2(account_id)

    if isinstance(from_id, int):
        if from_id > 0:
            user = mc.getUser(from_id)
            if user is not None:
                sender_name = mc.getUser(from_id).first_name
            else:
                sender_name = str(from_id)
        elif from_id < 0:
            sender_name = mc.getChat(-from_id).title
        else:
            sender_name = mc.getChat(-dialog_id).title
    else:
        sender_name = mc.getChat(-dialog_id).title

    return sender_name


def invoke_action(action_id: int, message_object):
    if message_object is None:
        logcat('MessageObject is None, can\'t invoke action')
        return

    dialog_id = message_object.getDialogId()
    topic_id = message_object.getTopicId()
    message_id = message_object.getId()

    if action_id == 0:
        open_chat_or_topic(dialog_id, message_object.currentAccount, topic_id, message_id)

    elif action_id == 1:
        run_on_ui_thread(
            lambda: get_messages_controller2(message_object.currentAccount).markDialogAsRead(
                dialog_id,
                message_id,
                message_id,
                0,
                False,
                topic_id,
                0,
                True,
                0
            )
        )

    elif action_id == 2:
        set_reaction(message_object)
        run_on_ui_thread(
            lambda: get_messages_controller2(message_object.currentAccount).markDialogAsRead(
                dialog_id,
                message_id,
                message_id,
                0,
                False,
                topic_id,
                0,
                True,
                0
            )
        )

    else:
        logcat('Invoked unknown action')


def get_double_tap_reaction(message_object):
    from org.telegram.ui.Components.Reactions import ReactionsLayoutInBubble #type: ignore

    media_center = AccountInstance.getInstance(message_object.currentAccount).getMediaDataController()
    reaction_string = media_center.getDoubleTapReaction()

    visible_reaction = (
        ReactionsLayoutInBubble.VisibleReaction.fromEmojicon(reaction_string) if reaction_string.startswith("animated_")
        else ReactionsLayoutInBubble.VisibleReaction.fromEmojicon(media_center.getReactionsMap().get(reaction_string))
    )

    return visible_reaction


def set_reaction(message_object):
    from org.telegram.ui.Components.Reactions import ReactionsEffectOverlay, ReactionsLayoutInBubble #type: ignore

    sh = AccountInstance.getInstance(message_object.currentAccount).getSendMessagesHelper()
    ReactionsEffectOverlay.removeCurrent(False)
    visible_reaction = get_double_tap_reaction(message_object)

    added = message_object.selectReaction(
        visible_reaction,
        False,
        True
    )

    if added and visible_reaction is not None and visible_reaction.emojicon is not None:
        AndroidUtilities.makeAccessibilityAnnouncement(TgLocale.formatString(R.string.AccDescrYouReactedWith, visible_reaction.emojicon))

    visible_reactions = ArrayList()
    visible_reactions.addAll(message_object.getChoosenReactions())

    sh.sendReaction(
        message_object,
        visible_reactions,
        visible_reaction,
        False,
        False,
        get_last_fragment(),
        None
    )


class LocaleController:
    def __init__(self):
        super().__init__()
        self.language: str = Locale.getDefault().getLanguage()

    def get_controller(self):
        if self.language == "ru":
            return self.LanguageRussian()
        else:
            return self.LanguageEnglish()

    class LanguageRussian:
        language = 'ru'

        Action_OpenChat = 'ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ'
        Action_ReadChat = 'ÐŸÑ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ'
        Action_Reply = 'ÐžÑ‚Ð²ÐµÑ‚Ð¸Ñ‚ÑŒ'
        Action_Reaction = 'Ð ÐµÐ°ÐºÑ†Ð¸Ñ'

        NewMessage = 'ÐÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ!'

        Settings_Title = 'ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸'
        Settings_ChatType_Title = 'Ð§Ð°Ñ‚Ñ‹'
        Settings_Customization_Title = 'ÐšÐ°ÑÑ‚Ð¾Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ'

        Settings_Notify_All = 'Ð’ÑÐµ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ'
        Settings_Notify_Mentions = 'Ð£Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ'
        Settings_Notify_Unmuted = 'ÐÐµ Ð·Ð°Ð³Ð»ÑƒÑˆÐµÐ½Ð½Ñ‹Ðµ'
        Settings_Notify_OnlyPrivate = 'Ð’ÑÐµ Ð›Ð¡'
        Settings_Notify_Archive = 'ÐÑ€Ñ…Ð¸Ð²'

        Settings_ChatType_Groups = 'Ð“Ñ€ÑƒÐ¿Ð¿Ñ‹'
        Settings_ChatType_Channels = 'ÐšÐ°Ð½Ð°Ð»Ñ‹'
        Settings_ChatType_Private = 'ÐŸÑ€Ð¸Ð²Ð°Ñ‚Ð½Ñ‹Ðµ Ñ‡Ð°Ñ‚Ñ‹'
        Settings_ChatType_Bot = 'Ð‘Ð¾Ñ‚Ñ‹'
        Settings_ChatType_Desc = 'Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ñ‚ÑƒÑ‚ Ð² Ð±ÑƒÐ´ÑƒÑ‰ÐµÐ¼ Ð±ÑƒÐ´ÐµÑ‚ Ð²Ñ‹Ð±Ð¾Ñ€ Ñ‡Ð°Ñ‚Ð¾Ð²ðŸ˜‡'

        Settings_Customization_ShowOnTop = 'ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°Ñ‚ÑŒ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð²ÐµÑ€Ñ…Ñƒ'
        Settings_Customization_Duration = 'Ð”Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ'
        Settings_Customization_CustomDuration = 'ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ð°Ñ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ'
        Settings_Customization_CustomDuration_Description = 'ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ð°Ñ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð´Ð¾Ð»Ð¶Ð½Ð° ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒÑÑ Ð² ÑÐµÐºÑƒÐ½Ð´Ð°Ñ…'
        Settings_Customization_Duration_Item1 = '5 ÑÐµÐº'
        Settings_Customization_Duration_Item2 = '2.75 ÑÐµÐº'
        Settings_Customization_Duration_Item3 = '1.5 ÑÐµÐº'
        Settings_Customization_Duration_Item4 = 'Ð¡Ð²Ð¾Ñ‘'
        Settings_Customization_MaxLines = 'ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÑ‚Ñ€Ð¾Ðº'
        Settings_Customization_MaxLines_Alert = 'ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÑ‚Ñ€Ð¾Ðº Ð½ÑƒÐ¶Ð½Ð¾ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð² Ð²Ð¸Ð´Ðµ Ñ‡Ð¸ÑÐ»Ð°, Ð° Ð½Ðµ Ñ€Ð°Ð½Ð´Ð¾Ð¼Ð½Ð¾Ð³Ð¾ Ñ‚ÐµÐºÑÑ‚Ð°!'
        Settings_Customization_MaxLines_Error = 'Ð’Ñ‹ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ! Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°.'
        Settings_Customization_Action = 'Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ'
        Settings_Customization_Action_Item1 = 'ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ'
        Settings_Customization_Action_Item2 = 'ÐŸÑ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ'
        Settings_Customization_Action_Item3 = 'Ð ÐµÐ°ÐºÑ†Ð¸Ñ'
        Settings_Customization_Vibrator = 'Ð’Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ñ'
        Settings_Customization_Vibrator_Description = 'ÐœÐ¾Ð¶ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½ÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ð¸Ð»Ð¸ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð²Ð¾Ð²ÑÐµ.'
        Settings_Customization_IgnoreSystemNotifications = 'Ð˜Ð³Ð½Ð¾Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ñ‹Ðµ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ'
        Settings_Customization_IgnoreSystemNotifications_Description = 'Ð Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾Ð³Ð´Ð° ÐºÐ¾Ð³Ð´Ð° Ð²Ñ‹ Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÐµÑÑŒ Ð² Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸.'
        Settings_Customization_CurrentAccountOnly = 'Ð¢Ð¾Ð»ÑŒÐºÐ¾ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¹ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚'
        Settings_Customization_CurrentAccountOnly_Description = 'Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿Ñ€Ð¸Ñ…Ð¾Ð´Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð° Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÑ Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ñ‹'
        Settings_Customization_ShowTopics = 'ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°Ñ‚ÑŒ Ð¸Ð¼Ñ Ñ‚Ð¾Ð¿Ð¸ÐºÐ°'
        Settings_Customization_BlurAnimation = 'Ð‘Ð»ÑŽÑ€ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ñ'
        Settings_Customization_VibratorPower = 'Ð¡Ð¸Ð»Ð° Ð²Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ð¸'
        Settings_Customization_VibratorPower_Item1 = 'Ð¡Ð»Ð°Ð±Ð°Ñ Ð²Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ñ'
        Settings_Customization_VibratorPower_Item2 = 'Ð¡Ñ€ÐµÐ´Ð½ÑÑ Ð²Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ñ'
        Settings_Customization_VibratorPower_Item3 = 'Ð¡Ð¸Ð»ÑŒÐ½Ð°Ñ Ð²Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ñ'

        Settings_Unknown = 'ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾'

    class LanguageEnglish:
        language = 'en'

        Action_OpenChat = 'Open'
        Action_ReadChat = 'Read'
        Action_Reply = 'Reply'
        Action_Reaction = 'Reaction'

        NewMessage = 'New message!'

        Settings_Title = 'Settings'
        Settings_ChatType_Title = 'Chats'
        Settings_Customization_Title = 'Customization'

        Settings_Notify_All = 'All'
        Settings_Notify_Mentions = 'Mentions'
        Settings_Notify_Unmuted = 'Unmuted'
        Settings_Notify_OnlyPrivate = 'All PMs'
        Settings_Notify_Archive = 'Archive'

        Settings_ChatType_Groups = 'Groups'
        Settings_ChatType_Channels = 'Channels'
        Settings_ChatType_Private = 'Private chats'
        Settings_ChatType_Bot = 'Bots'
        Settings_ChatType_Desc = 'Perhaps there will be a choice of chats here in the futureðŸ˜‡'

        Settings_Customization_ShowOnTop = 'Show on Top'
        Settings_Customization_Duration = 'Duration'
        Settings_Customization_CustomDuration = 'Custom Duration'
        Settings_Customization_CustomDuration_Description = 'Custom Duration must be set in sec'
        Settings_Customization_Duration_Item1 = '5 sec'
        Settings_Customization_Duration_Item2 = '2.75 sec'
        Settings_Customization_Duration_Item3 = '1.5 sec'
        Settings_Customization_Duration_Item4 = 'Custom'
        Settings_Customization_MaxLines = 'Max lines'
        Settings_Customization_MaxLines_Alert = 'The number of lines should be specified as a number, not a random text!'
        Settings_Customization_MaxLines_Error = 'You set the wrong value! The default value has been returned.'
        Settings_Customization_Action = 'Action'
        Settings_Customization_Action_Item1 = 'Open'
        Settings_Customization_Action_Item2 = 'Read'
        Settings_Customization_Action_Item3 = 'Reaction'
        Settings_Customization_Vibrator = 'Vibration'
        Settings_Customization_Vibrator_Description = 'May work incorrectly or not work at all.'
        Settings_Customization_IgnoreSystemNotifications = 'Ignore system notifications'
        Settings_Customization_IgnoreSystemNotifications_Description = 'Works only while you are inside the application.'
        Settings_Customization_CurrentAccountOnly = "Current account only"
        Settings_Customization_CurrentAccountOnly_Description = "Notifications will be received only from the current account, ignoring all other accounts"
        Settings_Customization_ShowTopics = "Show topic name"
        Settings_Customization_BlurAnimation = 'Blur animation'
        Settings_Customization_VibratorPower = 'Vibration power'
        Settings_Customization_VibratorPower_Item1 = 'Low'
        Settings_Customization_VibratorPower_Item2 = 'Mid'
        Settings_Customization_VibratorPower_Item3 = 'High'

        Settings_Unknown = 'Unknown'


class NotificationsHook(MethodHook):
    def __init__(self, plugin: BasePlugin):
        self.plugin: BasePlugin = plugin

    def set_plugin(self, plugin: BasePlugin):
        self.plugin = plugin

    def _get_max_lines(self) -> int:
        max_lines: str = self.plugin.get_setting('notification_lines', '1')
        if max_lines.isdigit():
            return int(max_lines) if int(max_lines) > 0 else 1
        else:
            self.plugin.set_setting('notification_lines', '1', True)
            return 1

    def _is_settings_true(self, dialog_id: int, message_object) -> bool:
        mc = get_messages_controller()
        current_user = get_user_config().getCurrentUser()
        notify_mentions = self.plugin.get_setting('notify_mentions', True)
        notify_unmuted = self.plugin.get_setting('notify_unmuted', True)
        notify_only_private = self.plugin.get_setting('notify_only_private', True)
        notify_archive = self.plugin.get_setting('notify_archive', True)

        is_true = False

        if notify_unmuted and not is_true:
            is_true = not mc.isDialogMuted(dialog_id, message_object.getTopicId())

        if notify_mentions:
            username: str = get_user_config().getInstance(message_object.currentAccount).getCurrentUser().username
            is_text_mention = f'@{username}' in str(message_object.messageText)
            if not is_text_mention:
                if not hasattr(message_object.messageOwner, "reply_to"):
                    return is_true

                if hasattr(message_object.messageOwner.reply_to, "reply_to_msg_id"):
                    if message_object.messageOwner.reply_to.reply_to_msg_id is not None and not 0:
                        reply = get_messages_storage().getMessage(dialog_id, message_object.messageOwner.reply_to.reply_to_msg_id)
                        if reply is not None and not is_true:
                            is_true = get_id_from_peer(reply.from_id) == current_user.id
            else:
                is_true = True

        if notify_only_private and not is_true:
            is_true = mc.getUser(dialog_id) is not None

        if notify_archive:
            dialog = mc.getDialog(dialog_id if dialog_id > 0 else -dialog_id)
            if dialog is not None:
                if dialog.folder_id == 1 and notify_archive and not is_true:
                    is_true = True

        return is_true

    def _get_duration(self) -> int:
        duration_type: int = self.plugin.get_setting('notification_duration', 0)
        duration: float = 0
        custom_duration = self.plugin.get_setting('notification_duration_custom', '5')

        short: float = 1.5
        long: float = 2.75
        very_long: float = 5

        if duration_type == 2:
            duration = very_long
        elif duration_type == 1:
            duration = long
        elif duration_type == 0:
            duration = short
        elif duration_type == 3:
            duration = int(custom_duration) if isinstance(custom_duration, int) else very_long

        return int(duration * 1000)

    def _vibrate(self):
        if self.plugin.get_setting('vibrator', True):
            VibratorUtils.vibrate(get_vibrator_power(self.plugin.get_setting('vibrator_power', 0)))

    def _is_not_current_account_only(self) -> bool:
        return get_user_config().getActivatedAccountsCount() > 1 and not self.plugin.get_setting('current_account_only', True)

    def show_bulletin_with_photo(self, tl_object, title: str, message: MessageObject, sender_name: str, topic_name: str | None = None):
        try:
            if tl_object is None:
                return

            if not isinstance(tl_object, TLRPC.User) and not isinstance(tl_object, TLRPC.Chat):
                return

            fragment = get_last_fragment()
            context = fragment.getContext()
            resource_provider = fragment.getResourceProvider()
            on_click = OnNotifyClickListener(message.getDialogId(), message.currentAccount, message.getTopicId(), message.getId())

            max_lines: int = self._get_max_lines()
            blur_animation: bool = self.plugin.get_setting('blur_animation', True)
            duration: int = self._get_duration()
            top: bool = self.plugin.get_setting('notification_position', True)
            action_id: int = self.plugin.get_setting('button_action', 0)
            show_topics: bool = self.plugin.get_setting('show_topics', True)
            formatted_sender_name: str = f'{sender_name}: ' if len(sender_name) > 0 and sender_name != title else ''

            if show_topics and (topic_name is not None and topic_name != ""):
                formatted_sender_name = f'#{topic_name}\n{formatted_sender_name}'
                max_lines += 1

            text: str = formatted_sender_name + str(message.messageText)
            shift = len(formatted_sender_name)
            java_list = ArrayList()

            if hasattr(message, 'getEntities'):
                entities = list(message.getEntities().toArray())
                for e in entities:
                    e.offset += shift
                    java_list.add(e)

            layout = (
                create_chats_bulletin([tl_object], title, text) if isinstance(tl_object, TLRPC.Chat)
                else create_users_bulletin([tl_object], title, text)
            )

            ssb = MessageObject.replaceAnimatedEmoji(text, java_list, layout.subtitleView.getPaint().getFontMetricsInt())

            # is_forum = isinstance(tl_object, TLRPC.Chat) and ChatObject.isForum(tl_object)
            # layout.avatarsImageView.getImageReceiver().setRoundRadius(ExteraConfig.getAvatarCorners(29, False, is_forum))

            layout.setOnClickListener(on_click)

            layout.textView.setText(title)
            layout.textView.setSingleLine(True)
            layout.textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
            layout.textView.setMaxLines(1)
            layout.textView.setEllipsize(TextUtils.TruncateAt.END)
            layout.textView.setTypeface(AndroidUtilities.bold())
            layout.textView.setOnClickListener(on_click)

            layout.subtitleView.setText(ssb if ssb is not None else locale.NewMessage)
            layout.subtitleView.setSingleLine(max_lines == 1)
            layout.subtitleView.setMaxLines(max_lines)
            layout.subtitleView.setEllipsize(TextUtils.TruncateAt.END)
            layout.subtitleView.setTextColor(Theme.getColor(Theme.key_chats_message))
            layout.subtitleView.setOnClickListener(on_click)

            button = Bulletin.UndoButton(context, True, resource_provider)
            button.removeView(button.undoTextView)
            button.undoTextView = None

            undoCancelColor = Theme.getColor(Theme.key_undo_cancelColor)
            button.undoTextView = LinkSpanDrawable.LinksTextView(context)
            button.undoTextView.setBackground(Theme.createSelectorDrawable((undoCancelColor & 0x00ffffff) | 0x19000000, 7))
            button.undoTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            button.undoTextView.setTypeface(AndroidUtilities.bold())
            button.undoTextView.setTextColor(undoCancelColor)
            button.undoTextView.setGravity(16)
            ViewHelper.setPaddingRelative(button.undoTextView, 12, 8, 12, 8)
            button.addView(button.undoTextView, LayoutHelper.createFrameRelatively(-2, -2, 16, 8, 0, 8, 0))
            button.setUndoAction(Runnable1(lambda _: invoke_action(action_id, message)))

            if action_id == 0:
                action_text = locale.Action_OpenChat
            elif action_id == 1:
                action_text = locale.Action_ReadChat
            elif action_id == 2:
                reaction = get_double_tap_reaction(message)
                action_text = reaction.toCharSequence(button.undoTextView.getPaint().getFontMetricsInt())
            else:
                action_text = locale.Settings_Unknown

            button.undoTextView.setText(action_text)
            layout.setButton(button)

            factory = BulletinFactory.of(fragment)
            bulletin = factory.create(layout, duration)

            if blur_animation:
                bulletin.allowBlur()

            run_on_ui_thread(lambda: bulletin.show(top))
        except:
            import traceback
            err = str(traceback.format_exc())
            BulletinHelper.show_with_button(
                f"[{__name__}] Error",
                R.raw.error,
                "copy",
                lambda: AndroidUtilities.addToClipboard(err)
            )

    @hook_filters(HookFilter.Condition("param.args[0] == org.telegram.messenger.NotificationCenter.didReceiveNewMessages"))
    def after_hooked_method(self, param):
        try:
            if param.args[0] == NotificationCenter.didReceiveNewMessages:
                self.handle_new_message(param)
            elif param.args[0] == NotificationCenter.didStartedCall:
                self.handle_new_call(param)
            else:
                logcat(f'Unknown id {param.args[0]}')
        except:
            import traceback
            err = str(traceback.format_exc())
            BulletinHelper.show_with_button(
                f"[{__name__}] Error",
                R.raw.error,
                "copy",
                lambda : AndroidUtilities.addToClipboard(err)
            )

    def handle_new_message(self, param):
        args = get_list(param.args[1])
        dialog_id: int = args[0]
        java_messages_list = args[1]

        last_fragment = get_last_fragment()
        if isinstance(last_fragment, ChatActivity):
            if last_fragment.getDialogId() == dialog_id:
                return

        if java_messages_list.size() > 0:
            message_object = java_messages_list.get(0)
            message_text: str = str(message_object.messageText)

            mc = get_messages_controller2(message_object.currentAccount)
            uc = get_user_config().getInstance(message_object.currentAccount)

            if self.plugin.get_setting('current_account_only', True):
                if message_object.currentAccount != uc.getProductionAccount():
                    return

            current_user = uc.getCurrentUser()
            from_id = message_object.getFromChatId()
            chat_id = message_object.getDialogId()

            if not from_id is None or not 0:
                if from_id == current_user.id:
                    return

            if chat_id < 0:
                chat = mc.getChat(-chat_id)
                if (hasattr(chat, 'kicked') and chat.kicked) or (hasattr(chat, 'left') and chat.left) or (
                        hasattr(chat, 'deactivated') and chat.deactivated):
                    return

            notify_all: bool = self.plugin.get_setting('notify_all', False)
            if notify_all:
                pass
            else:
                if not self._is_settings_true(dialog_id, message_object):
                    return

            source_group: bool = self.plugin.get_setting('source_0', True)
            source_channel: bool = self.plugin.get_setting('source_1', True)
            source_private: bool = self.plugin.get_setting('source_2', True)
            source_bot: bool = self.plugin.get_setting('source_3', True)
            show_topic: bool = self.plugin.get_setting('show_topics', True)

            title: str = ''
            if self._is_not_current_account_only():
                title += uc.getCurrentUser().first_name + ' â†’ '

            if chat_id < 0:
                chat = mc.getChat(-chat_id)
                if chat is None:
                    BulletinHelper.show_error(f'Chat {-chat_id} is none')
                    return

                if message_object.isFromChat() or is_channel(chat):
                    if is_channel(chat) and not source_channel:
                        return

                    if not source_group:
                        return

                    sender_name = get_chat_title(from_id, chat_id, message_object.currentAccount)
                    title += chat.title
                    topic_title: str | None = None

                    if ChatObject.isForum(chat) and show_topic:
                        topic = mc.getTopicsController().findTopic(-dialog_id, message_object.getTopicId())
                        if topic is not None:
                            topic_title = topic.title

                    self.show_bulletin_with_photo(
                        chat,
                        title,
                        message_object,
                        sender_name,
                        topic_title
                    )
            else:
                if not source_private:
                    return

                user = mc.getUser(chat_id)
                if user is None:
                    BulletinHelper.show_error(f'User {chat_id} is none')
                    return

                topic_title: str | None = None

                if hasattr(user, 'bot'):
                    if user.bot:
                        if not source_bot:
                            return

                        if user.bot_forum_view and show_topic:
                            topic = mc.getTopicsController().findTopic(dialog_id, message_object.getTopicId())
                            if topic is not None:
                                topic_title = topic.title

                title += user.first_name if user is not None else locale.NewMessage

                self.show_bulletin_with_photo(
                    user,
                    title,
                    message_object,
                    '',
                    topic_title
                )

            self._vibrate()
        else:
            logcat("Message list is empty")

    def handle_new_call(self, param):
        logcat("param")


class NotificationManagerHook(MethodReplacement):
    def replace_hooked_method(self, param) -> Any:
        param.setResult(None)
        return


locale = LocaleController().get_controller()


def can_use_vibrator() -> bool:
    from org.telegram.messenger import ApplicationLoader #type: ignore
    vibrator = ApplicationLoader.applicationContext.getSystemService('vibrator')
    return ExteraConfig.inAppVibration and vibrator.hasVibrator


def get_vibrator_power(vibrator_power_item: int) -> int:
    if vibrator_power_item == 0:
        return 10
    elif vibrator_power_item == 1:
        return 50
    elif vibrator_power_item == 2:
        return 100
    else:
        return 10


class InAppNotificationsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hooks = []
        self.notification_hook: NotificationsHook | None = None

    def on_plugin_load(self) -> None:
        self._setup_hooks()
        if not self.notification_hook is None:
            self.notification_hook.set_plugin(self)

    def on_plugin_unload(self) -> None:
        self._unhook_all()

    def create_settings(self) -> list[Any]:
        is_all_notify = self.get_setting('notify_all', False)
        source_pm = self.get_setting('source_2', True)
        duration = self.get_setting('notification_duration', 0)
        return [
            Header(locale.Settings_Title),
            Switch(
                key="notify_all",
                text=locale.Settings_Notify_All,
                default=False,
                icon='msg_notifications',
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ),
            Switch(
                key="notify_mentions",
                text=locale.Settings_Notify_Mentions,
                default=True,
                icon='msg_mention',
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ) if not is_all_notify else None,
            Switch(
                key="notify_unmuted",
                text=locale.Settings_Notify_Unmuted,
                default=True,
                icon='msg_unmute',
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ) if not is_all_notify else None,
            Switch(
                key="notify_only_private",
                text=locale.Settings_Notify_OnlyPrivate,
                default=True,
                icon='msg_contacts',
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ) if not is_all_notify and source_pm else None,
            Switch(
                key="notify_archive",
                text=locale.Settings_Notify_Archive,
                default=True,
                icon='msg_archive',
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ) if not is_all_notify and source_pm else None,

            Divider(),
            Header(locale.Settings_ChatType_Title),
            Switch(
                key=f"source_0",
                text=locale.Settings_ChatType_Groups,
                default=True,
                icon='msg_groups',
                on_change=self.notification_hook.set_plugin(self)
            ),
            Switch(
                key=f"source_1",
                text=locale.Settings_ChatType_Channels,
                default=True,
                icon='msg_channel',
                on_change=self.notification_hook.set_plugin(self)
            ),
            Switch(
                key=f"source_2",
                text=locale.Settings_ChatType_Private,
                default=True,
                icon='msg_contacts',
                on_change=self.notification_hook.set_plugin(self)
            ),
            Switch(
                key=f"source_3",
                text=locale.Settings_ChatType_Bot,
                default=True,
                icon='msg_bot',
                on_change=self.notification_hook.set_plugin(self)
            ),

            Divider(),
            Header(locale.Settings_Customization_Title),
            Switch(
                key="notification_position",
                text=locale.Settings_Customization_ShowOnTop,
                default=True,
                on_change=lambda new_value: self.show_preview_bulletin(new_value, self.get_setting('blur_animation', True)),
                icon='msg_background'
            ),
            Selector(
                key='notification_duration',
                text=locale.Settings_Customization_Duration,
                default=0,
                items=[
                    locale.Settings_Customization_Duration_Item3,
                    locale.Settings_Customization_Duration_Item2,
                    locale.Settings_Customization_Duration_Item1,
                    locale.Settings_Customization_Duration_Item4
                ],
                icon='msg_stories_timer',
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ),
            Input(
                key='notification_duration_custom',
                text=locale.Settings_Customization_CustomDuration,
                subtext=locale.Settings_Customization_CustomDuration_Description,
                default='5',
                on_change=lambda new_value: self.is_new_max_lines_correct('notification_duration_custom', '5000', new_value)
            ) if duration == 3 else None,
            Input(
                key='notification_lines',
                text=locale.Settings_Customization_MaxLines,
                subtext=locale.Settings_Customization_MaxLines_Alert,
                default='2',
                icon='menu_intro',
                on_change=lambda new_value: self.is_new_max_lines_correct('notification_lines', '1', new_value)
            ),
            Selector(
                key='button_action',
                text=locale.Settings_Customization_Action,
                icon='msg_actions',
                default=0,
                items=[
                    locale.Settings_Customization_Action_Item1,
                    locale.Settings_Customization_Action_Item2,
                    locale.Settings_Customization_Action_Item3
                ],
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ),
            Switch(
                key='vibrator',
                text=locale.Settings_Customization_Vibrator,
                subtext=locale.Settings_Customization_Vibrator_Description,
                icon='msg2_call_earpiece',
                default=True,
                on_change=lambda new_value: self.preview_vibrator()
            ) if can_use_vibrator() else None,
            Selector(
                key='vibrator_power',
                text=locale.Settings_Customization_VibratorPower,
                icon='msg_settings',
                items=[
                    locale.Settings_Customization_VibratorPower_Item1,
                    locale.Settings_Customization_VibratorPower_Item2,
                    locale.Settings_Customization_VibratorPower_Item3
                ],
                default=0,
                on_change=lambda _: self.preview_vibrator()
            ) if can_use_vibrator() and self.get_setting('vibrator', True) else None,
            Switch(
                key='ignore_system_notifications',
                text=locale.Settings_Customization_IgnoreSystemNotifications,
                subtext=locale.Settings_Customization_IgnoreSystemNotifications_Description,
                icon='msg_notifications',
                default=True,
                on_change=lambda _: self.update_system_notifications()
            ),
            Switch(
                key='current_account_only',
                text=locale.Settings_Customization_CurrentAccountOnly,
                subtext=locale.Settings_Customization_CurrentAccountOnly_Description,
                icon='msg_report_personal',
                default=True,
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ) if get_user_config().getActivatedAccountsCount() > 1 else None,
            Switch(
                key='show_topics',
                text=locale.Settings_Customization_ShowTopics,
                icon='msg_topics',
                default=True,
                on_change=lambda _: self.notification_hook.set_plugin(self)
            ),
            Switch(
                key='blur_animation',
                text=locale.Settings_Customization_BlurAnimation,
                icon='msg2_animations',
                default=True,
                on_change=lambda new_value: self.notification_hook.set_plugin(self)
            )
        ]

    def on_app_event(self, event_type: AppEvent):
        logcat(f'new app event {event_type}')
        if event_type == AppEvent.STOP or event_type == AppEvent.PAUSE:
            logcat('join')
            self._unhook_all()
            logcat('stop')
        elif event_type == AppEvent.START or event_type == AppEvent.RESUME:
            self._setup_hooks()

    def _setup_hooks(self):
        try:
            if self.hooks is None:
                self.hooks = []

            notification_center_clazz = jclass("org.telegram.messenger.NotificationCenter").getClass()
            if notification_center_clazz is None:
                logcat('Clazz not found')
                return

            post_notification_name = notification_center_clazz.getDeclaredMethod(
                "postNotificationName",
                Integer.TYPE,
                Array.newInstance(Object, 0).getClass()
            )

            if post_notification_name is not None:
                post_notification_name.setAccessible(True)
                self.notification_hook = NotificationsHook(self)
                self.hooks.append(self.hook_method(post_notification_name, self.notification_hook))
            else:
                BulletinHelper.show_error(f'[{__name__}] Failed to hook methods')
                return

            if self.get_setting('ignore_system_notifications', True):
                notification_manager_clazz = find_class("androidx.core.app.NotificationManagerCompat")
                notification_manager = find_class("android.app.NotificationManager")

                notify1 = self.hook_all_methods(notification_manager, "notify", NotificationManagerHook())
                notify2 = self.hook_all_methods(notification_manager_clazz, 'notify', NotificationManagerHook())

                self.hooks.append(notify1)
                self.hooks.append(notify2)

            logcat('hooking notify')
        except Exception as e:
            import traceback
            logcat(traceback.format_exc())

    def _unhook_all(self):
        try:
            if self.hooks is not None and len(self.hooks) > 0:
                for h in self.hooks:
                    if isinstance(h, list):
                        for i in h:
                            self.unhook_method(i)
                    else:
                        self.unhook_method(h)

            self.hooks = None
            self.notification_hook = None
        except Exception as e:
            import traceback
            logcat(traceback.format_exc())

    def is_new_max_lines_correct(self, key: str, default_value: Any, new_value: str):
        if new_value.isdigit():
            if int(new_value) <= 0:
                BulletinHelper.show_error(locale.Settings_Customization_MaxLines_Error)
                self.set_setting(key, default_value, True)
        else:
            BulletinHelper.show_error(locale.Settings_Customization_MaxLines_Error)
            self.set_setting(key, default_value, True)

        self.notification_hook.set_plugin(self)

    def show_preview_bulletin(self, top: bool, blur_animation: bool):
        show_bulletin("This is new position for bulletin!", "â˜ƒï¸", top, blur_animation)
        self.notification_hook.set_plugin(self)

    def preview_vibrator(self):
        VibratorUtils.vibrate(get_vibrator_power(self.get_setting('vibrator_power', 0)))
        self.notification_hook.set_plugin(self)

    def update_system_notifications(self):
        self._unhook_all()
        self._setup_hooks()
        self.notification_hook.set_plugin(self)