'''‚†Ä‚†Ä‚†Ä
–£–∂ –µ—Å–ª–∏ —Ç—ã –∏ —é–Ω—ã–π –ø–∞—Å—Ç–µ—Ä–æ–∫ , —Ç–æ —Ö–æ—Ç—è –±—ã –∏—Å—Ç–æ—á–Ω–∏–∫ —É–∫–∞–∑—ã–≤–∞–π –æ—Ç–∫—É–¥–∞ –ø–∞—Å—Ç–∏–ª :)
–í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ: @KangelPlugins & @MGEPlugins
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚£†‚£¥‚£Ø‚£´‚°á‚£Ä‚†ñ‚°∂‚†ä‚†Å‚†Ä‚†Ä‚†à‚†í‚¢§‚°Ä‚†Ä‚£¥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†ä‚¢ê‚†É‚°á‚°é‚£ø‚°ó‚†Ä‚†à‚†Ä‚†í‚¢ò‚†Ä‚¢±‚†ê‚°á‚†ê‚†â‚¢≤‚£ø‚£á‚£©‚¢ñ‚†¢‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ü‚†Ä‚°ç‚¢∏‚¢Ä‚¢∞‚£ø‚¢á‚†î‚†Ä‚°Ñ‚†Ä‚†à‚†Ñ‚†î‚¢â‚£ê‚†≤‚°Ä‚¢Ä‚£ø‚£∑‚†Ä‚†ò‚¢ì‚†à‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚£á‚°á‚°ò‚£æ‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚°ã‚¢∑‚†ì‚°è‚¢º‚£ø‚†Ä‚°Ä‚¢á‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ü‚†Ä‚£ø‚¢†‚¢°‚†ù‚†Ä‚†Ä‚¢Ä‚£æ‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†õ‚†ã‚£â‚°ô‚†õ‚¢ª‚†Ä‚¢§‚£û‚†Ä‚°∏‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚°Ä‚£á‚¢Ü‚£æ‚°è‚†Ä‚¢†‚£º‚£Ä‚£µ‚£Ñ‚¢Ä‚†Ä‚°Ñ‚¢†‚†Ä‚¢†‚£è‚¢∏‚†ö‚°û‚¢π‚°∏‚¢Å‚†¥‚†Å‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚£µ‚£ø‚°ç‚¢≥‚¢∂‚¢Ø‚°ü‚¢â‚°õ‚†£‚†Ä‚†Å‚†â‚†â‚¢â‚£â‚°ø‚†æ‚¢ª‚°£‚†æ‚°á‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚¢ø‚¢ã‚°Ä‚†ö‚£ä‚†û‚°•‚†∏‚¢Ä‚†à‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†õ‚†ã‚°á‚£†‚£∏‚£Ä‚¢Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚†ö‚†Å‚°á‚†Ä‚†à‚¢Ü‚¢Ä‚†§‚°ã‚†â‚°á‚¢π‚¢ü‚†Å‚†Ä‚¢†‚£†‚°Ä‚†Ä‚†Ä‚£†‚†û‚°á‚¢Ä‚£ß‚†õ‚¢Ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚†ä‚†Ä‚†Ä‚†Ä‚†ò‚¢Ñ‚£†‚°•‚¢è‚†Ä‚¢±‚†Ä‚†ô‚£ú‚£Ü‚£π‚£Ñ‚°à‚†õ‚£Å‚†¥‚†ö‚†Å‚¢∏‚†Å‚°û‚†∞‚†Ä‚†Ä‚†ô‚¢ø‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚°†‚†ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚°á‚†Ä‚¢∏‚†Ä‚¢∏‚†Ä‚¢Ä‚£®‚¢Ø‚†ø‚†õ‚†â‚†â‚¢ß‚£Ä‚°Ä‚£Ä‚£û‚°º‚¢ë‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£Ω‚¢≤‚°Ñ‚†Ä‚†Ä
‚†Ä‚¢Ä‚†ú‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚††‚£í‚†ù‚†ã‚†Ä‚£†‚£æ‚†§‚†ú‚†ö‚†â‚†Ä‚†π‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚£ß‚†â‚†ô‚¢¶‚¢§‚°Ä‚¢Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£æ‚£ó‚°Ñ
‚†Ä‚°ú‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚°æ‚†Å‚¢Ä‚†≤‚†â‚†â‚¢á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ß‚†Ä‚†≤‚†Ä‚¢†‚†É‚†Ä‚†Ä‚¢Ä‚°à‚†®‚¢ª‚¢Ü‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°ø‚¢∏
‚†ú‚†Ä‚†Ä‚†Ä‚†ê‚†æ‚°©‚†ô‚†£‚°Ä‚†ê‚†Ä‚†Ç‚†Ä‚†Ä‚†±‚£Ñ‚†Ä‚††‚†Ä‚†Ä‚†ò‚°Ñ‚†Ä‚¢Ä‚¢∏‚†Ä‚†Ä‚†∞‚°ª‚£å‚†ñ‚†Å‚†Ä‚†ë‚¢Ñ‚†Ä‚†Ä‚†Ä‚¢Ä‚°§‚†É‚°û
‚¢Ü‚°†‚††‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢Ç‚°Ä‚†Ä‚†Ä‚†Ä‚£Ñ‚†à‚†≥‚£Ñ‚†â‚†Ç‚°Ä‚¢±‚†Ä‚†Ä‚°∏‚¢Ä‚£æ‚£ó‚°û‚†Å‚†Ä‚†Ä‚†ê‚†Å‚†à‚†≥‚£Ä‚°¥‚†ã‚¢Ä‚°û‚†Ä
‚£†‚†û‚£ì‚†∂‚†í‚†Ç‚†¨‚£ç‚£Ç‚£†‚¢§‚†§‚†Å‚†Ñ‚¢ê‚°è‚†Ä‚¢†‚†í‚†ì‚†¢‚°Ä‚†¢‚¢Å‚¢Ä‚°Ø‚¢à‚†Ω‚†ç‚†Å‚¢Ñ‚†Ä‚†∏‚†Å‚†Ä‚††‚†Ä‚†â‚°≥‚£¥‚†Ø‚£Ä‚†Ä
'''
from ui.settings import Header, Input, Switch, Selector, Divider, Text
from base_plugin import BasePlugin, HookResult, HookStrategy
import json
import requests
from java.util import Locale, ArrayList
from markdown_utils import parse_markdown
import time
import threading
from org.telegram.ui.ActionBar import AlertDialog
from client_utils import send_message, get_last_fragment, get_send_messages_helper, get_messages_controller, get_user_config, send_request
from android_utils import log
from java.io import File
from org.telegram.messenger import ApplicationLoader, R as R_tg
from org.telegram.tgnet.tl import TL_account
from org.telegram.tgnet import TLRPC
from ui.bulletin import BulletinHelper
import os
import uuid
from typing import Optional
import io
from PIL import Image, ImageDraw, ImageFont, ImageFilter
from ui.alert import AlertDialogBuilder
from android.os import Build
from android.content import Context
from android.app import Notification, NotificationManager, NotificationChannel
from android.graphics import Color


class SteamAPI:
    def __init__(self, api_key: str, steam_id: str):
        self.api_key = api_key
        self.steam_id = steam_id
        self.base_url = "https://api.steampowered.com"
        self.session = requests.Session()
        self.session.timeout = 15

    def _make_request(self, endpoint: str, params: dict = None) -> dict:
        if params is None:
            params = {}
            
        params['key'] = self.api_key
        if 'steamid' not in params:
            params['steamid'] = self.steam_id

        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                response = self.session.get(
                    f"{self.base_url}/{endpoint}",
                    params=params,
                    timeout=15
                )
                response.raise_for_status()
                return response.json()
                
            except requests.exceptions.RequestException as e:
                log(f"[SteamAPI] Request failed (attempt {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                raise

    def get_player_summary(self) -> dict:
        return self._make_request("ISteamUser/GetPlayerSummaries/v0002/", {
            'steamids': self.steam_id
        })

    def get_recent_games(self) -> dict:
        return self._make_request("IPlayerService/GetRecentlyPlayedGames/v0001/")

    def get_owned_games(self) -> dict:

        return self._make_request("IPlayerService/GetOwnedGames/v0001/", {
            'include_appinfo': 1,
            'include_played_free_games': 1
        })

    def get_game_details(self, app_id: int) -> dict:
        try:
            response = self.session.get(
                "https://store.steampowered.com/api/appdetails",
                params={
                    'appids': app_id,
                    'l': 'russian'
                },
                timeout=15
            )
            response.raise_for_status()
            data = response.json()
            return data.get(str(app_id), {}).get('data', {})
        except Exception as e:
            log(f"[SteamAPI] Error getting game details: {e}")
            return {}


__id__ = "steam"
__name__ = "Steam"
__version__ = "1.6.0"
__description__ = "üéÆ Shows the current game on Steam\n\nüìã Commands:\n‚Ä¢ [.nowsteam/.snp] ‚Äî current game\n‚Ä¢ [.slibrary] ‚Äî games library\n‚Ä¢ [.sflibrary] ‚Äî full library\n\nüé® Design by @reNightly, @qmrrchh"
__author__ = "@KangelPlugins & @MGEPlugins"
__min_version__ = "11.12.0"
__icon__ = "Kangelcons_by_fStikBot/0"
__load__ = True

FONTS = {
    "NotoSansJP": "https://github.com/itsNightly/font_link/raw/refs/heads/main/NotoSansJP-Regular.ttf",
    "Zpix": "https://github.com/Ar4ikTrirtyFour/windose20/raw/refs/heads/main/fonts/zpix.ttf",
    "Impact": "https://github.com/localizator/ukrainian-fonts-pack/raw/refs/heads/master/TimesNRCyrMT-Bold%20-%20Times%20New%20Roman%20Cyr%20-%20Bold.ttf"
}

class Locales:
    default = {
        "settings_main_header": "‚öôÔ∏è Basic Settings",
        "settings_steam_id": "Steam ID",
        "settings_steam_id_subtext": "Enter your Steam ID",
        "settings_api_key": "Steam API Key",
        "settings_api_key_subtext": "Get it at: https://steamcommunity.com/dev/apikey",
        "settings_auto_update_header": "üéÆ Profile Auto-Update",
        "settings_enable_auto": "Enable auto-update",
        "settings_enable_auto_subtext": "Automatically updates profile with game info",
        "settings_check_interval": "Check interval (seconds)",
        "settings_check_interval_subtext": "How often to check game status",
        "settings_update_location": "Update location",
        "settings_update_location_items": ["About", "Location (Premium)"],
        "settings_text_template": "Text template",
        "settings_text_template_subtext": "Use {game} for game name",
        "settings_default_text": "Default text",
        "settings_default_text_subtext": "Shown when no game is running",
        "settings_sort_by_playtime": "Sort by playtime",
        "settings_sort_by_playtime_subtext": "If disabled, sorts by last played date",
        "settings_usage_divider": "Usage: .nowsteam",
        "card_settings_header": "üñºÔ∏è Card settings",
        "card_text_format": "Card text format",
        "card_text_format_subtext": "Use {nick} and {game}",
        "card_font_family": "Card font",
        "settings_show_card_authors": "Show authors credit on card",
        "settings_show_card_authors_subtext": "Adds 'Plugin by @KangelPlugins & @MGEPlugins' footer",
        "settings_icon_style": "Icon style",
        "settings_icon_style_items": ["Standard", "Needy Streamer Overload"],
        "custom_font_link": "Custom font link",
        "custom_font_link_subtext": "Direct link to .ttf file",
        "custom_font_help_title": "How to use custom fonts",
        "library_settings_header": "üìö Library settings",
        "error_steam_id_not_set": "First set up your Steam ID in plugin settings!",
        "error_api_key_not_set": "First set up your API key in plugin settings!",
        "error_steam_id_not_found": "Steam ID not found or profile is hidden",
        "error_invalid_api_key": "Invalid API key. Get a new key at https://steamcommunity.com/dev/apikey",
        "error_network": "Network error! Check your internet connection",
        "error_api": "Error: Invalid response from Steam API",
        "error_unknown": "Error: {e}",
        "error_invalid_steam_id": "‚ùå Error: Invalid Steam ID",
        "error_api_key_missing": "‚ùå Error: API key is missing",
        "error_api_code": "‚ùå API Error: {code}",
        "error_invalid_response": "‚ùå Error: Invalid response from Steam API",
        "error_private_profile": "‚ùå Error: Unable to get games list. Check your profile privacy settings.",
        "error_network_generic": "‚ùå Network error: {e}",
        "error_json_parse": "‚ùå JSON parse error: {e}",
        "error_unknown_generic": "‚ùå Unknown error: {e}",
        "failed_to_load_library": "‚ùå An error occurred while loading the library. Please check logs.",
        "searching": "Searching...",
        "loading_library": "üîç Loading game list...",
        "library_empty": "üìö Your game library is empty",
        "library_header": "Library of Steam games",
        "full_library_header": "Full Steam library",
        "total_games_and_time": "Total games: {count} | Total time: {hours}h",
        "sorting_label": "Sorting:",
        "sort_by_hours_text": "By playtime (descending)",
        "sort_by_last_played_text": "By last played date",
        "btn_sort_by_hours": "üïí By playtime",
        "btn_sort_by_last_played": "üìÖ By last played date",
        "last_played_suffix": " (last played: {date})",
        "duration_compact_hm": "{hours}h {minutes}m",
        "duration_compact_m": "{minutes}m",
        "and_more_games": "...and {count} more games",
        "stream_alert_title": "‚ö†Ô∏è‚ö†Ô∏èWARNING‚ö†Ô∏è‚ö†Ô∏è",
        "stream_alert_message": "This feature may work inconsistently due to Telegram's profile change limits. Your profile information may not update immediately. Use at your own risk.",
        "not_playing": "Not playing anything...",
        "playing_format": "**Currently playing:** {game}",
        "developers": "**Developers:** {developers}",
        "publishers": "**Publishers:** {publishers}",
        "metacritic": "**Metacritic Score:** {score}/100",
        "genres": "**Genres:** {genres}",
        "playtime": "**Playtime:** {hours} hrs. {minutes} min.",
        "playtime_minutes": "**Playtime:** {minutes} min.",
        "game_link": "[Game Link]({url})",
        "font_faq_title": "üé® How to use custom fonts",
        "font_faq_text": (
            "üìù How to add a custom font?\n\n"
            "1Ô∏è‚É£ Select 'Custom font' in the font selector\n\n"
            "2Ô∏è‚É£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
            "üîó Example links:\n"
            "‚Ä¢ https://example.com/font.ttf\n"
            "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "üí° AND THERE MUST BE .ttf AT THE END\n\n"
            "3Ô∏è‚É£ Create a card with .nowsteam command\n\n"
            "‚ö° The plugin will automatically download the font and use it!\n\n"
            "üö® IMPORTANT! ON FIRST USE/FONT CHANGE, IT WILL TAKE LONGER TO CREATE THAN USUAL\n\n"
            "üíª The author recommends uploading fonts to Github\n\n"
            "üåê Sites where you can find fonts (with direct links):\n"
            "‚Ä¢ https://fontsaddict.com\n\n"
            "‚Ä¢ https://en.bestfonts.pro\n\n"
        ),
        "alert_close_button": "‚úÖ Got it",
        "settings_enable_live_updates": "Show game notifications",
        "settings_enable_live_updates_subtext": "Display Live Updates when entering a game (Android 16+ only)",
    }
    en = default
    ru = {
        "settings_main_header": "‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings_steam_id": "Steam ID",
        "settings_steam_id_subtext": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Steam ID",
        "settings_api_key": "Steam API Key",
        "settings_api_key_subtext": "–ü–æ–ª—É—á–∏—Ç—å: https://steamcommunity.com/dev/apikey",
        "settings_auto_update_header": "üéÆ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è",
        "settings_enable_auto": "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
        "settings_enable_auto_subtext": "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∏–≥—Ä–µ",
        "settings_check_interval": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ (—Å–µ–∫—É–Ω–¥—ã)",
        "settings_check_interval_subtext": "–ö–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å—Ç–∞—Ç—É—Å –∏–≥—Ä—ã",
        "settings_update_location": "–ú–µ—Å—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è",
        "settings_update_location_items": ["–û —Å–µ–±–µ", "–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è (–ü—Ä–µ–º–∏—É–º)"],
        "settings_text_template": "–®–∞–±–ª–æ–Ω —Ç–µ–∫—Å—Ç–∞",
        "settings_text_template_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {game} –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è –∏–≥—Ä—ã",
        "settings_default_text": "–¢–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings_default_text_subtext": "–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞",
        "settings_sort_by_playtime": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã",
        "settings_sort_by_playtime_subtext": "–ï—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ, —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç –ø–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "settings_usage_divider": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .nowsteam",
        "card_settings_header": "üñºÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—Ä—Ç–æ—á–∫–∏",
        "card_text_format": "–§–æ—Ä–º–∞—Ç —Ç–µ–∫—Å—Ç–∞ –∫–∞—Ä—Ç–æ—á–∫–∏",
        "card_text_format_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {nick} –∏ {game}",
        "card_font_family": "–®—Ä–∏—Ñ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏",
        "settings_show_card_authors": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å—å –∞–≤—Ç–æ—Ä–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ",
        "settings_show_card_authors_subtext": "–î–æ–±–∞–≤–ª—è–µ—Ç —Ñ—É—Ç–µ—Ä 'Plugin by @KangelPlugins & @MGEPlugins'",
        "settings_icon_style": "–°—Ç–∏–ª—å –∏–∫–æ–Ω–æ–∫",
        "settings_icon_style_items": ["–û–±—ã—á–Ω—ã–µ", "Needy Streamer Overload"],
        "custom_font_link": "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç",
        "custom_font_link_subtext": "–°—Å—ã–ª–∫–∞ –Ω–∞ .ttf —Ñ–∞–π–ª",
        "custom_font_help_title": "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
        "library_settings_header": "üìö –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏",
        "error_steam_id_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ Steam ID –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_api_key_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ API –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_steam_id_not_found": "Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç",
        "error_invalid_api_key": "–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á. –ü–æ–ª—É—á–∏—Ç–µ –Ω–æ–≤—ã–π –∫–ª—é—á –Ω–∞ https://steamcommunity.com/dev/apikey",
        "error_network": "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É",
        "error_api": "–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API",
        "error_unknown": "–û—à–∏–±–∫–∞: {e}",
        "error_invalid_steam_id": "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π Steam ID",
        "error_api_key_missing": "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–∫–∞–∑–∞–Ω API –∫–ª—é—á",
        "error_api_code": "‚ùå –û—à–∏–±–∫–∞ API: {code}",
        "error_invalid_response": "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API",
        "error_private_profile": "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–≥—Ä. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ñ–∏–ª—è.",
        "error_network_generic": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: {e}",
        "error_json_parse": "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: {e}",
        "error_unknown_generic": "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}",
        "failed_to_load_library": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.",
        "searching": "–ò—â–µ–º –∏–≥—Ä—É...",
        "loading_library": "üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä...",
        "library_empty": "üìö –í–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞",
        "library_header": "–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä Steam",
        "full_library_header": "–ü–æ–ª–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Steam",
        "total_games_and_time": "–í—Å–µ–≥–æ –∏–≥—Ä: {count} | –û–±—â–µ–µ –≤—Ä–µ–º—è: {hours}—á",
        "sorting_label": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:",
        "sort_by_hours_text": "–ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)",
        "sort_by_last_played_text": "–ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "btn_sort_by_hours": "üïí –ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã",
        "btn_sort_by_last_played": "üìÖ –ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "last_played_suffix": " (–ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑: {date})",
        "duration_compact_hm": "{hours}—á {minutes}–º",
        "duration_compact_m": "{minutes}–º",
        "and_more_games": "...–∏ –µ—â–µ {count} –∏–≥—Ä",
        "stream_alert_title": "‚ö†Ô∏è‚ö†Ô∏è–í–ù–ò–ú–ê–ù–ò–ï‚ö†Ô∏è‚ö†Ô∏è",
        "stream_alert_message": "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Telegram –Ω–∞ —á–∞—Å—Ç—É—é —Å–º–µ–Ω—É –ø—Ä–æ—Ñ–∏–ª—è. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫.",
        "not_playing": "–°–µ–π—á–∞—Å –Ω–µ –∏–≥—Ä–∞—é –Ω–∏ –≤–æ —á—Ç–æ...",
        "playing_format": "**–°–µ–π—á–∞—Å –∏–≥—Ä–∞—é –≤:** {game}",
        "developers": "**–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏:** {developers}",
        "publishers": "**–ò–∑–¥–∞—Ç–µ–ª–∏:** {publishers}",
        "metacritic": "**–û—Ü–µ–Ω–∫–∞ Metacritic:** {score}/100",
        "genres": "**–ñ–∞–Ω—Ä—ã:** {genres}",
        "playtime": "**–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {hours} —á. {minutes} –º–∏–Ω.",
        "playtime_minutes": "**–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {minutes} –º–∏–Ω.",
        "game_link": "[–°—Å—ã–ª–∫–∞ –Ω–∞ –∏–≥—Ä—É]({url})",
        "font_faq_title": "üé® –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
        "font_faq_text": (
            "üìù –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç?\n\n"
            "1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ '–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —à—Ä–∏—Ñ—Ç–æ–≤\n\n"
            "2Ô∏è‚É£ –í –ø–æ–ª–µ '–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª\n\n"
            "üîó –ü—Ä–∏–º–µ—Ä—ã —Å—Å—ã–ª–æ–∫:\n"
            "‚Ä¢ https://example.com/font.ttf\n"
            "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "üí° –ò –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –¢–ê–ú –î–û–õ–ñ–ï–ù –ë–´–¢–¨ –í –ö–û–ù–¶–ï .ttf\n\n"
            "3Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É –∫–æ–º–∞–Ω–¥–æ–π .nowsteam\n\n"
            "‚ö° –ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞—á–∞–µ—Ç —à—Ä–∏—Ñ—Ç –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ!\n\n"
            "üö® –í–ê–ñ–ù–û! –ü–†–ò –ü–ï–†–í–û–ú –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ò/–°–ú–ï–ù–ï –®–†–ò–§–¢–ê –ë–£–î–ï–¢ –î–û–õ–¨–®–ï –°–û–ó–î–ê–í–ê–¢–¨–°–Ø –ß–ï–ú –û–ë–´–ß–ù–û\n\n"
            "üíª –ê–≤—Ç–æ—Ä —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã –Ω–∞ Github\n\n"
            "üåê –°–∞–π—Ç—ã –≥–¥–µ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ —à—Ä–∏—Ñ—Ç—ã (—Å –ø—Ä—è–º—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏):\n"
            "‚Ä¢ https://fontsaddict.com\n\n"
            "‚Ä¢ https://en.bestfonts.pro\n\n"
        ),
        "alert_close_button": "‚úÖ –ü–æ–Ω—è–ª",
        "settings_enable_live_updates": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–≥—Ä–µ",
        "settings_enable_live_updates_subtext": "–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å Live Updates –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –∏–≥—Ä—É (—Ç–æ–ª—å–∫–æ Android 16+)",
    }

def localise(key: str, **kwargs) -> str:
    lang = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, lang, Locales.default)
    text = locale_dict.get(key, key)
    return text.format(**kwargs) if kwargs else text

TEMP_DIR_NAME = "temp_steam_images"
DEFAULT_STREAM_STRING = localise("playing_format")
DEFAULT_STREAM_TEXT = localise("not_playing")
DEFAULT_CHECK_INTERVAL = 30

NO_STEAM_FALLBACK_URL = "https://raw.githubusercontent.com/ArThirtyFour/Fonts_For_Exteragram/refs/heads/main/no_steam.jpg"
progress_dialog = None
class AlertManager:
    def __init__(self):
        self.alert_builder_instance: Optional[AlertDialogBuilder] = None

    def show_info_alert(self, title: str, message: str, positive_button: str):
        last_fragment = get_last_fragment()
        if not last_fragment or not last_fragment.getParentActivity(): return
        context = last_fragment.getParentActivity()
        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.alert_builder_instance = builder
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda d, w: self.dismiss_dialog())
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def dismiss_dialog(self):
        if self.alert_builder_instance and self.alert_builder_instance.get_dialog() and self.alert_builder_instance.get_dialog().isShowing():
            self.alert_builder_instance.dismiss()
            self.alert_builder_instance = None


class SteamPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self._streamer_thread = None
        self._stop_streamer = False
        self.alert_manager = AlertManager()
        self.notification_manager: Optional[NotificationManager] = None
        self.app_context: Optional[Context] = None
        self.last_game_name: Optional[str] = None
        self.current_game_name: Optional[str] = None
        self.current_playtime_hours: int = 0
        self.last_notification_time: float = 0
        self.notification_resend_interval: int = 30
        threading.Thread(target=self._streamer, daemon=True).start()
        threading.Thread(target=self._notification_keeper, daemon=True).start()

    def _get_notification_manager(self) -> Optional[NotificationManager]:
        try:
            if not self.notification_manager:
                context = ApplicationLoader.applicationContext
                if context:
                    self.app_context = context
                    self.notification_manager = context.getSystemService(Context.NOTIFICATION_SERVICE)
                    log("[Steam] NotificationManager obtained")
                    return self.notification_manager
            return self.notification_manager
        except Exception as e:
            log(f"[Steam] Error getting NotificationManager: {e}")
            return None

    def _create_notification_channel(self):
        try:
            if Build.VERSION.SDK_INT >= 26:
                channel = NotificationChannel(
                    "steam_game_status",
                    "Steam Game Status",
                    NotificationManager.IMPORTANCE_LOW
                )
                channel.setDescription("Live updates of current game status")
                nm = self._get_notification_manager()
                if nm:
                    nm.createNotificationChannel(channel)
                    log("[Steam] Notification channel created")
        except Exception as e:
            log(f"[Steam] Error creating notification channel: {e}")

    def _show_game_notification(self, game_name: str, playtime_hours: int):
        try:
            if Build.VERSION.SDK_INT < 36:
                log("[LiveUpdates] Require Android 16 (API 36+), current: {Build.VERSION.SDK_INT}")
                return
            
            log(f"[LiveUpdates] Creating notification for: {game_name} ({playtime_hours}h)")
            self._create_notification_channel()
            nm = self._get_notification_manager()
            
            if not nm or not self.app_context:
                log("[LiveUpdates] ERROR: missing NotificationManager or context")
                return
            
            ps = Notification.ProgressStyle()
            
            segments = ArrayList()
            if playtime_hours < 1:
                color = Color.parseColor("#FF3333")
                color_name = "DARK_RED"
            elif playtime_hours < 10:
                color = Color.parseColor("#FF0000")
                color_name = "RED"
            elif playtime_hours < 20:
                color = Color.parseColor("#FF6600")
                color_name = "ORANGE"
            elif playtime_hours < 50:
                color = Color.parseColor("#FFDD00")
                color_name = "YELLOW"
            elif playtime_hours < 100:
                color = Color.parseColor("#00DD00")
                color_name = "GREEN"
            else:
                color = Color.parseColor("#00FFFF")
                color_name = "CYAN"
            
            segment_progress = min(int(playtime_hours), 100)
            log(f"[LiveUpdates] Progress: {segment_progress}% | Color: {color_name} | Hours: {playtime_hours}h")
            
            segments.add(Notification.ProgressStyle.Segment(segment_progress).setColor(color))
            segments.add(Notification.ProgressStyle.Segment(100 - segment_progress).setColor(Color.parseColor("#404040")))
            
            progress = segment_progress
            
            ps.setProgressSegments(segments)
            builder = Notification.Builder(self.app_context, "steam_game_status")
            builder.setContentTitle(f"üéÆ {game_name}")
            builder.setContentText(f"‚è±Ô∏è {playtime_hours}h ")
            builder.setSmallIcon(R_tg.drawable.notification)
            builder.setStyle(ps)
            builder.setOngoing(True)
            builder.setAutoCancel(False)
            builder.setProgress(100, progress, False)
            builder.setCategory(Notification.CATEGORY_PROGRESS)
            
            notification = builder.build()
            nm.notify(42070, notification)
            log(f"[LiveUpdates] ‚úÖ Notification sent to system (ID: 42070)")
            
        except Exception as e:
            log(f"[LiveUpdates] ‚ùå Error: {e}")

    def _cancel_game_notification(self):
        try:
            nm = self._get_notification_manager()
            if nm:
                nm.cancel(42070)
                log("[Steam] Game notification cancelled")
        except Exception as e:
            log(f"[Steam] Error cancelling notification: {e}")

    def _notification_keeper(self):
        log("[LiveUpdates] Keeper thread started (resend interval: {self.notification_resend_interval}s)")
        while not self._stop_streamer:
            try:
                if self.current_game_name:
                    current_time = time.time()
                    time_since_last = current_time - self.last_notification_time
                    if time_since_last >= self.notification_resend_interval:
                        log(f"[LiveUpdates] üîÑ Resending notification (last sent {time_since_last:.0f}s ago)")
                        self._show_game_notification(self.current_game_name, self.current_playtime_hours)
                        self.last_notification_time = current_time
                time.sleep(5)
            except Exception as e:
                log(f"[LiveUpdates] ‚ùå Keeper error: {e}")
                time.sleep(5)

    def _get_icon(self, key: str) -> str:
        style = self.get_setting("icon_style", 1)
        nso = {
            "star": "[üåü](5398096269786764342)",
            "game": "[üéÆ](5265139050263626266)",
            "dev": "[üì±](5363920828465431862)",
            "pub": "[‚ù§Ô∏è](5366551886776253280)",
            "meta": "[üíò](5364175348227395877)",
            "genre": "[üìù](5267392860122006833)",
            "time": "[‚è∞](5267166897597599285)",
            "link": "[üéÆ](5265139050263626266)",
        }
        std = {
            "star": "[üåü](5242483467144416949)",
            "game": "[üéÆ](5467583879948803288)",
            "dev": "[üë®‚Äçüíª](5190498849440931467)",
            "pub": "[üè¢](5264733042710181045)",
            "meta": "[‚≠ê](5438496463044752972)",
            "genre": "[üè∑](5278305362703835500)",
            "time": "[‚è±](5382194935057372936)",
            "link": "[üì±](5373144051690258848)",
        }
        icons = nso if style == 1 else std
        return icons.get(key, "")

    def _with_icon(self, text: str, icon: str) -> str:
        try:
            if "|" in text:
                return f"{icon} | {text.split('|', 1)[1].strip()}"
            return f"{icon} | {text}"
        except Exception:
            return text

    def _streamer(self):
        log("[Steam] Streamer started")
        while not self._stop_streamer:
            try:
                try:
                    interval_val = self.get_setting("check_interval", DEFAULT_CHECK_INTERVAL)
                    check_interval = int(interval_val) if interval_val else DEFAULT_CHECK_INTERVAL
                    if check_interval < 5:
                        check_interval = 5
                except:
                    check_interval = DEFAULT_CHECK_INTERVAL
                
                if self.get_setting("update_bio", False):
                    log("[Steam] Update bio is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[Steam] Failed to get userFull")
                        time.sleep(check_interval)
                        continue

                    stream_place = self.get_setting("stream_place", 1 if get_user_config().isPremium() else 0)
                    max_len = 140 if get_user_config().isPremium() else 70

                    steam_id = self.get_setting("steam_id", "")
                    api_key = self.get_setting("api_key", "")

                    if not steam_id:
                        log("[Steam] Steam ID is not set")
                        time.sleep(check_interval)
                        continue

                    result, _, playtime, _, _ = self.get_game(steam_id, api_key)

                    enable_live_updates = self.get_setting("enable_live_updates", True)
                    if isinstance(result, dict) and enable_live_updates:
                        try:
                            game_name = result.get('name', str(result))
                            playtime_int = int(playtime) if playtime else 0
                            playtime_hours = playtime_int // 60
                            if self.last_game_name != game_name:
                                log(f"[LiveUpdates] üéÆ Game changed: {game_name} ({playtime_hours}h)")
                                self._show_game_notification(game_name, playtime_hours)
                                self.last_game_name = game_name
                                self.current_game_name = game_name
                                self.current_playtime_hours = playtime_hours
                                self.last_notification_time = time.time()
                            else:
                                self.current_playtime_hours = playtime_hours
                        except Exception as e:
                            log(f"[LiveUpdates] ‚ùå Error: {e}")
                    else:
                        if self.last_game_name is not None:
                            log(f"[LiveUpdates] üõë Game stopped, cancelling notification")
                            self._cancel_game_notification()
                            self.last_game_name = None
                            self.current_game_name = None
                            self.current_playtime_hours = 0

                    if result != self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT):
                        new_about_text = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                        if isinstance(result, dict):
                            new_about_text = new_about_text.replace("{game}", str(result['name']))
                        else:
                            new_about_text = new_about_text.replace("{game}", str(result))

                        if stream_place == 0:
                            if userFull.about != new_about_text[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = int(4)
                                    req.about = new_about_text[:max_len]
                                    send_request(req, ())
                                except Exception as e:
                                    log(f"[Steam] Error updating bio: {e}")
                        else:
                            if not get_user_config().isPremium():
                                log("[Steam] User is not premium")
                                time.sleep(check_interval)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = new_about_text[:96]
                                req.flags = int(1)
                                send_request(req, ())
                            except Exception as e:
                                log(f"[Steam] Error updating business location: {e}")
                    else:
                        default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                        if stream_place == 0:
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = int(4)
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                except Exception as e:
                                    log(f"[Steam] Error setting default bio: {e}")
                        else:
                            if not get_user_config().isPremium():
                                log("[Steam] User is not premium")
                                time.sleep(check_interval)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = default_bio[:96]
                                req.flags = int(1)
                                send_request(req, ())
                            except Exception as e:
                                log(f"[Steam] Error setting default bio in business location: {e}")
                    
                    time.sleep(check_interval)
                else:
                    time.sleep(check_interval)
            except Exception as e:
                log(f"[Steam]: {e}")
    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            threading.Thread(target=self._download_fonts, daemon=True).start()
            log("Steam plugin loaded successfully")
        else:
            log("Failed to initialize temp directory for Steam")

    def _download_fonts(self):
        try:
            for font_name, font_url in FONTS.items():
                font_path = File(self._temp_dir, f"{font_name}-Regular.ttf").getAbsolutePath()
                if not os.path.exists(font_path):
                    response = requests.get(font_url)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                    log(f"Downloaded font: {font_name}")
        except Exception as e:
            log(f"Error downloading fonts: {e}")

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None

    def download_game_image(self, image_url):
        if not image_url:
            return None
        temp_dir = self._get_temp_dir()
        if not temp_dir or not temp_dir.isDirectory():
            return None

        filename = f"game_{uuid.uuid4()}.jpg"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()

        try:
            head = requests.head(image_url, timeout=5)
            content_length = int(head.headers.get('content-length', 0))
            if content_length > 10 * 1024 * 1024:
                return None

            resp = requests.get(image_url, stream=True, timeout=10)
            resp.raise_for_status()

            with open(temp_photo_path, 'wb') as f:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return temp_photo_path
        except Exception as e:
            try:
                if os.path.exists(temp_photo_path):
                    os.remove(temp_photo_path)
            except Exception:
                pass
            return None

    def delete_temp_file_async(self, file_path, delay_seconds=5):
        def _delete():
            try:
                time.sleep(delay_seconds)
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                pass
        threading.Thread(target=_delete, daemon=True).start()

    def _handle_show_faq_alert_click(self, view):
        title = localise("font_faq_title")
        text = localise("font_faq_text")
        close_button = localise("alert_close_button")
        self.alert_manager.show_info_alert(title, text, close_button)

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        update_bio = self.get_setting("update_bio", False)
        font_items = ["Noto Sans JP", "Zpix", "Impact", "–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç" if lang.startswith('ru') else "Custom font"]

        settings = [
            Header(text=localise("settings_main_header")),
            Input(
                key="steam_id",
                text=localise("settings_steam_id"),
                subtext=localise("settings_steam_id_subtext"),
                default="",
                icon="filled_username"
            ),
            Input(
                key="api_key",
                text=localise("settings_api_key"),
                subtext=localise("settings_api_key_subtext"),
                default="",
                icon="msg_secret"
            ),
            Selector(
                key="icon_style",
                text=localise("settings_icon_style"),
                default=1,
                items=localise("settings_icon_style_items"),
                icon="msg_emoji_smiles"
            ),
            Divider(),
            Header(text=localise("card_settings_header")),
            Input(
                key="card_text_format",
                text=localise("card_text_format"),
                subtext=localise("card_text_format_subtext"),
                default=("{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}" if lang.startswith('ru') else "{nick} plays {game}"),
                icon="msg_view_file"
            ),
            Selector(
                key="card_font_family",
                text=localise("card_font_family"),
                default=0,
                items=font_items,
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_path",
                text=localise("custom_font_link"),
                subtext=localise("custom_font_link_subtext"),
                default="",
                icon="msg_link"
            ),
            Text(
                text=localise("custom_font_help_title"),
                icon="msg_info",
                on_click=self._handle_show_faq_alert_click
            ),
            Switch(
                key="show_card_authors",
                text=localise("settings_show_card_authors"),
                default=True,
                subtext=localise("settings_show_card_authors_subtext"),
                icon="msg_info"
            ),
            Divider(),
            Header(text=localise("settings_auto_update_header")),
            Switch(
                key="update_bio",
                text=localise("settings_enable_auto"),
                default=False,
                subtext=localise("settings_enable_auto_subtext"),
                on_change=lambda new_value: self._show_stream_alert(new_value),
                icon="ic_ab_search"
            ),
            Input(
                key="check_interval",
                text=localise("settings_check_interval"),
                subtext=localise("settings_check_interval_subtext"),
                default=DEFAULT_CHECK_INTERVAL,
                icon="input_schedule"
            ) if update_bio else None,
            Selector(
                key="stream_place",
                text=localise("settings_update_location"),
                default=1 if get_user_config().isPremium() else 0,
                items=localise("settings_update_location_items"),
                icon="menu_premium_location" if get_user_config().isPremium() else "msg_openprofile"
            ) if update_bio and get_user_config().isPremium() else None,
            Input(
                key="track_display_format",
                text=localise("settings_text_template"),
                default=DEFAULT_STREAM_STRING,
                subtext=localise("settings_text_template_subtext"),
                icon="input_forward"
            ) if update_bio else None,
            Input(
                key="default_stream_text",
                text=localise("settings_default_text"),
                default=DEFAULT_STREAM_TEXT,
                subtext=localise("settings_default_text_subtext"),
                icon="input_reply"
            ) if update_bio else None,
            Switch(
                    key="enable_live_updates",
                    text=localise("settings_enable_live_updates"),
                    default=True,
                    subtext=localise("settings_enable_live_updates_subtext"),
                    icon="msg_notifications"
                ) if Build.VERSION.SDK_INT >= 36 and update_bio else None,
        ]
        
        
        settings.extend([
            Header(text=localise("library_settings_header")),
            Switch(
                key="sort_by_playtime",
                text=localise("settings_sort_by_playtime"),
                default=True,
                subtext=localise("settings_sort_by_playtime_subtext"),
                icon="filled_info"
            ),
        ])
        return [s for s in settings if s is not None]

    def _show_stream_alert(self, value):
        if value:
            title = localise("stream_alert_title")
            message = localise("stream_alert_message")
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            dialog = AlertDialog(ctx, 3)
            dialog.setTitle(title)
            dialog.setMessage(message)
            dialog.setButton("OK", None)
            dialog.show()

    def get_game(self, steam_id, api_key):
        if not api_key:
            BulletinHelper.show_error(localise("error_api_key_not_set"))
            return localise("error_api_key_missing"), None, None, None, None

        if not steam_id or not steam_id.strip():
            BulletinHelper.show_error(localise("error_steam_id_not_set"))
            return localise("error_invalid_steam_id"), None, None, None, None

        if not steam_id.isdigit():
            BulletinHelper.show_error(localise("error_invalid_steam_id"))
            return localise("error_invalid_steam_id"), None, None, None, None

        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º SteamAPI
            steam_api = SteamAPI(api_key, steam_id)
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Ñ–∏–ª–µ
            log("[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ—Ñ–∏–ª–µ...")
            profile = steam_api.get_player_summary()
            
            if not profile or 'response' not in profile or not profile['response'].get('players'):
                log("[SteamPlugin] –ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —Å–∫—Ä—ã—Ç")
                return localise("error_steam_id_not_found"), None, None, None, None
            
            player = profile['response']['players'][0]
            nickname = player.get('personaname', 'Unknown')
            
            if 'gameextrainfo' not in player:
                log("[SteamPlugin] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ –∏–≥—Ä–µ")
                return self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT), None, None, None, nickname
            
            game_name = player['gameextrainfo']
            game_id = player.get('gameid')
            
            if not game_id:
                log("[SteamPlugin] ID –∏–≥—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return game_name, None, None, None, nickname
            
            game_store_url = f"https://store.steampowered.com/app/{game_id}/"
            
            playtime = 0
            try:
                log("[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –∏–≥—Ä...")
                owned_games = steam_api.get_owned_games()
                if owned_games and 'response' in owned_games and 'games' in owned_games['response']:
                    for game in owned_games['response']['games']:
                        if str(game.get('appid')) == str(game_id):
                            playtime = game.get('playtime_forever', 0)
                            log(f"[SteamPlugin] –ù–∞–π–¥–µ–Ω–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã: {playtime} –º–∏–Ω—É—Ç")
                            break
            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã: {e}")
            
            game_details = steam_api.get_game_details(game_id)
            
            if game_details:
                log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–≥—Ä–µ: {game_details}")

                image_url = None
                if 'header_image' in game_details:
                    image_url = game_details['header_image']
                elif 'background' in game_details:
                    image_url = game_details['background']
                elif 'screenshots' in game_details and game_details['screenshots']:
                    image_url = game_details['screenshots'][0].get('path_full')

                metacritic_score = 'N/A'
                if 'metacritic' in game_details and isinstance(game_details['metacritic'], dict):
                    metacritic_score = game_details['metacritic'].get('score', 'N/A')
                
                game_info = {
                    'name': game_name,
                    'developers': game_details.get('developers', []),
                    'publishers': game_details.get('publishers', []),
                    'metacritic': metacritic_score,
                    'genres': [g['description'] for g in game_details.get('genres', [])],
                    'categories': [c['description'] for c in game_details.get('categories', [])],
                    'release_date': game_details.get('release_date', {}).get('date', 'N/A'),
                    'short_description': game_details.get('short_description', ''),
                    'playtime': playtime,
                    'store_url': game_store_url
                }
                
                log(f"[SteamPlugin] –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã: {game_info}")
                return game_info, image_url, playtime, game_store_url, nickname

            log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã")
            return game_name, None, playtime, game_store_url, nickname
            
        except requests.exceptions.RequestException as e:
            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: {e}")
            return localise("error_network"), None, None, None, None
        except json.JSONDecodeError as e:
            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ JSON: {e}")
            return localise("error_api"), None, None, None, None
        except Exception as e:
            log(f"[SteamPlugin] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
            return localise("error_unknown", e=str(e)), None, None, None, None

    def _dismiss_dialog(self):
        global progress_dialog
        try:
            if progress_dialog is not None and progress_dialog.isShowing():
                progress_dialog.dismiss()
        except Exception:
            pass
        finally:
            progress_dialog = None

    def get_steam_library(self, steam_id, api_key):
        log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –¥–ª—è Steam ID: {steam_id}")

        if not steam_id or not steam_id.strip() or not steam_id.isdigit():
            error_msg = localise("error_invalid_steam_id")
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

        if not api_key or not api_key.strip():
            error_msg = localise("error_api_key_missing")
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

        url = 'http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/'
        params = {
            'key': api_key,
            'steamid': steam_id,
            'include_appinfo': 1,
            'include_played_free_games': 1,
            'format': 'json'
        }

        try:
            log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ Steam API: {url}")
            response = requests.get(url, params=params, timeout=20)
            log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç. –°—Ç–∞—Ç—É—Å: {response.status_code}")

            if response.status_code != 200:
                error_msg = f"{localise('error_api_code', code=response.status_code)} - {response.text}"
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg

            data = response.json()
            log(f"[SteamPlugin] –û—Ç–≤–µ—Ç API: {json.dumps(data, ensure_ascii=False)[:500]}...")

            if 'response' not in data:
                error_msg = localise("error_invalid_response")
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg

            if 'games' not in data['response']:
                error_msg = localise("error_private_profile")
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg

            games = data['response'].get('games', [])
            log(f"[SteamPlugin] –ù–∞–π–¥–µ–Ω–æ –∏–≥—Ä: {len(games)}")

            if not games:
                log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                return [], localise("library_empty")

            sorted_games = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
            log(f"[SteamPlugin] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ –∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ {len(sorted_games)} –∏–≥—Ä")
            return sorted_games, None

        except requests.exceptions.RequestException as e:
            error_msg = localise("error_network_generic", e=str(e))
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
        except json.JSONDecodeError as e:
            error_msg = localise("error_json_parse", e=str(e))
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
        except Exception as e:
            import traceback
            error_msg = localise("error_unknown_generic", e=str(e)) + f"\n{traceback.format_exc()}"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

    def on_callback_query_hook(self, account, params):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ inline-–∫–Ω–æ–ø–∫–∏"""
        try:
            if not hasattr(params, 'data'):
                return HookResult()

            data = params.data
            log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω callback: {data}")

            if data.startswith('sort_'):
                sort_type, steam_id = data.split('_', 1)[1].split('_', 1)

                api_key = self.get_setting("api_key", "").strip()

                try:
                    get_messages_controller().callCallbackQuery(params.query_id, "")
                except:
                    pass

                self.send_sorted_library(params.peer, steam_id, api_key, sort_type)

                try:
                    get_messages_controller().editMessageReplyMarkup(params.peer, params.msg_id, None)
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–æ–∫: {str(e)}")

                return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –≤ on_callback_query_hook: {str(e)}")
            import traceback
            log(f"[SteamPlugin] –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")

        return HookResult()

    def send_sorted_library(self, peer, steam_id, api_key, sort_type='hours', full_list=False):

        def _send():
            try:
                log(f"[SteamPlugin] –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π: {sort_type}, full_list={full_list}")
                games, error = self.get_steam_library(steam_id, api_key)

                if error:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {error}")
                    send_message({"peer": peer, "message": error})
                    return

                if not games:
                    log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                    send_message({"peer": peer, "message": localise("library_empty")})
                    return

                if sort_type == 'hours':
                    games_sorted = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
                    sort_text = localise("sort_by_hours_text")
                else:
                    games_sorted = sorted(games,
                        key=lambda x: x.get('rtime_last_played', x.get('last_played', 0)),
                        reverse=True)
                    sort_text = localise("sort_by_last_played_text")

                games_list = []
                total_games = len(games_sorted)
                total_playtime = sum(game.get('playtime_forever', 0) for game in games_sorted) // 60

                max_games = 30
                games_to_show = games_sorted[:max_games]

                for i, game in enumerate(games_to_show, 1):
                    try:
                        name = game.get('name', 'Unknown game')
                        playtime = game.get('playtime_forever', 0)
                        hours = playtime // 60
                        minutes = playtime % 60

                        last_played = ""
                        if sort_type == 'last_played' and 'rtime_last_played' in game:
                            from datetime import datetime
                            last_played_ts = game['rtime_last_played']
                            if last_played_ts > 0:
                                last_played_date = datetime.fromtimestamp(last_played_ts).strftime('%d.%m.%Y')
                                last_played = localise("last_played_suffix", date=last_played_date)

                        if hours > 0:
                            playtime_str = localise("duration_compact_hm", hours=hours, minutes=minutes) + last_played
                        else:
                            playtime_str = localise("duration_compact_m", minutes=minutes) + last_played

                        games_list.append(f"{i}. {name} - {playtime_str}")
                    except Exception as game_err:
                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–≥—Ä—ã {i}: {str(game_err)}")

                if total_games > max_games:
                    games_list.append("\n" + localise("and_more_games", count=total_games - max_games))

                if full_list:
                    message = f"üéÆ *{localise('full_library_header')}*\n" + localise('total_games_and_time', count=total_games, hours=total_playtime) + "\n\n"

                    games_by_letter = {}
                    for game in games_sorted:
                        name = game.get('name', 'Unknown game')
                        first_letter = name[0].upper() if name and name[0].isalpha() else '#'
                        if first_letter not in games_by_letter:
                            games_by_letter[first_letter] = []
                        games_by_letter[first_letter].append(name)

                    sorted_letters = sorted(games_by_letter.keys())

                    for letter in sorted_letters:
                        games_str = ', '.join(games_by_letter[letter])
                        message += f"\n*{letter}*: {games_str}\n"

                    message += f"\nüìä *{localise('sorting_label')}* {sort_text}"
                else:
                    sort_buttons = [
                        [{"text": localise("btn_sort_by_hours"), "callback_data": f"sort_hours_{steam_id}"}],
                        [{"text": localise("btn_sort_by_last_played"), "callback_data": f"sort_last_played_{steam_id}"}]
                    ]

                    message = f"üéÆ *{localise('library_header')}*\n" + localise('total_games_and_time', count=total_games, hours=total_playtime) + "\n\n"
                    message += "\n".join(games_list)
                    message += f"\n\nüìä *{localise('sorting_label')}* {sort_text}"

                log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º {'–ø–æ–ª–Ω—ã–π' if full_list else '–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π'} —Å–ø–∏—Å–æ–∫ –∏–≥—Ä")
                parsed = parse_markdown(message)

                entities = [entity.to_tlrpc_object() for entity in parsed.entities]
                try:
                    blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                    blockquote_entity.collapsed = True
                    blockquote_entity.offset = 0
                    try:
                        blockquote_entity.length = len(parsed.text.encode('utf-16le')) // 2
                    except Exception:
                        blockquote_entity.length = len(parsed.text)
                    entities.append(blockquote_entity)
                except Exception as e:
                    log(f"[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Å–≤—ë—Ä–Ω—É—Ç—É—é —Ü–∏—Ç–∞—Ç—É: {e}")

                message_data = {
                    "peer": peer,
                    "message": parsed.text,
                    "entities": entities
                }

                if not full_list and 'sort_buttons' in locals():
                    message_data["reply_markup"] = {"inline_keyboard": sort_buttons}

                send_message(message_data)

            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {str(e)}")
                import traceback
                log(f"[SteamPlugin] –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")
                try:
                    send_message({
                        "peer": peer,
                        "message": localise("failed_to_load_library")
                    })
                except:
                    pass

        threading.Thread(target=_send, daemon=True).start()

    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        message = params.message.strip()

        if message in (".slibrary", ".sflibrary"):
            is_full_library = message == ".sflibrary"
            command_name = ".sflibrary" if is_full_library else ".slibrary"

            try:
                log(f"[SteamPlugin] –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã {command_name}")
                steam_id = self.get_setting("steam_id", "").strip()
                api_key = self.get_setting("api_key", "").strip()

                if not steam_id:
                    params.message = localise("error_steam_id_not_set")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                if not api_key:
                    params.message = localise("error_api_key_not_set")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                try:
                    BulletinHelper.show_info(localise("loading_library"))
                    log("[SteamPlugin] –ü–æ–∫–∞–∑–∞–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ")
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∞–∑–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {str(e)}")

                def send_library_message(peer):
                    try:
                        log("[SteamPlugin] –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏...")
                        games, error = self.get_steam_library(steam_id, api_key)

                        if error:
                            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {error}")
                            message = error
                        else:
                            if not games:
                                log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                                message = localise("library_empty")
                            else:
                                log(f"[SteamPlugin] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ {len(games)} –∏–≥—Ä")
                                games_sorted = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)

                                games_list = []
                                total_games = len(games_sorted)
                                total_playtime = sum(game.get('playtime_forever', 0) for game in games_sorted) // 60

                                max_games = 30
                                games_to_show = games_sorted[:max_games]

                                for i, game in enumerate(games_to_show, 1):
                                    try:
                                        name = game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–≥—Ä–∞')
                                        playtime = game.get('playtime_forever', 0)
                                        hours = playtime // 60
                                        minutes = playtime % 60
                                        if hours > 0:
                                            playtime_str = f"{hours}—á {minutes}–º"
                                        else:
                                            playtime_str = f"{minutes}–º"
                                        games_list.append(f"{i}. {name} - {playtime_str}")
                                    except Exception as game_err:
                                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–≥—Ä—ã {i}: {str(game_err)}")

                                if total_games > max_games:
                                    games_list.append("\n" + localise("and_more_games", count=total_games - max_games))

                                sort_buttons = [
                                    [{"text": localise("btn_sort_by_hours"), "callback_data": f"sort_hours_{steam_id}"}],
                                    [{"text": localise("btn_sort_by_last_played"), "callback_data": f"sort_last_played_{steam_id}"}]
                                ]

                                message = f"üéÆ *{localise('library_header')}*\n" + localise('total_games_and_time', count=total_games, hours=total_playtime) + "\n\n"
                                message += "\n".join(games_list)
                                message += f"\n\nüìä *{localise('sorting_label')}* {localise('sort_by_hours_text')}"
                                log("[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ")

                        log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π –∏ –∫–Ω–æ–ø–∫–∞–º–∏")
                        parsed = parse_markdown(message)
                        entities = [entity.to_tlrpc_object() for entity in parsed.entities]
                        try:
                            blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                            blockquote_entity.collapsed = True
                            blockquote_entity.offset = 0
                            try:
                                blockquote_entity.length = len(parsed.text.encode('utf-16le')) // 2
                            except Exception:
                                blockquote_entity.length = len(parsed.text)
                            entities.append(blockquote_entity)
                        except Exception as e:
                            log(f"[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Å–≤—ë—Ä–Ω—É—Ç—É—é —Ü–∏—Ç–∞—Ç—É: {e}")

                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": entities,
                            "reply_markup": {
                                "inline_keyboard": sort_buttons
                            }
                        })

                    except Exception as e:
                        import traceback
                        error_msg = f"{localise('error_unknown_generic', e=str(e))}\n\n{traceback.format_exc()}"
                        log(f"[SteamPlugin] {error_msg}")
                        try:
                            send_message({
                                "peer": peer,
                                "message": localise("failed_to_load_library")
                            })
                        except:
                            pass

                try:
                    BulletinHelper.show_info(localise("loading_library"))
                    sort_type = 'hours' if self.get_setting("sort_by_playtime", True) else 'last_played'
                    self.send_sorted_library(params.peer, steam_id, api_key, sort_type, is_full_library)
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø–æ—Ç–æ–∫–∞: {str(e)}")
                    params.message = localise("failed_to_load_library")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                return HookResult(strategy=HookStrategy.CANCEL)

            except Exception as e:
                import traceback
                error_msg = f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}\n\n{traceback.format_exc()}"
                log(f"[SteamPlugin] {error_msg}")
                params.message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏."
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if not (message.lower().startswith(".nowsteam") or message.lower().startswith(".snp")):
            return HookResult()

        try:
            steam_id = self.get_setting("steam_id", "")
            api_key = self.get_setting("api_key", "")

            log(f"[SteamPlugin] –ö–æ–º–∞–Ω–¥–∞ .nowsteam –ø–æ–ª—É—á–µ–Ω–∞. Steam ID: {steam_id}, API Key: {'*' * 8 + api_key[-4:] if api_key else '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}")

            if not steam_id:
                BulletinHelper.show_error(localise("error_steam_id_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            if not api_key:
                BulletinHelper.show_error(localise("error_api_key_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            def search_and_reply(peer):
                try:
                    log("[SteamPlugin] –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–≥—Ä–µ...")
                    result, image_url, playtime, game_url, nickname = self.get_game(steam_id, api_key)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {result}, nickname: {nickname}")
                    
                    if isinstance(result, str) and result.startswith('‚ùå –û—à–∏–±–∫–∞'):
                        BulletinHelper.show_error(result)
                        return

                    if result == self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT):
                        log("[SteamPlugin] –ò–≥—Ä–æ–∫ –Ω–µ –≤ –∏–≥—Ä–µ")
                        text_np = self._with_icon(str(result), self._get_icon("star"))
                        parsed = parse_markdown(text_np)
                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                        })
                        return
                    
                   
                    playtime_text = ""
                    if isinstance(result, dict) and 'playtime' in result:
                        hours = result['playtime'] // 60
                        minutes = result['playtime'] % 60
                        if hours > 0:
                            playtime_text = localise("playtime", hours=hours, minutes=minutes)
                        else:
                            playtime_text = localise("playtime_minutes", minutes=minutes)
                    elif playtime is not None:
                        hours = playtime // 60
                        minutes = playtime % 60
                        if hours > 0:
                            playtime_text = localise("playtime", hours=hours, minutes=minutes)
                        else:
                            playtime_text = localise("playtime_minutes", minutes=minutes)
                    
                    caption_message = ""
                    if isinstance(result, dict):
                        caption_lines = []
                        caption_lines.append(self._with_icon(localise("playing_format", game=result['name']), self._get_icon('game')))
                        if result.get('developers'):
                            caption_lines.append(self._with_icon(localise("developers", developers=', '.join(result['developers'])), self._get_icon('dev')))
                        if result.get('publishers') and result['publishers'] != result.get('developers', []):
                            caption_lines.append(self._with_icon(localise("publishers", publishers=', '.join(result['publishers'])), self._get_icon('pub')))
                        caption_lines.append(self._with_icon(localise("metacritic", score=result.get('metacritic', 'N/A')), self._get_icon('meta')))
                        if result.get('genres'):
                            caption_lines.append(self._with_icon(localise("genres", genres=', '.join(result['genres'][:3])), self._get_icon('genre')))
                        if isinstance(result, dict) and 'playtime' in result:
                            hours = result['playtime'] // 60
                            minutes = result['playtime'] % 60
                            if hours > 0:
                                pt = localise("playtime", hours=hours, minutes=minutes)
                            else:
                                pt = localise("playtime_minutes", minutes=minutes)
                            caption_lines.append(self._with_icon(pt, self._get_icon('time')))
                        if result.get('store_url'):
                            caption_lines.append("\n" + self._with_icon(localise("game_link", url=result['store_url']), self._get_icon('link')))
                        caption_message = "\n".join(caption_lines)
                    else:
                        line_playing = self._with_icon(localise("playing_format", game=result), self._get_icon('game'))
                        if playtime is not None:
                            hours = playtime // 60
                            minutes = playtime % 60
                            if hours > 0:
                                pt = localise("playtime", hours=hours, minutes=minutes)
                            else:
                                pt = localise("playtime_minutes", minutes=minutes)
                            line_time = self._with_icon(pt, self._get_icon('time'))
                            caption_message = f"{line_playing}\n{line_time}"
                        else:
                            caption_message = line_playing
                        if game_url:
                            caption_message += "\n\n" + self._with_icon(localise("game_link", url=game_url), self._get_icon('link'))

                    try:
                        temp_photo_path = self._make_card(result, nickname, image_url)
                        helper = get_send_messages_helper()
                        if temp_photo_path:
                            generated_photo = helper.generatePhotoSizes(temp_photo_path, None)
                            if generated_photo is not None:
                                log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–∞—Ä—Ç–æ—á–∫–æ–π –∏ –ø–æ–¥–ø–∏—Å—å—é")
                                parsed_caption = parse_markdown(caption_message.strip())
                                send_message({
                                    "peer": peer,
                                    "photo": generated_photo,
                                    "path": temp_photo_path,
                                    "caption": parsed_caption.text,
                                    "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                    "message": None
                                })
                                self.delete_temp_file_async(temp_photo_path)
                                return
                            else:
                                log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ (card)")
                                self.delete_temp_file_async(temp_photo_path)
                        log("[SteamPlugin] –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ fallback-—Ñ–æ—Ç–æ –±–µ–∑ –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                        fallback_path = self.download_game_image(NO_STEAM_FALLBACK_URL)
                        if fallback_path:
                            generated_photo = helper.generatePhotoSizes(fallback_path, None)
                            if generated_photo is not None:
                                parsed_caption = parse_markdown(caption_message.strip())
                                send_message({
                                    "peer": peer,
                                    "photo": generated_photo,
                                    "path": fallback_path,
                                    "caption": parsed_caption.text,
                                    "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                    "message": None
                                })
                                self.delete_temp_file_async(fallback_path)
                                return
                            else:
                                log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ (fallback)")
                                self.delete_temp_file_async(fallback_path)
                        BulletinHelper.show_error(localise("error_unknown_generic", e="card generation failed"))
                    except Exception as e:
                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–∞—Ä—Ç–æ—á–∫–∏: {e}")
                        BulletinHelper.show_error(localise("error_unknown", e=str(e)))

                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –≤ –ø–æ—Ç–æ–∫–µ –ø–æ–∏—Å–∫–∞: {e}")
                    BulletinHelper.show_error(localise("error_unknown", e=str(e)))

            try:
                BulletinHelper.show_info(localise("searching"))
            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–∏–∞–ª–æ–≥–∞: {e}")

            threading.Thread(target=lambda: search_and_reply(params.peer), daemon=True).start()
            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            params.message = localise("error_unknown", e=str(e))
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def _make_card(self, game_info, nickname, image_url):
        log(f"[SteamPlugin] Starting _make_card with game_info: {game_info}, nickname: {nickname}")
        
        if not game_info or not isinstance(game_info, dict):
            log(f"[SteamPlugin] Invalid game info: {game_info}")
            return None
            
        width, height = 1280, 720  # 16:9 aspect ratio
        text_start_y = 0
        
        try:
            game_name = game_info.get('name', 'Unknown Game')
            playtime = game_info.get('playtime', 0)
            
            hours, minutes = divmod(playtime, 60)
            playtime_text = f"{hours}—á {minutes}–º" if hours > 0 else f"{minutes}–º"
            
            card_text_format = self.get_setting("card_text_format", "{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}")
            main_text = card_text_format.replace("{nick}", nickname).replace("{game}", game_name)
            
            developers = ", ".join(game_info.get('developers', []))
            publishers = ", ".join(game_info.get('publishers', []))
            genres = ", ".join(game_info.get('genres', []))
            release_date = game_info.get('release_date', 'N/A')
            metacritic = game_info.get('metacritic', 'N/A')
            description = (game_info.get('short_description', '')[:200] + '...' 
                         if game_info.get('short_description') else '')
            store_url = game_info.get('store_url', '#')
            
            background_color = "#1B2838"
            accent_color = "#66C0F4"
            text_color = "#FFFFFF"
            
            log(f"[SteamPlugin] Creating card with dimensions: {width}x{height}")

            if not image_url or not image_url.strip():
                log(f"[SteamPlugin] No image_url provided ‚Äî cancel card generation to trigger raw fallback")
                return None
                
        except Exception as e:
            log(f"[SteamPlugin] Error processing game info: {e}")
            return None

        original_image = None
        try:
            log(f"[SteamPlugin] Downloading original image from: {image_url}")
            response = requests.get(image_url, timeout=10)
            response.raise_for_status()
            original_image = Image.open(io.BytesIO(response.content)).convert("RGBA")
        except Exception as e:
            log(f"[SteamPlugin] Error downloading cover image: {e}")
            return None

        full_background = Image.new('RGB', (width, height), background_color)
        if original_image:
            try:
                blurred_background = original_image.resize((width, height))
                blurred_background = blurred_background.filter(ImageFilter.GaussianBlur(30))
                overlay = Image.new("RGBA", (width, height), (0, 0, 0, 150))
                full_background = Image.alpha_composite(blurred_background, overlay).convert("RGB")
                log(f"[SteamPlugin] Full blurred background created")
            except Exception as e:
                log(f"[SteamPlugin] Error processing background cover: {e}")

        card = full_background
        draw = ImageDraw.Draw(card)

        if original_image:
            try:
                log(f"[SteamPlugin] Original image size: {original_image.size}, mode: {original_image.mode}")
                

                target_width = 1023 
                target_height = int(target_width / 2.14)
                
                thumbnail = original_image.copy()
                if thumbnail.mode != 'RGBA':
                    thumbnail = thumbnail.convert('RGBA')

                thumbnail = thumbnail.resize((target_width, target_height), Image.Resampling.LANCZOS)
                log(f"[SteamPlugin] Resized to {target_width}x{target_height}, mode: {thumbnail.mode}")
                
                paste_x = (width - target_width) // 2
                paste_y = 50
                
                if thumbnail.mode == 'RGBA':
                    card.paste(thumbnail, (paste_x, paste_y), thumbnail)
                else:
                    card.paste(thumbnail, (paste_x, paste_y))
                    
                log(f"[SteamPlugin] Image pasted at position ({paste_x}, {paste_y})")
                

                text_start_y = paste_y + target_height + 20
            except Exception as e:
                log(f"[SteamPlugin] Error processing album cover thumbnail: {e}")

                return None

        game_name = game_info.get('name', 'Unknown Game') if isinstance(game_info, dict) else game_info

        font_index = self.get_setting("card_font_family", 0)
        main_font, footer_font = None, None

        if font_index == 3:
            custom_font_url = self.get_setting("custom_font_path", "").strip()
            if custom_font_url and custom_font_url.startswith(('http://', 'https://')):
                try:
                    custom_font_file = File(self._temp_dir, "custom_font.ttf").getAbsolutePath()
                    if not os.path.exists(custom_font_file):
                        response = requests.get(custom_font_url)
                        with open(custom_font_file, 'wb') as f:
                            f.write(response.content)
                    main_font = ImageFont.truetype(custom_font_file, 45)
                    footer_font = ImageFont.truetype(custom_font_file, 25)
                    try:
                        setattr(main_font, "_path", custom_font_file)
                    except Exception:
                        pass
                except Exception as e:
                    log(f"[SteamPlugin] Failed to load custom font: {e}, falling back.")
                    font_index = 0

        if not main_font:
            font_key = list(FONTS.keys())[font_index]
            font_file_name = f"{font_key}-Regular.ttf"
            try:
                font_path = File(self._temp_dir, font_file_name).getAbsolutePath()
                main_font = ImageFont.truetype(font_path, 45)
                footer_font = ImageFont.truetype(font_path, 25)
                try:
                    setattr(main_font, "_path", font_path)
                except Exception:
                    pass
            except Exception as e:
                log(f"Error loading font, using default: {e}")
                main_font = ImageFont.load_default()
                footer_font = ImageFont.load_default()

        card_text_format = self.get_setting("card_text_format", "{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}")
        main_text = card_text_format.replace("{nick}", nickname).replace("{game}", game_name)
        footer_text = "Plugin by @KangelPlugins & @MGEPlugins" if self.get_setting("show_card_authors", True) else None
        
        def wrap_lines(text, font, max_width):
            words = text.split()
            lines = []
            current = ""
            for w in words:
                test = (current + (" " if current else "") + w).strip()
                wlen = draw.textlength(test, font=font)
                if wlen <= max_width:
                    current = test
                else:
                    if current:
                        lines.append(current)
                        current = w
                    else:

                        lines.append(w)
                        current = ""
            if current:
                lines.append(current)
            return lines

        def fit_and_draw_centered(start_y, text, base_font, fill, max_width, max_lines=3, min_size=20):
            size = base_font.size if hasattr(base_font, 'size') else 45
            font_path = getattr(base_font, '_path', None)

            def with_size(sz):
                try:
                    if font_path:
                        return ImageFont.truetype(font_path, sz)
                except Exception:
                    pass
                return base_font

            while size >= min_size:
                font_try = with_size(size)
                lines = wrap_lines(text, font_try, max_width)
                if len(lines) <= max_lines:
                    y = start_y
                    line_height = font_try.getbbox("Ay")[3] - font_try.getbbox("Ay")[1]
                    spacing = 6 
                    total_h = len(lines) * line_height + (len(lines)-1) * spacing
                    y = start_y
                    for line in lines:
                        bbox = draw.textbbox((0, 0), line, font=font_try)
                        tw = bbox[2] - bbox[0]
                        draw.text(((width - tw) / 2, y), line, font=font_try, fill=fill)
                        y += line_height + spacing
                    return True
                size -= 2

            font_try = with_size(min_size)
            lines = wrap_lines(text, font_try, max_width)
            y = start_y
            line_height = font_try.getbbox("Ay")[3] - font_try.getbbox("Ay")[1]
            spacing = 6
            for i, line in enumerate(lines[:max_lines]):
                bbox = draw.textbbox((0, 0), line, font=font_try)
                tw = bbox[2] - bbox[0]
                draw.text(((width - tw) / 2, y), line, font=font_try, fill=fill)
                y += line_height + spacing #–ü–ê–°–•–ê–õ–ö–ê–ê–ê
            return True


        available_width = width - 120
        try:
            _ = text_start_y
        except NameError:
            text_start_y = int(height * 0.6)

        fit_and_draw_centered(text_start_y, main_text, main_font, text_color, available_width)
        if footer_text:
            footer_bbox = draw.textbbox((0, 0), footer_text, font=footer_font)
            footer_w = footer_bbox[2] - footer_bbox[0]
            draw.text(((width - footer_w) / 2, height - 40), footer_text, font=footer_font, fill=text_color)

        filename = f"now_steam.png"
        temp_photo_path = File(self._temp_dir, filename).getAbsolutePath()
        log(f"[SteamPlugin] Saving card to: {temp_photo_path}")
        card.save(temp_photo_path)
        log(f"[SteamPlugin] Card saved successfully")
        return temp_photo_path


    def on_plugin_unload(self):
        log("Steam plugin unloaded")
        self.alert_manager.dismiss_dialog() # –∫—Ç–æ –ø—Ä–æ—á–∏—Ç–∞–ª —Ç–æ—Ç –ª–æ—Ö –ª–º–∞–æ
