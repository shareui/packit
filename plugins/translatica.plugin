from base_plugin import BasePlugin, HookStrategy, HookResult, MenuItemData, MenuItemType, MethodHook, hook_filters, HookFilter, MethodReplacement
from hook_utils import get_private_field, find_class
from typing import Any
import requests
import time
import re
import json
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from android_utils import run_on_ui_thread, log
from android.view import Gravity, View, MotionEvent
from android.widget import FrameLayout, TextView, LinearLayout, ImageView
from android.util import TypedValue
from android_utils import OnClickListener
from client_utils import get_last_fragment, get_messages_controller, send_request, send_message # Planned
from org.telegram.messenger import MediaDataController, ImageLocation, AndroidUtilities # Planned
from org.telegram.ui.Components import LayoutHelper, BackupImageView # Planned
from org.telegram.ui.ActionBar import Theme, BottomSheet # Planned
import hashlib
import threading
import random
from concurrent.futures import ThreadPoolExecutor
import os
from java import jclass
from java.util import ArrayList
from java.lang import String, Integer as JInteger
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import MessageObject


# v1.0.6 - Implementar restante das funcionalidades futuras

__id__          = "translatica"
__name__        = "Translatica"
__description__ = (
    "A context-aware translation plugin that **intelligently adapts messages to sound natural** in the target language, "
    "with advanced controls over translation behavior, reply handling, and language targeting.\n\n"
    "Контекстно-зависимый плагин перевода, который **интеллектуально адаптирует сообщения, чтобы они звучали естественно** на целевом языке, "
    "с расширенным контролем поведения перевода, обработки ответов и выбора языка."
)
__author__      = "@AGeekApple"
__version__     = "1.0.6"
__min_version__ = "11.12.0"
__icon__        = "ApplePlugins/19"

# Sistema Translatica - Funcionalidades Estendidas
_translatica_em_progresso_mensagens = set()
_translatica_traduzido_em_mensagem = set()
_translatica_classes_mensagem = {}
_translatica_cache_traducao = {}
_translatica_cache_sujo = False
_translatica_cache_ultimo_salvamento = 0
_translatica_cache_intervalo_salvamento = 30
_translatica_executor = ThreadPoolExecutor(max_workers=50, thread_name_prefix="translatica_translatica_")

# Sistema de Cache (Armazenamento Robusto) Experimental 
# Nova do Dev: Implementar melhorias restantes na versão 1.0.7
_translatica_cache_dir = None
try:
    import os as _os
    # Diretórios externos preferenciais (Persistência garantida - estilo Nowfy)
    ext_base = "/storage/emulated/0/Android/media/com.exteragram.messenger"
    ayu_base = "/storage/emulated/0/Android/media/com.radolyn.ayugram" # Deus tenha piedade
    candidates = []
    
    # Verifica existência das pastas base e propõe subpasta de cache
    if _os.path.isdir(ext_base):
        candidates.append(_os.path.join(ext_base, "translatica_cache"))
    if _os.path.isdir(ayu_base):
        candidates.append(_os.path.join(ayu_base, "translatica_cache"))
    
    # Fallback padrão
    candidates.append(_os.path.expanduser("~/.translatica_plugin_cache"))
    
    for d in candidates:
        try:
            _os.makedirs(d, exist_ok=True)
            # Teste de escrita simples
            t = _os.path.join(d, ".t")
            with open(t, "w") as f: f.write("t")
            _os.remove(t)
            _translatica_cache_dir = d
            break
        except:
            continue
except:
    pass

if not _translatica_cache_dir:
    _translatica_cache_dir = os.path.expanduser("~/.translatica_plugin_cache")
    try: os.makedirs(_translatica_cache_dir, exist_ok=True)
    except: pass

_translatica_arquivo_cache_traducoes = os.path.join(_translatica_cache_dir, "translatica_translations_cache.json")

_translatica_session = None
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Mobile Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (Linux; Android 9; Mi 9T Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Mobile Safari/537.36",
]

class TranslaticaResultado(MethodHook):
    def __init__(self, valor_resultado):
        self.valor_resultado = valor_resultado
    
    def before_hooked_method(self, param):
        param.setResult(self.valor_resultado)

class TranslaticaTraducao(MethodHook):
    def __init__(self, plugin, geracao):
        self.plugin = plugin
        self.geracao = geracao
        self.ocupado = False

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            if self.ocupado: return
            if not self.plugin or not self.plugin.get_setting("enable_entire_chat_translation", False):
                return
            
            # Validação de geração
            if self.geracao != getattr(self.plugin, "_translatica_geracao_global", 0):
                return

            self.ocupado = True
            msg_obj = param.args[0]
            
            if not msg_obj or msg_obj.isOut():
                self.ocupado = False
                return

            # Validação básica da mensagem
            texto_original = self.plugin._translatica_obter_texto_valido(msg_obj)
            if not texto_original:
                self.ocupado = False
                return
            
            self.plugin._translatica_log_debug(f"TranslaticaTraducao: Mensagem recebida {msg_obj.getId()}")

            # Evita loops
            msg_key = f"{msg_obj.getId()}"
            msg_id_tuple = (msg_obj.getDialogId(), msg_obj.getId())
            
            if msg_key in _translatica_em_progresso_mensagens:
                param.setResult(None)
                self.ocupado = False
                return

            if msg_id_tuple in _translatica_traduzido_em_mensagem:
                param.setResult(None)
                self.ocupado = False
                return

            target_lang = self.plugin._translatica_obter_idioma_alvo_telegram()
            
            # Verifica se já está traduzido no objeto nativo
            mo = getattr(msg_obj, "messageOwner", None)
            if mo and hasattr(mo, "translatedText") and mo.translatedText and \
               hasattr(mo, "translatedToLanguage") and mo.translatedToLanguage == target_lang:
                param.setResult(None) # Já traduzido
                self.ocupado = False
                return
            
            # Verifica caracteres (já no idioma)
            if self.plugin._translatica_ja_traduzido(texto_original, target_lang):
                param.setResult(None)
                self.ocupado = False
                return

            # Cancela o fluxo original e processa assincronamente
            param.setResult(None)
            _translatica_em_progresso_mensagens.add(msg_key)
            
            self.plugin._translatica_executor.submit(
                lambda: self.plugin._translatica_processar_traducao(texto_original, msg_key, target_lang, msg_obj)
            )
            
        except Exception as e:
            pass
        finally:
            self.ocupado = False

class TranslaticaBloqueioReversao(MethodHook):
    def before_hooked_method(self, p):
        try:
            m = p.thisObject
            if (m and (m.getDialogId(), m.getId()) in _translatica_traduzido_em_mensagem 
                and m.translated and m.messageOwner and m.messageOwner.translatedText):
                p.setResult(False)
        except:
            pass

class TranslaticaHookTradutorNativo(MethodReplacement):
    def __init__(self, plugin, generation: int):
        super().__init__()
        self.plugin = plugin
        self._generation = generation

    def cleanup(self):
        try:
            self.plugin._translatica_log_debug(f"TranslaticaHookTradutorNativo.cleanup gen={self._generation}")
        except Exception:
            pass

    def replace_hooked_method(self, param: Any) -> Any:
        try:
            if not self.plugin or not self.plugin.get_setting("enable_in_message_translation", False):
                return None

            if not param.args or len(param.args) == 0:
                return None

            message_object = param.args[0]
            if not message_object or not isinstance(message_object, MessageObject):
                return None

            mo = getattr(message_object, "messageOwner", None)
            if not mo:
                return None

            target_lang = self.plugin._translatica_obter_idioma_alvo_telegram()

            if (hasattr(mo, "translatedText") and mo.translatedText and
                hasattr(mo, "translatedToLanguage") and mo.translatedToLanguage == target_lang):
                return None

            original_text = self.plugin._translatica_obter_texto_valido(message_object)
            if not original_text or message_object.isOut():
                return None

            message_key = f"{message_object.getId()}"
            if message_key in _translatica_em_progresso_mensagens:
                return None

            _translatica_em_progresso_mensagens.add(message_key)

            def tarefa():
                self.plugin._translatica_processar_traducao(original_text, message_key, target_lang, message_object)

            _translatica_executor.submit(tarefa)
        except Exception as e:
            try:
                self.plugin._translatica_log_debug(f"Erro em TranslaticaHookTradutorNativo: {e}")
            except Exception:
                pass
        return None

class TranslaticaAlertaMensagem(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        self.pending = False

    def before_hooked_method(self, p):
        try:
            if not self.plugin or not self.plugin.get_setting("enable_in_message_translation", False):
                return
            if len(p.args) < 7:
                return
            
            f = p.args[1]
            if not isinstance(f, _translatica_classes_mensagem.get('CA')):
                return
            
            obj = get_private_field(f, "selectedObject")
            if not obj:
                return
            
            txt = next((a for a in p.args if isinstance(a, str) and len(a) > 5), None)
            if not txt:
                txt = _translatica_classes_mensagem.get('CU').getInstance().getMessageText(obj, None)
            if not txt:
                return
            
            lang = _translatica_classes_mensagem.get('TA').getToLanguage()
            
            # 1. Verifica Cache (Resposta Imediata)
            cached = self.plugin._translatica_obter_cache(str(txt), lang)
            if cached:
                self.plugin._translatica_aplicar_traducao_mensagem(obj, f, cached, lang)
                self.pending = True # Marca para fechar o alerta nativo
                return

            # 2. Tradução Async
            def on_translated(r):
                if r:
                    # Salva no cache
                    self.plugin._translatica_salvar_cache(str(txt), lang, r)
                    self.plugin._translatica_aplicar_traducao_mensagem(obj, f, r, lang)

            self.plugin._translatica_traduzir_google_async(str(txt), lang, on_translated)
            self.pending = True
        except:
            pass

    def after_hooked_method(self, p):
        if self.pending:
            try:
                res = p.getResult()
                if res:
                    res.dismiss()
            except:
                pass
            self.pending = False

class TranslaticaSettingsHeaderHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            activity = param.thisObject
            items = param.args[0]
            if not items or items.size() == 0:
                return
            
            plugin_obj = get_private_field(activity, "plugin")
            if not plugin_obj or str(plugin_obj.getId()) != "translatica":
                return
            
            if get_private_field(activity, "createSubFragmentCallback") is not None:
                return

            # Verifica se já tem o header para evitar duplicação
            
            header = self.plugin._criar_header_configuracao(activity.getContext())
            if header:
                from org.telegram.ui.Components import UItem
                try:
                    from com.exteragram.messenger.plugins.models import HeaderSetting
                    item = UItem.asCustom(header)
                    item.settingItem = HeaderSetting("translatica_header")
                except:
                    item = UItem.asCustom(header)
                
                try: item.setTransparent(True)
                except: pass
                
                # Adiciona no topo
                items.add(0, item)
                items.add(1, UItem.asShadow())
        except:
            pass

class Translatica(BasePlugin):
    # Sistema de desativação de logs
    _TRANSLATICA_LOGS_MUTED = False

    def _set_log_muted(self, muted: bool):
        try:
            Translatica._TRANSLATICA_LOGS_MUTED = bool(muted)
        except Exception:
            pass

    def onStart(self):
        try:
            super().onStart()
        except Exception:
            pass
        self._configurar_hook_header_configuracao()
        return True

    # API do Gemini
    def _show_gemini_api_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                # Se não há contexto UI, abre link diretamente
                self._open_gemini_api_link()
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            title_view = TextView(ctx)
            title_view.setText("Google Gemini")
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            desc_view = TextView(ctx)
            desc_view.setText(self._t("gemini_howto_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("get_gemini_api_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_gemini_api_link()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    # API do OpenRouter
    def _show_openrouter_api_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                self._open_openrouter_api_link()
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            title_view = TextView(ctx)
            title_view.setText(self._t("howto_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            try:
                WebView = self._find_class_safe("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                # Cache local da imagem e uso com base relativa
                _ = self._get_cached_image_src("https://i.postimg.cc/6prvBL0L/openrouter.png", "openrouter.png")
                html = """
                <html>
                <head>
                    <style>
                        body { margin: 0; padding: 0; background-color: transparent; }
                        img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                    </style>
                </head>
                <body>
                    <img src='openrouter.png' alt='API Banner'>
                </body>
                </html>
                """
                base = "file://" + self._get_cache_dir_path() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._layout_helper_create_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            desc_view = TextView(ctx)
            desc_view.setText(self._t("howto_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("get_api_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_openrouter_api_link()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            # Conteúdo do OpenRouter apenas (sem seção Gemini)

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _show_using_translatica_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            title_view = TextView(ctx)
            title_view.setText(self._t("using_translatica_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            try:
                WebView = self._find_class_safe("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                local_src = self._get_cached_image_src("https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExaDE3NmkyZmtzZXNzZ2ZsbmhqeHNwNTJuaHEyOTMxZ2I3b3JpaGt4eSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/2OfiQeMc1drQYdoARu/giphy.gif", "using_translatica.gif")
                html = f"""
                <html>
                <head>
                    <style>
                        body {{ margin: 0; padding: 0; background-color: transparent; }}
                        img {{ width: 100%; height: auto; display: block; margin-bottom: -4px; }}
                    </style>
                </head>
                <body>
                    <img src='{local_src}' alt='Banner'>
                </body>
                </html>
                """
                base = "file://" + self._get_cache_dir_path() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._layout_helper_create_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            desc_view = TextView(ctx)
            desc_view.setText(self._t("using_translatica_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("ok_button_label"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _show_check_before_dialog(self, text, original_text, params, is_caption):
        try:
            self._log("CheckBefore: _show_check_before_dialog chamado.")
            from ui.alert import AlertDialogBuilder
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    pass
            if not ctx:
                return

            builder = AlertDialogBuilder(ctx)
            builder.set_title("Check Before")
            
            # Formata mensagem com original vs resultado
            msg = (
                f"{self._t('check_before_original')}:\n"
                f"{original_text}\n\n"
                f"{self._t('check_before_result')}:\n"
                f"{text}"
            )
            builder.set_message(msg)
            
            # Enviar
            builder.set_positive_button(self._t("check_before_send"), lambda d, w: self._send_approved_text(params, text, is_caption))
            
            # Cancelar
            builder.set_negative_button(self._t("check_before_cancel"), lambda d, w: None)
            
            builder.show()
        except Exception:
            pass


    def _send_approved_text(self, params, text, is_caption):
        try:
            self._log(f"CheckBefore: Aprovado. Aplicando tradução...")
            # Debug: Log params info for channel diagnosis
            try:
                peer_id = getattr(params, "peer", "Unknown")
                self._log(f"CheckBefore: Envio para Peer ID: {peer_id}")
            except Exception:
                pass

            # Aplicar tradução
            self._apply_translation_result(params, text, is_caption)
            
            # Enviar
            self._suppress_next_hook = True
            
            # Feedback Tátil e Ondulação
            try:
                run_on_ui_thread(lambda: self._tocar_ripple_suave())
            except Exception:
                pass
            try:
                if self._get_bool_setting("haptic_feedback_ativado", False):
                    self._do_haptic_feedback()
            except Exception:
                pass
            try:
                if self._get_bool_setting("notify_ativado", False):
                    self._play_notify_sound()
            except Exception:
                pass
                
            from client_utils import get_send_messages_helper
            self._log("CheckBefore: Chamando sendMessage...")
            try:
                get_send_messages_helper().sendMessage(params)
                self._log("CheckBefore: sendMessage chamado com sucesso.")
            except Exception as e:
                self._log(f"CheckBefore: Erro ao chamar sendMessage: {e}")
                raise e
        except Exception as e:
            self._log(f"Erro crítico em _send_approved_text: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Send Error: {e}"))

    def _open_settings_check_before(self):
        try:
            from hook_utils import find_class
            PluginSettingsActivity = find_class("org.telegram.ui.PluginSettingsActivity")
            fragment = self.get_last_fragment_safe()
            if fragment and PluginSettingsActivity:
                fragment.presentFragment(PluginSettingsActivity(self))
        except Exception:
            pass



    def _log_wrapper(self, original_log):
        def wrapper(*args, **kwargs):
            try:
                if not Translatica._TRANSLATICA_LOGS_MUTED:
                    return original_log(*args, **kwargs)
            except Exception:
                return original_log(*args, **kwargs)
        return wrapper

    def _apply_log_wrapper(self):
        try:
            global log
            log = self._log_wrapper(log)
        except Exception:
            pass

    # Helper de log com prefixo do plugin
    def _log(self, message: str):
        try:
            # Tradução simples de mensagens comuns para português
            if "Tradução ignorada" in message: message = message.replace("Tradução ignorada", "Tradução ignorada")
            if "Traduzindo via" in message: message = message.replace("Traduzindo via", "Traduzindo via")
            if "Erro HTTP" in message: message = message.replace("Erro HTTP", "Erro HTTP")
            if "Erro JSON" in message: message = message.replace("Erro JSON", "Erro JSON")
            if "Falha na tradução" in message: message = message.replace("Falha na tradução", "Falha na tradução")
            if "Tradução concluída" in message: message = message.replace("Tradução concluída", "Tradução concluída")
            
            log(f"Translatica: {message}")
        except Exception:
            pass

    # Aplicar wrapper ao carregar classe
    _apply_log = True

    # Dicionário
    TRANSLATIONS = {
        
        "header_subtitle": {
            "en": "Adapts translations to real context",
            "pt": "Adapta traduções ao contexto real",
            "es": "Adapta las traducciones al contexto real",
            "ru": "Адаптирует переводы к реальному контексту",
            "cn": "根据实际语境调整翻译"
        },
        "config_required_title": {
            "en": "Configuration Required",
            "pt": "Configuração Necessária",
            "es": "Configuración Necesaria",
            "ru": "Требуется настройка",
            "cn": "需要配置"
        },
        "config_required_subtitle": {
            "en": "Please configure the API Key/URL for {0} to continue.",
            "pt": "Por favor, configure a chave API ou URL do {0} para continuar.",
            "es": "Por favor, configure la clave API o URL para {0} para continuar.",
            "ru": "Пожалуйста, настройте ключ API или URL для {0}, чтобы продолжить.",
            "cn": "请配置 {0} 的 API 密钥/URL 以继续。"
        },
        "plugin_lang_label": {
            "en": "Plugin Language",
            "pt": "Idioma do Plugin",
            "es": "Idioma del Plugin",
            "ru": "Язык плагина",
            "cn": "插件语言"
        },
        "target_lang_label": {
            "en": "Target Language",
            "pt": "Idioma Alvo",
            "es": "Idioma Objetivo",
            "ru": "Целевой язык",
            "cn": "目标语言"
        },
        "deeplx_experimental_warning": {
            "en": "DeepLX is an experimental service. Access requires an external account or invitation and is entirely your responsibility.",
            "pt": "O DeepLX é um serviço experimental. O acesso exige conta externa ou convite e é de sua total responsabilidade.",
            "es": "DeepLX es un servicio experimental. El acceso requiere una cuenta externa o invitación y es totalmente su responsabilidad.",
            "ru": "DeepLX — экспериментальный сервис. Доступ требует внешней учётной записи или приглашения и полностью лежит на вашей ответственности.",
            "cn": "DeepLX 是一个实验性服务。访问需要外部账户或邀请，完全由您负责。"
        },
        "check_before_ativado": {
            "en": "Enabled",
            "pt": "Ativado",
            "es": "Activado",
            "ru": "Включено",
            "cn": "已启用"
        },
        "check_before_desativado": {
            "en": "Disabled",
            "pt": "Desativado",
            "es": "Desactivado",
            "ru": "Выключено",
            "cn": "已禁用"
        },
        "check_before_send": {
            "en": "Send",
            "pt": "Enviar",
            "es": "Enviar",
            "ru": "Отправить",
            "cn": "发送"
        },
        "check_before_cancel": {
            "en": "Cancel",
            "pt": "Cancelar",
            "es": "Cancelar",
            "ru": "Отмена",
            "cn": "取消"
        },
        "modal_got_it": {
            "en": "Got it",
            "pt": "Entendi",
            "es": "Entendido",
            "ru": "Понятно",
            "cn": "明白了"
        },
        "auto_translate_subtext": {
            "en": "Translate all incoming messages and enable in-message translation.",
            "pt": "Traduz todas as mensagens recebidas e habilita a tradução dentro da mensagem.",
            "es": "Traduce todos los mensajes entrantes y habilita la traducción dentro del mensaje.",
            "ru": "Переводит все входящие сообщения и включает перевод внутри сообщения.",
            "cn": "翻译所有收到的消息并启用消息内翻译。"
        },
        "extended_settings_section_auto_trans": {
            "en": "Auto Translation",
            "pt": "Tradução Automática",
            "es": "Traducción Automática",
            "ru": "Автоматический перевод",
            "cn": "自动翻译"
        },
        "meaning_detector_info_text": {
            "en": "Prevents translation of common words (e.g., 'Ok', 'lol') and proper names to save resources and keep context.",
            "pt": "Impede a tradução de palavras comuns (ex: 'Ok', 'rs') e nomes próprios para economizar recursos e manter o contexto.",
            "es": "Evita la traducción de palabras comunes (ej. 'Ok', 'jaja') y nombres propios para ahorrar recursos y mantener el contexto.",
            "ru": "Предотвращает перевод общих слов (например, 'Ok', 'lol') и имен собственных для экономии ресурсов и сохранения контекста.",
            "cn": "防止翻译常用词（如 'Ok', 'lol'）和专有名词，以节省资源并保持上下文。"
        },

        "ai_settings_label": {
            "en": "AI Settings",
            "pt": "Configurações de IA",
            "es": "Configuración de IA",
            "ru": "Настройки ИИ",
            "cn": "AI 设置"
        },
        "alternate_ai_label": {
            "en": "Alternate AI Provider",
            "pt": "Alternar provedor de IA",
            "es": "Alternar proveedor de IA",
            "ru": "Чередовать провайдера ИИ",
            "cn": "切换 AI 提供商"
        },
        "alternate_ai_subtext": {
            "en": "Automatically alternates between configured AI providers to save resources.",
            "pt": "Alterna automaticamente entre os provedores de IA configurados para economizar recursos.",
            "es": "Alterna automáticamente entre proveedores de IA configurados para ahorrar recursos.",
            "ru": "Автоматически переключается между настроенными провайдерами ИИ для экономии ресурсов.",
            "cn": "自动在配置的 AI 提供商之间切换以节省资源。"
        },
        "explain_me_label": {
            "en": "Explain This",
            "pt": "Explicar isso",
            "es": "Explicar esto",
            "ru": "Пояснить это",
            "cn": "解释这个"
        },
        "explain_me_subtext": {
            "en": "Adds a context menu option that uses AI to explain the context of a selected message.",
            "pt": "Adiciona uma opção no menu de contexto que usa IA para explicar o contexto da mensagem selecionada.",
            "es": "Agrega una opción en el menú contextual que utiliza IA para explicar el contexto del mensaje seleccionado.",
            "ru": "Добавляет пункт в контекстное меню, использующий ИИ для объяснения контекста выбранного сообщения.",
            "cn": "添加一个上下文菜单选项，使用 AI 解释所选消息的上下文。"
        },
        "explain_me_menu_item": {
            "en": "Explain This",
            "pt": "Explicar isso",
            "es": "Explicar esto",
            "ru": "Пояснить это",
            "cn": "解释这个"
        },
        "silent_fix_label": {
            "en": "Silent Fix",
            "pt": "Correção Discreta",
            "es": "Corrección Discreta",
            "ru": "Тихая правка",
            "cn": "静默修正"
        },
        "silent_fix_subtext": {
            "en": "Corrects grammar and flow keeping original language. No translation.",
            "pt": "Corrige gramática e fluidez mantendo o idioma original. Sem tradução.",
            "es": "Corrige gramática y fluidez manteniendo el idioma original. Sin traducción.",
            "ru": "Исправляет грамматику и стиль, сохраняя исходный язык. Без перевода.",
            "cn": "修正语法和流畅度，保留原始语言。不翻译。"
        },
        "meaning_detector_label": {
            "en": "Meaning Detector",
            "pt": "Detector de Sentido",
            "es": "Detector de Significado",
            "ru": "Детектор смысла",
            "cn": "意义检测器"
        },
        "meaning_detector_subtext": {
            "en": "Prevents sending translations if the meaning is identical to the original (e.g. OK, lol, Thanks).",
            "pt": "Evita enviar traduções se o sentido for idêntico ao original (ex: OK, lol, Thanks).",
            "es": "Evita enviar traducciones si el significado es idéntico al original (ej. OK, lol, Thanks).",
            "ru": "Предотвращает отправку перевода, если смысл идентичен оригиналу (например, OK, lol, Thanks).",
            "cn": "如果含义与原文相同（例如 OK, lol, Thanks），则防止发送翻译。"
        },
        "meaning_detector_desativado": {
            "en": "Disabled",
            "pt": "Desativado",
            "es": "Desactivado",
            "ru": "Выключено",
            "cn": "已禁用"
        },
        "meaning_detector_ativado": {
            "en": "Enabled",
            "pt": "Ativado",
            "es": "Activado",
            "ru": "Включено",
            "cn": "已启用"
        },
        "pref_section_general": {
            "en": "General",
            "pt": "Geral",
            "es": "General",
            "ru": "Общие",
            "cn": "常规"
        },
        "pref_section_sending": {
            "en": "Sending",
            "pt": "Envio",
            "es": "Envío",
            "ru": "Отправка",
            "cn": "发送"
        },
        "pref_section_assistance": {
            "en": "Assistance",
            "pt": "Assistência",
            "es": "Asistencia",
            "ru": "Помощь",
            "cn": "辅助"
        },
        "pref_section_advanced": {
            "en": "Advanced",
            "pt": "Avançado",
            "es": "Avanzado",
            "ru": "Дополнительно",
            "cn": "高级"
        },
        "silent_fix_menu_item": {
            "en": "Silent Fix",
            "pt": "Corrigir Texto",
            "es": "Corregir Texto",
            "ru": "Исправить текст",
            "cn": "修正文本"
        },
        "silent_fix_processing": {
            "en": "Fixing...",
            "pt": "Corrigindo...",
            "es": "Corrigiendo...",
            "ru": "Исправляю...",
            "cn": "正在修正..."
        },
        "silent_fix_title": {
            "en": "Silent Fix",
            "pt": "Correção",
            "es": "Corrección",
            "ru": "Исправление",
            "cn": "修正"
        },
        "explanation_title": {
            "en": "Explanation",
            "pt": "Explicação",
            "es": "Explicación",
            "ru": "Объяснение",
            "cn": "解释"
        },
        "explanation_processing": {
            "en": "Translaticating...",
            "pt": "Translaticating...",
            "es": "Translaticating...",
            "ru": "Translaticating...",
            "cn": "Translaticating..."
        },
        "bullet_tokens_insufficient": {
            "en": "No tokens",
            "pt": "Sem tokens",
            "es": "Sin tokens",
            "ru": "Нет токенов",
            "cn": "无令牌"
        },
        "quickbite_default": {
            "en": "Standard",
            "pt": "Padrão",
            "es": "Estándar",
            "ru": "Стандарт",
            "cn": "标准"
        },
        # Temporário
        "quickbite_tldr": {
            "en": "TL;DR",
            "pt": "TL;DR",
            "es": "TL;DR",
            "ru": "TL;DR",
            "cn": "TL;DR"
        },
        "quickbite_whatisthis": {
            "en": "What is this?",
            "pt": "O que é isso?",
            "es": "¿Qué es esto?",
            "ru": "Что это?",
            "cn": "这是什么？"
        },
        "quickbite_info_title": {
            "en": "About QuickBite",
            "pt": "Sobre o QuickBite",
            "es": "Sobre QuickBite",
            "ru": "О QuickBite",
            "cn": "关于 QuickBite"
        },
        "quickbite_info_text": {
            "en": "QuickBite allows you to quickly get context or summaries of messages.\n\n• Standard: Explains context and meaning.\n• TL;DR: Concise bullet-point summary.\n\nNote: Selecting this option resets QuickBite to Standard mode.",
            "pt": "O QuickBite permite obter rapidamente o contexto ou resumos de mensagens.\n\n• Padrão: Explica o contexto e significado.\n• TL;DR: Resumo conciso em tópicos.\n\nNota: Selecionar esta opção redefine o QuickBite para o modo Padrão.",
            "es": "QuickBite le permite obtener rápidamente contexto o resúmenes de mensajes.\n\n• Estándar: Explica el contexto y el significado.\n• TL;DR: Resumen conciso en viñetas.\n\nNota: Seleccionar esta opción restablece QuickBite al modo Estándar.",
            "ru": "QuickBite позволяет быстро получить контекст или сводку сообщений.\n\n• Стандарт: Объясняет контекст и смысл.\n• TL;DR: Краткое резюме по пунктам.\n\nПримечание: Выбор этой опции сбрасывает QuickBite в стандартный режим.",
            "cn": "QuickBite 允许您快速获取消息的上下文或摘要。\n\n• 标准：解释上下文和含义。\n• TL;DR：简洁的要点摘要。\n\n注意：选择此选项会将 QuickBite 重置为标准模式。"
        },
        # Temporário
        "addl_label": {
            "en": "AddL",
            "pt": "AddL",
            "es": "AddL",
            "ru": "AddL",
            "cn": "AddL"
        },
        "addl_subtext": {
            "en": "Sends a second translation in another language in the same message.",
            "pt": "Envia uma segunda tradução em outro idioma na mesma mensagem.",
            "es": "Envía una segunda traducción en otro idioma en el mismo mensaje.",
            "ru": "Отправляет второй перевод на другом языке в одном и том же сообщении.",
            "cn": "在同一条消息中发送另一种语言的第二次翻译。"
        },
        "addl_lang_label": {
            "en": "AddL Language",
            "pt": "Idioma Extra",
            "es": "Idioma Extra",
            "ru": "Доп. язык",
            "cn": "额外语言"
        },
        "addl_style_label": {
            "en": "AddL Style",
            "pt": "Estilo AddL",
            "es": "Estilo AddL",
            "ru": "Стиль AddL",
            "cn": "AddL 风格"
        },
        "addl_style_default": {
            "en": "Default",
            "pt": "Padrão",
            "es": "Estándar",
            "ru": "Стандарт",
            "cn": "标准"
        },
        "addl_style_quote": {
            "en": "Quote",
            "pt": "Citação",
            "es": "Cita",
            "ru": "Цитата",
            "cn": "引用"
        },
        "addl_style_quote_collapsed": {
            "en": "Compact Quote",
            "pt": "Citação Compactada",
            "es": "Cita Compactada",
            "ru": "Компактная цитата",
            "cn": "紧凑引用"
        },
        "openai_quota_exceeded": {
            "en": "OpenAI: Quota exceeded. Check your billing.",
            "pt": "OpenAI: Cota excedida. Verifique seu faturamento.",
            "es": "OpenAI: Cuota excedida. Verifique su facturación.",
            "ru": "OpenAI: Квота превышена. Проверьте оплату.",
            "cn": "OpenAI: 配额已满。请检查账单。"
        },
        "ee_not_here": {
            "en": "Not here, friend.",
            "pt": "Não é aqui, amigo.",
            "es": "Aquí no, amigo.",
            "ru": "Не здесь, друг.",
            "cn": "不在这里，朋友。"
        },
        "translation_section": {
            "en": "Translation",
            "pt": "Tradução",
            "es": "Traducción",
            "ru": "Перевод",
            "cn": "翻译"
        },
        "help_section": {
            "en": "Help",
            "pt": "Ajuda",
            "es": "Ayuda",
            "ru": "Помощь",
            "cn": "帮助"
        },
        "extras_section": {
            "en": "Extras",
            "pt": "Extras",
            "es": "Extras",
            "ru": "Дополнительно",
            "cn": "额外"
        },
        "welcome_brief": {
            "en": "Welcome, {name}!\n\nTo start, configure your API Key. Need help? Join our [Community](https://t.me/+AYowC0lrZitjNDQx).",
            "pt": "Bem-vindo(a), {name}!\n\nPara começar, configure sua API Key. Precisa de ajuda? Entre na [Comunidade](https://t.me/+AYowC0lrZitjNDQx).",
            "es": "¡Bienvenido(a), {name}!\n\nPara empezar, configura tu API Key. ¿Ayuda? Únete a la [Comunidad](https://t.me/+AYowC0lrZitjNDQx).",
            "ru": "Привет, {name}!\n\nДля начала настройте API Key. Нужна помощь? Вступайте в [Сообщество](https://t.me/+AYowC0lrZitjNDQx).",
            "cn": "欢迎，{name}！\n\n请先配置 API Key。需要帮助？加入[社区](https://t.me/+AYowC0lrZitjNDQx)."
        },
        "logs_disable_subtext": {
            "en": "Hides plugin logs and notifications",
            "pt": "Oculta logs e notificações do plugin",
            "es": "Oculta registros y notificaciones del plugin",
            "ru": "Скрывает логи и уведомления плагина",
            "cn": "隐藏插件日志和通知"
        },
        "using_translatica_label": {
            "en": "Using Translatica",
            "pt": "Usando o Translatica",
            "es": "Usando Translatica",
            "ru": "Как пользоваться Translatica",
            "cn": "使用 Translatica"
        },
        "using_translatica_title": {
            "en": "Using Translatica",
            "pt": "Usando o Translatica",
            "es": "Usando Translatica",
            "ru": "Как пользоваться Translatica",
            "cn": "使用 Translatica"
        },
        "experimental_section": {
            "en": "Experimental",
            "pt": "Experimental",
            "es": "Experimental",
            "ru": "Экспериментальный",
            "cn": "实验性"
        },
        "experimental_providers_switch": {
            "en": "Experimental AI Providers",
            "pt": "Provedores Experimentais",
            "es": "Proveedores Experimentales",
            "ru": "Экспериментальные провайдеры ИИ",
            "cn": "实验性 AI 提供商"
        },
        "experimental_providers_subtext": {
            "en": "Enables experimental AI providers (Cerebras, llm7.io) that are still under evaluation.",
            "pt": "Habilita provedores de IA experimentais (Cerebras, llm7.io) que ainda estão em avaliação.",
            "es": "Habilita proveedores de IA experimentales (Cerebras, llm7.io) que aún están en evaluación.",
            "ru": "Включает экспериментальные ИИ-провайдеры (Cerebras, llm7.io), которые находятся в стадии оценки.",
            "cn": "启用仍在评估中的实验性 AI 提供商（Cerebras，llm7.io）。"
        },
        "cerebras_api_key_label": {
            "en": "Cerebras API Key",
            "pt": "Chave API Cerebras",
            "es": "Clave API Cerebras",
            "ru": "Ключ API Cerebras",
            "cn": "Cerebras API 密钥"
        },
        "get_cerebras_api_button": {
            "en": "Get Cerebras API Key",
            "pt": "Obter Chave API Cerebras",
            "es": "Obtener Clave API Cerebras",
            "ru": "Получить ключ API Cerebras",
            "cn": "获取 Cerebras API 密钥"
        },
        "llm7_api_key_label": {
            "en": "llm7.io API Key",
            "pt": "Chave API llm7.io",
            "es": "Clave API llm7.io",
            "ru": "Ключ API llm7.io",
            "cn": "llm7.io API 密钥"
        },
        "get_llm7_api_button": {
            "en": "Get llm7.io API Key",
            "pt": "Obter Chave API llm7.io",
            "es": "Obtener Clave API llm7.io",
            "ru": "Получить ключ API llm7.io",
            "cn": "获取 llm7.io API 密钥"
        },
        "llm7_model_selector_label": {
            "en": "llm7.io Model Selector",
            "pt": "Seletor de Modelo llm7.io",
            "es": "Selector de Modelo llm7.io",
            "ru": "Выбор модели llm7.io",
            "cn": "llm7.io 模型选择器"
        },
        "cerebras_description": {
            "en": "Experimental provider. Fast inference with large models.\nRequires API Key from cloud.cerebras.ai.",
            "pt": "Provedor experimental. Inferência rápida com modelos grandes.\nRequer API Key em cloud.cerebras.ai.",
            "es": "Proveedor experimental. Inferencia rápida con modelos grandes.\nRequiere clave API de cloud.cerebras.ai.",
            "ru": "Экспериментальный провайдер. Быстрый вывод с большими моделями.\nТребуется ключ API от cloud.cerebras.ai.",
            "cn": "实验性提供商。大模型快速推理。\n需要来自 cloud.cerebras.ai 的 API 密钥。"
        },
        "llm7_description": {
            "en": "Experimental provider. Some models are free and do not require an API Key (leave blank).\nUse 'default' or 'fast' for automatic selection.",
            "pt": "Provedor experimental. Alguns modelos são gratuitos e não exigem API Key (deixe em branco).\nUse 'default' ou 'fast' para seleção automática.",
            "es": "Proveedor experimental. Algunos modelos son gratuitos y no requieren clave API (dejar en blanco).\nUse 'default' o 'fast' para selección automática.",
            "ru": "Экспериментальный провайдер. Некоторые модели бесплатны и не требуют ключа API (оставьте пустым).\nИспользуйте 'default' или 'fast' для автоматического выбора.",
            "cn": "实验性提供商。某些模型是免费的，不需要 API 密钥（留空）。\n使用 'default' 或 'fast' 进行自动选择。"
        },
        "llm7_model_default": {
            "en": "Default (First Available)",
            "pt": "Padrão (Primeiro Disponível)",
            "es": "Predeterminado (Primero Disponible)",
            "ru": "По умолчанию (Первый доступный)",
            "cn": "默认（第一个可用）"
        },
        "llm7_model_fast": {
            "en": "Fastest (Low Latency)",
            "pt": "Mais Rápido (Baixa Latência)",
            "es": "Más Rápido (Baja Latencia)",
            "ru": "Самый быстрый (Низкая задержка)",
            "cn": "最快（低延迟）"
        },
        "extended_settings_title": {
            "en": "Extended Settings",
            "pt": "Extended Settings",
            "es": "Extended Settings",
            "ru": "Расширенные настройки",
            "cn": "扩展设置"
        },
        "filter_switch": {
            "en": "Filter Words",
            "pt": "Filtrar Palavras",
            "es": "Filtrar Palabras",
            "ru": "Фильтровать слова",
            "cn": "过滤词"
        },
        "filter_switch_sub": {
            "en": "Enable word filtering during translation.",
            "pt": "Ativa a filtragem de palavras durante a tradução.",
            "es": "Habilita el filtrado de palabras durante la traducción.",
            "ru": "Включает фильтрацию слов при переводе.",
            "cn": "在翻译过程中启用单词过滤。"
        },
        "filter_input": {
            "en": "Words to filter",
            "pt": "Palavras para filtrar",
            "es": "Palabras para filtrar",
            "ru": "Слова для фильтрации",
            "cn": "要过滤的词"
        },
        "filtro_label": {
            "en": "Filter",
            "pt": "Filtro",
            "es": "Filtro",
            "ru": "Фильтр",
            "cn": "过滤"
        },
        "filtro_input_label": {
            "en": "Words to ignore (comma separated)",
            "pt": "Palavras para não traduzir (separadas por vírgula)",
            "es": "Palabras para no traducir (separadas por coma)",
            "ru": "Слова для игнорирования (через запятую)",
            "cn": "忽略的词（逗号分隔）"
        },
        "filtro_subtext": {
            "en": "Words added here will be completely ignored during translation, keeping their original form.",
            "pt": "Palavras adicionadas aqui serão completamente ignoradas durante a tradução, mantendo sua forma original.",
            "es": "Las palabras añadidas aquí serán completamente ignoradas durante la traducción, manteniendo su forma original.",
            "ru": "Слова, добавленные сюда, будут полностью игнорироваться при переводе, сохраняя свою исходную форму.",
            "cn": "在此处添加的单词将在翻译过程中被完全忽略，保持其原始形式。"
        },
        "filtro_unlocked_msg": {
            "en": "You unlocked something!",
            "pt": "Você desbloqueou algo!",
            "es": "¡Desbloqueaste algo!",
            "ru": "Вы что-то разблокировали!",
            "cn": "你解锁了一些东西！"
        },
        "cmd_reset_success": {
            "en": "All chat overrides have been reset",
            "pt": "Todos os chats foram resetados",
            "es": "Todos los chats han sido restablecidos",
            "ru": "Все настройки чатов сброшены",
            "cn": "所有聊天覆盖已重置"
        },
        "using_translatica_description": {
            "en": "Translatica requires an API key to translate messages. You can use OpenRouter or Google Gemini, and you can also add your own AI provider using any OpenAI compatible endpoint.\n\nChoose the provider in the settings, enter the corresponding API key and select a model. Enable or disable Translatica through chat menu > plugins, or by sending .on (enable) and .off (disable).\n\nPer chat: use .add to activate translations in the current chat, and .del to deactivate them.\n\nLanguage override per chat: send .add followed by a language code (en, pt, es, ru or cm) to force that language. Example: .add en. Send .add reset to remove the override.\n\nIf any chats are added, translations run only in those chats except the ones desativado with .del. Otherwise, translations run in all chats except the ones desativado with .del.",
            "pt": "O Translatica exige uma chave de API para traduzir mensagens. Você pode usar OpenRouter ou Google Gemini e também pode adicionar seu próprio provedor de IA usando qualquer endpoint compatível com OpenAI.\n\nEscolha o provedor nas configurações, informe a chave correspondente e selecione um modelo. Ative ou desative o Translatica pelo menu do chat > plugins ou enviando .on (ativar) e .off (desativar).\n\nPor chat: use .add para ativar traduções no chat atual e .del para desativá-las.\n\nIdioma por chat: envie .add seguido de um código de idioma (en, pt, es, ru ou cm) para fixar o idioma. Exemplo: .add pt. Envie .add reset para remover o idioma definido.\n\nSe houver chats adicionados, as traduções funcionarão apenas neles, exceto os desativados com .del. Caso contrário, funcionarão em todos os chats, exceto os desativados com .del.",
            "es": "Translatica requiere una clave de API para traducir mensajes. Puedes usar OpenRouter o Google Gemini y también puedes añadir tu propio proveedor de IA usando cualquier endpoint compatible con OpenAI.\n\nElige el proveedor en la configuración, introduce la clave correspondiente y selecciona un modelo. Activa o desactiva Translatica desde el menú del chat > plugins o enviando .on (activar) y .off (desactivar).\n\nPor chat: usa .add para activar traducciones en el chat actual y .del para desactivarlas.\n\nIdioma por chat: envía .add seguido de un código de idioma (en, pt, es, ru o cm) para fijar el idioma. Ejemplo: .add es. Envía .add reset para quitar el idioma fijado.\n\nSi hay chats añadidos, las traducciones se ejecutarán solo en ellos excepto los desactivados con .del. De lo contrario, se ejecutarán en todos los chats excepto los desactivados con .del.",
            "ru": "Для работы Translatica требуется ключ API. Можно использовать OpenRouter или Google Gemini, а также можно добавить собственного провайдера ИИ через любой совместимый с OpenAI endpoint.\n\nВыберите провайдера в настройках, укажите ключ и модель. Включать или выключать Translatica можно через меню чата > плагины или командами .on и .off.\n\nДля каждого чата: используйте .add, чтобы включить перевод в текущем чате, и .del, чтобы выключить его.\n\nЯзык для чата: отправьте .add с кодом языка (en, pt, es, ru или cm), чтобы закрепить язык. Пример: .add ru. Отправьте .add reset, чтобы убрать закрепление.\n\nЕсли есть чаты, добавленные через .add, перевод будет работать только в них, кроме отключенных через .del. В остальных случаях перевод работает во всех чатах, кроме отключенных через .del.",
            "cn": "Translatica 需要 API 密钥来翻译消息。您可以使用 OpenRouter 或 Google Gemini，也可以使用任何兼容 OpenAI 的端点添加自己的 AI 提供商。\n\n在设置中选择提供商，输入相应的 API 密钥并选择模型。通过聊天菜单 > 插件或发送 .on（启用）和 .off（禁用）来启用或禁用 Translatica。\n\n每个聊天：使用 .add 激活当前聊天的翻译，使用 .del 停用。\n\n每个聊天的语言覆盖：发送 .add 后跟语言代码（en, pt, es, ru 或 cm）以强制使用该语言。例如：.add zh。发送 .add reset 以移除覆盖。\n\n如果有添加的聊天，翻译仅在这些聊天中运行，除了用 .del 禁用的那些。否则，翻译将在除用 .del 禁用的那些以外的所有聊天中运行。"
        },
        "ok_button_label": {
            "en": "Understood",
            "pt": "Entendido",
            "es": "Entendido",
            "ru": "Понятно",
            "cn": "明白了"
        },
        "cmd_on_success": {
            "en": "Translations ativado",
            "pt": "Traduções ativadas",
            "es": "Traducciones activadas",
            "ru": "Перевод включен",
            "cn": "翻译已启用"
        },
        "cmd_on_already_on": {
            "en": "Already ativado",
            "pt": "Já está ativado",
            "es": "Ya está activado",
            "ru": "Уже включено",
            "cn": "已启用"
        },
        "cmd_off_success": {
            "en": "Translations desativado",
            "pt": "Traduções desativadas",
            "es": "Traducciones desactivadas",
            "ru": "Перевод выключен",
            "cn": "翻译已禁用"
        },
        "cmd_off_already_off": {
            "en": "Already desativado",
            "pt": "Já está desativado",
            "es": "Ya está desactivado",
            "ru": "Уже выключено",
            "cn": "已禁用"
        },
        "cmd_add_success": {
            "en": "Chat added to ativado list",
            "pt": "Chat adicionado à lista de ativados",
            "es": "Chat añadido a la lista de activados",
            "ru": "Чат добавлен в список включённых",
            "cn": "聊天已添加到启用列表"
        },
        "cmd_add_already": {
            "en": "Chat already in ativado list",
            "pt": "Chat já está na lista de ativados",
            "es": "El chat ya está en la lista de activados",
            "ru": "Чат уже в списке включённых",
            "cn": "聊天已在启用列表中"
        },
        "cmd_del_success": {
            "en": "Chat removed from ativado list",
            "pt": "Chat removido da lista de ativados",
            "es": "Chat eliminado de la lista de activados",
            "ru": "Чат удалён из списка включённых",
            "cn": "聊天已从启用列表中移除"
        },
        "cmd_del_already": {
            "en": "Chat was not in ativado list",
            "pt": "Chat não estava na lista de ativados",
            "es": "El chat no estaba en la lista de activados",
            "ru": "Чат отсутствовал в списке включённых",
            "cn": "聊天不在启用列表中"
        },
        "cmd_add_lang_success": {
            "en": "Chat ativado with language {lang}",
            "pt": "Chat ativado com idioma {lang}",
            "es": "Chat activado con idioma {lang}",
            "ru": "Чат включён с языком {lang}",
            "cn": "聊天已启用，语言为 {lang}"
        },
        "cmd_add_lang_reset": {
            "en": "Chat language override removed",
            "pt": "Idioma do chat redefinido",
            "es": "Idioma del chat restablecido",
            "ru": "Переопределение языка чата удалено",
            "cn": "聊天语言覆盖已移除"
        },
        "cmd_block_success": {
            "en": "Chat desativado for translations",
            "pt": "Chat desativado para traduções",
            "es": "Chat desactivado para traducciones",
            "ru": "Чат отключён для перевода",
            "cn": "聊天已禁用翻译"
        },
        "cmd_block_already": {
            "en": "Chat já desativado",
            "pt": "Chat já está desativado",
            "es": "El chat ya está desactivado",
            "ru": "Чат уже отключён",
            "cn": "聊天已禁用"
        },
        "my_chat_ativado_label": {
            "en": "My Chat",
            "pt": "Meu Chat",
            "es": "Mi Chat",
            "ru": "Мой Чат",
            "cn": "我的聊天"
        },
        "my_chat_ativado_subtext": {
            "en": "Adds 'My Chat' to the chat's three-dot menu, allowing you to quickly set the target language for that specific chat.",
            "pt": "Adiciona 'Meu Chat' ao menu de três pontos do chat, permitindo definir rapidamente o idioma alvo apenas para aquele chat.",
            "es": "Agrega 'Mi Chat' al menú de tres puntos del chat, lo que permite configurar rápidamente el idioma de destino para ese chat específico.",
            "ru": "Добавляет пункт «Мой чат» в меню с тремя точками чата, позволяя быстро задать целевой язык именно для этого чата.",
            "cn": "将“我的聊天”添加到聊天的三点菜单中，用于快速设置该聊天的目标语言。"
        },
        "my_chat_menu_item": {
            "en": "My Chat",
            "pt": "Meu Chat",
            "es": "Mi Chat",
            "ru": "Мой Чат",
            "cn": "我的聊天"
        },
        "check_before_original": {
            "en": "Original",
            "pt": "Original",
            "es": "Original",
            "ru": "Оригинал",
            "cn": "原来的"
        },
        "check_before_result": {
            "en": "Result",
            "pt": "Resultado",
            "es": "Resultado",
            "ru": "Результат",
            "cn": "结果"
        },
        "cmd_dialog_not_found": {
            "en": "Could not identify this chat",
            "pt": "Não foi possível identificar este chat",
            "es": "No fue posible identificar este chat",
            "ru": "Не удалось определить этот чат",
            "cn": "无法识别此聊天"
        },
        "reply_mode_label": {
            "en": "Reply Mode",
            "pt": "Modo Resposta",
            "es": "Modo Resposta",
            "ru": "Режим ответа",
            "cn": "回复模式"
        },
        "reply_mode_subtext": {
            "en": "Automatically translates your reply to the language of the message you are replying to",
            "pt": "Traduz automaticamente sua resposta para o idioma da mensagem que você está respondendo",
            "es": "Traduce automáticamente tu respuesta al idioma del mensaje al que estás respondiendo",
            "ru": "Автоматически переводит ваш ответ на язык сообщения, на которое вы отвечаете",
            "cn": "自动将您的回复翻译为您正在回复的消息的语言"
        },
        "profanity_normal": {
            "en": "Normal",
            "pt": "Normal",
            "es": "Normal",
            "ru": "Нормально",
            "cn": "正常"
        },
        "profanity_soften": {
            "en": "Soften words",
            "pt": "Suavizar palavras",
            "es": "Suavizar palabras",
            "ru": "Смягчить слова",
            "cn": "软化词语"
        },
        "profanity_keep": {
            "en": "Keep swear words",
            "pt": "Manter palavrões",
            "es": "Mantener palabrotas",
            "ru": "Оставить мат",
            "cn": "保留脏话"
        },
        "profanity_censor_std": {
            "en": "Standard censor",
            "pt": "Censurar padrão",
            "es": "Censura estándar",
            "ru": "Стандартная цензура",
            "cn": "标准审查"
        },
        "profanity_censor_spoiler": {
            "en": "Spoiler censor",
            "pt": "Censurar spoiler",
            "es": "Censura spoiler",
            "ru": "Цензура спойлером",
            "cn": "剧透审查"
        },
        "profanity_label": {
            "en": "Profanity Filter",
            "pt": "Filtro de Palavrões",
            "es": "Filtro de Groserías",
            "ru": "Фильтр мата",
            "cn": "脏话过滤"
        },
        "chats_label": {
            "en": "Chats",
            "pt": "Conversas",
            "es": "Chats",
            "ru": "Чаты",
            "cn": "聊天"
        },
        "keep_target_label": {
            "en": "Keep My Target",
            "pt": "Manter Idioma Alvo",
            "es": "Mantener Idioma Objetivo",
            "ru": "Сохранить целевой язык",
            "cn": "保持目标语言"
        },
        "keep_target_subtext": {
            "en": "Ensures non-reply messages are translated to the selected Target Language",
            "pt": "Garante que mensagens sem resposta sejam traduzidas para o Idioma Alvo selecionado",
            "es": "Garantiza que los mensajes sin respuesta se traduzcan al Idioma Objetivo seleccionado",
            "ru": "Гарантирует, что сообщения без ответа будут переведены на выбранный целевой язык",
            "cn": "确保无回复消息被翻译为选定的目标语言"
        },
        "fast_mode_label": {
            "en": "Fast send mode",
            "pt": "Modo rápido de envio",
            "es": "Modo de envío rápido",
            "ru": "Быстрый режим отправки",
            "cn": "快速发送模式"
        },
        "notify_ativado": {
            "en": "Notify",
            "pt": "Notify",
            "es": "Notify",
            "ru": "Notify",
            "cn": "通知"
        },
        "notify_subtext": {
            "en": "Notification sound on send",
            "pt": "Som de notificação ao enviar",
            "es": "Sonido de notificación al enviar",
            "ru": "Звук уведомления при отправке",
            "cn": "发送时的通知声音"
        },
        "fast_mode_subtext": {
            "en": "Experimental mode. Prioritizes speed using a lighter model with fewer tokens",
            "pt": "Modo experimental. Prioriza a velocidade usando um modelo mais leve e menos tokens",
            "es": "Modo experimental. Prioriza la velocidad usando un modelo más ligero y menos tokens",
            "ru": "Экспериментальный режим. Приоритет скорости за счёт более лёгкой модели и меньшего количества токенов",
            "cn": "实验模式。使用更轻量级、令牌更少的模型优先考虑速度"
        },
        "lang_custom": {
            "en": "Custom",
            "pt": "Custom",
            "es": "Personalizado",
            "ru": "Пользовательский",
            "cn": "自定义"
        },
        "custom_lang_label": {
            "en": "Custom language",
            "pt": "Idioma personalizado",
            "es": "Idioma personalizado",
            "ru": "Пользовательский язык",
            "cn": "自定义语言"
        },
        "custom_lang_subtext": {
            "en": "Type any language name, for example: Hindi, French, Italian",
            "pt": "Digite o nome de qualquer idioma, por exemplo: Hindi, Francês, Italiano",
            "es": "Escribe el nombre de cualquier idioma, por ejemplo: Hindi, Francés, Italiano",
            "ru": "Введите название любого языка, например: хинди, французский, итальянский",
            "cn": "输入任何语言名称，例如：印地语、法语、意大利语"
        },
        "api_key_label": {
            "en": "API Key",
            "pt": "Chave de API",
            "es": "Clave de API",
            "ru": "Ключ API",
            "cn": "API 密钥"
        },
        "ai_provider_label": {
            "en": "AI Provider",
            "pt": "Provedor de IA",
            "es": "Proveedor de IA",
            "ru": "Провайдер ИИ",
            "cn": "AI 提供商"
        },
        "ai_provider_custom": {
            "en": "Custom",
            "pt": "Custom",
            "es": "Personalizado",
            "ru": "Пользовательский",
            "cn": "自定义"
        },
        
        "openrouter_api_key_label": {
            "en": "OpenRouter API Key",
            "pt": "Chave OpenRouter",
            "es": "Clave OpenRouter",
            "ru": "Ключ OpenRouter",
            "cn": "OpenRouter 密钥"
        },
        "gemini_api_key_label": {
            "en": "Gemini API Key",
            "pt": "Chave do Gemini",
            "es": "Clave de Gemini",
            "ru": "Ключ Gemini",
            "cn": "Gemini 密钥"
        },
        "get_api_help_label": {
            "en": "Get the API",
            "pt": "Obter a API",
            "es": "Obtener la API",
            "ru": "Получить API",
            "cn": "获取 API"
        },
        "get_openrouter_api_label": {
            "en": "Get OpenRouter API",
            "pt": "Obter API do OpenRouter",
            "es": "Obtener API de OpenRouter",
            "ru": "Получить API OpenRouter",
            "cn": "获取 OpenRouter API"
        },
        "get_gemini_api_button": {
            "en": "Get Gemini API",
            "pt": "Obter API do Gemini",
            "es": "Obtener API de Gemini",
            "ru": "Получить API Gemini",
            "cn": "获取 Gemini API"
        },
        "custom_api_url_label": {
            "en": "Custom API URL",
            "pt": "URL de API (custom)",
            "es": "URL de API (custom)",
            "ru": "URL API (кастом)",
            "cn": "API URL (自定义)"
        },
        "custom_api_key_label": {
            "en": "Custom API Key",
            "pt": "Chave de API (custom)",
            "es": "Clave de API (custom)",
            "ru": "Ключ API (кастом)",
            "cn": "API 密钥 (自定义)"
        },
        "custom_model_label": {
            "en": "Custom model",
            "pt": "Modelo (custom)",
            "es": "Modelo (custom)",
            "ru": "Модель (кастом)",
            "cn": "模型 (自定义)"
        },
        "howto_title": {
            "en": "Get the API",
            "pt": "Obter a API",
            "es": "Obtener la API",
            "ru": "Получить API",
            "cn": "获取 API"
        },
        "howto_description": {
            "en": "You need an OpenRouter API key to use AI models through this service.",
            "pt": "Você precisa de uma chave de API do OpenRouter para usar os modelos por meio deste serviço.",
            "es": "Necesitas una clave de API de OpenRouter para usar los modelos a través de este servicio.",
            "ru": "Вам нужен ключ API OpenRouter, чтобы использовать модели через этот сервис.",
            "cn": "您需要 OpenRouter API 密钥才能通过此服务使用 AI 模型。"
        },
        
        "gemini_howto_description": {
            "en": "Go to aistudio.google.com/apikey, sign in and create an API key. This provider uses an OpenAI-compatible endpoint.",
            "pt": "Acesse aistudio.google.com/apikey, faça login e crie uma chave de API. Este provedor usa um endpoint compatível com OpenAI.",
            "es": "Ve a aistudio.google.com/apikey, inicia sesión y crea una clave de API. Este proveedor usa un endpoint compatible con OpenAI.",
            "ru": "Перейдите на aistudio.google.com/apikey, войдите и создайте ключ API. Этот провайдер использует совместимый с OpenAI endpoint.",
            "cn": "转到 aistudio.google.com/apikey，登录并创建 API 密钥。此提供商使用与 OpenAI 兼容的端点。"
        },
        "get_api_button": {
            "en": "Get the API",
            "pt": "Obter a API",
            "es": "Obtener la API",
            "ru": "Получить API",
            "cn": "获取 API"
        },
        "model_label": {
            "en": "Model",
            "pt": "Modelo",
            "es": "Modelo",
            "ru": "Модель",
            "cn": "模型"
        },
        "model_creativity_section": {
            "en": "Model & Creativity",
            "pt": "Modelo e Criatividade",
            "es": "Modelo y Creatividad",
            "ru": "Модель и Креативность",
            "cn": "模型与创造力"
        },
        "temperature_label": {
            "en": "Creativity",
            "pt": "Criatividade",
            "es": "Creatividad",
            "ru": "Креативность",
            "cn": "创造力"
        },  
        "quick_dismiss_subtext": {
            "en": "Shows an alert when sending a text",
            "pt": "Exibe um alerta ao enviar texto",
            "es": "Muestra una alerta al enviar texto",
            "ru": "Показывает предупреждение при отправке текста",
            "cn": "发送文本时显示警报"
        },
        
        "aura_subtext": {
            "en": "Displays a subtle ripple effect when sending",
            "pt": "Exibe um efeito ripple sutil ao enviar",
            "es": "Muestra un efecto ripple sutil al enviar",
            "ru": "Отображает тонкий эффект ряби при отправке",
            "cn": "发送时显示微妙的波纹效果"
        },
        "logs_disable_label": {
            "en": "Disable Logs",
            "pt": "Desativar Logs",
            "es": "Desactivar Logs",
            "ru": "Отключить логи",
            "cn": "禁用日志"
        },
        "quick_dismiss_alert_text": {
            "en": "Message is being sent",
            "pt": "Mensagem sendo enviada",
            "es": "Mensaje siendo enviado",
            "ru": "Сообщение отправляется",
            "cn": "消息正在发送"
        },
        "chat_overrides_title": {
            "en": "Languages per chat",
            "pt": "Idiomas por chat",
            "es": "Idiomas por chat",
            "ru": "Языки по чатам",
            "cn": "每个聊天的语言"
        },
        "chat_overrides_empty": {
            "en": "No chat with a fixed language (.add lang)",
            "pt": "Nenhum chat com idioma fixado (.add lang)",
            "es": "Ningún chat con idioma fijado (.add lang)",
            "ru": "Нет чатов с закреплённым языком (.add lang)",
            "cn": "没有固定语言的聊天 (.add lang)"
        },
        "lang_english": {
            "en": "English",
            "pt": "Inglês",
            "es": "Inglés",
            "ru": "Английский",
            "cn": "英语"
        },
        "lang_portuguese": {
            "en": "Portuguese",
            "pt": "Português",
            "es": "Portugués",
            "ru": "Португальский",
            "cn": "葡萄牙语"
        },
        "lang_spanish": {
            "en": "Spanish",
            "pt": "Espanhol",
            "es": "Español",
            "ru": "Испанский",
            "cn": "西班牙语"
        },
        "lang_russian": {
            "en": "Russian",
            "pt": "Russo",
            "es": "Ruso",
            "ru": "Русский",
            "cn": "俄语"
        },
        "lang_chinese_simplified": {
            "en": "Chinese Simplified",
            "pt": "Chinês Simplificado",
            "es": "Chino Simplificado",
            "ru": "Китайский упрощенный",
            "cn": "简体中文"
        },
        "plugin_ativado_msg": {
            "en": "Translatica ativado",
            "pt": "Translatica ativado",
            "es": "Translatica activado",
            "ru": "Translatica включен",
            "cn": "Translatica 已启用"
        },
        "plugin_desativado_msg": {
            "en": "Translatica desativado",
            "pt": "Translatica desativado",
            "es": "Translatica desactivado",
            "ru": "Translatica выключен",
            "cn": "Translatica 已禁用"
        },
        
        "support_title": {
            "en": "Support",
            "pt": "Suporte",
            "es": "Soporte",
            "ru": "Поддержка",
            "cn": "支持"
        },
        "support_description": {
            "pt": "Oi. Sou o Apple, desenvolvedor de plugins e projetos independentes. Se você curtiu, pode apoiar enviando um presente pelo Telegram. É só tocar no meu nome de usuário ou me chamar se quiser ajudar de outra forma. Seu apoio mantém os projetos ativos e novas ideias ganhando vida. Obrigado.",
            "en": "Hey. I am Apple, a developer of plugins and independent projects. If you like what I do, you can support it by sending a gift on Telegram. Just tap my username or reach out if you’d like to help in another way. Your support keeps the projects alive and new ideas coming. Thank you.",
            "ru": "Привет. Я Apple, разработчик плагинов и независимых проектов. Если вам нравится моя работа, вы можете поддержать меня, отправив подарок в Telegram. Просто нажмите на мое имя пользователя или напишите мне, если хотите помочь другим способом. Ваша поддержка помогает проектам развиваться и воплощать новые идеи. Спасибо.",
            "cn": "嘿。我是 Apple，插件和独立项目的开发者。如果你喜欢我所做的，你可以通过在 Telegram 上发送礼物来支持。如果你想以其他方式提供帮助，只需点击我的用户名或联系我。您的支持使项目保持活力并带来新想法。谢谢。"
        },
        "support_button": {
            "en": "Contact the Dev",
            "pt": "Falar com o Dev",
            "es": "Contactar al Dev",
            "ru": "Связаться с разработчиком",
            "cn": "联系开发者"
        },
        "optional_label": {
            "en": "Advanced Options",
            "pt": "Opções Avançadas",
            "es": "Opciones Avanzadas",
            "ru": "Дополнительные параметры",
            "cn": "高级选项"
        },
        "prompt_selector_label": {
            "en": "Prompt",
            "pt": "Prompt",
            "es": "Prompt",
            "ru": "Подсказка",
            "cn": "提示"
        },
        "prompt_mode_base": {
            "en": "Translatica Mode",
            "pt": "Translatica Mode",
            "es": "Translatica Mode",
            "ru": "Режим Translatica",
            "cn": "Translatica 模式"
        },
        "prompt_mode_extra": {
            "en": "Enhancement",
            "pt": "Aprimoramento",
            "es": "Mejora",
            "ru": "Уточнение",
            "cn": "增强"
        },
        "prompt_extra_input_label": {
            "en": "Enhancement prompt",
            "pt": "Prompt de aprimoramento",
            "es": "Prompt de mejora",
            "ru": "Подсказка уточнения",
            "cn": "增强提示"
        },
        "advanced_cat_logging": {
            "en": "Logging",
            "pt": "Registros",
            "es": "Registros",
            "ru": "Журналы",
            "cn": "日志记录"
        },
        "advanced_cat_prompt": {
            "en": "Prompt",
            "pt": "Prompt",
            "es": "Prompt",
            "ru": "Подсказка",
            "cn": "提示"
        },
        "advanced_cat_optional": {
            "en": "Optional",
            "pt": "Opcional",
            "es": "Opcional",
            "ru": "Опционально",
            "cn": "可选"
        },
        "advanced_cat_behavior": {
            "en": "Translation Behavior",
            "pt": "Comportamento de Tradução",
            "es": "Comportamiento de Traducción",
            "ru": "Поведение перевода",
            "cn": "翻译行为"
        },
        "advanced_cat_language": {
            "en": "Plugin Language",
            "pt": "Idioma do Plugin",
            "es": "Idioma del Plugin",
            "ru": "Язык плагина",
            "cn": "插件语言"
        },
        "haptic_feedback_label": {
            "en": "Haptic feedback",
            "pt": "Feedback háptico",
            "es": "Vibración háptica",
            "ru": "Тактильная отдача",
            "cn": "触觉反馈"
        },
        "haptic_feedback_subtext": {
            "en": "When ativado, briefly vibrates on send.",
            "pt": "Ao ativar, vibra brevemente ao enviar mensagens.",
            "es": "Al activar, vibra brevemente al enviar mensajes.",
            "ru": "При включении кратко вибрирует при отправке сообщений.",
            "cn": "启用时，发送时会短暂振动。"
        },
        "preferences_label": {
            "en": "Preferences",
            "pt": "Preferências",
            "es": "Preferencias",
            "ru": "Предпочтения",
            "cn": "偏好设置"
        },
        "formatting_label": {
            "en": "Formatting",
            "pt": "Formatação",
            "es": "Formato",
            "ru": "Форматирование",
            "cn": "格式设置"
        },
        "formatting_subtext": {
            "en": "Preserve line breaks, markdown, links and code blocks (Experimental - Needs improvement)",
            "pt": "Recurso experimental. Requer melhorias na preservação de formatações.",
            "es": "Recurso experimental. Requiere mejoras en la preservación de formatos.",
            "ru": "Экспериментальная функция. Требует улучшения сохранения форматирования.",
            "cn": "实验性功能。需改进格式保留。"
        },
        "translation_style_label": {
            "en": "Translation Style",
            "pt": "Estilo de Tradução",
            "es": "Estilo de Traducción",
            "ru": "Стиль перевода",
            "cn": "翻译风格"
        },
        "translation_style_neutral": {
            "en": "Neutral",
            "pt": "Neutro",
            "es": "Neutral",
            "ru": "Нейтральный",
            "cn": "中性"
        },
        "translation_style_natural": {
            "en": "Natural / Conversational",
            "pt": "Natural / Conversacional",
            "es": "Natural / Conversacional",
            "ru": "Натуральный / Разговорный",
            "cn": "自然/会话式"
        },
        "translation_style_formal": {
            "en": "Formal",
            "pt": "Formal",
            "es": "Formal",
            "ru": "Формальный",
            "cn": "正式"
        },
        "translation_style_short": {
            "en": "Short / Compact",
            "pt": "Curto / Compacto",
            "es": "Corto / Compacto",
            "ru": "Короткий / Компактный",
            "cn": "简短/紧凑"
        },
        "translation_style_expanded": {
            "en": "Expanded / Detailed",
            "pt": "Ampliado / Detalhado",
            "es": "Ampliado / Detallado",
            "ru": "Расширенный / Детальный",
            "cn": "扩展/详细"
        },
        
        # Easter Eggs
        "ee_context_detected": {
            "en": "Ah… got it.",
            "pt": "Ah… entendi.",
            "es": "Ah… ya entendí.",
            "ru": "А, понял.",
            "cn": "哦，懂了。"
        },
        "ee_context_matters": {
            "en": "Details matter.",
            "pt": "Os detalhes contam.",
            "es": "Los detalles importan.",
            "ru": "Детали важны.",
            "cn": "细节很重要。"
        },
        "ee_reading_lines": {
            "en": "Reading the room.",
            "pt": "Lendo o clima.",
            "es": "Leyendo el ambiente.",
            "ru": "Читаю обстановку.",
            "cn": "读懂氛围。"
        },
        "ee_more_than_literal": {
            "en": "Not taking it literally.",
            "pt": "Não é ao pé da letra.",
            "es": "No es literal.",
            "ru": "Не буквально.",
            "cn": "不是字面意思。"
        },
        "ee_words_context": {
            "en": "Words, but smarter.",
            "pt": "Palavras, mas espertas.",
            "es": "Palabras, pero listas.",
            "ru": "Слова, но умнее.",
            "cn": "词语，但更聪明。"
        },
        "ee_semantic_layer": {
            "en": "Brain layer on.",
            "pt": "Camada cérebro ligada.",
            "es": "Capa cerebro activada.",
            "ru": "Мозг включён.",
            "cn": "大脑模式开启。"
        },
        "ee_context_resolution": {
            "en": "Puzzle solved.",
            "pt": "Quebra-cabeça montado.",
            "es": "Rompecabezas resuelto.",
            "ru": "Пазл сложился.",
            "cn": "拼图完成。"
        },
        "ee_meaning_words": {
            "en": "Meaning beats grammar.",
            "pt": "Sentido vence gramática.",
            "es": "El sentido gana.",
            "ru": "Смысл важнее.",
            "cn": "意思更重要。"
        },
        "ee_intent_recognized": {
            "en": "I see what you mean.",
            "pt": "Saquei a ideia.",
            "es": "Ya entiendo.",
            "ru": "Понял, к чему вы.",
            "cn": "我懂你的意思。"
        },
        "ee_context_pipeline": {
            "en": "Thinking…",
            "pt": "Pensando…",
            "es": "Pensando…",
            "ru": "Думаю…",
            "cn": "思考中…"
        },
        "ee_makes_sense": {
            "en": "Now it clicks.",
            "pt": "Agora clicou.",
            "es": "Ahora encaja.",
            "ru": "Теперь сошлось.",
            "cn": "现在通了。"
        },
        "ee_depends_context": {
            "en": "Well… depends.",
            "pt": "Bom… depende.",
            "es": "Bueno… depende.",
            "ru": "Ну… зависит.",
            "cn": "嗯…看情况。"
        },
        "ee_sounds_right": {
            "en": "Yep. That’s it.",
            "pt": "Isso. É isso.",
            "es": "Eso. Así sí.",
            "ru": "Да, так лучше.",
            "cn": "对，这就对了。"
        },
        "ee_understands_more": {
            "en": "Not my first language.",
            "pt": "Não é meu primeiro idioma.",
            "es": "No es mi primer idioma.",
            "ru": "Не первый язык.",
            "cn": "不是第一次处理。"
        },
        "ee_built_context": {
            "en": "Built with common sense.",
            "pt": "Feito com bom senso.",
            "es": "Hecho con sentido común.",
            "ru": "Сделано с умом.",
            "cn": "基于常识构建。"
        },
        "ee_context_syntax": {
            "en": "Rules can wait.",
            "pt": "Regras podem esperar.",
            "es": "Las reglas esperan.",
            "ru": "Правила подождут.",
            "cn": "规则先放一边。"
        },
        "ee_original": {
            "en": "Translatica is paying attention to context",
            "pt": "Translatica está prestando atenção ao contexto",
            "es": "Translatica está prestando atención al contexto",
            "ru": "Translatica обращает внимание на контекст",
            "cn": "Translatica 正在关注上下文"
        },
        "header_subtitle_1": {
            "en": "Lost in translation? Nope.",
            "pt": "Perdido na tradução? Não.",
            "es": "¿Perdido en la traducción? No.",
            "ru": "Потерялись в переводе? Нет.",
            "cn": "迷失在翻译中？不。"
        },
        "header_subtitle_2": {
            "en": "Say it once. Understood.",
            "pt": "Fale uma vez. Entendido.",
            "es": "Dilo una vez. Entendido.",
            "ru": "Скажите один раз. Понятно.",
            "cn": "说一次，就懂。"
        },
        "header_subtitle_3": {
            "en": "Meaning first.",
            "pt": "O sentido primeiro.",
            "es": "El sentido primero.",
            "ru": "Смысл прежде всего.",
            "cn": "意义优先。"
        },
        "header_subtitle_4": {
            "en": "No dictionary.",
            "pt": "Sem dicionário.",
            "es": "Sin diccionario.",
            "ru": "Без словаря.",
            "cn": "无需字典。"
        },
        "header_subtitle_5": {
            "en": "Context matters.",
            "pt": "Contexto importa.",
            "es": "El contexto importa.",
            "ru": "Контекст важен.",
            "cn": "语境很重要。"
        },
        "header_subtitle_6": {
            "en": "Human, not robotic.",
            "pt": "Humano, não robótico.",
            "es": "Humano, no robótico.",
            "ru": "По-человечески.",
            "cn": "更像人类。"
        },
        "header_subtitle_7": {
            "en": "Less guessing.",
            "pt": "Menos suposições.",
            "es": "Menos suposiciones.",
            "ru": "Меньше догадок.",
            "cn": "少猜测。"
        },
        "header_subtitle_8": {
            "en": "Designed by Apple. Not Cupertino.",
            "pt": "Criado pelo Apple. Não a de Cupertino.",
            "es": "Creado por Apple. No el de Cupertino.",
            "ru": "Сделано Apple. Не из Купертино.",
            "cn": "由 Apple 打造，但不是库比蒂诺的。"
        },
        "header_subtitle_9": {
            "en": "Smart translation.",
            "pt": "Tradução inteligente.",
            "es": "Traducción inteligente.",
            "ru": "Умный перевод.",
            "cn": "智能翻译。"
        },
        "header_subtitle_10": {
            "en": "Clear words.",
            "pt": "Palavras claras.",
            "es": "Palabras claras.",
            "ru": "Чёткие слова.",
            "cn": "清晰表达。"
        },
        "welcome_configured_1": {
            "en": "Hello, {name}! Translatica is ready. Explore the world with no limits. Need help? [Join us](https://t.me/+AYowC0lrZitjNDQx)",
            "pt": "Olá, {name}! O Translatica está pronto. Explore o mundo sem limites. Precisa de ajuda? [Junte-se a nós](https://t.me/+AYowC0lrZitjNDQx)",
            "es": "¡Hola, {name}! Translatica está listo. Explora el mundo sin límites. ¿Necesitas ayuda? [Únete a nosotros](https://t.me/+AYowC0lrZitjNDQx)",
            "ru": "Привет, {name}! Translatica готов. Исследуйте мир без границ. Нужна помощь? [Присоединяйтесь](https://t.me/+AYowC0lrZitjNDQx)",
            "cn": "你好，{name}！Translatica 已准备就绪。无限探索世界。需要帮助？[加入我们](https://t.me/+AYowC0lrZitjNDQx)"
        },
        "welcome_configured_2": {
            "en": "Welcome back, {name}! Your translation superpower is active. Check out new features or get [support](https://t.me/+AYowC0lrZitjNDQx)",
            "pt": "Bem-vindo(a) de volta, {name}! Seu superpoder de tradução está ativo. Confira novidades ou obtenha [suporte](https://t.me/+AYowC0lrZitjNDQx)",
            "es": "¡Bienvenido de nuevo, {name}! Tu superpoder de traducción está activo. Mira las novedades o obtén [soporte](https://t.me/+AYowC0lrZitjNDQx)",
            "ru": "С возвращением, {name}! Ваша суперсила перевода активна. Узнайте о новых функциях или получите [поддержку](https://t.me/+AYowC0lrZitjNDQx)",
            "cn": "欢迎回来，{name}！您的翻译超能力已激活。查看新功能或获取[支持](https://t.me/+AYowC0lrZitjNDQx)"
        },
        "welcome_configured_3": {
            "en": "Hi {name}! You're all set to communicate globally. Questions or feedback? We're [here](https://t.me/+AYowC0lrZitjNDQx)",
            "pt": "Oi {name}! Você está pronto para se comunicar globalmente. Dúvidas ou feedback? Estamos [aqui](https://t.me/+AYowC0lrZitjNDQx)",
            "es": "¡Hola {name}! Estás listo para comunicarte globalmente. ¿Preguntas o comentarios? Estamos [aquí](https://t.me/+AYowC0lrZitjNDQx)",
            "ru": "Привет, {name}! Вы готовы к глобальному общению. Вопросы или отзывы? Мы [здесь](https://t.me/+AYowC0lrZitjNDQx)",
            "cn": "嗨 {name}！您已准备好进行全球交流。有问题或反馈？我们[在这里](https://t.me/+AYowC0lrZitjNDQx)"
        },
        "welcome_configured_4": {
            "en": "Greetings, {name}! Enjoy seamless translations across languages. Join our [community](https://t.me/+AYowC0lrZitjNDQx) for tips",
            "pt": "Saudações, {name}! Aproveite traduções perfeitas entre idiomas. Entre na [comunidade](https://t.me/+AYowC0lrZitjNDQx) para dicas",
            "es": "¡Saludos, {name}! Disfruta de traducciones fluidas entre idiomas. Únete a nuestra [comunidad](https://t.me/+AYowC0lrZitjNDQx) para consejos",
            "ru": "Приветствия, {name}! Наслаждайтесь бесшовным переводом между языками. Присоединяйтесь к нашему [сообществу](https://t.me/+AYowC0lrZitjNDQx) за советами",
            "cn": "问候，{name}！享受跨语言的无缝翻译。[加入我们的社区](https://t.me/+AYowC0lrZitjNDQx)获取提示"
        },
        "welcome_configured_5": {
            "en": "Ready to go, {name}! Translatica is optimized for you. Share your experience [with us](https://t.me/+AYowC0lrZitjNDQx)",
            "pt": "Tudo pronto, {name}! O Translatica está otimizado para você. Compartilhe sua experiência [conosco](https://t.me/+AYowC0lrZitjNDQx)",
            "es": "¡Listo para empezar, {name}! Translatica está optimizado para ti. Comparte tu experiencia [con nosotros](https://t.me/+AYowC0lrZitjNDQx)",
            "ru": "Готово, {name}! Translatica оптимизирован для вас. Поделитесь своим опытом [с нами](https://t.me/+AYowC0lrZitjNDQx)",
            "cn": "准备好了，{name}！Translatica 已为您优化。[与我们分享](https://t.me/+AYowC0lrZitjNDQx)您的体验"
        },

        # Traduções (Extended Settings)
        "extended_settings_title": {
            "en": "Extended Settings",
            "pt": "Configurações Estendidas",
            "es": "Configuraciones Extendidas",
            "ru": "Расширенные настройки",
            "cn": "扩展设置"
        },
        "auto_translate_label": {
            "en": "Auto Translate",
            "pt": "Auto Tradução",
            "es": "Traducción Automática",
            "ru": "Автоперевод",
            "cn": "自动翻译"
        },
        "auto_translate_subtext": {
            "en": "Enable Telegram’s built-in translation for chats and incoming messages (uses Telegram’s own engine, no tokens or credits)",
            "pt": "Ativa a tradução nativa do Telegram para chats e mensagens recebidas (usa o próprio motor do Telegram, sem tokens ou créditos)",
            "es": "Activa la traducción nativa de Telegram para chats y mensajes entrantes (usa el motor propio de Telegram, sin tokens ni créditos)",
            "ru": "Включает встроенный перевод Telegram для чатов и входящих сообщений (использует собственный движок Telegram, без токенов и кредитов)",
            "cn": "启用 Telegram 内置翻译，用于聊天和接收的消息（使用 Telegram 自有引擎，不消耗令牌或积分）"
        },
        "translation_engine_label": {
            "en": "Engine",
            "pt": "Motor",
            "es": "Motor",
            "ru": "Движок",
            "cn": "引擎"
        },
        "server_2_fast": {
            "en": "Server 2 (Direct/Fast)",
            "pt": "Servidor 2 (Direto/Rápido)",
            "es": "Servidor 2 (Directo/Rápido)",
            "ru": "Сервер 2 (Прямой/Быстрый)",
            "cn": "服务器 2 (直接/快速)"
        },
        "server_smart_best": {
            "en": "Smart Auto (Best)",
            "pt": "Smart Auto (Melhor)",
            "es": "Smart Auto (Mejor)",
            "ru": "Smart Auto (Лучший)",
            "cn": "智能自动 (最佳)"
        },
        "server_3_mobile": {
            "en": "Server 3 (Mobile)",
            "pt": "Servidor 3 (Mobile)",
            "es": "Servidor 3 (Móvil)",
            "ru": "Сервер 3 (Мобильный)",
            "cn": "服务器 3 (移动)"
        },
        "server_1_legacy": {
            "en": "Server 1 (Legacy)",
            "pt": "Servidor 1 (Legado)",
            "es": "Servidor 1 (Legado)",
            "ru": "Сервер 1 (Устаревший)",
            "cn": "服务器 1 (旧版)"
        },
        "check_before_desativado": {
            "en": "Disabled",
            "pt": "Desativado",
            "es": "Desactivado",
            "ru": "Отключено",
            "cn": "禁用"
        },
        "check_before_ativado": {
            "en": "Enabled",
            "pt": "Ativado",
            "es": "Activado",
            "ru": "Включено",
            "cn": "启用"
        },
        "deeplx_api_url_label": {
            "en": "DeepLX Endpoint",
            "pt": "Endpoint DeepLX",
            "es": "Punto final DeepLX",
            "ru": "Конечная точка DeepLX",
            "cn": "DeepLX 端点"
        },
        "deeplx_api_token_label": {
            "en": "DeepLX Token (Optional)",
            "pt": "Token DeepLX (Opcional)",
            "es": "Token DeepLX (Opcional)",
            "ru": "Токен DeepLX (Необязательно)",
            "cn": "DeepLX 令牌 (可选)"
        },
        "openai_api_key_label": {
            "en": "OpenAI API Key",
            "pt": "Chave API OpenAI",
            "es": "Clave API OpenAI",
            "ru": "API ключ OpenAI",
            "cn": "OpenAI API 密钥"
        },

        "section_auto_trans": {
            "en": "Auto Translation",
            "pt": "Tradução Automática",
            "es": "Traducción Automática",
            "ru": "Автоматический перевод",
            "cn": "自动翻译"
        },
        "entire_chat": {
            "en": "Translate Entire Chat",
            "pt": "Traduzir Chat Inteiro",
            "es": "Traducir Chat Completo",
            "ru": "Перевести весь чат",
            "cn": "翻译整个聊天"
        },
        "entire_chat_sub": {
            "en": "Automatically translates all incoming messages in the chat.",
            "pt": "Traduz automaticamente todas as mensagens recebidas no chat.",
            "es": "Traduce automáticamente todos los mensajes recibidos en el chat.",
            "ru": "Автоматически переводит все входящие сообщения в чате.",
            "cn": "自动翻译聊天中所有接收到的消息。"
        },
        "in_message": {
            "en": "In-Message Translation",
            "pt": "Tradução na Mensagem",
            "es": "Traducción en Mensaje",
            "ru": "Перевод в сообщении",
            "cn": "消息内翻译"
        },
        "in_message_sub": {
            "en": "Translates individual messages inline when using the translate option.",
            "pt": "Traduz mensagens individuais inline ao usar a opção de tradução.",
            "es": "Traduce mensajes individuales en línea al usar la opción de traducción.",
            "ru": "Переводит отдельные сообщения внутри строки при использовании опции перевода.",
            "cn": "使用翻译选项时内联翻译单个消息。"
        },
        "section_auto_trans": {
            "en": "Auto Translation",
            "pt": "Tradução Automática",
            "es": "Traducción Automática",
            "ru": "Автоматический перевод",
            "cn": "自动翻译"
        },
        "extended_unlocked_footer": {
            "en": "Extra Features Unlocked! Enjoy.",
            "pt": "Funcionalidades Extras Desbloqueadas! Aproveite.",
            "es": "¡Funciones Extras Desbloqueadas! Disfrute.",
            "ru": "Дополнительные функции разблокированы! Наслаждайтесь.",
            "cn": "额外功能已解锁！享受。"
        },
        "section_cache": {
            "en": "Cache Management",
            "pt": "Gerenciamento de Cache",
            "es": "Gestión de Caché",
            "ru": "Управление кешем",
            "cn": "缓存管理"
        },
        "clear_cache": {
            "en": "Clear Translation Cache",
            "pt": "Limpar Cache de Tradução",
            "es": "Limpiar Caché de Traducción",
            "ru": "Очистить кеш перевода",
            "cn": "清除翻译缓存"
        },
        "cache_cleared": {
            "en": "Cache cleared! {} entries removed.",
            "pt": "Cache limpo! {} entradas removidas.",
            "es": "¡Caché limpiado! {} entradas eliminadas.",
            "ru": "Кеш очищен! Удалено {} записей.",
            "cn": "缓存已清除！删除了 {} 个条目。"
        },
        "cache_empty": {
            "en": "Cache is already empty",
            "pt": "Cache já está vazio",
            "es": "El caché ya está vacío",
            "ru": "Кеш уже пуст",
            "cn": "缓存已空"
        },
        "cache_error": {
            "en": "Error clearing cache: {}",
            "pt": "Erro ao limpar cache: {}",
            "es": "Error al limpiar caché: {}",
            "ru": "Ошибка при очистке кеша: {}",
            "cn": "清除缓存时出错：{}"
        },
        "filter_section": {
            "en": "Filter",
            "pt": "Filtro",
            "es": "Filtro",
            "ru": "Фильтр",
            "cn": "过滤器"
        },
        "filter_switch": {
            "en": "Word Filter",
            "pt": "Filtro de Palavras",
            "es": "Filtro de Palabras",
            "ru": "Фильтр слов",
            "cn": "单词过滤器"
        },
        "filter_switch_sub": {
            "en": "Do not translate messages containing these words",
            "pt": "Não traduzir mensagens contendo estas palavras",
            "es": "No traducir mensajes que contengan estas palabras",
            "ru": "Не переводить сообщения, содержащие эти слова",
            "cn": "不翻译包含这些单词的消息"
        },
        "filter_input": {
            "en": "Words to ignore (comma separated)",
            "pt": "Palavras para ignorar (separadas por vírgula)",
            "es": "Palabras para ignorar (separadas por coma)",
            "ru": "Слова для игнорирования (через запятую)",
            "cn": "要忽略的单词（逗号分隔）"
        },
        "cache_info": {
            "en": "Cache: {} entries (~{:.1f}KB)",
            "pt": "Cache: {} entradas (~{:.1f}KB)",
            "es": "Caché: {} entradas (~{:.1f}KB)",
            "ru": "Кеш: {} записей (~{:.1f}KB)",
            "cn": "缓存：{} 个条目 (~{:.1f}KB)"
        },
        "google_translate_error": {
            "en": "Google Translate error: {}",
            "pt": "Erro na tradução Google: {}",
            "es": "Error de Google Translate: {}",
            "ru": "Ошибка Google Translate: {}",
            "cn": "Google 翻译错误：{}"
        },
        "translating_debug": {
            "en": "Traduzindo via Google: {}... -> {}",
            "pt": "Traduzindo via Google: {}... -> {}",
            "es": "Traduciendo vía Google: {}... -> {}",
            "ru": "Перевод через Google: {}... -> {}",
            "cn": "通过 Google 翻译：{}... -> {}"
        },
        "translation_success": {
            "en": "Translation successful: {}...",
            "pt": "Tradução bem-sucedida: {}...",
            "es": "Traducción exitosa: {}...",
            "ru": "Перевод успешен: {}...",
            "cn": "翻译成功：{}..."
        },
        "dns_resolve_fail": {
            "en": "Failed to resolve IP for Google Translate",
            "pt": "Falha ao resolver IP para Google Translate",
            "es": "Error al resolver IP para Google Translate",
            "ru": "Не удалось разрешить IP для Google Translate",
            "cn": "无法解析 Google 翻译的 IP"
        },
        "debug_logs_ativado": {
            "en": "Translation debug logs ENABLED",
            "pt": "Logs de debug de tradução ATIVADOS",
            "es": "Registros de depuración de traducción HABILITADOS",
            "ru": "Журналы отладки перевода ВКЛЮЧЕНЫ",
            "cn": "翻译调试日志已启用"
        },
        "debug_logs_desativado": {
            "en": "Translation debug logs DISABLED",
            "pt": "Logs de debug de tradução DESATIVADOS",
            "es": "Registros de depuración de traducción DESHABILITADOS",
            "ru": "Журналы отладки перевода ОТКЛЮЧЕНЫ",
            "cn": "翻译调试日志已禁用"
        },
        "agent_settings_header": {
            "en": "Agent Settings",
            "pt": "Configurações do Agente",
            "es": "Configuración del Agente",
            "ru": "Настройки агента",
            "cn": "代理设置"
        },
        "agent_enabled_label": {
            "en": "Translatica Agent",
            "pt": "Agente Translatica",
            "es": "Agente Translatica",
            "ru": "Агент Translatica",
            "cn": "Translatica 代理"
        },
        "agent_enabled_subtext": {
            "en": "Allows the intelligent assistant to analyze, explain, or answer any message or prompt when using /agent, either by replying to a message or providing a custom query.",
            "pt": "Permite que o assistente inteligente analise, explique ou responda qualquer mensagem ou comando ao usar /agent, seja respondendo a uma mensagem ou informando um texto personalizado.",
            "es": "Permite que el asistente inteligente analice, explique o responda cualquier mensaje o comando al usar /agent, ya sea respondiendo a un mensaje o proporcionando un texto personalizado.",
            "ru": "Позволяет интеллектуальному помощнику анализировать, объяснять или отвечать на любое сообщение или запрос при использовании /agent, как в ответе на сообщение, так и с произвольным текстом.",
            "cn": "允许智能助手在使用 /agent 时分析、解释或回答任何消息或提示，可通过回复消息或输入自定义内容。"
        },
        "agent_persona_label": {
            "en": "Agent Persona",
            "pt": "Personalidade do Agente",
            "es": "Personalidad del Agente",
            "ru": "Личность агента",
            "cn": "代理角色"
        },
        "agent_persona_default": {
            "en": "Default (Simple)",
            "pt": "Padrão (Simples)",
            "es": "Predeterminado (Simple)",
            "ru": "По умолчанию (Простой)",
            "cn": "默认（简单）"
        },
        "agent_persona_nerd": {
            "en": "Nerd Mode",
            "pt": "Modo Nerd",
            "es": "Modo Nerd",
            "ru": "Режим ботаника",
            "cn": "极客模式"
        },
        "agent_persona_layman": {
            "en": "Layman (Explain to Layman)",
            "pt": "Sou Leigo (Explicar para Leigos)",
            "es": "Principiante (Explicar para principiantes)",
            "ru": "Для чайников (Объяснить просто)",
            "cn": "外行（解释给外行）"
        },
        "agent_persona_custom": {
            "en": "Custom",
            "pt": "Personalizado",
            "es": "Personalizado",
            "ru": "Пользовательский",
            "cn": "自定义"
        },
        "agent_custom_persona_label": {
            "en": "Custom Style",
            "pt": "Estilo Personalizado",
            "es": "Estilo Personalizado",
            "ru": "Пользовательский стиль",
            "cn": "自定义风格"
        },
        "agent_custom_persona_hint": {
            "en": "Ex: Physics Professor, Quantum Expert...",
            "pt": "Ex: Professor de Física, Especialista em Quântica...",
            "es": "Ej: Profesor de Física, Experto Cuántico...",
            "ru": "Например: Профессор физики, Квантовый эксперт...",
            "cn": "例如：物理教授，量子专家..."
        },
        "agent_processing": {
            "en": "Translatica Agent thinking...",
            "pt": "Agente Translatica pensando...",
            "es": "Agente Translatica pensando...",
            "ru": "Агент Translatica думает...",
            "cn": "Translatica 代理正在思考..."
        },
        "agent_send_button": {
            "en": "Send to Chat",
            "pt": "Enviar no Chat",
            "es": "Enviar al Chat",
            "ru": "Отправить в чат",
            "cn": "发送到聊天"
        },
        "agent_cancel_button": {
            "en": "Close",
            "pt": "Fechar",
            "es": "Cerrar",
            "ru": "Закрыть",
            "cn": "关闭"
        },
        "agent_dialog_title": {
            "en": "Translatica Agent",
            "pt": "Translatica Agent",
            "es": "Agente Translatica",
            "ru": "Агент Translatica",
            "cn": "Translatica 代理"
        },
        "agent_send_lang_label": {
            "en": "Send Language",
            "pt": "Idioma de Envio",
            "es": "Idioma de Envío",
            "ru": "Язык отправки",
            "cn": "发送语言"
        },
        "agent_send_lang_original": {
            "en": "Keep Generated (Auto)",
            "pt": "Manter Gerado (Auto)",
            "es": "Mantener Generado (Auto)",
            "ru": "Оставить сгенерированное (Авто)",
            "cn": "保持生成（自动）"
        },
        "agent_send_lang_target": {
            "en": "Translate to Target",
            "pt": "Traduzir para Alvo (Target)",
            "es": "Traducir al Objetivo",
            "ru": "Перевести на целевой",
            "cn": "翻译为目标语言"
        },

    }

    # Resolve a tradução para uma chave com base no idioma atual do plugin
    def _t(self, key: str) -> str:
        try:
            lang = self._get_plugin_lang_code()
            d = self.TRANSLATIONS.get(key)
            if not d:
                return key
            return d.get(lang) or d.get("en") or key
        except Exception:
            return key

    def _get_random_subtitle(self):
        try:
            import random
            keys = [f"header_subtitle_{i}" for i in range(1, 11)]
            key = random.choice(keys)
            return self._t(key)
        except:
            return self._t("header_subtitle")

    def _get_dynamic_welcome(self, user_name):
        try:
            # Verifica se existe alguma configuração de API Key (OpenAI ou Gemini)
            # ou se o provider não é o default (caso use custom endpoint sem key, mas raro)
            has_openai = self.get_setting("openai_api_key")
            has_gemini = self.get_setting("google_gemini_api_key")
            
            if not (has_openai or has_gemini):
                return (self._t("welcome_brief") or "").format(name=str(user_name or ""))
            
            import random
            keys = [f"welcome_configured_{i}" for i in range(1, 6)]
            key = random.choice(keys)
            return (self._t(key) or "").format(name=str(user_name or ""))
        except:
            return (self._t("welcome_brief") or "").format(name=str(user_name or ""))


    # Utilitários de cache para imagens (.png) nos BottomSheets
    def _get_cache_dir_path(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            base = str(ApplicationLoader.getFilesDirFixed())
            import os
            p = os.path.join(base, "translatica_cache")
            try:
                os.makedirs(p, exist_ok=True)
            except Exception:
                pass
            return p
        except Exception:
            return "/"

    def _get_cached_image_src(self, url: str, name: str) -> str:
        try:
            import os
            cache_dir = self._get_cache_dir_path()
            local_path = os.path.join(cache_dir, name)
            if not os.path.exists(local_path):
                try:
                    resp = requests.get(url, timeout=10)
                    if resp and resp.status_code == 200:
                        with open(local_path, "wb") as f:
                            f.write(resp.content)
                except Exception:
                    pass
            return ("file://" + local_path) if os.path.exists(local_path) else url
        except Exception:
            return url

    # Detecta erros de cota/tokens e exibe um boletim curto
    def _maybe_show_tokens_bulletin(self, resp) -> None:
        try:
            text_low = str(getattr(resp, "text", "") or "").lower()
            data = {}
            try:
                data = resp.json() if resp.text else {}
            except Exception:
                data = {}
            err = None
            if isinstance(data, dict):
                err = data.get("error") or data.get("errors") or None
            msg = ""
            code = ""
            status = ""
            if isinstance(err, dict):
                msg = str(err.get("message", "") or "").lower()
                code = str(err.get("code", "") or "").lower()
                status = str(err.get("status", "") or "").lower()
            elif isinstance(err, list) and err:
                try:
                    msg = str((err[0] or {}).get("message", "") or "").lower()
                    code = str((err[0] or {}).get("code", "") or "").lower()
                    status = str((err[0] or {}).get("status", "") or "").lower()
                except Exception:
                    pass
            keywords = [
                "insufficient_quota",
                "quota exceeded",
                "quota_exceeded",
                "resource_exhausted",
                "no credits",
                "not enough credits",
                "insufficient tokens",
                "token quota",
                "exceeded quota",
            ]
            blob = " ".join([text_low, msg, code, status])
            if any(k in blob for k in keywords):
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(self._t("bullet_tokens_insufficient")))
                except Exception:
                    pass
                try:
                    self._log("Cota de tokens insuficiente; exibindo bulletin curto")
                except Exception:
                    pass
        except Exception:
            pass

    # Helpers robustos para leitura de booleans salvos como bool/int/str
    def _get_bool_setting(self, key: str, default: bool = False) -> bool:
        try:
            val = self.get_setting(key, default)
            if isinstance(val, bool):
                return val
            if isinstance(val, int):
                return val != 0
            s = str(val).strip().lower()
            if s in ("true", "1", "yes", "on"):  # valores verdadeiros comuns
                return True
            if s in ("false", "0", "no", "off", ""):
                return False
            return bool(val) if val is not None else bool(default)
        except Exception:
            return bool(default)

    # Helpers de idioma do plugin
    def _get_plugin_lang_index(self) -> int:
        try:
            raw = self.get_setting("plugin_lang", 0)
            # Aceita código ou índice
            codes = ["en", "pt", "es", "ru", "cn"]
            try:
                idx = int(raw)
                return idx if 0 <= idx < len(codes) else 0
            except Exception:
                try:
                    return codes.index(str(raw or "en").lower())
                except Exception:
                    return 0
        except Exception:
            return 0

    def _get_plugin_lang_code(self) -> str:
        try:
            # Ordem deve bater com plugin_labels em _create_advanced_options_subfragment
            codes = ["en", "pt", "es", "ru", "cn"]
            idx = self._get_plugin_lang_index()
            if 0 <= idx < len(codes):
                return codes[idx]
            return "en"
        except Exception:
            return "en"
    # Mapeia as chaves para rótulos de idiomas
    def _opcoes_idioma(self):
        return [
            {"key": "pt", "label": "Português"},
            {"key": "en", "label": "Inglês"},
            {"key": "es", "label": "Espanhol"},
            {"key": "ru", "label": "Russo"},
            {"key": "cn", "label": "Chinês Simplificado"},
            {"key": "custom", "label": "Custom"},
        ]

    # Modelos disponíveis via OpenRouter (slugs oficiais)
    def _opcoes_modelos(self):
        return [
            {"key": "google/gemini-2.5-flash", "label": "Gemini 2.5 Flash"},
            {"key": "google/gemini-2.5-pro", "label": "Gemini 2.5 Pro"},
            {"key": "google/gemini-2.5-flash-lite", "label": "Gemini 2.5 Flash Lite"},
            {"key": "google/gemini-2.0-flash-lite", "label": "Gemini 2.0 Flash Lite"},
        ]

    # Modelos via Gemini direto (endpoint Google OpenAI-compatible)
    def _opcoes_modelos_gemini(self):
        return [
            {"key": "gemini-2.5-pro", "label": "gemini-2.5-pro"},
            {"key": "gemini-2.5-flash", "label": "gemini-2.5-flash"},
            {"key": "gemini-flash-latest", "label": "gemini-flash-latest"},
            {"key": "gemini-2.5-flash-lite", "label": "gemini-2.5-flash-lite"},
            {"key": "gemini-flash-lite-latest", "label": "gemini-flash-lite-latest"},
        ]

    def _opcoes_modelos_cerebras(self):
        return [
            {"key": "llama3.1-8b", "label": "Llama 3.1 8B"},
            {"key": "llama-3.3-70b", "label": "Llama 3.3 70B"},
            {"key": "qwen-3-235b", "label": "Qwen 3 235B"},
            {"key": "qwen-3-32b", "label": "Qwen 3 32B"},
            {"key": "gpt-oss-120b", "label": "GPT-OSS 120B"},
            {"key": "zai-glm-4.6", "label": "Zai GLM 4.6"},
        ]

    def _opcoes_modelos_llm7(self):
        return [
            {"key": "default", "label": "Default (Auto)"},
            {"key": "fast", "label": "Fast (Turbo)"},
            {"key": "gpt-4.1-nano", "label": "GPT 4.1 Nano"},
            {"key": "gpt-5-mini", "label": "GPT 5 Mini"},
            {"key": "codestral", "label": "Codestral"},
        ]

    def _open_url_generic(self, url: str):
        try:
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            try:
                from hook_utils import find_class
                Browser = find_class("org.telegram.messenger.browser.Browser")
                Browser.openUrl(ctx, url)
                return
            except Exception:
                pass
            try:
                from android.content import Intent
                from android.net import Uri
                intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
                ctx.startActivity(intent)
            except Exception:
                pass
        except Exception:
            pass

    def _get_ai_provider_idx(self) -> int:
        try:
            raw = self.get_setting("ai_provider", 0)
            return int(raw) if str(raw).isdigit() else 0
        except Exception:
            return 0

    def _resolve_model_for_provider(self, prov_idx: int) -> str:
        try:
            # Lista de modelos conforme provedor
            if prov_idx == 0:
                modelos = [m["key"] for m in self._opcoes_modelos()]  # OpenRouter slugs
                default_model = modelos[0] if modelos else "google/gemini-2.5-flash"
            elif prov_idx == 1:
                modelos = [m["key"] for m in self._opcoes_modelos_gemini()]  # Gemini direto
                default_model = modelos[0] if modelos else "gemini-2.5-flash"
            elif prov_idx == 5:
                # Mapeamento OpenAI
                modelos = ["gpt-4o-mini", "gpt-4o", "gpt-4.1", "gpt-4.1-mini"]
                idx = int(self.get_setting("openai_model_idx", 0))
                if 0 <= idx < len(modelos):
                    return modelos[idx]
                return modelos[0]
            elif prov_idx == 6:
                # Cerebras
                modelos = [m["key"] for m in self._opcoes_modelos_cerebras()]
                idx = int(self.get_setting("modelo_cerebras_idx", 0))
                if 0 <= idx < len(modelos):
                    return modelos[idx]
                return modelos[0] if modelos else "llama3.1-8b"
            elif prov_idx == 7:
                # llm7.io
                modelos = [m["key"] for m in self._opcoes_modelos_llm7()]
                idx = int(self.get_setting("modelo_llm7_idx", 0))
                if 0 <= idx < len(modelos):
                    return modelos[idx]
                return modelos[0] if modelos else "default"
            else:
                # Provedor custom: modelo livre via Input
                raw_custom = str(self.get_setting("custom_model_name", "") or "").strip()
                return raw_custom

            raw = self.get_setting("modelo_gemini", default_model)
            # Permite índice salvo (preferível) ou slug
            try:
                idx = int(raw)
                if 0 <= idx < len(modelos):
                    return modelos[idx]
            except Exception:
                pass

            # Caso slug: tenta mapear entre provedores ao trocar
            val = str(raw or default_model)
            if prov_idx == 0:
                # Se usuário tinha salvo um slug de Gemini puro (sem prefixo), prefixar para OpenRouter
                if "/" not in val:
                    pref = f"google/{val}"
                    return pref if pref in modelos else default_model
                return val if val in modelos else default_model
            else:
                # Se usuário tinha salvo um slug OpenRouter (com prefixo), remover 'google/'
                if "/" in val:
                    parts = val.split("/")
                    tail = parts[-1]
                    return tail if tail in modelos else default_model
                return val if val in modelos else default_model
        except Exception:
            return "gemini-2.5-flash"

    # Obtém o código ISO do idioma escolhido pelo usuário
    def _idioma_alvo(self):
        try:
            # Aceita índice (Selector) ou código (compatibilidade)
            raw = self.get_setting("idioma_alvo", "pt")
            codigos = ["pt", "en", "es", "ru"]
            try:
                idx = int(raw)
                if idx >= len(codigos):
                    val = str(self.get_setting("idioma_custom_code", "") or "").strip()
                    return val if val else "pt"
                if 0 <= idx < len(codigos):
                    return codigos[idx]
            except Exception:
                pass
            val = str(raw or "pt").lower()
            if val not in codigos:
                # Caso antigo com código diferente: usar custom se existir
                custom = str(self.get_setting("idioma_custom_code", "") or "").strip()
                if custom:
                    return custom
                val = "pt"
            return val
        except Exception:
            return "pt"

    def _open_openrouter_api_link(self):
        try:
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            # Preferir navegador interno (WebView)
            try:
                from hook_utils import find_class
                Browser = find_class("org.telegram.messenger.browser.Browser")
                Browser.openUrl(ctx, "https://openrouter.ai/settings/keys")
                return
            except Exception:
                pass
            # Fallback para Intent do Android se Browser falhar
            try:
                from android.content import Intent
                from android.net import Uri
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://openrouter.ai/settings/keys"))
                ctx.startActivity(intent)
            except Exception:
                pass
        except Exception:
            pass

    def _open_gemini_api_link(self):
        try:
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            try:
                from hook_utils import find_class
                Browser = find_class("org.telegram.messenger.browser.Browser")
                Browser.openUrl(ctx, "https://aistudio.google.com/apikey")
                return
            except Exception:
                pass
            try:
                from android.content import Intent
                from android.net import Uri
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://aistudio.google.com/apikey"))
                ctx.startActivity(intent)
            except Exception:
                pass
        except Exception:
            pass

    def _lang_label_from_code(self, code: str) -> str:
        try:
            c = str(code or "").lower().strip()
            mapping = {
                "pt": self._t("lang_portuguese"),
                "en": self._t("lang_english"),
                "es": self._t("lang_spanish"),
                "ru": self._t("lang_russian"),
                "cn": self._t("lang_chinese_simplified"),
            }
            if c in mapping:
                return mapping[c]
            return c.upper() if c else "—"
        except Exception:
            return str(code or "—")

    def _get_dialog_title_by_id(self, did: int) -> str:
        try:
            mc = self.get_messages_controller()
            if mc is None:
                return str(did)
            if isinstance(did, int) and did > 0:
                try:
                    user = mc.getUser(did)
                    if user:
                        try:
                            from org.telegram.messenger import ContactsController
                            return str(ContactsController.formatName(user.first_name, user.last_name) or (getattr(user, "username", "") or str(did))).replace("\n", " ")
                        except Exception:
                            return str(getattr(user, "first_name", "") or getattr(user, "username", "") or did)
                except Exception:
                    pass
            else:
                try:
                    chat = mc.getChat(-did)
                    if chat:
                        return str(getattr(chat, "title", str(did)) or str(did))
                except Exception:
                    pass
            return str(did)
        except Exception:
            return str(did)

    def _show_chat_overrides_sheet(self):
        try:
            overrides = self._load_chat_lang_overrides()
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                return

            from org.telegram.ui.ActionBar import BottomSheet, Theme
            from android.widget import LinearLayout, TextView
            from android.util import TypedValue
            from android.view import Gravity

            container = LinearLayout(ctx)
            try:
                container.setOrientation(LinearLayout.VERTICAL)
            except Exception:
                pass
            try:
                title_view = TextView(ctx)
                title_view.setText(self._t("chat_overrides_title") or "Idiomas por Chat")
                try:
                    title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                except Exception:
                    pass
                try:
                    title_view.setTypeface(Theme.getTypeface("fonts/rmedium.ttf"))
                except Exception:
                    pass
                try:
                    title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
                except Exception:
                    pass
                container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))
            except Exception:
                pass
            if not overrides:
                try:
                    empty_view = TextView(ctx)
                    empty_view.setText(self._t("chat_overrides_empty") or "Nenhum chat com idioma fixado (.add lang)")
                    try:
                        empty_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                    except Exception:
                        pass
                    try:
                        empty_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
                    except Exception:
                        pass
                    container.addView(empty_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))
                except Exception:
                    pass
            else:
                try:
                    items = []
                    for did, code in overrides.items():
                        name = self._get_dialog_title_by_id(int(did))
                        items.append((name, int(did), str(code)))
                    items.sort(key=lambda x: x[0].lower())
                    for name, did, code in items:
                        try:
                            line = TextView(ctx)
                            label = f"{name} - {self._lang_label_from_code(code)}"
                            line.setText(label)
                            try:
                                line.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                            except Exception:
                                pass
                            try:
                                line.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                            except Exception:
                                pass
                            container.addView(line, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 6, 24, 6))
                        except Exception:
                            pass
                except Exception:
                    pass
            try:
                sheet = BottomSheet(ctx, True)
                sheet.setCustomView(container)
                run_on_ui_thread(sheet.show)
            except Exception:
                pass
        except Exception:
            try:
                self._log("Erro ao abrir lista de idiomas por chat")
            except Exception:
                pass


    # Helpers locais para LayoutHelper sem import direto
    def _layout_helper_create_linear(self, w, h, g, l, t, r, b):
        try:
            from org.telegram.ui.Components import LayoutHelper
            return LayoutHelper.createLinear(w, h, g, l, t, r, b)
        except Exception:
            return None

    def _layout_helper_create_frame(self, w, h, g):
        try:
            from org.telegram.ui.Components import LayoutHelper
            return LayoutHelper.createFrame(w, h, g)
        except Exception:
            return None

    def _find_class_safe(self, name):
        try:
            from hook_utils import find_class
            return find_class(name)
        except Exception:
            return None

    # Aura: Efeito ripple suave ao enviar mensagens (menção honrosa: @mihailkotovski)
    def _tocar_ripple_suave(self, intensidade: float = 0.35):
        try:
            if not self._get_bool_setting("aura_ativado", False):
                return
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                return
            try:
                view = None
                try:
                    window = ctx.getWindow()
                    if window:
                        view = window.getDecorView()
                except Exception:
                    view = None
                width = float(view.getWidth()) if view else 540.0
                height = float(view.getHeight()) if view else 960.0
                cx = width / 2.0
                cy = height / 2.0
            except Exception:
                cx, cy = 270.0, 480.0
            try:
                LA = self._find_class_safe("org.telegram.ui.LaunchActivity")
                if LA and hasattr(LA, "makeRipple"):
                    run_on_ui_thread(lambda: LA.makeRipple(float(cx), float(cy), float(intensidade)))
            except Exception:
                pass
        except Exception:
            pass

    # Prompt para tradução com contexto
    def _montar_prompt(self, texto, idioma_destino, reply_context=None, prov_idx=None):
        try:
            # Configurações de estilo
            fmt_ativado = self._get_bool_setting("formatting_ativado", False)
            style_idx = int(self.get_setting("translation_style", 0))

            # Base do prompt
            system = (
                "Você é uma assistente de tradução contextual altamente natural. Traduza o conteúdo fornecido "
                "para o idioma solicitado."
            )

            # Filtro de Palavras
            try:
                if self._get_bool_setting("filtro_ativado", False):
                    palavras = self._get_cache_value("filtro_palavras", "").strip()
                    if palavras:
                        # Reforçando a instrução de filtro para evitar traduções indesejadas
                        system += (
                            f" ALERTA CRÍTICO DE FILTRO: O usuário definiu explicitamente que as seguintes palavras/termos "
                            f"NÃO DEVEM SER TRADUZIDOS sob hipótese alguma: [{palavras}]. "
                            f"Se você encontrar qualquer um desses termos no texto (como 'Maçã' ou qualquer outro listado), "
                            f"você deve mantê-lo exatamente como está no idioma original. "
                            f"Exemplo: Se a lista incluir 'Maçã' e o texto for 'Eu comi uma Maçã', a tradução para inglês deve ser 'I ate a Maçã', NÃO 'I ate an Apple'. "
                            f"Isso é uma regra absoluta."
                        )
            except Exception:
                pass

            # Injeção de Estilo
            if style_idx == 1: # Natural / Conversational
                system += " Use um tom natural, conversacional e fluido, adaptando expressões idiomáticas para soarem nativas."
            elif style_idx == 2: # Formal
                system += " Use um tom formal, profissional e polido, adequado para documentos ou comunicações oficiais."
            elif style_idx == 3: # Short / Compact
                system += " Seja breve e conciso. Remova redundâncias e entregue a tradução mais compacta possível sem perder o sentido."
            elif style_idx == 4: # Expanded / Detailed
                system += " Seja detalhado e explicativo se necessário para capturar todas as nuances do original."
            else: # Neutral (0)
                system += " Preserve o tom original, evitando traduções literais mas mantendo a fidelidade."

            # Injeção de Formatação
            if fmt_ativado:
                system += (
                    " IMPORTANTE: O texto de entrada contém formatação Markdown (negrito, itálico, links, etc). "
                    "Você DEVE preservar essa formatação na tradução. "
                    "Exemplo: se a entrada for '**Olá**', a saída deve ser '**Hello**'. "
                    "Não remova asteriscos, underscores, crases ou links. "
                    "Não adicione espaços dentro das marcações (ex: use '**Texto**', não '** Texto **')."
                )
            else:
                system += " Nunca use hífens ou travessões de diálogo e não utilize listas, bullets ou qualquer estrutura de marcação. Entregue apenas uma única passagem contínua de texto, sem explicações, sem metadados, sem comentários."

            # Resto das instruções de segurança e idioma
            system += " Preserve nomes próprios, siglas e números. Soe completamente natural para nativos do idioma-alvo."
            
            try:
                prof_mode = int(self.get_setting("profanity_mode", 0))
                if prof_mode == 1:
                    system += " " + "Suavize palavras ofensivas e palavrões, substituindo por termos mais leves."
                elif prof_mode == 2:
                    system += " " + "Mantenha palavrões e linguagem ofensiva explícitos, sem censura."
                elif prof_mode == 3:
                    system += " " + "Censure palavrões substituindo letras por asteriscos (ex: f***)."
                elif prof_mode == 4:
                    system += " " + "Envolva palavrões e linguagem ofensiva em tags de spoiler Markdown: ||palavra||."
            except Exception:
                pass
            # Complemento de Prompt (modo 'Complement') — compatível com índice (0/1) ou string ('base'/'extra')
            try:
                raw_mode = self.get_setting("prompt_mode", "base")
                if isinstance(raw_mode, int):
                    mode_raw = "base" if int(raw_mode) == 0 else "extra"
                else:
                    mode_raw = str(raw_mode or "base").lower()
                extra_text = str(self.get_setting("prompt_extra_text", "") or "").strip()
                if mode_raw == "extra" and extra_text:
                    system += f" Além disso, aplique este complemento de estilo: {extra_text}. Mantenha naturalidade humana, evitando tom robótico."
            except Exception:
                pass
            
            # Lógica do Meaning Detector (Injetar no prompt)
            try:
                meaning_mode = int(self.get_setting("meaning_detector_mode", 0))
                if meaning_mode == 1:
                    system += " Se o texto for uma expressão universal (ex: OK, lol, Thanks, Wow, Haha) ou um nome próprio que seja amplamente compreendido sem tradução, RETORNE O TEXTO ORIGINAL exato, sem traduzi-lo."
            except Exception:
                pass

            # Lógica AddL (Instrução para LLM)
            try:
                addl_ativado = self._get_bool_setting("addl_ativado", False)
                addl_lang = str(self.get_setting("addl_lang", "")).strip()
                # Verifica se não é DeepL (DeepL não usa prompt, lógica separada no request)
                # Se for DeepL (prov_idx=3), não injetamos instruções de formato no prompt principal
                if addl_ativado and addl_lang and prov_idx != 3:
                    system += (
                        f" INSTRUÇÃO EXTRA: Além de traduzir para {idioma_destino}, forneça também uma tradução para {addl_lang}. "
                        "FORMATO DE SAÍDA OBRIGATÓRIO (use tags exatas):\n"
                        "[MAIN]\n(Tradução principal aqui)\n[/MAIN]\n"
                        "[ADDL]\n(Tradução extra aqui)\n[/ADDL]\n"
                        "Não adicione nada além disso."
                    )
            except Exception:
                pass

            if reply_context:
                user = (
                    f"[[[CONTEXTO_START]]]\n"
                    f"{reply_context}\n"
                    f"[[[CONTEXTO_END]]]\n\n"
                    f"[[[ALVO_START]]]\n"
                    f"{texto}\n"
                    f"[[[ALVO_END]]]\n\n"
                    f"INSTRUÇÃO CRÍTICA: O texto entre [[[CONTEXTO_START]]] e [[[CONTEXTO_END]]] é APENAS para contexto. "
                    f"NÃO O TRADUZA. "
                    f"Você DEVE traduzir APENAS o texto entre [[[ALVO_START]]] e [[[ALVO_END]]]. "
                    f"Se o texto alvo for curto ou parecer uma continuação, AINDA ASSIM traduza APENAS ele. "
                    f"Ignore links e conteúdos do contexto na sua saída."
                )
            else:
                user = (
                    f"Idioma de destino: {idioma_destino}\n"
                    f"Texto para traduzir:\n{texto}"
                )
            return system, user
        except Exception:
            return "Traduza com contexto.", str(texto or "")

    def _montar_prompt_agent(self, texto, reply_context=None):
        try:
            persona_idx = int(self.get_setting("agent_persona_mode", 0))
            
            # Lógica de Idioma Dinâmica:
            # Se usuário digitou algo (texto), responder no idioma dele.
            # Se for apenas /agent (sem texto), responder no Target Language.
            if texto and str(texto).strip():
                lang_instruction = "Identifique o idioma da mensagem do usuário e responda no MESMO idioma."
            else:
                # Fallback para Target Language
                try:
                    tgt_code = self._idioma_alvo()
                    tgt_name = self._lang_label_from_code(tgt_code)
                    lang_instruction = f"Responda explicativamente no idioma: {tgt_name}."
                except:
                    lang_instruction = "Responda no idioma de destino configurado."

            system = f"Você é o Translatica Agent, um assistente inteligente. {lang_instruction} "
            
            if persona_idx == 1: # Nerd
                system += "Use um tom 'Nerd', técnico, detalhado, usando terminologia geek/científica sempre que possível, como se estivesse explicando para outro nerd."
            elif persona_idx == 2: # Layman
                system += "Use um tom extremamente didático e simples (ELI5). Explique como se o usuário fosse leigo ou uma criança de 10 anos. Use analogias simples."
            elif persona_idx == 3: # Custom
                custom = str(self.get_setting("agent_custom_persona", "")).strip()
                if custom:
                    system += f"Adote a seguinte persona/estilo: {custom}."
                else:
                    system += "Seja útil e direto."
            else: # Default (0)
                system += "Seja direto, útil e conciso. Explique o contexto de forma simples."

            if reply_context:
                if texto:
                    user = f"[[[CONTEXTO]]]\n{reply_context}\n[[[FIM_CONTEXTO]]]\n\nMinha solicitação sobre o contexto acima:\n{texto}"
                else:
                    user = f"[[[CONTEXTO]]]\n{reply_context}\n[[[FIM_CONTEXTO]]]\n\nPor favor, analise/explique ou responda ao contexto acima conforme sua persona."
            else:
                user = texto

            return system, user
        except Exception:
            return "You are a helpful assistant.", str(texto)

    def _show_agent_dialog(self, text, params, account):
        try:
            from ui.alert import AlertDialogBuilder
            from android_utils import run_on_ui_thread
            
            fragment = self.get_last_fragment_safe()
            if not fragment:
                return

            ctx = fragment.getParentActivity()
            if not ctx:
                return

            builder = AlertDialogBuilder(ctx)
            builder.set_title(self._t("agent_dialog_title"))
            builder.set_message(text)
            
            def _on_send(b, w):
                try:
                    self._send_generated_response(params, text, account)
                    b.dismiss()
                except Exception:
                    pass

            builder.set_positive_button(self._t("agent_send_button"), _on_send)
            builder.set_negative_button(self._t("agent_cancel_button"), lambda b, w: b.dismiss())
            builder.show()
            
        except Exception:
            pass

    def _send_generated_response(self, params, text, account):
        def _do_send():
            try:
                from client_utils import get_send_messages_helper
                from android_utils import run_on_ui_thread
                from org.telegram.messenger import SendMessagesHelper
                
                self._log("Agent: Preparando envio de resposta...")
                
                text_to_send = text
                
                # Verifica modo de envio
                send_mode = int(self.get_setting("agent_send_lang_mode", 0))
                if send_mode == 1: # Traduzir para Target
                    try:
                        did_temp = self._extract_dialog_id(params)
                        overrides = self._load_chat_lang_overrides()
                        target_lang = overrides.get(did_temp) or self._idioma_alvo()
                        
                        self._log(f"Agent: Traduzindo envio para {target_lang}")
                        translated = self._traduzir_com_ia(text_to_send, target_lang, None)
                        if translated and translated != text_to_send:
                            text_to_send = translated
                    except Exception as e:
                        self._log(f"Erro tradução envio agente: {e}")

                # Determina se é caption (igual ao hook)
                origem_caption = False
                try:
                    if hasattr(params, 'caption') and isinstance(params.caption, str) and str(params.caption).strip():
                        origem_caption = True
                except Exception:
                    pass

                # Processa Markdown
                final_txt, entities = self._parse_markdown_text(text_to_send)
                self._log("Agent: Markdown processado.")

                # Evita que o hook intercepte novamente (loop)
                self._suppress_next_hook = True

                # Tenta criar um novo SendMessageParams limpo para evitar "retry" visual
                req = None
                
                did = self._extract_dialog_id(params)
                if did:
                    reply_to_id = 0
                    reply_obj = None
                    try:
                         reply_obj = getattr(params, 'replyToMsg', None)
                         if reply_obj:
                             reply_to_id = reply_obj.id
                    except:
                        pass
                    
                    # Tentativa 1: Assinatura completa recente (várias versões)
                    if req is None:
                        try:
                            # (message, dialog_id, reply_to_msg, reply_to_story, webpage, invert_media, entities, shortcuts, reply_to_msg_id, media_info, schedule_date, parent_object)
                            req = SendMessagesHelper.SendMessageParams.of(
                                final_txt, did, reply_obj, None, None, False, entities, None, reply_to_id, None, 0, None
                            )
                        except Exception: pass
                    
                    # Tentativa 2: Sem media_info
                    if req is None:
                        try:
                            req = SendMessagesHelper.SendMessageParams.of(
                                final_txt, did, reply_obj, None, None, False, entities, None, reply_to_id, 0, None
                            )
                        except Exception: pass

                    # Tentativa 3: Versão simplificada antiga
                    if req is None:
                        try:
                             req = SendMessagesHelper.SendMessageParams.of(
                                final_txt, did, reply_obj, None, False, entities, reply_to_id, 0, None
                            )
                        except Exception: pass

                if req:
                    # Envia o novo request limpo
                    self._log("Agent: Enviando via novo SendMessageParams...")
                    # Usa run_on_ui_thread para garantir acesso seguro ao helper e banco
                    run_on_ui_thread(lambda: SendMessagesHelper.getInstance(account).sendMessage(req))
                else:
                    # Fallback: Reutiliza params original (pode causar retry visual)
                    # Aplica texto e entidades ao params (Reusa lógica do Check Before)
                    self._log("Agent: Fallback para params original...")
                    self._apply_translation_result(params, text_to_send, origem_caption)
                    run_on_ui_thread(lambda: SendMessagesHelper.getInstance(account).sendMessage(params))
                
                # Efeitos visuais/sonoros
                try:
                    run_on_ui_thread(lambda: self._tocar_ripple_suave())
                except Exception:
                    pass
                
                self._log(f"Agent: Envio finalizado com sucesso. ID Dialog: {did}")

            except Exception as e:
                self._log(f"ERRO CRÍTICO no envio do Agent: {e}")
                import traceback
                self._log(traceback.format_exc())

        import threading
        threading.Thread(target=_do_send).start()

    def _process_agent_command(self, content, reply_context, params, account):
        def _bg_task():
            try:
                run_on_ui_thread(lambda: self._exibir_loading_agent(True))
                
                custom_prompts = self._montar_prompt_agent(content, reply_context)
                
                # Nota do Dev: Adicionar nota, futuramente, recurso experimental
                # FIX: Passa o idioma do plugin como target_lang real
                target_lang = self._get_plugin_lang_code()
                
                response = self._traduzir_com_ia(content or "Context Analysis", target_lang, reply_context, custom_prompts=custom_prompts)
                
                run_on_ui_thread(lambda: self._exibir_loading_agent(False))
                
                if response:
                    run_on_ui_thread(lambda: self._show_agent_dialog(response, params, account))
            except Exception as e:
                run_on_ui_thread(lambda: self._exibir_loading_agent(False))
                self._log(f"Agent Error: {e}")

        import threading
        threading.Thread(target=_bg_task).start()

    def _exibir_loading_agent(self, show):
        try:
            if show:
                from ui.alert import AlertDialogBuilder
                from android_utils import run_on_ui_thread
                
                fragment = self.get_last_fragment_safe()
                if not fragment: return
                ctx = fragment.getParentActivity()
                if not ctx: return

                self._agent_loading_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_SPINNER)
                self._agent_loading_dialog.set_title(self._t("agent_dialog_title"))
                self._agent_loading_dialog.set_message(self._t("agent_processing"))
                self._agent_loading_dialog.set_cancelable(False)
                self._agent_loading_dialog.show()
            else:
                if hasattr(self, '_agent_loading_dialog') and self._agent_loading_dialog:
                    self._agent_loading_dialog.dismiss()
                    self._agent_loading_dialog = None
        except Exception:
            pass

    def _parse_markdown_text(self, text):
        try:
            from org.telegram.tgnet import TLRPC
            import re
        except ImportError:
            return text, []

        if not text:
            return text, []

        def u16_len(s):
            return len(s.encode('utf-16-le')) // 2

        # Padrões suportados
        patterns = [
            (r'```(?:(\w+)\n)?(.+?)```', 'pre'),
            (r'`([^`\n]+)`', 'code'),
            (r'\|\|\s*(.+?)\s*\|\|', 'spoiler'),
            (r'\*\*\s*([^*\n]+?)\s*\*\*', 'bold'),  # Double asterisk bold (tolerant)
            (r'\*\s*([^*\n]+?)\s\*', 'bold'),        # Single asterisk bold (tolerant)
            (r'__\s*([^_\n]+?)\s*__', 'underline'),
            (r'_\s*([^_\n]+?)\s*_', 'italic'),
            (r'~\s*([^~\n]+?)\s*~', 'strike'),
            (r'\[\s*([^\]]+?)\s*\]\s*\(\s*([^)]+?)\s*\)', 'link')
        ]
        
        compiled_patterns = []
        for p, t in patterns:
            flags = re.DOTALL if t == 'pre' else 0
            compiled_patterns.append((re.compile(p, flags), t))

        def parse_recursive(input_text):
            best_match = None
            best_start = len(input_text) + 1
            best_type = None
            
            for pat, type_ in compiled_patterns:
                m = pat.search(input_text)
                if m:
                    if m.start() < best_start:
                        best_start = m.start()
                        best_match = m
                        best_type = type_
            
            if not best_match:
                return input_text, []
            
            prefix = input_text[:best_match.start()]
            suffix = input_text[best_match.end():]
            
            ent = None
            c_text = ""
            c_ents = []

            if best_type == 'pre':
                lang = best_match.group(1)
                content = best_match.group(2)
                c_text = content
                ent = TLRPC.TL_messageEntityPre()
                ent.language = lang or ""
            elif best_type == 'link':
                text_part = best_match.group(1)
                url_part = best_match.group(2)
                c_text, c_ents = parse_recursive(text_part)
                ent = TLRPC.TL_messageEntityTextUrl()
                ent.url = url_part
            else:
                content = best_match.group(1)
                if best_type == 'code':
                    c_text = content
                    ent = TLRPC.TL_messageEntityCode()
                else:
                    c_text, c_ents = parse_recursive(content)
                    if best_type == 'bold': ent = TLRPC.TL_messageEntityBold()
                    elif best_type == 'italic': ent = TLRPC.TL_messageEntityItalic()
                    elif best_type == 'underline': ent = TLRPC.TL_messageEntityUnderline()
                    elif best_type == 'strike': ent = TLRPC.TL_messageEntityStrike()
                    elif best_type == 'spoiler': ent = TLRPC.TL_messageEntitySpoiler()
                    else: ent = TLRPC.TL_messageEntityUnknown()

            p_text, p_ents = parse_recursive(prefix)
            s_text, s_ents = parse_recursive(suffix)
            
            if ent:
                ent.offset = u16_len(p_text)
                ent.length = u16_len(c_text)
            
            final_text = p_text + c_text + s_text
            final_ents = []
            final_ents.extend(p_ents)
            if ent:
                final_ents.append(ent)
            
            for e in c_ents:
                e.offset += u16_len(p_text)
                final_ents.append(e)
                
            offset_shift = u16_len(p_text) + u16_len(c_text)
            for e in s_ents:
                e.offset += offset_shift
                final_ents.append(e)
                
            return final_text, final_ents

        try:
            return parse_recursive(text)
        except Exception:
            return text, []

    def _apply_translation_result(self, params, text, origem_caption):
        try:
            # Processa Markdown interno
            final_text, final_entities = self._parse_markdown_text(text)

            # Processamento de Blockquotes (> quote)
            # Tenta aplicar estilo nativo de citação se disponível
            try:
                from org.telegram.tgnet import TLRPC
                # Verifica disponibilidade da entidade (Layer 166+)
                _ = TLRPC.TL_messageEntityBlockquote
                
                # Helper de comprimento UTF-16
                def u16_len(s):
                    return len(s.encode('utf-16-le')) // 2

                new_text_builder = []
                new_entities = []
                
                # Lista de deslocamentos: [(start_index_in_original, amount_removed)]
                shifts = []
                current_original_idx = 0
                current_new_idx = 0
                
                lines = final_text.split('\n')
                
                # Reconstrói o texto removendo "> " e criando entidades
                processed_any_quote = False
                
                # Variáveis para agrupamento de quotes
                quote_active = False
                quote_start_idx = 0
                quote_accumulated_len = 0

                for i, line in enumerate(lines):
                    # Calcula comprimento original da linha + newline
                    # Nota: split remove o \n. Adicionamos virtualmente para contagem.
                    
                    is_quote = line.startswith("> ") or line == ">"
                    
                    if is_quote:
                        processed_any_quote = True
                        content = line[2:] if line.startswith("> ") else (line[1:] if line.startswith(">") else "")
                        
                        if not quote_active:
                            quote_active = True
                            quote_start_idx = current_new_idx
                            quote_accumulated_len = 0
                        
                        new_text_builder.append(content)
                        
                        # Registra shift
                        # Removeu 2 chars ("> ") ou 1 (">")
                        removed_len = len(line) - len(content)
                        shifts.append((current_original_idx, removed_len))
                        
                        c_len = u16_len(content)
                        current_new_idx += c_len
                        quote_accumulated_len += c_len
                    else:
                        if quote_active:
                            # Fecha quote anterior
                            ent_quote = TLRPC.TL_messageEntityBlockquote()
                            ent_quote.offset = quote_start_idx
                            ent_quote.length = quote_accumulated_len
                            
                            # AddL: Compact Quote (Collapsed)
                            try:
                                if self._get_bool_setting("addl_ativado", False) and int(self.get_setting("addl_style", 0)) == 2:
                                    ent_quote.collapsed = True
                            except Exception:
                                pass

                            new_entities.append(ent_quote)
                            quote_active = False
                            quote_accumulated_len = 0
                        
                        new_text_builder.append(line)
                        current_new_idx += u16_len(line)
                    
                    # Adiciona newline se não for o último (reconstrução simples)
                    if i < len(lines) - 1:
                        new_text_builder.append("\n")
                        
                        # Se estamos num quote, verifica se o \n deve fazer parte dele
                        if quote_active:
                            next_line = lines[i+1]
                            if next_line.startswith("> ") or next_line == ">":
                                quote_accumulated_len += 1
                            # Se a próxima não for quote, o \n fica de fora do bloco
                        
                        current_new_idx += 1 # \n é 1 char
                        current_original_idx += u16_len(line) + 1
                    else:
                        current_original_idx += u16_len(line)

                # Fecha quote se terminou ativo (última linha era quote)
                if quote_active:
                    ent_quote = TLRPC.TL_messageEntityBlockquote()
                    ent_quote.offset = quote_start_idx
                    ent_quote.length = quote_accumulated_len

                    # AddL: Compact Quote (Collapsed)
                    try:
                        if self._get_bool_setting("addl_ativado", False) and int(self.get_setting("addl_style", 0)) == 2:
                            ent_quote.collapsed = True
                    except Exception:
                        pass

                    new_entities.append(ent_quote)

                if processed_any_quote:
                    # Ajusta entidades originais (ex: bold dentro ou fora do quote)
                    # final_entities contém objetos TLRPC com offset/length
                    
                    adjusted_entities = []
                    # Adiciona as novas (Blockquotes)
                    adjusted_entities.extend(new_entities)
                    
                    for old_ent in final_entities:
                        # Calcula novo offset
                        # Subtrai shifts que ocorreram ANTES ou NO INÍCIO da entidade
                        total_shift = 0
                        for sh_start, sh_amount in shifts:
                            if sh_start <= old_ent.offset:
                                total_shift += sh_amount
                        
                        old_ent.offset -= total_shift
                        # O length não muda pois removemos apenas o prefixo "> ", não conteúdo interno formatado
                        # A menos que a formatação cruzasse linhas de quote, o que o parser não faria normalmente
                        
                        if old_ent.length > 0:
                            adjusted_entities.append(old_ent)
                            
                    final_text = "".join(new_text_builder)
                    final_entities = adjusted_entities

            except Exception as e:
                # Se der erro (ex: classe não existe) ou falha lógica, mantém o texto original com "> "
                self._log(f"Erro no processamento de Blockquote: {e}")
                pass

            # Aplica resultado final (texto + entidades combinadas)
            if origem_caption:
                try:
                    params.caption = final_text
                except Exception:
                    params["caption"] = final_text
            else:
                try:
                    params.message = final_text
                except Exception:
                    params["message"] = final_text
            
            if final_entities:
                from java.util import ArrayList
                j_entities = ArrayList()
                for ent in final_entities:
                    j_entities.add(ent)
                
                try:
                    params.entities = j_entities
                except Exception:
                    params["entities"] = j_entities
            
            # Se já processamos tudo, retornamos para evitar conflito com lógica legada abaixo
            return
        except Exception:
            pass

    # Chama o endpoint de chat para obter a tradução
    def _exibir_notificacao_configuracao(self, provider_name: str):
        # Nota do Dev: Menção honrosa: @meeowPlugins > @chqhmrr
        # Implementação de feedback visual usando notificações in-app nativas do Telegram (Bulletin),
        # similar ao plugin in-app-notifications. Exibe um alerta não intrusivo com ícone e ação.
        try:
            from org.telegram.ui.Components import BulletinFactory, Bulletin
            from org.telegram.messenger import R
            
            fragment = self.get_last_fragment_safe()
            if not fragment:
                return

            ctx = fragment.getContext()
            resource_provider = fragment.getResourceProvider()
            
            # Layout de duas linhas com imagem (TwoLineLayout)
            # Este layout espera uma imagem, título e subtítulo.
            layout = Bulletin.TwoLineLayout(ctx, resource_provider)
            
            # Define os textos usando o sistema de tradução
            layout.titleTextView.setText(self._t("config_required_title"))
            layout.subtitleTextView.setText(self._t("config_required_subtitle").format(provider_name))
            
            # Define o ícone
            # Usamos o ícone de configurações (msg_settings) ou aviso se disponível.
            # O uso de try/except garante que não crashamos se o recurso não for encontrado.
            try:
                layout.imageView.setImageResource(R.drawable.msg_settings)
            except Exception:
                pass

            # Teste temporário    
            # Define ação de clique para abrir configurações
            def _abrir_configs(view):
                try:
                    # Tenta fechar o bulletin ao clicar
                    if 'bulletin' in locals() and bulletin:
                        bulletin.dismiss()
                except: 
                    pass
                
                try:
                    from hook_utils import find_class
                    PluginSettingsActivity = find_class("org.telegram.ui.PluginSettingsActivity")
                    if fragment and PluginSettingsActivity:
                        fragment.presentFragment(PluginSettingsActivity(self))
                except Exception:
                    pass

            layout.setOnClickListener(OnClickListener(_abrir_configs))

            # Cria e exibe o Bulletin
            # Duração de 5000ms (5 segundos) para dar tempo de clicar
            factory = BulletinFactory.of(fragment)
            bulletin = factory.create(layout, 5000)
            
            # Exibe no topo da tela (True)
            run_on_ui_thread(lambda: bulletin.show(True))
            
        except Exception:
            # Fallback seguro: se a construção visual falhar, tentamos um erro simples ou ignoramos
            try:
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Config {provider_name} Missing"))
            except:
                pass

    def _exibir_notificacao_generica(self, title, subtitle, icon_res=None, is_error=False):
        try:
            from org.telegram.ui.Components import BulletinFactory, Bulletin
            from org.telegram.messenger import R
            
            fragment = self.get_last_fragment_safe()
            if not fragment:
                return

            ctx = fragment.getContext()
            resource_provider = fragment.getResourceProvider()
            
            layout = Bulletin.TwoLineLayout(ctx, resource_provider)
            
            # Textos
            layout.titleTextView.setText(title)
            layout.subtitleTextView.setText(subtitle)
            
            # Ícone
            try:
                if icon_res:
                    layout.imageView.setImageResource(icon_res)
                else:
                    layout.imageView.setImageResource(R.drawable.msg_settings)
            except Exception:
                pass

            # Ação de clique
            def _abrir_configs(view):
                try:
                    if 'bulletin' in locals() and bulletin:
                        bulletin.dismiss()
                except: pass
                
                try:
                    from hook_utils import find_class
                    PluginSettingsActivity = find_class("org.telegram.ui.PluginSettingsActivity")
                    if fragment and PluginSettingsActivity:
                        fragment.presentFragment(PluginSettingsActivity(self))
                except Exception:
                    pass

            layout.setOnClickListener(OnClickListener(_abrir_configs))

            factory = BulletinFactory.of(fragment)
            bulletin = factory.create(layout, 5000)
            run_on_ui_thread(lambda: bulletin.show(True))
            
        except Exception:
            try:
                if is_error:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(subtitle))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(subtitle))
            except:
                pass

    def _exibir_notificacao_quota(self):
        # Notificação visual para erro de cota excedida (OpenAI)
        self._exibir_notificacao_generica("OpenAI Quota Exceeded", self._t("openai_quota_exceeded"), is_error=True)

    def _traduzir_com_ia(self, texto, idioma_destino, reply_context=None, custom_prompts=None):
        try:
            start_ts = time.time()
            # Obtém o provedor de IA efetivo, considerando a alternância automática se estiver ativa
            prov_idx = self._get_effective_provider_idx()
            
            if custom_prompts:
                system, user = custom_prompts
            else:
                system, user = self._montar_prompt(texto, idioma_destino, reply_context, prov_idx=prov_idx)
            
            messages = [
                {"role": "system", "content": system},
                {"role": "user", "content": user},
            ]

            # Temperatura (Criatividade) e tokens
            try:
                temperatura = float(self.get_setting("temperatura", 0.2))
            except Exception:
                temperatura = 0.2
            
            fast_mode = self._get_bool_setting("fast_mode_ativado", False)
            
            # Seleção de modelo com compatibilidade entre provedores
            modelo = self._resolve_model_for_provider(prov_idx)
            
            # Ajuste de tokens dinâmico para OpenAI (Gust Refactored)
            if prov_idx == 5: # OpenAI
                txt_len = len(str(texto))
                # Heurística: pelo menos 1000 tokens ou o dobro do tamanho do texto para evitar cortes
                # Modelos mini são mais eficientes, permitimos margem maior
                if "mini" in str(modelo):
                     max_tokens = max(2000, int(txt_len * 2.5))
                else:
                     max_tokens = max(1000, int(txt_len * 2))
                
                # Fast mode apenas limita o teto máximo, não a base
                if fast_mode and max_tokens > 2500:
                     max_tokens = 2500
            else:
                # Outros provedores (manter conservador)
                max_tokens = 1500 if not fast_mode else 512

            is_deepl = False

            if prov_idx == 0:
                # OpenRouter
                api_key = str(self.get_setting("openrouter_api_key", "") or "").strip()
                if not api_key:
                    self._log("Tradução ignorada (OpenRouter): sem API key")
                    self._exibir_notificacao_configuracao("OpenRouter")
                    return texto
                base = "https://openrouter.ai/api/v1"
                url = f"{base}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Authorization": f"Bearer {api_key}",
                }
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Traduzindo via OpenRouter: modelo={modelo}, temp={temperatura}, idioma={idioma_destino}, len={len(str(texto))}")
                except Exception:
                    pass
            elif prov_idx == 1:
                # Google Gemini (endpoint OpenAI-compatible)
                api_key = str(self.get_setting("gemini_api_key", "") or "").strip()
                if not api_key:
                    self._log("Tradução ignorada (Gemini): sem API key")
                    self._exibir_notificacao_configuracao("Google Gemini")
                    return texto
                base = "https://generativelanguage.googleapis.com/v1beta/openai"
                url = f"{base}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Authorization": f"Bearer {api_key}",
                }
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Traduzindo via Gemini (OpenAI-compat): modelo={modelo}, temp={temperatura}, idioma={idioma_destino}, len={len(str(texto))}")
                except Exception:
                    pass
            elif prov_idx == 3:
                # DeepL Official (Adaptado para Translatica) - Precisa de testes de feedback
                # Suporta múltiplas chaves separadas por vírgula para rotação
                raw_keys = str(self.get_setting("deepl_api_key", "") or "").strip()
                if not raw_keys:
                    self._log("Translatica: Tradução ignorada (DeepL): sem API key")
                    self._exibir_notificacao_configuracao("DeepL")
                    return texto

                api_keys = [k.strip() for k in raw_keys.split(',') if k.strip()]
                if not api_keys:
                    self._log("Translatica: Tradução ignorada (DeepL): lista de chaves vazia")
                    return texto

                # Tenta rotacionar chaves em caso de erro 456 (Quota)
                for i, key in enumerate(api_keys):
                    # Determina endpoint baseado na chave (Free vs Pro)
                    if key.endswith(":fx"):
                        url = "https://api-free.deepl.com/v2/translate"
                    else:
                        url = "https://api.deepl.com/v2/translate"
                    
                    headers = {
                        "Content-Type": "application/json",
                        "Authorization": f"DeepL-Auth-Key {key}"
                    }
                    
                    # Payload padrão DeepL
                    payload = {
                        "text": [texto],
                        "target_lang": str(idioma_destino).upper()
                    }
                    
                    # Suporte a instruções personalizadas (se disponível no futuro/plano)
                    if system:
                        payload["custom_instructions"] = system

                    try:
                        self._log(f"Translatica: Traduzindo via DeepL (Chave {i+1}/{len(api_keys)}): url={url}, lang={idioma_destino.upper()}")
                        
                        # Timeout ajustado conforme modo
                        timeout_val = (10, 30) if fast_mode else (10, 60)
                        
                        # Executa requisição isolada para permitir rotação
                        resp = requests.post(url, headers=headers, json=payload, timeout=timeout_val)
                        
                        if resp.status_code == 200:
                            data = resp.json()
                            if "translations" in data and isinstance(data["translations"], list):
                                res_text = data["translations"][0].get("text", "")
                                if res_text:
                                    self._log(f"Translatica: Sucesso DeepL (Chave {i+1}).")
                                    return res_text
                        elif resp.status_code == 456:
                            self._log(f"Translatica: Quota Excedida DeepL (Chave {i+1}). Tentando próxima...")
                            continue # Tenta próxima chave
                        else:
                            self._log(f"Translatica: Erro DeepL {resp.status_code}: {resp.text}")
                            # Em caso de outros erros, continua para tentar outra chave por segurança
                            continue

                    except Exception as e:
                        self._log(f"Translatica: Erro conexão DeepL (Chave {i+1}): {e}")
                        continue
                
                # Se saiu do loop, todas falharam
                run_on_ui_thread(lambda: BulletinHelper.show_error("Translatica: DeepL - Todas as chaves falharam."))
                return texto
            elif prov_idx == 4:
                # DeepLX (Experimental)
                base = str(self.get_setting("deeplx_api_url", "") or "").strip()
                if not base:
                    self._log("Tradução ignorada (DeepLX): URL vazia")
                    self._exibir_notificacao_configuracao("DeepLX")
                    return texto
                
                # Normaliza URL
                # Suporte específico para api.deeplx.org (Linux DO Connect) que exige token na URL
                if "api.deeplx.org" in base and api_key and api_key not in base:
                    clean_base = base.replace("/translate", "").rstrip("/")
                    url = f"{clean_base}/{api_key}/translate"
                    # Se o token já está na URL, não precisamos enviá-lo novamente, mas
                    # manter no header Authorization não costuma quebrar.
                elif "translate" not in base:
                    # Tenta inferir se precisa adicionar /translate (comum em DeepLX)
                    # Se não houver 'translate' na URL, adiciona automaticamente.
                    url = f"{base.rstrip('/')}/translate"
                else:
                    url = base

                api_key = str(self.get_setting("deeplx_api_token", "") or "").strip()
                
                headers = {
                    "Content-Type": "application/json"
                }
                if api_key:
                    # Tenta formato Bearer padrão
                    headers["Authorization"] = f"Bearer {api_key}"

                # Payload DeepLX (imita DeepL Free/Pro ou padrão DeepLX)
                # DeepLX aceita: text, source_lang, target_lang
                payload = {
                    "text": texto, # DeepLX espera string ou lista? Geralmente string
                    "source_lang": "auto",
                    "target_lang": str(idioma_destino).upper()
                }
                
                try:
                    self._log(f"Traduzindo via DeepLX: url={url}, lang={idioma_destino.upper()}")
                except Exception:
                    pass
            elif prov_idx == 5: # ChatGPT (OpenAI)
                # Cache Check
                try:
                    cache_key = self._get_cache_key(texto, idioma_destino)
                    cached = self._autotranslate_cache.get(cache_key)
                    if cached:
                        self._log(f"OpenAI Cache Hit: {len(cached)} chars")
                        return cached
                except Exception:
                    pass

                api_key = str(self.get_setting("openai_api_key", "")).strip()
                if not api_key:
                    self._log("Tradução ignorada (ChatGPT): sem API key")
                    self._exibir_notificacao_configuracao("ChatGPT")
                    return texto
                
                url = "https://api.openai.com/v1/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Authorization": f"Bearer {api_key}"
                }
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Traduzindo via ChatGPT: modelo={modelo}, temp={temperatura}, idioma={idioma_destino}")
                except Exception:
                    pass
            elif prov_idx == 6:
                # Cerebras (Experimental)
                api_key = str(self.get_setting("cerebras_api_key", "")).strip()
                if not api_key:
                    self._log("Tradução ignorada (Cerebras): sem API key")
                    self._exibir_notificacao_configuracao("Cerebras")
                    return texto
                
                base = "https://api.cerebras.ai/v1"
                url = f"{base}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Authorization": f"Bearer {api_key}",
                }
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Translatica: Traduzindo via Cerebras: modelo={modelo}, temp={temperatura}, idioma={idioma_destino}")
                except Exception:
                    pass
            elif prov_idx == 7:
                # llm7.io (Experimental)
                api_key = str(self.get_setting("llm7_api_key", "")).strip()
                # llm7 permite modelos free sem key, mas eu recomendo uma conta.
                # Se tiver key, usa. Se não, tenta sem e reza.
                
                base = "https://api.llm7.io/v1"
                url = f"{base}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                }
                if api_key:
                    headers["Authorization"] = f"Bearer {api_key}"
                
                # Tratamento de aliases de modelo
                # Se o modelo selecionado for "default" ou "fast", enviamos assim mesmo.
                
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    auth_status = "com key" if api_key else "sem key (free models)"
                    self._log(f"Translatica: Traduzindo via llm7.io ({auth_status}): modelo={modelo}, temp={temperatura}, idioma={idioma_destino}")
                except Exception:
                    pass
            else:
                # Custom OpenAI-compatible
                base = str(self.get_setting("custom_api_url", "") or "").strip()
                if not base:
                    self._log("Tradução ignorada (Custom): URL vazia")
                    self._exibir_notificacao_configuracao("Custom AI")
                    return texto
                
                # Verifica se é DeepL
                if "deepl.com" in base.lower():
                    is_deepl = True
                    api_key = str(self.get_setting("custom_api_key", "") or "").strip()
                    
                    # Heurística simples para endpoint correto
                    if "/translate" in base:
                        url = base
                    else:
                        url = f"{base.rstrip('/')}/translate"
                        
                    headers = {
                        "Content-Type": "application/json",
                        "Authorization": f"DeepL-Auth-Key {api_key}"
                    }
                    payload = {
                        "text": [texto],
                        "target_lang": str(idioma_destino).upper()
                    }
                    if system:
                        # Injeta instruções personalizadas (se suportado pelo plano/API)
                        payload["custom_instructions"] = system

                    try:
                        self._log(f"Traduzindo via DeepL: url={url}, lang={idioma_destino.upper()}")
                    except Exception:
                        pass
                else:
                    # Custom OpenAI-compatible (Fluxo Original)
                    try:
                        while base.endswith("//"):
                            base = base[:-1]
                    except Exception:
                        pass
                    api_key = str(self.get_setting("custom_api_key", "") or "").strip()
                    if not modelo:
                        self._log("Tradução ignorada (Custom): modelo ausente")
                        return texto
                    url = f"{base.rstrip('/')}/chat/completions"
                    headers = {
                        "Content-Type": "application/json",
                        "Accept": "application/json",
                    }
                    if api_key:
                        headers["Authorization"] = f"Bearer {api_key}"
                    payload = {
                        "model": modelo,
                        "messages": messages,
                        "temperature": temperatura,
                        "max_tokens": max_tokens,
                    }
                    try:
                        self._log(f"Traduzindo via Custom OpenAI-compat: base={base}, modelo={modelo}, temp={temperatura}, idioma={idioma_destino}, len={len(str(texto))}")
                    except Exception:
                        pass

            # Requisição HTTP
            try:
                resp = requests.post(url, headers=headers, json=payload, timeout=(10, 30) if fast_mode else (10, 60))
                
                # OpenAI Error Handling & Fallback (Gust Refactored)
                if prov_idx == 5 and (resp is None or resp.status_code != 200):
                    code = resp.status_code if resp else 0
                    err_msg = ""
                    should_fallback = True
                    
                    if code == 401: 
                        err_msg = "API Key Inválida (401)"
                        should_fallback = False # Não adianta tentar fallback se o erro é de auth básico (a menos que fallback use outra key)
                    elif code == 429: 
                        err_msg = "Rate Limit/Quota (429)"
                    elif code == 402 or (resp and "insufficient_quota" in resp.text.lower()): 
                        err_msg = "Quota Excedida (402)"
                    elif code >= 500:
                        err_msg = f"Erro Servidor OpenAI ({code})"
                    else: 
                        err_msg = f"Erro HTTP {code}"
                    
                    if code != 0:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(f"OpenAI: {err_msg}"))
                    
                    if not should_fallback:
                         self._log(f"OpenAI falhou ({err_msg}). Fallback abortado.")
                         return texto
                    
                    # Fallback (DeepL) - Melhorias
                    self._log(f"OpenAI falhou ({err_msg}), tentando fallback DeepL...")
                    try:
                         deepl_key = str(self.get_setting("deepl_api_key", "") or "").strip()
                         if deepl_key:
                             is_free = deepl_key.endswith(":fx")
                             d_url = "https://api-free.deepl.com/v2/translate" if is_free else "https://api.deepl.com/v2/translate"
                             d_headers = {"Authorization": f"DeepL-Auth-Key {deepl_key}"}
                             d_payload = {"text": [texto], "target_lang": str(idioma_destino).upper()}
                             resp_fb = requests.post(d_url, headers=d_headers, json=d_payload, timeout=20)
                             if resp_fb.status_code == 200:
                                 resp = resp_fb
                                 is_deepl = True
                                 self._log("Fallback DeepL sucesso.")
                    except Exception as e:
                         self._log(f"Fallback DeepL falhou: {e}")

            except Exception as e:
                self._log(f"Erro HTTP ao traduzir: {e}")
                resp = None

            # Fallback OpenAI (ChatGPT) - Booster
            if (resp is None or resp.status_code >= 500) and prov_idx == 5 and modelo != "gpt-4o-mini":
                try:
                    self._log("Falha no ChatGPT principal (Timeout/500), tentando fallback para gpt-4o-mini...")
                    payload["model"] = "gpt-4o-mini"
                    resp = requests.post(url, headers=headers, json=payload, timeout=(10, 30) if fast_mode else (10, 60))
                    if resp and resp.status_code == 200:
                        self._log("Fallback ChatGPT (gpt-4o-mini) sucesso.")
                except Exception as e:
                    self._log(f"Erro HTTP no fallback ChatGPT: {e}")

            # Fallbacks para Gemini se a chamada OpenAI-compat falhar
            if resp is not None and resp.status_code != 200 and prov_idx == 1:
                try:
                    self._log(f"Gemini compat falhou ({resp.status_code}); tentando com query key...")
                except Exception:
                    pass
                try:
                    url2 = f"https://generativelanguage.googleapis.com/v1beta/openai/chat/completions?key={api_key}"
                    headers2 = {"Content-Type": "application/json", "Accept": "application/json"}
                    resp = requests.post(url2, headers=headers2, json=payload, timeout=(10, 30) if fast_mode else (10, 60))
                except Exception as e:
                    self._log(f"Erro HTTP fallback Gemini (query key): {e}")
                    resp = None

            if resp is not None and resp.status_code != 200 and prov_idx == 1:
                try:
                    self._log(f"Gemini compat ainda falhou ({resp.status_code}); fallback generateContent...")
                except Exception:
                    pass
                try:
                    model_gc = modelo.split("/")[-1]
                    url3 = f"https://generativelanguage.googleapis.com/v1beta/models/{model_gc}:generateContent?key={api_key}"
                    prompt = f"{system}\n\n{user}"
                    payload3 = {
                        "contents": [{"parts": [{"text": prompt}]}],
                        "generationConfig": {
                            "temperature": temperatura,
                            "maxOutputTokens": max_tokens,
                        }
                    }
                    headers3 = {"Content-Type": "application/json", "Accept": "application/json"}
                    resp = requests.post(url3, headers=headers3, json=payload3, timeout=(10, 30) if fast_mode else (10, 60))
                except Exception as e:
                    self._log(f"Erro HTTP fallback Gemini (generateContent): {e}")
                    resp = None

            if resp is None:
                return texto
            if resp.status_code != 200:
                if prov_idx != 5:
                    try:
                        self._maybe_show_tokens_bulletin(resp)
                    except Exception:
                        pass
                else:
                    # Notificação para erro de quota OpenAI
                    try:
                        if resp.status_code == 429 or "quota" in resp.text.lower():
                            self._exibir_notificacao_quota()
                    except Exception:
                        pass

                try:
                    self._log(f"Falha na tradução: status={resp.status_code}; body='{resp.text[:180]}'")
                except Exception:
                    pass
                return texto

            try:
                data = resp.json() if resp.text else {}
            except Exception:
                try:
                    self._log(f"Erro JSON DeepLX/Provider: {resp.text[:100]}")
                except Exception:
                    pass
                return texto

            conteudo = ""
            try:
                if is_deepl:
                    if "translations" in data and isinstance(data["translations"], list):
                        conteudo = data["translations"][0].get("text", "")
                elif prov_idx == 4:
                    # DeepLX
                    if "data" in data and isinstance(data["data"], str):
                         conteudo = data["data"]
                    elif "translations" in data and isinstance(data["translations"], list):
                         conteudo = data["translations"][0].get("text", "")
                elif prov_idx == 1 and isinstance(data, dict) and "candidates" in data:
                    cands = data.get("candidates", [])
                    if cands:
                        conteudo = (((cands[0] or {}).get("content") or {}).get("parts") or [{}])[0].get("text") or ""
                else:
                    ch = data.get("choices", [])
                    if ch and isinstance(ch, list):
                        c0 = ch[0]
                        conteudo = (c0.get("message") or {}).get("content") or c0.get("content") or c0.get("text") or ""
            except Exception:
                conteudo = ""

            saida = str(conteudo or "").strip()
            if not saida:
                try:
                    self._log("Tradução vazia; retornando texto original")
                except Exception:
                    pass
                return texto

            saida = saida.replace("\u2026", "").strip()
            
            # Save to Cache (OpenAI)
            if prov_idx == 5 and saida:
                try:
                    cache_key = self._get_cache_key(texto, idioma_destino)
                    self._autotranslate_cache[cache_key] = saida
                    self._save_autotranslate_cache()
                except Exception:
                    pass

            try:
                elapsed = (time.time() - start_ts)
                preview = (saida[:60] + ("…" if len(saida) > 60 else ""))
                self._log(f"Tradução concluída em {elapsed:.2f}s; saída={len(saida)} chars; preview='{preview}'")
            except Exception:
                pass

            # Verificação do Meaning Detector (Pós-processamento)
            try:
                meaning_mode = int(self.get_setting("meaning_detector_mode", 0))
                if meaning_mode == 1:
                    # Se o resultado for idêntico ao original (case-insensitive), retorna o original
                    # Isso captura: "OK" -> "OK", "OK" -> "ok", "lol" -> "LOL", etc.
                    # Se o Prompt funcionou, ele já deve ter retornado o original.
                    if saida.strip().lower() == str(texto).strip().lower():
                        # Garante que retornamos o original exato (para não alterar case se não necessário)
                        return texto
            except Exception:
                pass

            # Processamento AddL (Feature de Idioma Extra)
            try:
                addl_ativado = self._get_bool_setting("addl_ativado", False)
                addl_lang = str(self.get_setting("addl_lang", "")).strip()
                
                if addl_ativado and addl_lang and saida:
                    addl_style = int(self.get_setting("addl_style", 0))
                    main_text = ""
                    addl_text = ""
                    
                    if is_deepl:
                        # DeepL: Requer segunda requisição
                        main_text = saida # O que já temos é a tradução principal
                        try:
                            # Reutiliza url e headers definidos anteriormente (escopo de função)
                            # Apenas atualiza o payload para o novo idioma
                            payload_addl = payload.copy()
                            payload_addl["target_lang"] = addl_lang.upper()
                            payload_addl["text"] = [texto] # Garante texto original
                            
                            self._log(f"Traduzindo AddL via DeepL para {addl_lang}")
                            resp_addl = requests.post(url, headers=headers, json=payload_addl, timeout=(10, 30))
                            
                            if resp_addl.status_code == 200:
                                data_addl = resp_addl.json()
                                if "translations" in data_addl and isinstance(data_addl["translations"], list):
                                    addl_text = data_addl["translations"][0].get("text", "")
                        except Exception as e:
                            self._log(f"Erro AddL DeepL: {e}")
                            
                    else:
                        # LLM: Tenta parsear tags [MAIN] e [ADDL]
                        # Regex para capturar conteúdo entre tags
                        match_main = re.search(r"\[MAIN\](.*?)\[/MAIN\]", saida, re.DOTALL | re.IGNORECASE)
                        match_addl = re.search(r"\[ADDL\](.*?)\[/ADDL\]", saida, re.DOTALL | re.IGNORECASE)
                        
                        if match_main and match_addl:
                            main_text = match_main.group(1).strip()
                            addl_text = match_addl.group(1).strip()
                        elif match_main:
                             # Se só achou Main, usa ele
                             main_text = match_main.group(1).strip()
                        else:
                            # Fallback: Se não encontrar tags, assume que tudo é Main
                            main_text = saida

                    # Combina se tivermos ambos
                    if main_text and addl_text:
                        # Prevenção de redundância: Se o texto principal e o AddL forem idênticos (ex: links), ignora o AddL
                        if main_text.strip().lower() == addl_text.strip().lower():
                            saida = main_text
                        elif addl_style == 1 or addl_style == 2: # Quote or Quote Compact
                            # Formata AddL como citação
                            # Adiciona > em cada linha
                            quoted_addl = "\n".join([f"> {line}" for line in addl_text.splitlines()])
                            saida = f"{main_text}\n\n{quoted_addl}"
                        else: # Default
                            saida = f"{main_text}\n\n{addl_text}"
                    elif main_text and not is_deepl:
                        # Se for LLM e parseamos algo, atualiza saida
                        saida = main_text
                    
                    # Limpeza de segurança para tags residuais
                    # Mesmo se o regex falhar ou se o AddL não estiver ativo mas o LLM alucinar
                    if "[MAIN]" in saida or "[/MAIN]" in saida:
                        saida = saida.replace("[MAIN]", "").replace("[/MAIN]", "")
                    if "[ADDL]" in saida or "[/ADDL]" in saida:
                        saida = saida.replace("[ADDL]", "").replace("[/ADDL]", "")
                        
            except Exception as e:
                self._log(f"Erro processamento AddL: {e}")

            return saida
        except Exception as e:
            try:
                self._log(f"Erro inesperado em tradução: {e}")
            except Exception:
                pass
            return texto

    def _entities_to_markdown(self, text, entities):
        try:
            if not entities or not text:
                return text
            
            # Ordena entidades por offset reverso para inserção segura
            ents_list = []
            try:
                ents_list = list(entities)
            except:
                return text
                
            sorted_ents = sorted(ents_list, key=lambda e: e.offset, reverse=True)
            
            # Helper para obter nome do tipo de entidade
            def get_type_name(e):
                return e.__class__.__name__
                
            res = list(text)
            
            for e in sorted_ents:
                start = e.offset
                end = e.offset + e.length
                
                # Verificação de limites
                if start < 0 or end > len(res):
                    continue
                    
                etype = get_type_name(e)
                
                # Mapeamento de entidades para Markdown
                if "Bold" in etype:
                    res.insert(end, "**")
                    res.insert(start, "**")
                elif "Italic" in etype:
                    res.insert(end, "_")
                    res.insert(start, "_")
                elif "Code" in etype:
                    res.insert(end, "`")
                    res.insert(start, "`")
                elif "Pre" in etype:
                    res.insert(end, "```")
                    lang = getattr(e, "language", "")
                    res.insert(start, f"```{lang}\n" if lang else "```")
                elif "TextUrl" in etype:
                    url = getattr(e, "url", "")
                    res.insert(end, f"]({url})")
                    res.insert(start, "[")
                elif "Spoiler" in etype:
                    res.insert(end, "||")
                    res.insert(start, "||")
                elif "Strike" in etype:
                    res.insert(end, "~")
                    res.insert(start, "~")
                elif "Underline" in etype:
                    res.insert(end, "__")
                    res.insert(start, "__")
                    
            return "".join(res)
        except Exception:
            return text

    # Hook de envio: traduz antes de enviar
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        try:


            # Evita loop: se estamos reenviando a própria mensagem traduzida, não intercepte
            try:
                if getattr(self, "_suppress_next_hook", False):
                    self._suppress_next_hook = False
                    return HookResult(strategy=HookStrategy.DEFAULT)
            except Exception:
                pass
            # Respeita estado on/off do plugin, mas permite comandos .on/.off/.add/.del sempre
            try:
                if not self._is_ativado():
                    try:
                        if isinstance(params.message, str):
                            _cmd = params.message.strip().lower()
                            # Mesmo desativado, permitir comandos de controle e utilidade
                            if _cmd in (".on", ".off", ".add", ".del", ".reset", ".chat", ".chats", ".op"):
                                pass
                            else:
                                return HookResult()
                        else:
                            return HookResult()
                    except Exception:
                        return HookResult()
            except Exception:
                pass
            # Detecta texto: prioriza caption (mídia) e depois mensagem
            origem_caption = False
            texto_original = None
            try:
                if hasattr(params, 'caption') and isinstance(params.caption, str) and str(params.caption).strip():
                    texto_original = str(params.caption).strip()
                    origem_caption = True
                elif isinstance(params.message, str) and str(params.message).strip():
                    texto_original = str(params.message).strip()
                    origem_caption = False
            except Exception:
                texto_original = None
                origem_caption = False
            if not texto_original:
                return HookResult()
            mensagem_original = texto_original
            try:
                preview = (mensagem_original[:60] + ("…" if len(mensagem_original) > 60 else ""))
                try:
                    orig = "caption" if origem_caption else "message"
                except Exception:
                    orig = "message"
                self._log(f"Interceptado envio: conta={account}, origem={orig}, len={len(mensagem_original)}; preview='{preview}'")
            except Exception:
                pass

            # Lógica: Modo de Resposta e Manter Alvo
            reply_context = None
            try:
                if self._get_bool_setting("reply_mode_ativado", False):
                    reply_obj = getattr(params, 'replyToMsg', None)
                    if reply_obj:
                        real_msg = getattr(reply_obj, 'messageOwner', reply_obj)
                        if hasattr(real_msg, 'caption') and isinstance(real_msg.caption, str) and str(real_msg.caption).strip():
                            reply_context = str(real_msg.caption).strip()
                        elif hasattr(real_msg, 'message') and isinstance(real_msg.message, str) and str(real_msg.message).strip():
                            reply_context = str(real_msg.message).strip()
            except Exception:
                pass
            # Notas e comparações:    
            # Lógica: Manter Alvo (Check removido para garantir funcionamento padrão)
            # O comportamento padrão deve ser traduzir sempre, a menos que configurado o contrário.
            # A lógica anterior bloqueava traduções normais se Keep Target estivesse desativado.
            pass

            # Comandos .on / .off e .add / .del (sempre funcionam e sempre cancelam)
            cmd = mensagem_original.strip().lower()

            # Translatica Agent
            if cmd.startswith("/agent"):
                try:
                    if self.get_setting("agent_enabled", False):
                        # Extrai conteúdo após /agent mantendo case original
                        # cmd é lower, mensagem_original é original
                        # /agent tem 6 chars. Verifica se mensagem_original começa com /agent (case insensitive)
                        if len(mensagem_original) >= 6 and mensagem_original[:6].lower() == "/agent":
                            content = mensagem_original[6:].strip()
                            
                            # Se for reply e não tivermos pego o contexto ainda (caso reply_mode estivesse off)
                            if not reply_context:
                                try:
                                    reply_obj = getattr(params, 'replyToMsg', None)
                                    if reply_obj:
                                        real_msg = getattr(reply_obj, 'messageOwner', reply_obj)
                                        if hasattr(real_msg, 'caption') and isinstance(real_msg.caption, str) and str(real_msg.caption).strip():
                                            reply_context = str(real_msg.caption).strip()
                                        elif hasattr(real_msg, 'message') and isinstance(real_msg.message, str) and str(real_msg.message).strip():
                                            reply_context = str(real_msg.message).strip()
                                except:
                                    pass
                            
                            self._process_agent_command(content, reply_context, params, account)
                            return HookResult(HookStrategy.CANCEL)
                except Exception as e:
                    self._log(f"Erro /agent: {e}")

            if cmd == ".op": # Que curioso, né? Tá fazendo o quê aqui?
                try:
                    self._log("Comando .op: abrir configurações do plugin")
                except Exception:
                    pass
                try:
                    from hook_utils import find_class
                    PluginSettingsActivity = find_class("org.telegram.ui.PluginSettingsActivity")
                    fragment = get_last_fragment()
                    if fragment and PluginSettingsActivity:
                        fragment.presentFragment(PluginSettingsActivity(self))
                except Exception:
                    try:
                        fragment = get_last_fragment()
                        fragment.presentFragment(PluginSettingsActivity(self))
                    except Exception:
                        pass
                return HookResult(HookStrategy.CANCEL)
            if cmd == ".on":
                if self._is_ativado():
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_on_already_on")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                self.set_setting("plugin_ativado", 1)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_on_success")))
                    self._log("Cmd .on: plugin_ativado=1")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)
            if cmd == ".off":
                if not self._is_ativado():
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_off_already_off")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                self.set_setting("plugin_ativado", 0)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_off_success")))
                    self._log("Cmd .off: plugin_ativado=0")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)
            if cmd.startswith(".add"):
                did = self._extract_dialog_id(params)
                if not did:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_dialog_not_found")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                ativado = self._load_ativado_dialogs()
                desativado = self._load_desativado_dialogs()
                overrides = self._load_chat_lang_overrides()
                # Parse subcomando em estilo SearchIt: ".add <sub>" (opcional)
                try:
                    parts = mensagem_original.strip().split()
                    sub = parts[1].strip().lower() if len(parts) >= 2 else ""
                    if sub.startswith("-"):
                        sub = sub[1:].strip()
                except Exception:
                    sub = ""
                if sub:
                    if sub == "reset":
                        if did in overrides:
                            del overrides[did]
                            self._save_chat_lang_overrides(overrides)
                        if did not in ativado:
                            ativado.add(did)
                            self._save_ativado_dialogs(ativado)
                        if did in desativado:
                            desativado.discard(did)
                            self._save_desativado_dialogs(desativado)
                        try:
                            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_add_lang_reset")))
                            self._log(f"Cmd .add reset: did={did}")
                        except Exception:
                            pass
                        return HookResult(HookStrategy.CANCEL)
                    else:
                        lang_map = {"en": "en", "pt": "pt", "es": "es", "ru": "ru", "cm": str(self.get_setting("idioma_custom_code", "") or "").strip()}
                        sel = lang_map.get(sub, sub)
                        overrides[did] = sel
                        self._save_chat_lang_overrides(overrides)
                        if did not in ativado:
                            ativado.add(did)
                            self._save_ativado_dialogs(ativado)
                        if did in desativado:
                            desativado.discard(did)
                            self._save_desativado_dialogs(desativado)
                        try:
                            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_add_lang_success").format(lang=sel or sub)))
                            self._log(f"Cmd .add lang: did={did} lang={sel}")
                        except Exception:
                            pass
                        return HookResult(HookStrategy.CANCEL)
                if did in ativado:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_add_already")))
                        self._log(f"Cmd .add: did={did} já ativado")
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                ativado.add(did)
                if did in desativado:
                    desativado.discard(did)
                    self._save_desativado_dialogs(desativado)
                self._save_ativado_dialogs(ativado)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_add_success")))
                    self._log(f"Cmd .add: did={did} ativado")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)
            if cmd == ".del":
                did = self._extract_dialog_id(params)
                if not did:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_dialog_not_found")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                ativado = self._load_ativado_dialogs()
                desativado = self._load_desativado_dialogs()
                if did in ativado:
                    ativado.discard(did)
                    self._save_ativado_dialogs(ativado)
                if did in desativado:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_block_already")))
                        self._log(f"Cmd .del: did={did} já desativado")
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                desativado.add(did)
                self._save_desativado_dialogs(desativado)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_block_success")))
                    self._log(f"Cmd .del: did={did} desativado")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)

            if cmd == ".reset":
                try:
                    self._save_chat_lang_overrides({})
                    self._save_ativado_dialogs(set())
                    self._save_desativado_dialogs(set())
                    run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_reset_success") or "All chat overrides have been reset"))
                    self._log("Cmd .reset: Todas as conversas limpas")
                except Exception as e:
                    self._log(f"Cmd .reset erro: {e}")
                return HookResult(HookStrategy.CANCEL)

            # Comando .chat / .chats: mostra info com chats e idiomas fixados (.add lang)
            if cmd in (".chat", ".chats"):
                try:
                    run_on_ui_thread(lambda: self._show_chat_overrides_sheet())
                except Exception:
                    self._show_chat_overrides_sheet()
                return HookResult(HookStrategy.CANCEL)

            # Check Before: Intercepta, traduz e pede confirmação
            try:
                if self._get_bool_setting("check_before_ativado", False):
                    # Ignora se for comando /agent para evitar conflito
                    if mensagem_original.strip().lower().startswith("/agent"):
                        return HookResult()

                    # Prepara dados de idioma
                    try:
                        did_cb = self._extract_dialog_id(params)
                    except Exception:
                        did_cb = 0
                    overrides_cb = self._load_chat_lang_overrides()
                    idioma_cb = overrides_cb.get(did_cb) or self._idioma_alvo()

                    def _process_check_before():
                        try:
                            self._log(f"CheckBefore: Iniciando processo para chat {did_cb} idioma {idioma_cb}")
                            # Traduz
                            texto_traduzido = self._traduzir_com_ia(mensagem_original, idioma_cb, reply_context)
                            self._log(f"CheckBefore: Tradução concluída. Exibindo diálogo.")
                            # Mostra dialog na UI thread
                            run_on_ui_thread(lambda: self._show_check_before_dialog(texto_traduzido, mensagem_original, params, origem_caption))
                        except Exception as e:
                            self._log(f"Erro no Verificar Antes: {e}")

                    # Executa em background
                    try:
                        from client_utils import run_on_queue
                        run_on_queue(_process_check_before)
                    except Exception:
                        import threading
                        threading.Thread(target=_process_check_before).start()

                    return HookResult(HookStrategy.CANCEL)
            except Exception:
                pass

            # Fast mode: envia imediatamente o original e, em background, envia a tradução como mensagem subsequente
            try:
                fast_mode = self._get_bool_setting("fast_mode_ativado", False)
            except Exception:
                fast_mode = False
            if fast_mode:
                try:
                    from client_utils import run_on_queue, get_send_messages_helper
                except Exception:
                    run_on_queue = None
                    get_send_messages_helper = None
                # Respeita overrides por chat também no Fast Mode
                try:
                    did_for_lang_fast = self._extract_dialog_id(params)
                except Exception:
                    did_for_lang_fast = 0
                overrides_fast = self._load_chat_lang_overrides()
                idioma_fast = overrides_fast.get(did_for_lang_fast) or self._idioma_alvo()
                def _translate_and_send_fast():
                    try:
                        self._log("Fast mode: traduzindo em background")
                        texto_traduzido_local = self._traduzir_com_ia(mensagem_original, idioma_fast, reply_context)
                        if not texto_traduzido_local or texto_traduzido_local == mensagem_original:
                            return
                        self._apply_translation_result(params, texto_traduzido_local, origem_caption)
                        def _mark_and_send_fast():
                            try:
                                self._suppress_next_hook = True
                            except Exception:
                                pass
                            try:
                                run_on_ui_thread(lambda: self._tocar_ripple_suave())
                            except Exception:
                                pass
                            # Pós-envio: haptic
                            try:
                                if self._get_bool_setting("haptic_feedback_ativado", False):
                                    self._do_haptic_feedback()
                            except Exception:
                                pass
                            try:
                                if self._get_bool_setting("notify_ativado", False):
                                    self._play_notify_sound()
                            except Exception:
                                pass
                            try:
                                self._log("Fast mode: enviando tradução subsequente")
                            except Exception:
                                pass
                            get_send_messages_helper().sendMessage(params)
                        run_on_ui_thread(_mark_and_send_fast)
                    except Exception:
                        try:
                            self._log("Fast mode: erro ao traduzir em background")
                        except Exception:
                            pass
                try:
                    if run_on_queue:
                        run_on_queue(_translate_and_send_fast)
                    else:
                        import threading
                        threading.Thread(target=_translate_and_send_fast).start()
                except Exception:
                    pass
                return HookResult(HookStrategy.DEFAULT)

            # Quick Dismiss: mostra um spinner durante a tradução e dispensa ao concluir
            try:
                qd_ativado = self._get_bool_setting("quick_dismiss_ativado", False)
            except Exception:
                qd_ativado = False

            quick_dialog = None
            if qd_ativado:
                try:
                    fragment = self.get_last_fragment_safe()
                    ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
                    if not ctx:
                        try:
                            from org.telegram.messenger import ApplicationLoader
                            ctx = ApplicationLoader.applicationContext
                        except Exception:
                            ctx = None
                    if ctx:
                        # Usa AlertDialogBuilder com spinner, padrão em outros plugins Apple
                        from ui.alert import AlertDialogBuilder
                        quick_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_SPINNER)
                        quick_dialog.set_title("Quick Dismiss")
                        quick_dialog.set_message(self._t("quick_dismiss_alert_text"))
                        try:
                            quick_dialog.set_cancelable(False)
                        except Exception:
                            pass
                        try:
                            quick_dialog.set_canceled_on_touch_outside(False)
                        except Exception:
                            pass
                        try:
                            quick_dialog.set_progress(0)
                        except Exception:
                            pass
                        run_on_ui_thread(quick_dialog.show)
                except Exception:
                    quick_dialog = None

            # Verificar filtro por chat
            try:
                ativado_set = self._load_ativado_dialogs()
                desativado_set = self._load_desativado_dialogs()
                did = self._extract_dialog_id(params)
                if did:
                    if ativado_set:
                        if (did not in ativado_set) or (did in desativado_set):
                            return HookResult()
                    else:
                        if did in desativado_set:
                            return HookResult()
            except Exception:
                pass

            try:
                did_for_lang = self._extract_dialog_id(params)
            except Exception:
                did_for_lang = 0
            overrides = self._load_chat_lang_overrides()
            idioma = overrides.get(did_for_lang) or self._idioma_alvo()

            # Verifica se formatação está ativa e converte para Markdown
            if self._get_bool_setting("formatting_ativado", False):
                try:
                    # Tenta obter entidades originais
                    ents_orig = getattr(params, "entities", None)
                    if not ents_orig and origem_caption:
                         # Tenta pegar de captionEntities se existir ou params.entities
                         ents_orig = getattr(params, "captionEntities", getattr(params, "entities", None))
                    
                    if ents_orig and mensagem_original:
                        converted_md = self._entities_to_markdown(mensagem_original, ents_orig)
                        if converted_md != mensagem_original:
                            self._log("Formatting: Entidades convertidas para Markdown antes da tradução")
                            mensagem_original = converted_md
                except Exception as e:
                    self._log(f"Erro ao converter entidades para Markdown: {e}")

            # Quando Quick Dismiss está ativo, cancela o envio original e reenvia após traduzir
            if qd_ativado:
                try:
                    from client_utils import run_on_queue, get_send_messages_helper
                except Exception:
                    # Fallback: traduz sincrono e modifica params (mensagem ou caption)
                    self._log("Quick Dismiss indisponível; traduzindo de forma síncrona")
                    texto_traduzido = self._traduzir_com_ia(mensagem_original, idioma, reply_context)
                    self._apply_translation_result(params, texto_traduzido, origem_caption)
                    try:
                        changed = (texto_traduzido != mensagem_original)
                        self._log(f"Envio síncrono: traduzido={changed}")
                    except Exception:
                        pass
                    # Pós-envio: haptic
                    try:
                        if self._get_bool_setting("haptic_feedback_ativado", False):
                            self._do_haptic_feedback()
                    except Exception:
                        pass
                    return HookResult(HookStrategy.MODIFY, params=params)

                def _translate_and_send():
                    try:
                        self._log("Tradução assíncrona iniciada")
                        texto_traduzido_local = self._traduzir_com_ia(mensagem_original, idioma, reply_context)
                        self._apply_translation_result(params, texto_traduzido_local, origem_caption)
                        # Atualiza e fecha o diálogo, então envia
                        if quick_dialog:
                            try:
                                run_on_ui_thread(lambda: quick_dialog.set_progress(100))
                            except Exception:
                                pass
                            run_on_ui_thread(quick_dialog.dismiss)
                        try:
                            def _mark_and_send():
                                try:
                                    self._suppress_next_hook = True
                                except Exception:
                                    pass
                                try:
                                    run_on_ui_thread(lambda: self._tocar_ripple_suave())
                                except Exception:
                                    pass
                                try:
                                    changed = (texto_traduzido_local != mensagem_original)
                                    self._log(f"Envio assíncrono: traduzido={changed}")
                                except Exception:
                                    pass
                                # Pós-envio: haptic
                                try:
                                    if self._get_bool_setting("haptic_feedback_ativado", False):
                                        self._do_haptic_feedback()
                                except Exception:
                                    pass
                                try:
                                    if self._get_bool_setting("notify_ativado", False):
                                        self._play_notify_sound()
                                except Exception:
                                    pass
                                get_send_messages_helper().sendMessage(params)
                            run_on_ui_thread(_mark_and_send)
                        except Exception:
                            pass
                    except Exception:
                        # Fecha o diálogo em caso de erro
                        if quick_dialog:
                            try:
                                run_on_ui_thread(quick_dialog.dismiss)
                            except Exception:
                                pass
                        try:
                            self._log("Erro na tradução assíncrona; diálogo fechado")
                        except Exception:
                            pass
                    
                run_on_queue(_translate_and_send)
                return HookResult(HookStrategy.CANCEL)

            # Quick Dismiss desativado: traduz assíncrono e reenvia para evitar travar UI
            try:
                from client_utils import run_on_queue, get_send_messages_helper
            except Exception:
                # Fallback: manter fluxo síncrono se APIs de fila não estiverem disponíveis
                self._log("Quick Dismiss desativado; fallback síncrono por ausência de run_on_queue")
                texto_traduzido = self._traduzir_com_ia(mensagem_original, idioma, reply_context)
                self._apply_translation_result(params, texto_traduzido, origem_caption)
                try:
                    run_on_ui_thread(lambda: self._tocar_ripple_suave())
                except Exception:
                    pass
                # Pós-envio: haptic
                try:
                    if self._get_bool_setting("haptic_feedback_ativado", False):
                        self._do_haptic_feedback()
                except Exception:
                    pass
                try:
                    if self._get_bool_setting("notify_ativado", False):
                        self._play_notify_sound()
                except Exception:
                    pass
                try:
                    changed = (texto_traduzido != mensagem_original)
                    self._log(f"Envio síncrono: traduzido={changed}")
                except Exception:
                    pass
                return HookResult(HookStrategy.MODIFY, params=params)

            def _translate_and_send_no_qd():
                try:
                    self._log("Tradução assíncrona iniciada (QD off)")
                    texto_traduzido_local = self._traduzir_com_ia(mensagem_original, idioma, reply_context)
                    self._apply_translation_result(params, texto_traduzido_local, origem_caption)
                    def _mark_and_send():
                        try:
                            self._suppress_next_hook = True
                        except Exception:
                            pass
                        try:
                            run_on_ui_thread(lambda: self._tocar_ripple_suave())
                        except Exception:
                            pass
                        try:
                            changed = (texto_traduzido_local != mensagem_original)
                            self._log(f"Envio assíncrono (QD off): traduzido={changed}")
                        except Exception:
                            pass
                        # Pós-envio: haptic
                        try:
                            if self._get_bool_setting("haptic_feedback_ativado", False):
                                self._do_haptic_feedback()
                        except Exception:
                            pass
                        try:
                            if self._get_bool_setting("notify_ativado", False):
                                self._play_notify_sound()
                        except Exception:
                            pass
                        get_send_messages_helper().sendMessage(params)
                    run_on_ui_thread(_mark_and_send)
                except Exception:
                    try:
                        self._log("Erro na tradução assíncrona (QD off)")
                    except Exception:
                        pass

            run_on_queue(_translate_and_send_no_qd)
            return HookResult(HookStrategy.CANCEL)
        except Exception as e:
            try:
                self._log(f"Erro inesperado no hook de envio: {e}")
            except Exception:
                pass
            return HookResult()

    # Carregamento do plugin: registra o hook
    def on_plugin_load(self) -> None:
        # Garante que o hook de envio esteja ativo
        self.add_on_send_message_hook()
        # Registrar subfragmentos de forma explícita (quando o host suportar)
        try:
            register = getattr(self, "register_subfragment", None)
            if callable(register):
                # Permite abrir diretamente pelas rotas internas (ex.: optional_subfragment)
                register("optional_subfragment", self._create_optional_subfragment)
                register("ai_settings_subfragment", self._create_ai_settings_subfragment)
        except Exception:
            pass
        # Aplicar wrapper de logs apenas uma vez
        try:
            if Translatica._apply_log:
                self._apply_log_wrapper()
                Translatica._apply_log = False
        except Exception:
            pass
        # Aplicar estado inicial de desativação de logs a partir das configurações
        try:
            initial_muted = False
            try:
                initial_muted = bool(int(self.get_setting("logs_desativado", 0)))
            except Exception:
                initial_muted = bool(self.get_setting("logs_desativado", False))
            self._set_log_muted(initial_muted)
        except Exception:
            pass
        # Garante item de toggle no menu do chat
        try:
            self._ensure_chat_toggle_menu_item()
        except Exception:
            pass
        # Garante item do menu Explain Me se estiver ativado
        try:
            self._ensure_explain_me_menu_item()
        except Exception:
            pass

        # Garante item do menu Silent Fix se estiver ativado
        try:
            self._ensure_silent_fix_menu_item()
        except Exception:
            pass
        
        # Garante item do menu My Chat se estiver ativado
        try:
            self._ensure_my_chat_menu_item()
        except Exception:
            pass

        # Inicializa Hooks do Translatica (Entire Chat / Incoming)
        try:
            self._translatica_alternar_hooks_premium(self.get_setting("enable_entire_chat_translation", False))
            self._translatica_configurar_hooks_mensagem()
        except Exception:
            pass

        # Configura o Hook do Header de Configurações
        self._configurar_hook_header_configuracao()

    def _configurar_hook_header_configuracao(self):
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            if not PSA:
                return
            method = PSA.getClass().getDeclaredMethod("fillItems", find_class("java.util.ArrayList"), find_class("org.telegram.ui.Components.UniversalAdapter"))
            method.setAccessible(True)
            self.hook_settings_header_ref = self.hook_method(method, TranslaticaSettingsHeaderHook(self))
        except:
            pass

    # Header de Configurações (Estilo UiTweaks) - Menção honrosa: @luvztroy
    def _criar_header_configuracao(self, context):
        try:
            from android.widget import FrameLayout, TextView
            from android.view import Gravity
            from android.util import TypedValue
            from org.telegram.messenger import AndroidUtilities, ImageLocation
            from org.telegram.ui.ActionBar import Theme
            from org.telegram.ui.Components import LayoutHelper, BackupImageView
            from android_utils import OnClickListener
            
            container = FrameLayout(context)
            
            # Imagem (BackupImageView)
            # Tamanho: 108x108 dp (base)
            try:
                # Efeito de Partícula ao toque (Particle Effect)
                particles_view = None
                hide_particles_runnable = [None]
                try:
                    from org.telegram.ui.Components.Premium import StarParticlesView
                    particles_view = StarParticlesView(context)
                    particles_view.drawable.useRotate = False
                    particles_view.drawable.isCircle = True
                    particles_view.drawable.centerOffsetY = AndroidUtilities.dp(0)
                    particles_view.drawable.minLifeTime = 2000
                    particles_view.drawable.randLifeTime = 3000
                    try: particles_view.drawable.colorKey = Theme.key_premiumStarGradient2
                    except: pass
                    particles_view.drawable.updateColors()
                    particles_view.setVisibility(View.INVISIBLE)
                    container.addView(particles_view, LayoutHelper.createFrame(340, 140, Gravity.CENTER | Gravity.TOP, 0, 10, 0, 0))
                except: pass

                imagem_logo = BackupImageView(context)
                imagem_logo.setRoundRadius(AndroidUtilities.dp(54))
                
                # Dynamic Logo (Apple Refactored)
                is_unlocked = self.get_setting("extended_settings_unlocked", False)
                if is_unlocked:
                    url = "https://i.postimg.cc/zvzL5g5j/logopro.png"
                else:
                    url = "https://i.postimg.cc/C5hZYqY7/logot.png"
                
                imagem_logo.setImage(url, "108_108", None)
                
                # Easter Egg: 3 cliques para mensagem especial
                clicks = [0]
                last_click = [0]
                
                def on_logo_click(view):
                    # Trigger para particles
                    if particles_view:
                        try:
                            particles_view.setVisibility(View.VISIBLE)
                            particles_view.flingParticles(40)
                            
                            if hide_particles_runnable[0]:
                                AndroidUtilities.cancelRunOnUIThread(hide_particles_runnable[0])
                            
                            def _hide():
                                try: particles_view.setVisibility(View.INVISIBLE)
                                except: pass
                            
                            hide_particles_runnable[0] = _hide
                            run_on_ui_thread(_hide, 3000)
                        except: pass

                    # Ripple se já desbloqueado
                    is_unlocked = self.get_setting("extended_settings_unlocked", False)
                    if is_unlocked:
                        try:
                            from android.graphics.drawable import RippleDrawable
                            from android.content.res import ColorStateList
                            color = Theme.getColor(Theme.key_dialogTextBlue)
                            ripple = RippleDrawable(ColorStateList.valueOf(color), None, None)
                            view.setBackground(ripple)
                        except: pass

                    import time
                    now = time.time()
                    if now - last_click[0] > 1.0: # Reset após 1s sem clique
                        clicks[0] = 0
                    
                    clicks[0] += 1
                    last_click[0] = now
                    
                    # Easter Egg (3 cliques) - apenas se não desbloqueado ou sempre? 
                    # Ripple já foi aplicado acima se "unlocked".
                    if clicks[0] == 3:
                        import random
                        keys = [
                            "ee_context_detected", "ee_context_matters", "ee_reading_lines",
                            "ee_more_than_literal", "ee_words_context", "ee_semantic_layer",
                            "ee_context_resolution", "ee_meaning_words", "ee_intent_recognized",
                            "ee_context_pipeline", "ee_makes_sense", "ee_depends_context",
                            "ee_sounds_right", "ee_understands_more", "ee_built_context",
                            "ee_context_syntax", "ee_original"
                        ]
                        key = random.choice(keys)
                        text = self._t(key)
                        run_on_ui_thread(lambda: BulletinHelper.show_success(text))

                    # Unlock Extended Settings (15 clicks)
                    if clicks[0] == 15 and not is_unlocked:
                        try:
                            from android.graphics.drawable import RippleDrawable
                            from android.content.res import ColorStateList
                            
                            # Ripple effect
                            color = Theme.getColor(Theme.key_dialogTextBlue)
                            ripple = RippleDrawable(ColorStateList.valueOf(color), None, None)
                            view.setBackground(ripple)
                            
                            # Bulletin (Só na primeira vez)
                            self._exibir_notificacao_generica(self._t("extended_settings_title") or "Extended Settings", self._t("filtro_unlocked_msg") or "You unlocked something!")
                            
                            # Save setting
                            self.set_setting("extended_settings_unlocked", True)
                            
                            # Reset clicks
                            clicks[0] = 0
                        except Exception as e:
                            self._log(f"Erro ao desbloquear configurações estendidas: {e}")
                
                imagem_logo.setOnClickListener(OnClickListener(on_logo_click))
                
                container.addView(imagem_logo, LayoutHelper.createFrame(108, 108, Gravity.CENTER | Gravity.TOP, 0, 20, 0, 0))
            except: pass
            
            # Título
            titulo = TextView(context)
            titulo.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            try: titulo.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            except: pass
            titulo.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22)
            titulo.setText(f"Translatica v{__version__}")
            titulo.setSingleLine(True)
            titulo.setGravity(Gravity.CENTER)
            
            # Easter Egg no Título (5 cliques)
            header_clicks = [0]
            header_last_click = [0]
            
            def on_header_click(view):
                import time
                now = time.time()
                if now - header_last_click[0] > 1.0:
                    header_clicks[0] = 0
                
                header_clicks[0] += 1
                header_last_click[0] = now
                
                if header_clicks[0] == 5:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("ee_not_here")))
                    header_clicks[0] = 0

            titulo.setOnClickListener(OnClickListener(on_header_click))

            container.addView(titulo, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 50, 145, 50, 0))
            
            # Subtítulo
            subtitulo = TextView(context)
            subtitulo.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            subtitulo.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            subtitulo.setText(self._get_random_subtitle())
            subtitulo.setGravity(Gravity.CENTER)
            container.addView(subtitulo, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 60, 180, 60, 27))
            
            return container
        except:
            return None

    # Configurações expostas na tela de ajustes
    def create_settings(self):
        try:
            from ui.settings import Header, Divider, Input, Selector, Switch, Text
            
            items = []

            # Welcome
            try:
                user_name = self._get_current_user_name()
            except Exception:
                user_name = ""
            welcome_text = self._get_dynamic_welcome(user_name)

            items.append(Divider(text=welcome_text or self._t("translation_section")))

            # Preferências (Subfragmento)
            items.append(Text(
                text=self._t("preferences_label"),
                icon="attach_arrow_right",
                create_sub_fragment=self._create_preferences_subfragment,
                link_alias="preferences_subfragment"
            ))

            items.extend([
                Divider(),
                Text(
                    text=self._t("ai_settings_label"),
                    icon="msg_download_settings",
                    create_sub_fragment=self._create_ai_settings_subfragment,
                    link_alias="ai_settings_subfragment"
                ),
            ])

            items.extend([
                Divider(),
                Text(
                    text=self._t("using_translatica_label"),
                    icon="msg_info",
                    link_alias="using_translatica",
                    on_click=lambda view: self._show_using_translatica_sheet()
                ),
            ])



            # Dotted Plugins e Suporte
            try:
                items.append(Divider())
                # Padrão Apple Plugins
                items.append(Text(
                    text="Dotted Plugins",
                    icon="etg_settings",
                    accent=True,
                    link_alias="dotted_plugins",
                    on_click=lambda view: run_on_ui_thread(lambda: self._open_by_username("exteraDevPlugins"))
                ))
                items.append(Text(
                    text=self._t("support_title"),
                    icon="msg_reactions",
                    accent=True,
                    link_alias="support",
                    on_click=lambda view: self._show_support_sheet()
                ))
            except Exception:
                pass

            return items
        except Exception:
            return []

    def _on_change_idioma_alvo(self, idx):
        codigos = ["pt", "en", "es", "ru"]
        val = int(idx)
        if 0 <= val < len(codigos):
            self.set_setting("idioma_alvo", codigos[val])
        else:
            self.set_setting("idioma_alvo", "custom")
        self.reload_settings()

    def _on_change_custom_lang(self, val):
        self.set_setting("idioma_custom_code", str(val).strip())

    def _on_change_open_chats(self, idx):
        self.reload_settings()
        run_on_ui_thread(lambda: self._show_chat_overrides_sheet())

    def _get_cache_value(self, key, default=""):
        try:
            import os
            path = os.path.join(self._get_cache_dir_path(), f"{key}.txt")
            if os.path.exists(path):
                with open(path, "r", encoding="utf-8") as f:
                    return f.read().strip()
            return default
        except:
            return default

    def _set_cache_value(self, key, value):
        try:
            import os
            path = os.path.join(self._get_cache_dir_path(), f"{key}.txt")
            with open(path, "w", encoding="utf-8") as f:
                f.write(str(value))
        except:
            pass

    def _on_change_filtro(self, val):
        self.set_setting("filtro_ativado", bool(val))
        self.reload_settings()

    # Sistema Translatica Helpers | Translatica

    def _translatica_log_debug(self, mensagem: str):
        # Usa o sistema de logs existente do Translatica se possível ou apenas log interno
        try:
            log(f"Translatica: {mensagem}")
            print(f"Translatica: {mensagem}")
        except:
            pass

    def _translatica_obter_texto(self, chave, *args):
        texto = self._t(chave)
        if args:
            try:
                return texto.format(*args)
            except:
                return texto
        return texto

    def _translatica_executar_seguro(self, func, prefixo_erro="", padrao=None):
        try:
            return func()
        except Exception as e:
            if prefixo_erro:
                pass # Silencioso
            return padrao

    def _translatica_carregar_cache(self):
        global _translatica_cache_traducao
        if _translatica_cache_traducao:
            return _translatica_cache_traducao
        if os.path.exists(_translatica_arquivo_cache_traducoes):
            resultado = self._translatica_executar_seguro(
                lambda: json.load(open(_translatica_arquivo_cache_traducoes, "r", encoding="utf-8")),
                "[CACHE] Falha ao carregar"
            )
            if resultado:
                _translatica_cache_traducao = resultado
                return _translatica_cache_traducao
        _translatica_cache_traducao = {}
        return _translatica_cache_traducao

    def _translatica_salvar_cache(self, chave_texto, idioma_alvo, texto_traduzido):
        global _translatica_cache_sujo
        
        chave = f"{hashlib.md5(chave_texto.encode('utf-8')).hexdigest()}_{idioma_alvo}"
        cache = self._translatica_carregar_cache()
        cache[chave] = texto_traduzido
        
        # Rodando em bg
        def _salvar():
            try:
                # Garante que o diretório existe (Fix Persistence)
                d = os.path.dirname(_translatica_arquivo_cache_traducoes)
                if d and not os.path.exists(d):
                    os.makedirs(d, exist_ok=True)

                with open(_translatica_arquivo_cache_traducoes, "w", encoding="utf-8") as f:
                    json.dump(cache, f, ensure_ascii=False, indent=2)
                    f.flush()
                    os.fsync(f.fileno())
                
                # Debug log para confirmar
                self._translatica_log_debug(f"Cache salvo em: {_translatica_arquivo_cache_traducoes} | Chaves: {len(cache)}")
            except Exception as e:
                # Log de erro explícito
                self._translatica_log_debug(f"ERRO CRÍTICO ao salvar cache: {e}")
                import traceback
                traceback.print_exc()
        
        # Executa sem wrapper para garantir (mas ainda em thread se possível, ou direto)
        # Como _translatica_executar_seguro usa try/except, vamos usar direto aqui
        try:
             _translatica_executor.submit(_salvar)
        except:
             # Fallback sincrono se executor falhar
             _salvar()

    def _translatica_obter_cache(self, texto, idioma_alvo):
        chave = f"{hashlib.md5(texto.encode('utf-8')).hexdigest()}_{idioma_alvo}"
        cache = self._translatica_carregar_cache()
        return cache.get(chave)

    def _translatica_ja_traduzido(self, texto_original: str, codigo_idioma_alvo: str) -> bool:
        if not texto_original or len(texto_original) < 3:
            return True
        
        faixas_chars = {
            ("zh", "ja", "ko"): [("\u4e00", "\u9fff"), ("\u3040", "\u309f"), ("\u30a0", "\u30ff"), ("\uac00", "\ud7af")],
            ("ru", "uk", "bg"): [("\u0400", "\u04ff")],
        }
        
        for grupo_lang, faixas in faixas_chars.items():
            if codigo_idioma_alvo in grupo_lang:
                return any(inicio <= c <= fim for c in texto_original for inicio, fim in faixas)
        return False

    def _translatica_resolver_dns_doh(self, hostname):
        # Tenta Cloudflare
        try:
            # Usa IP direto para evitar resolução de DNS local para o provedor DoH (experimnental)
            session = self._translatica_get_session()
            r = session.get("https://1.1.1.1/dns-query", 
                             params={"name": hostname, "type": "A"},
                             headers={"Accept": "application/dns-json"}, timeout=2, verify=False)
            if r.status_code == 200:
                data = r.json()
                if "Answer" in data:
                    for ans in data["Answer"]:
                        if ans["type"] == 1: # Record
                            return ans["data"]
        except:
            pass
        
        # Fallback para Google (8.8.8.8)
        try:
            session = self._translatica_get_session()
            r = session.get("https://8.8.8.8/resolve", 
                             params={"name": hostname, "type": "A"}, timeout=2, verify=False)
            if r.status_code == 200:
                data = r.json()
                if "Answer" in data:
                    for ans in data["Answer"]:
                        if ans["type"] == 1:
                            return ans["data"]
        except:
            pass
        return None
    # Avaliar necessidade
    def _translatica_verificar_online(self):
        try:
            session = self._translatica_get_session()
            session.get("https://1.1.1.1", timeout=1, verify=False)
            return True
        except:
            return False

    def _translatica_get_session(self):
        global _translatica_session
        if _translatica_session is None:
            _translatica_session = requests.Session()
            adapter = requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100, max_retries=1)
            _translatica_session.mount("http://", adapter)
            _translatica_session.mount("https://", adapter)
        return _translatica_session

    def _translatica_get_random_user_agent(self):
        return random.choice(USER_AGENTS)

    def _translatica_traduzir_google(self, text: str, target_lang: str):
        # 0=Server 2 (Direct) [DEFAULT], 1=Smart Auto, 2=Server 3 (Mobile), 3=Server 1 (Legacy)
        server_pref = int(self.get_setting("translation_server", 0))
        
        if server_pref == 0:
             # Default: Direct (Fastest)
             return self._translatica_traduzir_google_v2(text, target_lang)
        
        elif server_pref == 1:
             # Smart Auto: V2 -> V3 -> V1
             res = self._translatica_traduzir_google_v2(text, target_lang)
             if res: return res
             res = self._translatica_traduzir_google_v3(text, target_lang)
             if res: return res
             return self._translatica_traduzir_google_v1(text, target_lang)
             
        elif server_pref == 2:
            return self._translatica_traduzir_google_v3(text, target_lang)
            
        elif server_pref == 3:
            return self._translatica_traduzir_google_v1(text, target_lang)
            
        # Fallback default
        return self._translatica_traduzir_google_v2(text, target_lang)

    def _translatica_traduzir_google_v1(self, text: str, target_lang: str):
        try:
            hostname = "clients5.google.com"
            ip = self._translatica_resolver_dns_doh(hostname)
            
            # Métodos experimentais
            params = {"client": "gtx", "sl": "auto", "tl": target_lang, "dt": "t", "q": text}
            headers = {
                "User-Agent": self._translatica_get_random_user_agent(),
                "Host": hostname
            }
            
            url = f"https://{ip}/translate_a/t" if ip else f"https://{hostname}/translate_a/t"
            
            session = self._translatica_get_session()
            response = session.get(
                url,
                params=params, headers=headers, timeout=3, verify=False
            )
            response.raise_for_status()
            result = response.json()
            if result and isinstance(result, list) and result[0] and isinstance(result[0], list):
                return result[0][0]
        except Exception:
            pass
        return None

    def _translatica_traduzir_google_v2(self, text: str, translatica_lang: str):
        try:
            # Server 2: translate.googleapis.com (Mais Rápido/Direto) - SEM DNS (Velocidade Maxima)
            import urllib.parse
            encoded_text = urllib.parse.quote(text)
            url = f"https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl={translatica_lang}&dt=t&q={encoded_text}"
            
            headers = {'User-Agent': 'Mozilla/5.0'}
            session = self._translatica_get_session()
            response = session.get(url, headers=headers, timeout=3, verify=False)
            
            if response.status_code == 200:
                result = response.json()
                if result and len(result) > 0 and result[0]:
                    translated_parts = []
                    for part in result[0]:
                        if part[0]:
                            translated_parts.append(part[0])
                    return ' '.join(translated_parts)
        except Exception:
             pass
        return None

    def _translatica_traduzir_google_v3(self, text: str, target_lang: str):
        try:
            # Server 3: Mobile Web (Lightweight/HTML) + DNS
            hostname = "translate.google.com"
            ip = self._translatica_resolver_dns_doh(hostname)
            
            import urllib.parse
            import re
            import html
            
            encoded_text = urllib.parse.quote(text)
            
            base_url = f"https://{ip}" if ip else f"https://{hostname}"
            url = f"{base_url}/m?sl=auto&tl={target_lang}&q={encoded_text}"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36',
                'Host': hostname
            }
            
            session = self._translatica_get_session()
            response = session.get(url, headers=headers, timeout=3, verify=False)
            
            if response.status_code == 200:
                text_html = response.text
                match = re.search(r'class="result-container">([\s\S]*?)</div>', text_html)
                if match:
                    raw_text = match.group(1)
                    return html.unescape(raw_text)
        except Exception:
            pass
        return None

    def _translatica_traduzir_google_async(self, text: str, target_lang: str, callback):
        def tarefa():
            traduzido = self._translatica_traduzir_google(text, target_lang)
            if traduzido:
                callback(traduzido)
        _translatica_executor.submit(tarefa)

    def _translatica_inicializar_classes_mensagem(self):
        global _translatica_classes_mensagem
        if _translatica_classes_mensagem:
            return True
        try:
            _translatica_classes_mensagem.update({
                'CU': jclass("com.exteragram.messenger.utils.ChatUtils"),
                'TA': jclass("org.telegram.ui.Components.TranslateAlert2"), # Lembrete: odeio esse efeito
                'CA': jclass("org.telegram.ui.ChatActivity"),
                'CM': jclass("org.telegram.ui.Cells.ChatMessageCell"),
            })
            return True
        except:
            return False

    def _translatica_aplicar_traducao_mensagem(self, msg, activity, txt, lang):
        try:
            mo = msg.messageOwner
            if not mo:
                return

            e_transcricao = (
                (hasattr(mo, "voiceTranscription") and mo.voiceTranscription) or
                (hasattr(mo, "transcription") and mo.transcription)
            )

            if not e_transcricao:
                # Cria TL_textWithEntities
                te = TLRPC.TL_textWithEntities()
                te.text = txt
                te.entities = ArrayList()
                
                mo.translatedText = te
                mo.translatedToLanguage = lang
                _translatica_traduzido_em_mensagem.add((msg.getDialogId(), msg.getId()))

            def ui():
                try:
                    if e_transcricao:
                        for attr in ("voiceTranscription", "transcription"):
                            if hasattr(mo, attr) and getattr(mo, attr):
                                setattr(mo, attr, txt)
                                break
                    else:
                        msg.translated = True
                        msg.applyNewText(txt)
                    
                    msg.generateCaption()
                    msg.resetLayout()
                    
                    adapter = get_private_field(activity, "chatAdapter")
                    if adapter:
                        adapter.notifyDataSetChanged()
                except:
                    pass

            run_on_ui_thread(ui)
        except:
            pass

    def _translatica_alternar_hooks_premium(self, ativar: bool):
        if ativar:
            self._translatica_hook_premium()
        else:
            self._translatica_unhook_premium()

    def _translatica_hook_premium(self):
        try:
            clazz = jclass("org.telegram.messenger.UserConfig")
            clazz2 = jclass("org.telegram.messenger.MessagesController")
            
            if not hasattr(self, "_translatica_hooks_premium_lista"):
                self._translatica_hooks_premium_lista = []
            
            # Evita duplicar
            if self._translatica_hooks_premium_lista:
                return

            self._translatica_hooks_premium_lista = [
                self.hook_method(clazz.getClass().getDeclaredMethod("isPremium"), TranslaticaResultado(True)),
                self.hook_method(clazz.getClass().getDeclaredMethod("hasPremiumOnAccounts"), TranslaticaResultado(True)),
                self.hook_method(clazz2.getClass().getDeclaredMethod("premiumFeaturesBlocked"), TranslaticaResultado(False)),
            ]
        except:
            pass

    def _translatica_unhook_premium(self):
        if hasattr(self, "_translatica_hooks_premium_lista") and self._translatica_hooks_premium_lista:
            for unhook in self._translatica_hooks_premium_lista:
                self._translatica_executar_seguro(lambda u=unhook: self.unhook_method(u))
            self._translatica_hooks_premium_lista = []

    def _translatica_configurar_hooks_mensagem(self):
        if self.get_setting("enable_in_message_translation", False):
            if not self._translatica_inicializar_classes_mensagem():
                return
            try:
                if not hasattr(self, "_translatica_hooks_mensagem_lista"):
                    self._translatica_hooks_mensagem_lista = []
                
                if not self._translatica_hooks_mensagem_lista:
                    hooks = []
                    hooks.append(self.hook_all_methods(_translatica_classes_mensagem['TA'], "showAlert", TranslaticaAlertaMensagem(self)))
                    hooks.append(self.hook_all_methods(MessageObject, "updateTranslation", TranslaticaBloqueioReversao()))

                    try:
                        TranslateController = jclass("org.telegram.messenger.TranslateController")
                        Utilities = jclass("org.telegram.messenger.Utilities")
                        Callback4 = Utilities.Callback4
                        target_method = TranslateController.getClass().getDeclaredMethod("pushToTranslate", MessageObject, String, Callback4)
                        target_method.setAccessible(True)
                        # MethodReplacement para integrar totalmente ao fluxo nativo
                        hook_instance = TranslaticaHookTradutorNativo(self, 1)
                        hooks.append(self.hook_method(target_method, hook_instance))
                    except Exception as e:
                        try:
                            self._translatica_log_debug(f"Falha ao hookar pushToTranslate: {e}")
                        except Exception:
                            pass

                    self._translatica_hooks_mensagem_lista = hooks
            except Exception:
                pass
        else:
            self._translatica_desmontar_hooks_mensagem()

    def _translatica_desmontar_hooks_mensagem(self):
        if hasattr(self, "_translatica_hooks_mensagem_lista") and self._translatica_hooks_mensagem_lista:
            for lista_hooks in self._translatica_hooks_mensagem_lista:
                # hook_all_methods retorna lista
                if isinstance(lista_hooks, list):
                    for h in lista_hooks:
                        self._translatica_executar_seguro(lambda u=h: self.unhook_method(u))
                else:
                    self._translatica_executar_seguro(lambda u=lista_hooks: self.unhook_method(u))
            self._translatica_hooks_mensagem_lista = []
        _translatica_traduzido_em_mensagem.clear()

    def _translatica_limpar_traducoes_nativas(self):
        try:
            mc = self.get_messages_controller()
            fragment = self.get_last_fragment_safe()
            if not mc or not fragment or not hasattr(fragment, "getDialogId"):
                return
            
            did = fragment.getDialogId()
            
            def toggle():
                tc = mc.getTranslateController()
                if tc:
                    tc.toggleTranslatingDialog(did, False)
                    tc.toggleTranslatingDialog(did, True)
            
            run_on_ui_thread(toggle)
            # Post UI refresh
            try:
                NotificationCenter.getInstance(mc.getCurrentAccount()).postNotificationName(
                    NotificationCenter.updateInterfaces, JInteger(4)
                )
            except:
                pass
        except:
            pass

    def _translatica_limpar_cache_traducao_com_nativo(self, view=None):
        global _translatica_traduzido_em_mensagem
        try:
            contagem = self._translatica_obter_contagem_cache()
            self._translatica_limpar_traducoes_nativas()
            
            if os.path.exists(_translatica_arquivo_cache_traducoes):
                os.remove(_translatica_arquivo_cache_traducoes)
                run_on_ui_thread(lambda: BulletinHelper.show_success(self._translatica_obter_texto("cache_cleared", contagem)))
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_info(self._translatica_obter_texto("cache_empty")))
            
            _translatica_traduzido_em_mensagem.clear()
            global _translatica_cache_traducao
            _translatica_cache_traducao = {}
            self.reload_settings() # Atualiza UI se estiver aberta
        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(self._translatica_obter_texto("cache_error", e)))

    def _translatica_obter_tamanho_cache(self):
        if os.path.exists(_translatica_arquivo_cache_traducoes):
            return self._translatica_executar_seguro(lambda: os.path.getsize(_translatica_arquivo_cache_traducoes) / 1024, default=0)
        return 0

    def _translatica_obter_contagem_cache(self):
        return self._translatica_executar_seguro(lambda: len(self._translatica_carregar_cache()), default=0)

    def _translatica_obter_idioma_alvo_telegram(self):
        try:
            mc = self.get_messages_controller()
            if mc:
                tc = mc.getTranslateController()
                fragment = self.get_last_fragment_safe()
                if tc and fragment and hasattr(fragment, "getDialogId"):
                    dlg_lang = tc.getDialogTranslateTo(fragment.getDialogId())
                    if dlg_lang:
                        return dlg_lang
        except:
            pass
        
        try:
            MessagesController_class = jclass("org.telegram.messenger.MessagesController")
            telegram_lang = MessagesController_class.getGlobalMainSettings().getString("translate_to_language", None)
            if telegram_lang:
                return telegram_lang
        except:
            pass
        return "en"

    def _translatica_obter_texto_valido(self, message_object) -> str:
        original_text = message_object.messageText
        if not original_text or not isinstance(original_text, str) or not original_text.strip():
            mo = getattr(message_object, "messageOwner", None)
            if mo and hasattr(mo, "message") and mo.message:
                original_text = mo.message
        
        if original_text and isinstance(original_text, str) and original_text.strip():
            return original_text
        return None

    def _translatica_criar_texto_com_entidades(self, text: str):
        te = TLRPC.TL_textWithEntities()
        te.text = text
        te.entities = ArrayList()
        return te

    def _translatica_reverter_traducao_nativo(self, message_object):
        def ui_update_task():
            try:
                mo = getattr(message_object, "messageOwner", None)
                if not mo:
                    return
                
                # Limpa tradução
                mo.translatedText = None
                mo.translatedToLanguage = None
                
                # Remove do set de traduzidos para permitir comportamento nativo se necessário
                try:
                    _translatica_traduzido_em_mensagem.discard((message_object.getDialogId(), message_object.getId()))
                except:
                    pass
                
                account = getattr(message_object, "currentAccount", 0)
                NC = jclass("org.telegram.messenger.NotificationCenter")
                nc_inst = NC.getInstance(account)
                
                # Notifica que a mensagem foi "traduzida" (atualizada)
                nc_inst.postNotificationName(NC.messageTranslated, message_object)
                
                # Atualiza UI
                nc_inst.postNotificationName(NC.updateInterfaces, JInteger(4))
            except Exception:
                pass
        
        run_on_ui_thread(ui_update_task)

    def _translatica_armazenar_traducao_nativo(self, message_object, texto_traduzido: str, codigo_idioma_alvo: str):
        def ui_update_task():
            try:
                mo = getattr(message_object, "messageOwner", None)
                if not mo:
                    return
                
                mo.translatedText = self._translatica_criar_texto_com_entidades(texto_traduzido)
                mo.translatedToLanguage = codigo_idioma_alvo
                
                account = getattr(message_object, "currentAccount", 0)
                NC = jclass("org.telegram.messenger.NotificationCenter")
                nc_inst = NC.getInstance(account)
                nc_inst.postNotificationName(NC.messageTranslated, message_object)
                
                # Post UI refresh
                nc_inst.postNotificationName(NC.updateInterfaces, JInteger(4))
            except Exception:
                pass
        
        run_on_ui_thread(ui_update_task)

    def _translatica_processar_traducao(self, original_text: str, message_key: str, target_lang_code: str, message_object):
        try:
            self._translatica_log_debug(f"Processando tradução: {message_key} -> {target_lang_code}")
            cached = self._translatica_obter_cache(original_text, target_lang_code)
            if cached:
                self._translatica_log_debug(f"Cache encontrado para {message_key}")
                self._translatica_armazenar_traducao_nativo(message_object, cached, target_lang_code)
                # Marca como traduzido para evitar loops mesmo com cache
                try:
                    _translatica_traduzido_em_mensagem.add((message_object.getDialogId(), message_object.getId()))
                except:
                    pass
                return
            
            if not self._translatica_verificar_online():
                self._translatica_log_debug("Offline: não é possível traduzir")
                return
            
            # Tradução
            traduzido = self._translatica_traduzir_google(original_text, target_lang_code)
            
            if not traduzido:
                self._translatica_log_debug("Tradução retornou vazio")
                return
            
            self._translatica_salvar_cache(original_text, target_lang_code, traduzido)
            self._translatica_armazenar_traducao_nativo(message_object, traduzido, target_lang_code)
            
            # Marca como traduzido para evitar loops
            try:
                _translatica_traduzido_em_mensagem.add((message_object.getDialogId(), message_object.getId()))
            except:
                pass

        except Exception as e:
            self._translatica_log_debug(f"Erro em _translatica_processar_traducao: {e}")
        finally:
            _translatica_em_progresso_mensagens.discard(message_key)

    # Handlers UI Premium (evitar piada)
    def _translatica_ao_alternar_premium(self, valor):
        self._translatica_alternar_hooks_premium(valor)
        # Sincroniza com nativo
        try:
            mc = self.get_messages_controller()
            if mc:
                tc = mc.getTranslateController()
                run_on_ui_thread(lambda: tc.setChatTranslateEnabled(valor))
        except:
            pass
        self.reload_settings()

    def _translatica_ao_alternar_in_message(self, valor):
        self._translatica_configurar_hooks_mensagem()
        self.reload_settings()

    def _translatica_ao_alternar_auto_translate(self, valor):
        self.set_setting("auto_translate_ativado", valor)
        self.set_setting("enable_entire_chat_translation", valor)
        self.set_setting("enable_in_message_translation", valor)
        
        self._translatica_alternar_hooks_premium(valor)
        self._translatica_configurar_hooks_mensagem()
        
        try:
            mc = self.get_messages_controller()
            if mc:
                tc = mc.getTranslateController()
                run_on_ui_thread(lambda: tc.setChatTranslateEnabled(valor))
        except:
            pass
        self.reload_settings()

    def _ao_alterar_meaning_detector(self, idx):
        try:
            val = int(idx)
            # 0=Desativado, 1=Ativado, 2=OQueÉIsso
            if val == 2:
                old_val = int(self.get_setting("meaning_detector_mode", 0))
                try:
                    def _show_info_sheet():
                        try:
                            from org.telegram.ui.ActionBar import BottomSheet, Theme
                            from org.telegram.messenger import AndroidUtilities
                            from android.widget import LinearLayout, TextView
                            from android.view import Gravity
                            from android.util import TypedValue
                            from org.telegram.ui.Components import LayoutHelper
                            from android_utils import OnClickListener

                            fragment = self.get_last_fragment_safe()
                            ctx = fragment.getParentActivity() if fragment else None
                            if not ctx: return

                            sheet = BottomSheet(ctx, True)
                            container = LinearLayout(ctx)
                            container.setOrientation(LinearLayout.VERTICAL)
                            container.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(24))

                            title = TextView(ctx)
                            title.setText(self._translatica_obter_texto("meaning_detector_label"))
                            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
                            title.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                            title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                            container.addView(title, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 12))

                            text = TextView(ctx)
                            text.setText(self._translatica_obter_texto("meaning_detector_info_text"))
                            text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                            text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                            container.addView(text, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 24))

                            btn = TextView(ctx)
                            btn.setText(self._translatica_obter_texto("modal_got_it"))
                            btn.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
                            btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
                            btn.setGravity(Gravity.CENTER)
                            btn.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                            btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                            
                            def _close_click(v):
                                try: sheet.dismiss()
                                except: pass

                            btn.setOnClickListener(OnClickListener(_close_click))
                            container.addView(btn, LayoutHelper.createLinear(-2, -2, Gravity.END))

                            sheet.setCustomView(container)
                            sheet.show()
                        except Exception:
                            pass
                    run_on_ui_thread(_show_info_sheet)
                except: pass
                
                # Restaura o valor anterior imediatamente
                try:
                    self.set_setting("meaning_detector_mode", 0)
                    
                    # Hack: Força a atualização da UI para reverter visualmente a seleção ;)
                    def _restore_ui():
                        try:
                            self.reload_settings()
                        except: pass
                    
                    run_on_ui_thread(_restore_ui)
                except: pass
                return

            self.set_setting("meaning_detector_mode", val)
        except Exception:
            self.set_setting("meaning_detector_mode", 0)

    def _create_extended_settings_subfragment(self, parent_view=None):
        try:
            from ui.settings import Divider, Switch, Input, Text, Selector, Header
            items = []
            
            items.append(Divider(text=self._translatica_obter_texto("section_auto_trans")))

            # Funcionalidade Unificada
            auto_translate = self.get_setting("auto_translate_ativado", False)
            items.append(Switch(
                key="auto_translate_ativado",
                text=self._translatica_obter_texto("auto_translate_label"),
                default=auto_translate,
                icon="msg_translate",
                on_change=self._translatica_ao_alternar_auto_translate,
                subtext=self._translatica_obter_texto("auto_translate_subtext"),
                link_alias="auto_translate_ativado",
            ))
            
            # Seletor de Servidor
            server_idx = int(self.get_setting("translation_server", 0))
            items.append(Selector(
                key="translation_server",
                text=self._translatica_obter_texto("translation_engine_label"),
                default=server_idx,
                items=[
                    self._translatica_obter_texto("server_2_fast"),
                    self._translatica_obter_texto("server_smart_best"),
                    self._translatica_obter_texto("server_3_mobile"),
                    self._translatica_obter_texto("server_1_legacy"),
                ],
                icon="msg_language",
                link_alias="translation_server",
                on_change=lambda v: self.set_setting("translation_server", int(v))
            ))
            # Nova do Dev:
            # Meaning Detector (Movido para Filtro)
            # Gerenciamento de Cache - Melhorar futuramente
          
            items.append(Divider(text=self._translatica_obter_texto("filter_section")))
            
            # Filtro Switch
            items.append(Switch(
                key="filtro_ativado",
                text=self._translatica_obter_texto("filter_switch"),
                subtext=self._translatica_obter_texto("filter_switch_sub"),
                default=self._get_bool_setting("filtro_ativado", False),
                icon="msg_block",
                on_change=self._on_change_filtro,
                link_alias="filtro_ativado"
            ))
            
            # Filtro Input (visível quando Switch está ativado)
            if self._get_bool_setting("filtro_ativado", False):
                val = self._get_cache_value("filtro_palavras", "")
                items.append(Input(
                    key="filtro_palavras",
                    text=self._translatica_obter_texto("filter_input"),
                    default=val,
                    icon="msg_edit",
                    link_alias="filtro_palavras",
                    on_change=lambda v: self._set_cache_value("filtro_palavras", str(v))
                ))

            # Meaning Detector (Seção correta - Após Filtro)
            meaning_idx = int(self.get_setting("meaning_detector_mode", 0))
            items.append(Selector(
                key="meaning_detector_mode",
                text=self._t("meaning_detector_label"),
                default=meaning_idx,
                items=[self._t("meaning_detector_desativado"), self._t("meaning_detector_ativado"), self._t("quickbite_whatisthis")],
                icon="input_suggest_s",
                link_alias="meaning_detector_mode",
                on_change=self._ao_alterar_meaning_detector,
            ))

            # Translatica Agent
            items.append(Divider(text=self._t("agent_settings_header")))
            
            agent_enabled = self.get_setting("agent_enabled", False)
            items.append(Switch(
                key="agent_enabled",
                text=self._t("agent_enabled_label"),
                subtext=self._t("agent_enabled_subtext"),
                default=agent_enabled,
                icon="menu_premium_chatbot",
                on_change=lambda v: self.set_setting("agent_enabled", bool(v)),
                link_alias="agent_enabled"
            ))

            if agent_enabled:
                persona_idx = int(self.get_setting("agent_persona_mode", 0))
                items.append(Selector(
                    key="agent_persona_mode",
                    text=self._t("agent_persona_label"),
                    default=persona_idx,
                    items=[
                        self._t("agent_persona_default"),
                        self._t("agent_persona_nerd"),
                        self._t("agent_persona_layman"),
                        self._t("agent_persona_custom"),
                    ],
                    icon="msg_arrowright",
                    link_alias="agent_persona_mode",
                    on_change=lambda v: self.set_setting("agent_persona_mode", int(v))
                ))
                
                if persona_idx == 3:
                    custom_persona = str(self.get_setting("agent_custom_persona", ""))
                    items.append(Input(
                        key="agent_custom_persona",
                        text=self._t("agent_custom_persona_label"),
                        default=custom_persona,
                        icon="msg_arrowright",
                        link_alias="agent_custom_persona",
                        on_change=lambda v: self.set_setting("agent_custom_persona", str(v))
                    ))

            # Opção de idioma de envio (sem subtext)
            send_mode_idx = int(self.get_setting("agent_send_lang_mode", 0))
            items.append(Selector(
                key="agent_send_lang_mode",
                text=self._t("agent_send_lang_label"),
                default=send_mode_idx,
                items=[
                    self._t("agent_send_lang_original"),
                    self._t("agent_send_lang_target"),
                ],
                icon="msg_arrowright",
                link_alias="agent_send_lang_mode",
                on_change=lambda v: self.set_setting("agent_send_lang_mode", int(v))
            ))

            # Experimental
            items.append(Divider(text=self._t("experimental_section")))
            
            experimental_enabled = self.get_setting("experimental_providers_enabled", False)
            items.append(Switch(
                key="experimental_providers_enabled",
                text=self._t("experimental_providers_switch"),
                subtext=self._t("experimental_providers_subtext"),
                default=experimental_enabled,
                on_change=lambda v: self.set_setting("experimental_providers_enabled", bool(v)),
                link_alias="experimental_providers_enabled"
            ))

            items.append(Divider(text=self._translatica_obter_texto("extended_unlocked_footer")))
            
            return items
        except Exception:
            return []



    def _create_preferences_subfragment(self, parent_view=None):
        try:
            from ui.settings import Header, Divider, Input, Selector, Switch, Text
            items = []

            # 0. Idioma Alvo
            try:
                # Seção Geral
                items.append(Divider(text=self._t("pref_section_general")))
                
                raw_alvo = str(self.get_setting("idioma_alvo", "pt"))
                cur_lang = self._idioma_alvo()
                codigos = ["pt", "en", "es", "ru"]
                
                if raw_alvo == "custom":
                    target_idx = 4
                elif cur_lang in codigos:
                    target_idx = codigos.index(cur_lang)
                else:
                    target_idx = 4 # Custom

                target_labels = [
                    self._t("lang_portuguese"),
                    self._t("lang_english"),
                    self._t("lang_spanish"),
                    self._t("lang_russian"),
                    self._t("lang_custom")
                ]

                items.append(Selector(
                    key="idioma_alvo",
                    text=self._t("target_lang_label") or "Target Language",
                    default=target_idx,
                    items=target_labels,
                    icon="msg_language",
                    link_alias="target_lang",
                    on_change=self._on_change_idioma_alvo,
                ))

                if target_idx == 4:
                    items.append(Input(
                        key="idioma_custom_code",
                        text=self._t("custom_lang_label") or "Code (e.g. fr, de, it)",
                        default=str(self.get_setting("idioma_custom_code", "")),
                        icon="msg_edit",
                        link_alias="custom_lang_input",
                        on_change=self._on_change_custom_lang
                    ))
                
                items.append(Divider())
            except Exception:
                pass

            # Meu Chat
            items.append(Switch(
                key="my_chat_ativado",
                text=self._t("my_chat_ativado_label"),
                subtext=self._t("my_chat_ativado_subtext"),
                default=self._get_bool_setting("my_chat_ativado", False),
                icon="msg_msgbubble3_solar",
                link_alias="my_chat_ativado",
                on_change=self._on_change_my_chat,
            ))

            try:
                items.append(Text(
                    text=self._t("chats_label"),
                    icon="msg_chats_add_remix",
                    on_click=lambda view: run_on_ui_thread(lambda: self._show_chat_overrides_sheet()),
                    link_alias="chats_list"
                ))
            except Exception:
                pass
            
            # 1. Modo de Resposta
            # Seção de Envio
            items.append(Divider(text=self._t("pref_section_sending")))
            
            items.append(Switch(
                key="reply_mode_ativado",
                text=self._t("reply_mode_label"),
                default=self._get_bool_setting("reply_mode_ativado", False),
                icon="menu_reply",
                subtext=self._t("reply_mode_subtext"),
                link_alias="reply_mode_ativado",
            ))

            # 2. Manter Alvo
            items.append(Switch(
                key="keep_target_ativado",
                text=self._t("keep_target_label"),
                default=self._get_bool_setting("keep_target_ativado", True),
                icon="chats_pin",
                subtext=self._t("keep_target_subtext"),
                link_alias="keep_target_ativado",
            ))

            # 3. Explicar Isso
            # Seção de Assistência
            items.append(Divider(text=self._t("pref_section_assistance")))

            items.append(Switch(
                key="explain_me_ativado",
                text=self._t("explain_me_label"),
                default=self._get_bool_setting("explain_me_ativado", False),
                icon="msg_emoji_question",
                subtext=self._t("explain_me_subtext"),
                link_alias="explain_me_ativado",
                on_change=self._on_change_explain_me,
            ))
            
            # Seletor QuickBite (apenas se Explicar Isso estiver ativo)
            if self._get_bool_setting("explain_me_ativado", False):
                qb_idx = int(self.get_setting("quickbite_mode", 0))
                items.append(Selector(
                    key="quickbite_mode",
                    text="QuickBite",
                    default=qb_idx,
                    items=[self._t("quickbite_default"), self._t("quickbite_tldr"), self._t("quickbite_whatisthis")],
                    icon="menu_quote_remix",
                    link_alias="quickbite_mode",
                    on_change=self._ao_alterar_quickbite,
                ))

            # Correção Silenciosa
            items.append(Switch(
                key="silent_fix_ativado",
                text=self._t("silent_fix_label"),
                default=self._get_bool_setting("silent_fix_ativado", False),
                icon="msg_edit",
                subtext=self._t("silent_fix_subtext"),
                link_alias="silent_fix_ativado",
                on_change=self._on_change_silent_fix,
            ))

            # 4. AddL
            # Seção Avançada
            items.append(Divider(text=self._t("pref_section_advanced")))
            
            addl_ativado = self._get_bool_setting("addl_ativado", False)
            items.append(Switch(
                key="addl_ativado",
                text=self._t("addl_label"),
                subtext=self._t("addl_subtext"),
                default=addl_ativado,
                icon="msg_chats_add_remix",
                link_alias="addl_ativado",
                on_change=self._on_change_addl_ativado,
            ))
            
            if addl_ativado:
                items.append(Input(
                    key="addl_lang",
                    text=self._t("addl_lang_label"),
                    default=str(self.get_setting("addl_lang", "")),
                    icon="msg_language_solar",
                    link_alias="addl_lang",
                    on_change=self._on_change_addl_lang,
                ))
                addl_style_idx = int(self.get_setting("addl_style", 0))
                items.append(Selector(
                    key="addl_style",
                    text=self._t("addl_style_label"),
                    default=addl_style_idx,
                    items=[self._t("addl_style_default"), self._t("addl_style_quote"), self._t("addl_style_quote_collapsed")],
                    icon="mini_quote_remix",
                    link_alias="addl_style",
                    on_change=self._on_change_addl_style,
                ))

            # 5. Verificar Antes
            check_before = self._get_bool_setting("check_before_ativado", False)
            items.append(Selector(
                key="check_before_enabled",
                text="Check Before",
                default=1 if check_before else 0,
                items=[self._t("check_before_desativado"), self._t("check_before_ativado")],
                icon="send_plane_24",
                link_alias="check_before_ativado",
                on_change=self._on_change_check_before
            ))

            # 6. Formatação (da v1.0.5)
            items.append(Divider())
            items.append(Switch(
                key="formatting_ativado",
                text=self._t("formatting_label"),
                subtext=self._t("formatting_subtext"),
                default=self._get_bool_setting("formatting_ativado", False),
                icon="msg_photo_text2",
                link_alias="formatting_ativado",
            ))

            # 7. Estilo de Tradução (v1.0.5)
            style_idx = int(self.get_setting("translation_style", 0))
            style_labels = [
                self._t("translation_style_neutral"),
                self._t("translation_style_natural"),
                self._t("translation_style_formal"),
                self._t("translation_style_short"),
                self._t("translation_style_expanded")
            ]
            items.append(Selector(
                key="translation_style",
                text=self._t("translation_style_label"),
                default=style_idx if 0 <= style_idx < len(style_labels) else 0,
                items=style_labels,
                icon="msg_topic_create",
                link_alias="translation_style",
                on_change=self._on_change_translation_style,
            ))

            # Comportamento de Tradução (Nota: movido de Opções Avançadas)
            items.append(Divider())
            
            items.append(Switch(
                key="fast_mode_ativado",
                text=self._t("fast_mode_label"),
                subtext=self._t("fast_mode_subtext"),
                default=self._get_bool_setting("fast_mode_ativado", False),
                icon="flash_on_remix",
                link_alias="fast_mode_ativado",
                on_change=self._on_change_fast_mode,
            ))

            prof_idx = int(self.get_setting("profanity_mode", 0))
            items.append(Selector(
                key="profanity_mode",
                text=self._t("profanity_label"),
                default=prof_idx,
                items=[
                    self._t("profanity_normal"),
                    self._t("profanity_soften"),
                    self._t("profanity_keep"),
                    self._t("profanity_censor_std"),
                    self._t("profanity_censor_spoiler")
                ],
                icon="msg_view_file",
                link_alias="profanity_mode",
                on_change=self._on_change_profanity_mode,
            ))

            # Advanced Options (Botão - Última posição)
            items.append(Divider())
            items.append(Text(
                text=self._t("optional_label"),
                icon="msg_settings",
                create_sub_fragment=self._create_optional_subfragment,
                link_alias="optional_subfragment"
            ))

            # Extended Settings (via 15 cliques)
            if self.get_setting("extended_settings_unlocked", False):
                items.append(Divider())
                items.append(Text(
                    text=self._t("extended_settings_title") or "Extended Settings",
                    icon="msg_secret_hw_remix",
                    create_sub_fragment=self._create_extended_settings_subfragment,
                    link_alias="extended_settings_subfragment"
                ))

            return items
        except Exception as e:
            return [Text(text=f"Erro: {e}")]

    def _on_change_translation_style(self, idx):
        try:
            self.set_setting("translation_style", int(idx))
        except Exception:
            pass

    # Suporte Obter a API
    def _show_support_sheet(self):
        try:
            # API
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(self._t("support_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            # Banner
            try:
                WebView = self._find_class_safe("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                _ = self._get_cached_image_src("https://i.postimg.cc/DZJxvkZ8/applebanner.png", "support_banner.png")
                html = """
                <html>
                <head>
                    <style>
                        body { margin: 0; padding: 0; background-color: transparent; }
                        img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                    </style>
                </head>
                <body>
                    <img src='support_banner.png' alt='Support Banner'>
                </body>
                </html>
                """
                base = "file://" + self._get_cache_dir_path() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._layout_helper_create_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            # Descrição
            desc_view = TextView(ctx)
            desc_view.setText(self._t("support_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            # Botão
            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("support_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_support_user()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _open_support_user(self, v=None):
        try:
            # Tenta abrir via MessagesController
            try:
                if self._open_by_username("AGeekApple"):
                    return
            except Exception:
                pass
            # Fallback via Intent
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            from android.content import Intent
            from android.net import Uri
            intent = Intent(Intent.ACTION_VIEW)
            intent.setData(Uri.parse("tg://resolve?domain=AGeekApple"))
            ctx.startActivity(intent)
        except Exception as e:
            self._log(f"Erro ao abrir usuário de suporte: {e}")

    # Helper de fragmento
    def get_last_fragment_safe(self):
        try:
            from client_utils import get_last_fragment
            return get_last_fragment()
        except Exception:
            return None

    def get_messages_controller(self):
        try:
            from client_utils import get_messages_controller
            return get_messages_controller()
        except Exception:
            return None

    def _extract_dialog_id(self, params: Any) -> int:
        try:
            # Tenta obter diretamente
            for key in ("dialog_id", "did"):
                try:
                    v = getattr(params, key)
                    if isinstance(v, int) and v != 0:
                        return int(v)
                except Exception:
                    pass

            # Tenta construir a partir de peer (user/chat/channel)
            try:
                peer = getattr(params, "peer")
            except Exception:
                peer = None

            if peer:
                try:
                    uid = getattr(peer, "user_id")
                except Exception:
                    uid = 0
                try:
                    gid = getattr(peer, "chat_id")
                except Exception:
                    gid = 0
                try:
                    cid = getattr(peer, "channel_id")
                except Exception:
                    cid = 0

                # Convenção: usuários positivos; chats/canais negativos
                if isinstance(uid, int) and uid != 0:
                    return int(uid)
                if isinstance(gid, int) and gid != 0:
                    return int(-gid)
                if isinstance(cid, int) and cid != 0:
                    return int(-cid)

                # Fallback para dialog_id interno
                try:
                    dv = getattr(peer, "dialog_id")
                    if isinstance(dv, int) and dv != 0:
                        return int(dv)
                except Exception:
                    pass

            # Fallback: tentar obter do fragmento atual (ChatActivity)
            try:
                fragment = self.get_last_fragment_safe()
                if fragment:
                    # Tenta obter currentDialogId (padrão Telegram)
                    try:
                        v = getattr(fragment, "currentDialogId", 0)
                        if isinstance(v, int) and v != 0:
                            return int(v)
                    except Exception:
                        pass

                    # Tenta método getDialogId()
                    try:
                        v = fragment.getDialogId()
                        if isinstance(v, int) and v != 0:
                            return int(v)
                    except Exception:
                        pass
            except Exception:
                pass

            return 0
        except Exception as e:
            self._log(f"Erro extract_dialog_id: {e}")
            return 0


    def _load_ativado_dialogs(self) -> set:
        try:
            raw = str(self.get_setting("ativado_dialogs", "") or "")
            items = [s for s in raw.split(",") if s.strip()]
            out = set()
            for s in items:
                try:
                    if s and (s.lstrip("-").isdigit()):
                        out.add(int(s))
                except Exception:
                    pass
            return out
        except Exception:
            return set()

    def _save_ativado_dialogs(self, s: set):
        try:
            val = ",".join(str(int(x)) for x in sorted(s))
            self.set_setting("ativado_dialogs", val)
        except Exception:
            pass

    def _load_desativado_dialogs(self) -> set:
        try:
            raw = str(self.get_setting("desativado_dialogs", "") or "")
            items = [s for s in raw.split(",") if s.strip()]
            out = set()
            for s in items:
                try:
                    if s and (s.lstrip("-").isdigit()):
                        out.add(int(s))
                except Exception:
                    pass
            return out
        except Exception:
            return set()

    def _save_desativado_dialogs(self, s: set):
        try:
            val = ",".join(str(int(x)) for x in sorted(s))
            self.set_setting("desativado_dialogs", val)
        except Exception:
            pass

    def _load_chat_lang_overrides(self) -> dict:
        out = {}
        try:
            raw = str(self.get_setting("chat_lang_overrides", "") or "")
            pairs = [p for p in raw.split(";") if p.strip()]
            for p in pairs:
                try:
                    did_str, lang = p.split("=", 1)
                    did_str = did_str.strip()
                    lang = lang.strip()
                    if did_str and (did_str.lstrip("-").isdigit()) and lang:
                        out[int(did_str)] = lang
                except Exception:
                    pass
        except Exception:
            pass
        return out

    def _save_chat_lang_overrides(self, d: dict):
        try:
            val = ";".join(f"{int(k)}={str(v)}" for k, v in d.items())
            self.set_setting("chat_lang_overrides", val)
        except Exception:
            pass

    def _get_current_user_name(self) -> str:
        try:
            try:
                from org.telegram.messenger import UserConfig, ContactsController, MessagesController
                account = getattr(UserConfig, 'selectedAccount', 0)
                mc = MessagesController.getInstance(account)
                me = UserConfig.getInstance(account)
                user = mc.getUser(me.getClientUserId()) if mc and me else None
                if user:
                    try:
                        return ContactsController.formatName(user.first_name, user.last_name).replace('\n', ' ')
                    except Exception:
                        pass
            except Exception:
                pass
            return "Você"
        except Exception:
            return "Você"

    def _open_by_username(self, username: str) -> bool:
        try:
            mc = self.get_messages_controller()
            if mc is None:
                return False
            fragment = self.get_last_fragment_safe()
            mc.openByUserName(str(username), fragment, 1)
            return True
        except Exception:
            return False

    #  Handlers de on_change (sem retornar valores)
    def _on_change_target_language(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        if i < 0 or i >= 5:
            i = 0
        self.set_setting("idioma_alvo", i)
        run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("target_language_label")))
        # Recarrega para refletir visibilidade do campo Custom
        self.reload_settings()

    def _on_change_profanity_mode(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        if i < 0 or i > 4:
            i = 0
        self.set_setting("profanity_mode", i)
        run_on_ui_thread(lambda: BulletinHelper.show_success("Profanity"))

    def _on_change_custom_lang_code(self, v):
        try:
            self.set_setting("idioma_custom_code", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_lang_label")))
        except Exception:
            pass

    def _on_change_api_key(self, v):
        try:
            self.set_setting("openrouter_api_key", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_gemini_api_key(self, v):
        try:
            self.set_setting("gemini_api_key", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("gemini_api_key_label") or self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_openrouter_api_key(self, v):
        try:
            self.set_setting("openrouter_api_key", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("openrouter_api_key_label")))
        except Exception:
            pass

    def _on_change_model(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        prov_idx = self._get_ai_provider_idx()
        modelos = self._opcoes_modelos() if prov_idx == 0 else self._opcoes_modelos_gemini()
        if i < 0 or i >= len(modelos):
            i = 0
        # Salvamos apenas o índice; resolução para slug ocorre dinamicamente
        self.set_setting("modelo_gemini", i)
        run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("model_label")))

    def _on_change_ai_provider(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        
        # Limite dinâmico baseado na ativação de experimentais
        limit = 7 if self.get_setting("experimental_providers_enabled", False) else 5
        
        if i < 0 or i > limit:
            i = 0
        self.set_setting("ai_provider", i)
        # Recarrega para atualizar campos dependentes (API key, lista de modelos, ajuda)
        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("ai_provider_label")))
        self.reload_settings()

    def _on_change_temperature(self, v):
        try:
            # Aceita índice do selector ou valor direto (compatibilidade)
            temp_values = [0.0, 0.2, 0.4, 0.7, 1.0]
            try:
                idx = int(v)
                if idx < 0 or idx >= len(temp_values):
                    idx = 1
                val = temp_values[idx]
            except Exception:
                try:
                    val = float(str(v))
                except Exception:
                    val = 0.2
                # Deriva índice do valor recebido para manter consistência
                try:
                    idx = temp_values.index(val)
                except Exception:
                    try:
                        idx = min(range(len(temp_values)), key=lambda i: abs(temp_values[i] - val))
                    except Exception:
                        idx = 1
            # Salva valor e índice para estabilidade do componente
            self.set_setting("temperatura", val)
            self.set_setting("temperatura_idx", idx)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("temperature_label")))
        except Exception:
            pass

    def _on_change_custom_api_url(self, v):
        try:
            s = str(v or "").strip()
            # Remove barras duplicadas no final, preservando uma única se existir
            try:
                while s.endswith("//"):
                    s = s[:-1]
            except Exception:
                pass
            self.set_setting("custom_api_url", s)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_api_url_label")))
        except Exception:
            pass

    def _on_change_deepl_api_key(self, v):
        try:
            self.set_setting("deepl_api_key", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_custom_api_key(self, v):
        try:
            self.set_setting("custom_api_key", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_api_key_label") or self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_custom_model_name(self, v):
        try:
            self.set_setting("custom_model_name", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_model_label") or self._t("model_label")))
        except Exception:
            pass

    def _on_change_deeplx_api_url(self, v):
        try:
            s = str(v or "").strip()
            # Normaliza URL: remove barras duplicadas, preservando protocolo
            try:
                # Se não tem protocolo, adiciona http:// por padrão para evitar erros
                if not s.startswith("http"):
                    s = "http://" + s
            except Exception:
                pass
            self.set_setting("deeplx_api_url", s)
            run_on_ui_thread(lambda: BulletinHelper.show_success("DeepLX Endpoint"))
        except Exception:
            pass

    def _on_change_deeplx_api_token(self, v):
        try:
            self.set_setting("deeplx_api_token", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success("DeepLX Token"))
        except Exception:
            pass

    def _on_change_openai_api_key(self, v):
        try:
            self.set_setting("openai_api_key", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_openai_model(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        
        # Lista de modelos OpenAI
        # 0: gpt-4o-mini (Tradução eficiente)
        # 1: gpt-4o (Reescrita/Style)
        # 2: gpt-4-turbo (Contexto complexo/Explicação - usando gpt-4-turbo como equivalente ao gpt-4.1 
        
        self.set_setting("openai_model_idx", i)
        run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("model_label")))

    # Handlers AddL
    def _on_change_addl_ativado(self, val):
        self.set_setting("addl_ativado", val)
        self.reload_settings()

    def _on_change_addl_lang(self, val):
        self.set_setting("addl_lang", str(val).strip())
        run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("addl_lang_label")))

    def _on_change_addl_style(self, idx):
        try:
            self.set_setting("addl_style", int(idx))
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("addl_style_label")))
        except Exception:
            pass

    def _on_change_check_before(self, idx):
        try:
            val = bool(int(idx))
            self.set_setting("check_before_ativado", val)
            run_on_ui_thread(lambda: BulletinHelper.show_info("Check Before"))
        except Exception:
            pass

    def _on_change_quick_dismiss(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            # Salva como booleano (sempre visível; só estado muda)
            self.set_setting("quick_dismiss_ativado", v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info("Quick Dismiss"))
        except Exception:
            pass

    def _on_change_fast_mode(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("fast_mode_ativado", v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("fast_mode_label")))
        except Exception:
            pass

    def _on_change_aura(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("aura_ativado", v_bool)
            # Feedback visual simples
            if v_bool:
                self._tocar_ripple_suave(0.5)
                run_on_ui_thread(lambda: BulletinHelper.show_info("Aura Activated!"))
            else:
                 run_on_ui_thread(lambda: BulletinHelper.show_info("Aura Disabled"))
        except Exception:
            pass

    def _on_change_my_chat(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("my_chat_ativado", v_bool)
            if v_bool:
                self._ensure_my_chat_menu_item()
            else:
                self._remove_my_chat_menu_item()
        except Exception:
            pass

    def _on_change_logs_desativado(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            # Salva como booleano (sempre visível > só estado muda)
            self.set_setting("logs_desativado", v_bool)
            self._set_log_muted(v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("logs_disable_label")))
        except Exception:
            pass

    def _on_change_plugin_lang(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        if i < 0 or i >= 5:
            i = 0
        self.set_setting("plugin_lang", i)
        self.reload_settings()

    # Estado on/off
    def _is_ativado(self) -> bool:
        try:
            return bool(int(self.get_setting("plugin_ativado", 1)))
        except Exception:
            return True

    def _toggle_ativado(self) -> bool:
        try:
            cur = 1 if self._is_ativado() else 0
            new = 0 if cur == 1 else 1
            self.set_setting("plugin_ativado", new)
            # Feedback visual
            msg = self._t("plugin_ativado_msg") if new == 1 else self._t("plugin_desativado_msg")
            if new == 1:
                run_on_ui_thread(lambda: BulletinHelper.show_success(msg))
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_info(msg))
            return bool(new)
        except Exception:
            return self._is_ativado()

    # Toggle no menu do chat (3-dot)
    def _add_chat_toggle_menu_item(self):
        try:
            # Evita duplicatas removendo anterior
            if getattr(self, "_chat_toggle_item_id", None):
                try:
                    self.remove_menu_item(self._chat_toggle_item_id)
                except Exception:
                    pass
                self._chat_toggle_item_id = None

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text="Translatica",
                icon="msg_translate",
                priority=5,
                on_click=lambda ctx: self._handle_chat_toggle_click(ctx)
            ))
            self._chat_toggle_item_id = item_id
        except Exception:
            pass

    def _remove_chat_toggle_menu_item(self):
        try:
            if getattr(self, "_chat_toggle_item_id", None):
                try:
                    self.remove_menu_item(self._chat_toggle_item_id)
                except Exception:
                    pass
                self._chat_toggle_item_id = None
        except Exception:
            pass

    # My Chat Menu
    def _ensure_my_chat_menu_item(self):
        try:
            # Remove se já existir para evitar duplicatas
            self._remove_my_chat_menu_item()
            
            # Verifica se está ativado
            if not self._get_bool_setting("my_chat_ativado", False):
                return

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text=self._t("my_chat_menu_item"),
                icon="msg_msgbubble3_solar",
                priority=6, # Após o Translatica toggle
                on_click=lambda ctx: self._on_my_chat_clicked(ctx)
            ))
            self._my_chat_menu_item_id = item_id
        except Exception:
            pass

    def _remove_my_chat_menu_item(self):
        try:
            if getattr(self, "_my_chat_menu_item_id", None):
                try:
                    self.remove_menu_item(self._my_chat_menu_item_id)
                except Exception:
                    pass
                self._my_chat_menu_item_id = None
        except Exception:
            pass
    
    def _on_my_chat_clicked(self, ctx):
        try:
            # Identifica o chat atual
            did = self._extract_dialog_id(ctx)
            if not did:
                try:
                    fragment = self.get_last_fragment_safe()
                    if hasattr(fragment, "getDialogId"):
                        did = fragment.getDialogId()
                except: pass
            
            if not did:
                run_on_ui_thread(lambda: BulletinHelper.show_error(self._t("cmd_dialog_not_found")))
                return

            # Abre o seletor de idioma
            run_on_ui_thread(lambda: self._show_my_chat_lang_selector(did))
        except Exception:
            pass

    def _show_my_chat_lang_selector(self, did):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx: return

            # Lista de idiomas
            # 0=en, 1=pt, 2=es, 3=ru, 4=custom
            langs = [
                {"code": "en", "label": self._t("lang_english"), "icon": "msg_language"},
                {"code": "pt", "label": self._t("lang_portuguese"), "icon": "msg_language"},
                {"code": "es", "label": self._t("lang_spanish"), "icon": "msg_language"},
                {"code": "ru", "label": self._t("lang_russian"), "icon": "msg_language"}
            ]

            # Adiciona Custom (sempre visível)
            custom_code = str(self.get_setting("idioma_custom_code", "")).strip()
            custom_label = f"Custom ({custom_code})" if custom_code else "Custom (Not set)"
            langs.append({"code": "custom", "label": custom_label, "icon": "msg_language"})
            
            # Adiciona opção de Reset/Desativar específico
            langs.append({"code": "reset", "label": "Reset / Default", "icon": "msg_delete"})

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)
            
            # Título
            title = TextView(ctx)
            title.setText(self._t("my_chat_menu_item"))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            try: title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except: pass
            title.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(16), AndroidUtilities.dp(20), AndroidUtilities.dp(8))
            container.addView(title)
            
            # Opções
            for l in langs:
                frame = FrameLayout(ctx)
                frame.setBackground(Theme.getSelectorDrawable(False))
                
                txt = TextView(ctx)
                txt.setText(l["label"])
                txt.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                try: txt.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                except: pass
                txt.setGravity(Gravity.CENTER_VERTICAL | Gravity.START)
                
                frame.addView(txt, LayoutHelper.createFrame(-1, 48, Gravity.CENTER_VERTICAL | Gravity.START, 20, 0, 20, 0))
                
                def _click(v, code=l["code"]):
                    try:
                        sheet.dismiss()
                        self._apply_my_chat_lang(did, code)
                    except: pass
                
                frame.setOnClickListener(OnClickListener(lambda v, c=l["code"]: _click(v, c)))
                container.addView(frame, LayoutHelper.createLinear(-1, 48))
                
            sheet.setCustomView(container)
            sheet.show()
        except Exception:
            pass

    def _apply_my_chat_lang(self, did, code):
        try:
            if code == "custom":
                custom_code = str(self.get_setting("idioma_custom_code", "")).strip()
                if not custom_code:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Custom language not set in Settings"))
                    return
                code = custom_code

            ativado = self._load_ativado_dialogs()
            desativado = self._load_desativado_dialogs()
            overrides = self._load_chat_lang_overrides()
            
            if code == "reset":
                if did in overrides:
                    del overrides[did]
                    self._save_chat_lang_overrides(overrides)
                # Mantém ativado, apenas reseta o override
                run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_add_lang_reset")))
            else:
                overrides[did] = code
                self._save_chat_lang_overrides(overrides)
                
                # Garante que está na lista de ativados
                if did not in ativado:
                    ativado.add(did)
                    self._save_ativado_dialogs(ativado)
                if did in desativado:
                    desativado.discard(did)
                    self._save_desativado_dialogs(desativado)
                
                msg = self._t("cmd_add_lang_success").format(lang=code)
                run_on_ui_thread(lambda: BulletinHelper.show_success(msg))
                
            self._log(f"My Chat: did={did} lang={code}")
        except Exception:
            pass

    def _ensure_chat_toggle_menu_item(self):
        try:
            self._add_chat_toggle_menu_item()
        except Exception:
            pass

    def _handle_chat_toggle_click(self, ctx: Any = None):
        try:
            ativado = self._toggle_ativado()
            # Opcionalmente atualizar o texto do item conforme estado
            try:
                # Remove e adiciona novamente para refletir mudanças, mantendo simples
                self._add_chat_toggle_menu_item()
            except Exception:
                pass
        except Exception:
            pass

    # Handlers para novos recursos
    def _on_change_alternate_ai(self, v):
        try:
            # Converte o valor para booleano com segurança
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            # Salva a configuração de alternância de IA
            self.set_setting("alternate_ai_ativado", v_bool)
        except Exception:
            pass

    def _ao_alterar_quickbite(self, idx):
        try:
            val = int(idx)
            # 0=Default, 1=TL;DR, 2=WhatIsThis
            if val == 2:
                # Opção informativa - não persistir
                try:
                    def _show_quickbite_sheet():
                        try:
                            # BottomSheet Implementation for "What is this?"
                            from org.telegram.ui.ActionBar import BottomSheet
                            from org.telegram.messenger import AndroidUtilities
                            from android.widget import LinearLayout, TextView
                            from android.view import Gravity
                            from android.util import TypedValue
                            from org.telegram.ui.ActionBar import Theme
                            from org.telegram.ui.Components import LayoutHelper
                            from android_utils import OnClickListener

                            fragment = self.get_last_fragment_safe()
                            ctx = fragment.getParentActivity() if fragment else None
                            if not ctx:
                                 try:
                                     if fragment and fragment.getFragmentView():
                                         ctx = AndroidUtilities.findActivity(fragment.getFragmentView().getContext())
                                 except: pass
                        
                            if ctx:
                                sheet = BottomSheet(ctx, True)
                                container = LinearLayout(ctx)
                                container.setOrientation(LinearLayout.VERTICAL)
                                container.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(24))

                                title = TextView(ctx)
                                title.setText(self._t("quickbite_info_title"))
                                title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
                                title.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                                title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                                container.addView(title, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 12))

                                text = TextView(ctx)
                                text.setText(self._t("quickbite_info_text"))
                                text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                                text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                                container.addView(text, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 24))

                                btn = TextView(ctx)
                                btn.setText(self._t("ok_button_label"))
                                btn.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
                                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
                                btn.setGravity(Gravity.CENTER)
                                btn.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                                btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                                
                                def _close_click(v):
                                    try:
                                        sheet.dismiss()
                                    except:
                                        pass

                                btn.setOnClickListener(OnClickListener(_close_click))
                                container.addView(btn, LayoutHelper.createLinear(-2, -2, Gravity.END))

                                sheet.setCustomView(container)
                                sheet.show()
                            else:
                                BulletinHelper.show_error("Error: Context not found")
                        except Exception as e:
                            self._log(f"Erro interno QuickBite Sheet: {e}")

                    run_on_ui_thread(_show_quickbite_sheet)
                except Exception as e:
                    self._log(f"Erro ao mostrar info QuickBite: {e}")
                
                # Força o reset para Padrão (0) como solicitado pelo usuário
                try:
                    self.set_setting("quickbite_mode", 0)
                    
                    # Hack: Força a UI a perceber que o valor deve ser 0
                    def _restore_ui():
                        try:
                            self.reload_settings()
                        except: pass
                    
                    run_on_ui_thread(_restore_ui)
                except:
                    pass
                return

            self.set_setting("quickbite_mode", val)
        except Exception:
            self.set_setting("quickbite_mode", 0)

    def _on_change_silent_fix(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("silent_fix_ativado", v_bool)
            if v_bool:
                self._ensure_silent_fix_menu_item()
            else:
                self._remove_silent_fix_context_menu_item()
        except Exception:
            pass

    def _on_change_explain_me(self, v):
        try:
            # Converte o valor para booleano com segurança
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            # Salva a configuração e atualiza o menu de contexto
            self.set_setting("explain_me_ativado", v_bool)
            if v_bool:
                # Adiciona o item ao menu se ativado
                self._add_explain_me_context_menu_item()
            else:
                # Remove o item do menu se desativado
                self._remove_explain_me_context_menu_item()
            
            # Recarrega a UI para exibir/ocultar o seletor QuickBite
            self.reload_settings()
        except Exception:
            pass

    def _get_effective_provider_idx(self) -> int:
        try:
            # Obtém o índice do provedor configurado pelo usuário
            base_idx = self._get_ai_provider_idx()
            
            # Se a alternância automática estiver desativada, retorna o provedor padrão
            if not self._get_bool_setting("alternate_ai_ativado", False):
                return base_idx
            
            # Lista de provedores disponíveis (com chaves configuradas)
            available = []
            # 0: OpenRouter - verifica se tem chave API
            if str(self.get_setting("openrouter_api_key", "")).strip():
                available.append(0)
            # 1: Gemini - verifica se tem chave API
            if str(self.get_setting("gemini_api_key", "")).strip():
                available.append(1)
            # 2: Custom - verifica se tem URL configurada
            if str(self.get_setting("custom_api_url", "")).strip():
                available.append(2)
            # 3: DeepL - verifica se tem chave API
            if str(self.get_setting("deepl_api_key", "")).strip():
                available.append(3)
            # 4: DeepLX - verifica se tem URL configurada
            if str(self.get_setting("deeplx_api_url", "")).strip():
                available.append(4)
            
            # Se houver menos de 2 provedores disponíveis, não há o que alternar
            if len(available) < 2:
                return base_idx
            
            # Inicializa o contador se não existir
            if not hasattr(self, "_alternate_counter"):
                self._alternate_counter = 0
            
            # Seleciona o próximo provedor da lista usando módulo e incrementa o contador
            idx = available[self._alternate_counter % len(available)]
            self._alternate_counter += 1
            return idx
        except Exception:
            # Em caso de erro, retorna o provedor padrão configurado
            return self._get_ai_provider_idx()

    # Explain Me Context Menu
    def _add_explain_me_context_menu_item(self):
        try:
            # Remove o item anterior para evitar duplicatas
            if getattr(self, "explain_me_menu_id", None):
                self.remove_menu_item(self.explain_me_menu_id)
                self.explain_me_menu_id = None
            
            # Verifica se o recurso está ativado
            if not self._get_bool_setting("explain_me_ativado", False):
                return

            # Adiciona o item ao menu de contexto da mensagem
            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=self._t("explain_me_menu_item"),
                icon="msg_emoji_question",
                on_click=lambda ctx: run_on_ui_thread(lambda: self._on_explain_me_clicked(ctx))
            ))
            self.explain_me_menu_id = item_id
        except Exception:
            pass

    def _remove_explain_me_context_menu_item(self):
        try:
            # Remove o item do menu se ele existir
            if getattr(self, "explain_me_menu_id", None):
                self.remove_menu_item(self.explain_me_menu_id)
                self.explain_me_menu_id = None
        except Exception:
            pass

    # Silent Fix Menu Item
    def _add_silent_fix_context_menu_item(self):
        # Desativado por padrão conforme pedido do usuário
        pass

    def _remove_silent_fix_context_menu_item(self):
        try:
            if getattr(self, "silent_fix_menu_id", None):
                self.remove_menu_item(self.silent_fix_menu_id)
                self.silent_fix_menu_id = None
        except Exception:
            pass

    def _ensure_silent_fix_menu_item(self):
        # Desativado
        pass

    def _ensure_explain_me_menu_item(self):
        try:
            # Garante que o item do menu seja adicionado se necessário
            self._add_explain_me_context_menu_item()
        except Exception:
            pass

    def _extract_text_from_message(self, m) -> str:
        try:
            txt = None
            # Tenta via messageOwner (TLRPC.Message)
            try:
                msg_owner = getattr(m, 'messageOwner', m)
                if msg_owner:
                    # Prioridade: Caption > Message
                    if hasattr(msg_owner, 'caption') and isinstance(msg_owner.caption, str) and str(msg_owner.caption).strip():
                        txt = str(msg_owner.caption)
                    elif hasattr(msg_owner, 'message') and isinstance(msg_owner.message, str) and str(msg_owner.message).strip():
                        txt = str(msg_owner.message)
            except Exception:
                pass
                
            if not txt:
                try:
                    txt = getattr(m, 'messageText', None)
                except Exception:
                    txt = None
            
            if not txt:
                try:
                    txt = m.getMessageText()
                except Exception:
                    txt = None
                    
            return (txt or '').strip()
        except Exception:
            return ''

    def _on_explain_me_clicked(self, ctx):
        try:
            message = None
            
            # 1. Tenta extrair do contexto (HashMap)
            if ctx:
                try:
                    # Chaves comuns
                    message = ctx.get("message") or ctx.get("message_object") or ctx.get("msg")
                    
                    # Se não achou, tenta 'view' e busca o objeto da mensagem na view
                    if not message:
                        view = ctx.get("view")
                        if view:
                            if hasattr(view, "getMessageObject"):
                                message = view.getMessageObject()
                            elif hasattr(view, "getTag"):
                                tag = view.getTag()
                                if tag and hasattr(tag, "messageOwner"):
                                    message = tag
                except Exception:
                    pass

            # 2. Se falhar, tenta pegar a mensagem selecionada/focada na Activity atual
            if not message:
                try:
                    fragment = self.get_last_fragment_safe()
                    if fragment:
                        # Tenta acessar mensagem do menu de contexto (comum no TG)
                        # Muitos forks usam contextMenuMessage ou getContextMenuMessage()
                        if hasattr(fragment, "contextMenuMessage"):
                            message = fragment.contextMenuMessage
                        
                        # Se não, tenta mensagem selecionada (se houver seleção)
                        if not message and hasattr(fragment, "getSelectedMessages"):
                            # getSelectedMessages retorna SparseArray ou lista
                            selected = fragment.getSelectedMessages()
                            if selected:
                                # Lógica para pegar o primeiro item dependendo do tipo
                                if hasattr(selected, "valueAt"): # SparseArray
                                    if selected.size() > 0:
                                        message = selected.valueAt(0)
                                elif isinstance(selected, list) and len(selected) > 0:
                                    message = selected[0]
                except Exception:
                    pass

            # 3. Fallback final: se o próprio ctx parecer ser a mensagem
            if not message and ctx:
                if hasattr(ctx, "messageOwner") or hasattr(ctx, "messageText"):
                    message = ctx

            text = self._extract_text_from_message(message)
            
            if not text:
                self._log(f"Explain This: Nenhum texto encontrado. tipo ctx: {type(ctx)}")
                try:
                    if hasattr(ctx, "keys"):
                         self._log(f"Explain This: ctx keys: {list(ctx.keys())}")
                    else:
                         self._log(f"Explain This: ctx dir: {dir(ctx)[:5]}")
                except:
                    pass
                return
            
            self._log(f"Explain This: Iniciado para tamanho de texto {len(text)}")
            
            # Mostra feedback visual
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("explanation_processing")))
            
            # Inicia o processo de explicação em background para não travar a UI
            import threading
            def _bg():
                try:
                    explanation = self._explain_with_ai(text)
                    if explanation:
                        self._log("Explain This: Sucesso")
                        run_on_ui_thread(lambda: self._show_explanation_dialog(explanation))
                    else:
                        self._log("Explain This: Falhou (nenhuma explicação retornada)")
                        run_on_ui_thread(lambda: BulletinHelper.show_error(self._t("bullet_tokens_insufficient")))
                except Exception as e:
                    self._log(f"Explain This: Erro na tarefa em segundo plano: {e}")
            
            threading.Thread(target=_bg).start()
        except Exception as e:
            self._log(f"Explain This: Error in click handler: {e}")

    def _explain_with_ai(self, text):
        try:
            # Obtém provedor
            prov_idx = self._get_effective_provider_idx()
            
            # Bloqueio DeepL: não suporta explain/contexto
            if prov_idx == 3:
                self._log("Explain This ignorado (DeepL ativo)")
                return None
                
            if prov_idx == 2:
                base = str(self.get_setting("custom_api_url", "") or "").strip()
                if "deepl.com" in base.lower():
                    self._log("Explain This ignorado (DeepL ativo)")
                    return None
            
            # Define o idioma da explicação baseado na configuração do plugin
            # 0=English, 1=Portuguese, 2=Spanish, 3=Russian
            plugin_lang = self._get_plugin_lang_index()
                
            lang_map = {
                0: self._t("lang_english"),
                1: self._t("lang_portuguese"),
                2: self._t("lang_spanish"),
                3: self._t("lang_russian")
            }
            target_lang = lang_map.get(plugin_lang, self._t("lang_english"))
            
            # Verifica o modo QuickBite (0=Padrão, 1=TL;DR)
            quickbite_mode = int(self.get_setting("quickbite_mode", 0))
            
            if quickbite_mode == 1:
                # Modo TL;DR: Resumo conciso em tópicos
                system = (
                    f"Resuma o texto abaixo em {target_lang} de forma extremamente concisa, usando tópicos (bullet points). "
                    "Vá direto ao ponto. Use uma linguagem clara e objetiva. "
                    "Ideal para uma leitura rápida (TL;DR)."
                )
            else:
                # Modo Padrão: Explicação contextual detalhada
                system = (
                    f"Explique o contexto e o significado do texto abaixo em {target_lang}. "
                    "Use um tom neutro e adulto, como se estivesse explicando para um leitor comum. "
                    "Evite jargões e simplificações excessivas, mas não use linguagem infantil. "
                    "Não use markdown (negrito, itálico, listas). "
                    "Não traduza o texto; apenas explique seu sentido e contexto.\n\n"
                    "Separe a explicação em parágrafos curtos, com quebras de linha entre eles, para facilitar a leitura."
                )
            
            messages = [
                {"role": "system", "content": system},
                {"role": "user", "content": text}
            ]
            
            temperatura = 0.7
            max_tokens = 512
            modelo = self._resolve_model_for_provider(prov_idx)
            
            url = ""
            headers = {}
            payload = {}
            
            # Configura a requisição com base no provedor
            if prov_idx == 0: # OpenRouter
                api_key = str(self.get_setting("openrouter_api_key", "")).strip()
                if not api_key: return None
                url = "https://openrouter.ai/api/v1/chat/completions"
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            elif prov_idx == 1: # Gemini
                api_key = str(self.get_setting("gemini_api_key", "")).strip()
                if not api_key: return None
                url = "https://generativelanguage.googleapis.com/v1beta/openai/chat/completions"
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            elif prov_idx == 5: # ChatGPT (OpenAI)
                api_key = str(self.get_setting("openai_api_key", "")).strip()
                if not api_key: return None
                url = "https://api.openai.com/v1/chat/completions"
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                # Silent Fix: Force gpt-4o-mini as requested
                payload = {"model": "gpt-4o-mini", "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}

            else: # Custom
                base = str(self.get_setting("custom_api_url", "")).strip().rstrip("/")
                api_key = str(self.get_setting("custom_api_key", "")).strip()
                if not base: return None
                url = f"{base}/chat/completions"
                headers = {"Content-Type": "application/json"}
                if api_key: headers["Authorization"] = f"Bearer {api_key}"
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            
            # Executa a requisição
            resp = requests.post(url, headers=headers, json=payload, timeout=30)
            if resp.status_code != 200:
                return None
                
            data = resp.json()
            conteudo = ""
            if "choices" in data:
                conteudo = data["choices"][0]["message"]["content"]
            elif "candidates" in data:
                conteudo = data["candidates"][0]["content"]["parts"][0]["text"]
                
            return conteudo.strip()
        except Exception:
            return None

    def _show_explanation_dialog(self, text):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            
            if not activity:
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(self._t("explanation_title"))
            builder.set_message(text)
            builder.set_positive_button(self._t("ok_button_label"), None)
            builder.show()
        except Exception as e:
            self._log(f"Erro ao exibir diálogo: {e}")

    def _on_silent_fix_clicked(self, ctx):
        try:
            message = None
            if ctx:
                try:
                    message = ctx.get("message") or ctx.get("message_object") or ctx.get("msg")
                    if not message:
                        view = ctx.get("view")
                        if view:
                            if hasattr(view, "getMessageObject"):
                                message = view.getMessageObject()
                            elif hasattr(view, "getTag"):
                                tag = view.getTag()
                                if tag and hasattr(tag, "messageOwner"):
                                    message = tag
                except Exception:
                    pass

            if not message:
                try:
                    fragment = self.get_last_fragment_safe()
                    if fragment:
                        if hasattr(fragment, "contextMenuMessage"):
                            message = fragment.contextMenuMessage
                        if not message and hasattr(fragment, "getSelectedMessages"):
                            selected = fragment.getSelectedMessages()
                            if selected:
                                if hasattr(selected, "valueAt"):
                                    if selected.size() > 0:
                                        message = selected.valueAt(0)
                                elif isinstance(selected, list) and len(selected) > 0:
                                    message = selected[0]
                except Exception:
                    pass

            if not message and ctx:
                if hasattr(ctx, "messageOwner") or hasattr(ctx, "messageText"):
                    message = ctx

            text = self._extract_text_from_message(message)
            
            if not text:
                return
            
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("silent_fix_processing")))
            
            import threading
            def _bg():
                try:
                    fixed_text = self._silent_fix_with_ai(text)
                    if fixed_text:
                        run_on_ui_thread(lambda: self._show_silent_fix_dialog(fixed_text))
                    else:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(self._t("bullet_tokens_insufficient")))
                except Exception as e:
                    self._log(f"Silent Fix: Erro na tarefa em segundo plano: {e}")
            
            threading.Thread(target=_bg).start()
        except Exception as e:
            self._log(f"Silent Fix: Error in click handler: {e}")

    def _silent_fix_with_ai(self, text):
        try:
            prov_idx = self._get_effective_provider_idx()
            if prov_idx == 3: # DeepL
                return None
            if prov_idx == 2: # Custom checking for DeepL
                base = str(self.get_setting("custom_api_url", "") or "").strip()
                if "deepl.com" in base.lower():
                    return None
            
            # Silent Fix Prompt
            system = (
                "Você é um assistente de correção de texto. Sua tarefa é corrigir a gramática, pontuação e fluidez do texto fornecido. "
                "IMPORTANTE: Preserve o idioma original do texto. NÃO traduza. "
                "Mantenha o tom e o estilo originais, apenas corrija erros. "
                "Retorne APENAS o texto corrigido, sem introduções, explicações ou markdown (aspas, negrito, etc)."
            )
            
            messages = [
                {"role": "system", "content": system},
                {"role": "user", "content": text}
            ]
            
            temperatura = 0.3
            max_tokens = 2048
            modelo = self._resolve_model_for_provider(prov_idx)
            
            url = ""
            headers = {}
            payload = {}
            
            if prov_idx == 0: # OpenRouter
                api_key = str(self.get_setting("openrouter_api_key", "")).strip()
                if not api_key: return None
                url = "https://openrouter.ai/api/v1/chat/completions"
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            elif prov_idx == 1: # Gemini
                api_key = str(self.get_setting("gemini_api_key", "")).strip()
                if not api_key: return None
                url = "https://generativelanguage.googleapis.com/v1beta/openai/chat/completions"
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            elif prov_idx == 5: # ChatGPT (OpenAI)
                api_key = str(self.get_setting("openai_api_key", "")).strip()
                if not api_key: return None
                url = "https://api.openai.com/v1/chat/completions"
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            else: # Custom
                base = str(self.get_setting("custom_api_url", "")).strip().rstrip("/")
                api_key = str(self.get_setting("custom_api_key", "")).strip()
                if not base: return None
                url = f"{base}/chat/completions"
                headers = {"Content-Type": "application/json"}
                if api_key: headers["Authorization"] = f"Bearer {api_key}"
                payload = {"model": modelo, "messages": messages, "temperature": temperatura, "max_tokens": max_tokens}
            
            resp = requests.post(url, headers=headers, json=payload, timeout=30)
            if resp.status_code != 200:
                return None
                
            data = resp.json()
            conteudo = ""
            if "choices" in data:
                conteudo = data["choices"][0]["message"]["content"]
            elif "candidates" in data:
                conteudo = data["candidates"][0]["content"]["parts"][0]["text"]
                
            return conteudo.strip()
        except Exception:
            return None

    def _show_silent_fix_dialog(self, text):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            
            if not activity:
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(self._t("silent_fix_title"))
            builder.set_message(text)
            
            def _copy(d, w):
                try:
                    AndroidUtilities.addToClipboard(text)
                    BulletinHelper.show_success("Copied!")
                except:
                    pass
            
            builder.set_positive_button(self._t("ok_button_label"), None)
            builder.set_neutral_button("Copy", _copy)
            builder.show()
        except Exception as e:
            self._log(f"Erro ao exibir diálogo: {e}")

    # Subfragmento: Configurações de IA
    def _create_ai_settings_subfragment(self, parent_view=None):
        try:
            try:
                from ui.settings import Divider, Switch, Selector, Input, Text
            except Exception:
                pass
            
            items = []
            
            # Provider atual e lista de modelos correspondente
            prov_idx = self._get_ai_provider_idx()
            modelos = self._opcoes_modelos() if prov_idx == 0 else self._opcoes_modelos_gemini()
            modelo_labels = [m["label"] for m in modelos]
            modelo_keys = [m["key"] for m in modelos]
            raw_model = self.get_setting("modelo_gemini", modelo_keys[0])
            try:
                m_idx = int(raw_model)
                modelo_idx = m_idx if 0 <= m_idx < len(modelo_labels) else 0
            except Exception:
                try:
                    modelo_idx = modelo_keys.index(str(raw_model or modelo_keys[0]))
                except Exception:
                    modelo_idx = 0

            # Temperatura
            temp_values = [0.0, 0.2, 0.4, 0.7, 1.0]
            temp_labels = ["0.0", "0.2", "0.4", "0.7", "1.0"]
            try:
                temp_idx = int(self.get_setting("temperatura_idx", 1))
                if temp_idx < 0 or temp_idx >= len(temp_values):
                    temp_idx = 1
            except Exception:
                temp_idx = 1

            # Alternar provedor (Switch)
            try:
                items.append(Switch(
                    key="alternate_ai_ativado",
                    text=self._t("alternate_ai_label"),
                    subtext=self._t("alternate_ai_subtext"),
                    default=self._get_bool_setting("alternate_ai_ativado", False),
                    icon="media_repost",
                    link_alias="alternate_ai_ativado",
                    on_change=self._on_change_alternate_ai,
                ))
            except Exception:
                pass

            prov_list = ["OpenRouter", "Google Gemini", (self._t("ai_provider_custom") or "Custom OpenAI compatible"), "DeepL", "DeepLX", "ChatGPT (OpenAI)"]
            if self.get_setting("experimental_providers_enabled", False):
                prov_list.extend(["Cerebras (Experimental)", "llm7.io (Experimental)"])

            items.extend([
                Divider(text=self._t("ai_provider_label")),
                Selector(
                    key="ai_provider",
                    text=self._t("ai_provider_label"),
                    default=prov_idx,
                    items=prov_list,
                    icon="msg_bot",
                    link_alias="ai_provider",
                    on_change=self._on_change_ai_provider,
                ),
            ])

            # API Key e ajuda
            if prov_idx == 0:
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="openrouter_api_key",
                        text=self._t("openrouter_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("openrouter_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="openrouter_api_key",
                        on_change=self._on_change_api_key,
                    ),
                    Text(
                        text=self._t("get_openrouter_api_label") or self._t("get_api_help_label"),
                        icon="menu_link_create2",
                        accent=True,
                        link_alias="get_openrouter_api",
                        on_click=lambda view: self._show_openrouter_api_sheet()
                    ),
                ])
            elif prov_idx == 1:
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="gemini_api_key",
                        text=self._t("gemini_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("gemini_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="gemini_api_key",
                        on_change=self._on_change_gemini_api_key,
                    ),
                    Text(
                        text=self._t("get_gemini_api_button") or self._t("get_api_help_label"),
                        icon="menu_link_create2",
                        accent=True,
                        link_alias="get_gemini_api",
                        on_click=lambda view: self._show_gemini_api_sheet()
                    ),
                ])
            elif prov_idx == 3: # DeepL
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="deepl_api_key",
                        text=self._t("custom_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("deepl_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="deepl_api_key",
                        on_change=self._on_change_deepl_api_key,
                    ),
                ])
            elif prov_idx == 4: # DeepLX
                items.append(Divider(text="DeepLX"))
                items.extend([
                    Input(
                        key="deeplx_api_url",
                        text=self._t("deeplx_api_url_label"),
                        default=str(self.get_setting("deeplx_api_url", "")),
                        icon="msg_link",
                        link_alias="deeplx_api_url",
                        on_change=self._on_change_deeplx_api_url,
                    ),
                    Input(
                        key="deeplx_api_token",
                        text=self._t("deeplx_api_token_label"),
                        default=str(self.get_setting("deeplx_api_token", "")),
                        icon="menu_feature_reliable",
                        link_alias="deeplx_api_token",
                        on_change=self._on_change_deeplx_api_token,
                    ),
                ])
            elif prov_idx == 5: # ChatGPT (OpenAI)
                items.append(Divider(text="OpenAI ChatGPT"))
                items.extend([
                    Input(
                        key="openai_api_key",
                        text=self._t("openai_api_key_label"),
                        default=str(self.get_setting("openai_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="openai_api_key",
                        on_change=self._on_change_openai_api_key,
                    ),
                ])
            elif prov_idx == 6: # Cerebras
                items.append(Divider(text=self._t("cerebras_description") or "Cerebras"))
                items.extend([
                    Input(
                        key="cerebras_api_key",
                        text=self._t("cerebras_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("cerebras_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="cerebras_api_key",
                        on_change=lambda v: self.set_setting("cerebras_api_key", str(v or "").strip()),
                    ),
                    Text(
                        text=self._t("get_cerebras_api_button") or "Obter API Key (Cerebras)",
                        icon="menu_link_create2",
                        accent=True,
                        link_alias="get_cerebras_api",
                        on_click=lambda view: self._open_url_generic("https://cloud.cerebras.ai/"),
                    ),
                ])
            elif prov_idx == 7: # llm7.io
                items.append(Divider(text=self._t("llm7_description") or "llm7.io"))
                items.extend([
                    Input(
                        key="llm7_api_key",
                        text=self._t("llm7_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("llm7_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="llm7_api_key",
                        on_change=lambda v: self.set_setting("llm7_api_key", str(v or "").strip()),
                    ),
                    Text(
                        text=self._t("get_llm7_api_button") or "Obter API Key (llm7.io)",
                        icon="menu_link_create2",
                        accent=True,
                        link_alias="get_llm7_api",
                        on_click=lambda view: self._open_url_generic("https://token.llm7.io/"),
                    ),
                ])
            else: # Custom
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="custom_api_url",
                        text=self._t("custom_api_url_label"),
                        default=str(self.get_setting("custom_api_url", "")),
                        icon="msg_link",
                        link_alias="custom_api_url",
                        on_change=self._on_change_custom_api_url,
                    ),
                    Input(
                        key="custom_api_key",
                        text=self._t("custom_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("custom_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="custom_api_key",
                        on_change=self._on_change_custom_api_key,
                    ),
                ])

            if prov_idx != 3 and prov_idx != 4:
                items.append(Divider(text=self._t("model_creativity_section")))
                if prov_idx == 2:
                    items.append(Input(
                        key="custom_model_name",
                        text=self._t("custom_model_label") or self._t("model_label"),
                        default=str(self.get_setting("custom_model_name", "")),
                        icon="menu_edit_price",
                        link_alias="custom_model_name",
                        on_change=self._on_change_custom_model_name,
                    ))
                elif prov_idx == 5:
                    items.append(Selector(
                        key="openai_model",
                        text=self._t("model_label"),
                        default=int(self.get_setting("openai_model_idx", 0)),
                        items=["gpt-4o-mini", "gpt-4o", "gpt-4.1", "gpt-4.1-mini"],
                        icon="menu_edit_price",
                        link_alias="openai_model",
                        on_change=self._on_change_openai_model,
                    ))
                elif prov_idx == 6: # Cerebras
                    modelos_cerebras = self._opcoes_modelos_cerebras()
                    items.append(Selector(
                        key="modelo_cerebras",
                        text=self._t("model_label"),
                        default=int(self.get_setting("modelo_cerebras_idx", 0)),
                        items=[m["label"] for m in modelos_cerebras],
                        icon="menu_edit_price",
                        link_alias="modelo_cerebras",
                        on_change=lambda v: self.set_setting("modelo_cerebras_idx", int(v)),
                    ))
                elif prov_idx == 7: # llm7.io
                    modelos_llm7 = self._opcoes_modelos_llm7()
                    items.append(Selector(
                        key="modelo_llm7",
                        text=self._t("llm7_model_selector_label"),
                        default=int(self.get_setting("modelo_llm7_idx", 0)),
                        items=[m["label"] for m in modelos_llm7],
                        icon="menu_edit_price",
                        link_alias="modelo_llm7",
                        on_change=lambda v: self.set_setting("modelo_llm7_idx", int(v)),
                    ))
                else:
                    items.append(Selector(
                        key="modelo_gemini",
                        text=self._t("model_label"),
                        default=modelo_idx,
                        items=modelo_labels,
                        icon="menu_edit_price",
                        link_alias="modelo_gemini",
                        on_change=self._on_change_model,
                    ))
                items.extend([
                    Selector(
                        key="temperatura_idx",
                        text=self._t("temperature_label"),
                        default=temp_idx,
                        items=temp_labels,
                        icon="media_settings",
                        link_alias="temperatura_idx",
                        on_change=self._on_change_temperature,
                    ),
                ])
            # Nota: v1.0.5
            # Categoria: Prompt (Movido de Advanced Options)
            # DeepLX (4) não suporta instruções personalizadas
            if prov_idx != 4:
                try:
                    items.append(Divider(text=self._t("advanced_cat_prompt")))
                except Exception:
                    pass
                try:
                    raw = self.get_setting("prompt_mode", 0)
                    try:
                        mode_idx = int(raw)
                    except Exception:
                        try:
                            mode_idx = 0 if str(raw).lower() != "extra" else 1
                        except Exception:
                            mode_idx = 0
                    items.append(Selector(
                        key="prompt_mode",
                        text=self._t("prompt_selector_label"),
                        default=mode_idx,
                        items=[self._t("prompt_mode_base"), self._t("prompt_mode_extra")],
                        icon="input_bot1",
                        link_alias="prompt_mode",
                        on_change=self._on_change_prompt_mode,
                    ))
                except Exception:
                    pass
                # Campo de complemento exibido quando o modo for Complement (índice 1)
                try:
                    if int(mode_idx) == 1:
                        items.append(Input(
                            key="prompt_extra_text",
                            text=self._t("prompt_extra_input_label"),
                            default=str(self.get_setting("prompt_extra_text", "") or ""),
                            icon="msg_arrowright",
                            link_alias="prompt_extra_text",
                            on_change=self._on_change_prompt_extra_text,
                        ))
                except Exception:
                    pass
            
            # DeepLX: Aviso experimental no final
            if prov_idx == 4:
                try:
                    items.append(Divider(text=self._t("deeplx_experimental_warning")))
                except Exception:
                    pass

            return items
        except Exception as e:
            return [Text(text=f"Erro: {e}")]

    # Subfragmento: Opções avançadas
    def _create_optional_subfragment(self, parent_view=None):
        try:
            # Importa classes de UI de settings
            try:
                from ui.settings import Divider, Switch, Selector, Input, Text
            except Exception:
                # Fallback: objetos já resolvidos pelo host
                pass
            try:
                self._log("Abrindo subfragment: Opções avançadas")
            except Exception:
                pass
            # Contexto do fragmento atual
            try:
                fragment = get_last_fragment()
                mc = get_messages_controller()
            except Exception:
                fragment = None
                mc = None
            items = []
            
            
            # Categoria: Opcional (comportamentos não essenciais)
            try:
                items.append(Divider(text=self._t("advanced_cat_optional")))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="quick_dismiss_ativado",
                    text="Quick Dismiss",
                    subtext=self._t("quick_dismiss_subtext"),
                    default=self._get_bool_setting("quick_dismiss_ativado", False),
                    icon="msg_autodelete_badge2",
                    link_alias="quick_dismiss_ativado",
                    on_change=self._on_change_quick_dismiss,
                ))
            except Exception:
                pass
            try:
                notify_ativado = self._get_bool_setting("notify_ativado", False)
                items.append(Switch(
                    key="notify_ativado",
                    text=self._t("notify_ativado"),
                    subtext=self._t("notify_subtext"),
                    default=notify_ativado,
                    icon="filter_note",
                    link_alias="notify_ativado",
                    on_change=self._on_change_notify,
                ))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="aura_ativado",
                    text="Aura",
                    subtext=self._t("aura_subtext"),
                    default=self._get_bool_setting("aura_ativado", False),
                    icon="msg_photo_curve",
                    link_alias="aura_ativado",
                    on_change=self._on_change_aura,
                ))
            except Exception:
                pass
            # Feedback Tátil
            try:
                items.append(Switch(
                    key="haptic_feedback_ativado",
                    text=self._t("haptic_feedback_label"),
                    subtext=self._t("haptic_feedback_subtext"),
                    default=self._get_bool_setting("haptic_feedback_ativado", False),
                    icon="profile_newmsg",
                    link_alias="haptic_feedback_ativado",
                    on_change=self._on_change_haptic_feedback,
                ))
            except Exception:
                pass
            # Categoria: Idioma do plugin
            try:
                items.append(Divider(text=self._t("plugin_lang_label")))
                
                plugin_labels = [
                    self._t("lang_english"),
                    self._t("lang_portuguese"),
                    self._t("lang_spanish"),
                    self._t("lang_russian"),
                    self._t("lang_chinese_simplified")
                ]
                plugin_lang_idx = self._get_plugin_lang_index()
                
                items.append(Selector(
                    key="plugin_lang",
                    text=self._t("plugin_lang_label"),
                    default=plugin_lang_idx,
                    items=plugin_labels,
                    icon="msg_language",
                    link_alias="plugin_lang",
                    on_change=self._on_change_plugin_lang,
                ))
            except Exception:
                pass
            # Categoria: Registros (última opção)
            try:
                items.append(Divider(text=self._t("advanced_cat_logging")))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="logs_desativado",
                    text=self._t("logs_disable_label"),
                    default=self._get_bool_setting("logs_desativado", False),
                    icon="msg_log",
                    link_alias="logs_desativado",
                    on_change=self._on_change_logs_desativado,
                ))
            except Exception:
                pass
            try:
                self._log(f"Opções avançadas: itens={len(items)}")
            except Exception:
                pass
            return items
        except Exception as e:
            return [Text(text=f"Erro: {e}")]

    # Handlers de Opções avançadas
    def _on_change_prompt_mode(self, idx):
        try:
            try:
                i = int(idx)
            except Exception:
                # Compatibilidade: se vier string "base"/"extra", mapeia para índice
                try:
                    s = str(idx).lower()
                    i = 0 if s != "extra" else 1
                except Exception:
                    i = 0
            # Persistir como índice numérico para evitar mismatch com o Selector
            self.set_setting("prompt_mode", int(i))
            # Atualizar UI para refletir visibilidade do campo de complemento
            try:
                self.reload_settings()
            except Exception:
                pass
        except Exception:
            pass

    def _on_change_prompt_extra_ativado(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("prompt_extra_ativado", v_bool)
        except Exception:
            pass
    def _on_change_prompt_extra_text(self, v):
        try:
            self.set_setting("prompt_extra_text", str(v))
        except Exception:
            pass

    def _on_change_haptic_feedback(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("haptic_feedback_ativado", v_bool)
            try:
                run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("haptic_feedback_label")))
            except Exception:
                pass
        except Exception:
            pass

    def _on_change_notify(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("notify_ativado", v_bool)
            if v_bool:
                self._play_notify_sound()
            self.reload_settings()
        except Exception:
            pass

    def _play_notify_sound(self) -> None:
        try:
            from android.media import RingtoneManager
            from org.telegram.messenger import ApplicationLoader
            
            ctx = ApplicationLoader.applicationContext
            uri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)
            ringtone = RingtoneManager.getRingtone(ctx, uri)
            if ringtone:
                ringtone.play()
        except Exception:
            pass

    # Helpers internos: Haptic e Notify
    def _do_haptic_feedback(self) -> None:
        try:
            # Tenta vibração via View (HapticFeedbackConstants)
            success = False
            try:
                fragment = self.get_last_fragment_safe()
                if fragment:
                    view = fragment.getFragmentView()
                    if view:
                        from android.view import HapticFeedbackConstants
                        # Tenta KEYBOARD_TAP primeiro
                        view.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
                        success = True
            except Exception:
                pass

            # Fallback: (Android 16+ friendly) - revisitar futuramente para melhorias
            if not success:
                try:
                    from android.content import Context
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                    vibrator = ctx.getSystemService(Context.VIBRATOR_SERVICE)
                    if vibrator and vibrator.hasVibrator():
                        vibrator.vibrate(40) # 40ms de vibração suave
                except Exception:
                    pass
        except Exception:
            pass







