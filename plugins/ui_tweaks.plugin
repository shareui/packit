import traceback
import re
import urllib.parse
import os
import json
import urllib.request
import base64
import weakref
import threading
import time
import math
import shutil


from typing import Set, Any, Optional, List, Dict
from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy, MethodReplacement, AppEvent, MethodHook, hook_filters, HookFilter
from hook_utils import find_class, get_private_field, set_private_field
from java import dynamic_proxy, jclass, jlong

from ui.settings import Header, Switch, Divider, Selector, Text, EditText
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder

from client_utils import get_last_fragment, get_send_messages_helper, get_messages_storage, run_on_queue, PLUGINS_QUEUE, get_messages_controller, get_account_instance, send_message, send_request, RequestCallback, get_notification_center, get_connections_manager
from android_utils import run_on_ui_thread, log, OnLongClickListener, OnClickListener
from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment

from android.view import View, ViewGroup, Gravity, HapticFeedbackConstants
from android.widget import FrameLayout, TextView, ImageView, LinearLayout, HorizontalScrollView, ScrollView
from android.graphics import Canvas, Path, Rect, Typeface
from android.graphics.drawable import Drawable, GradientDrawable
from android.text import SpannableStringBuilder, TextUtils, Spanned
from android.text.style import ForegroundColorSpan, TypefaceSpan, CharacterStyle
from android.text import InputType
from android.util import TypedValue
from android.os import Bundle, Handler, Looper
from android.content import Context, ClipData, ClipboardManager
from java.util import ArrayList
import threading
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginsActivity, PluginSettingsActivity

from org.telegram.messenger import R as R_tg
from org.telegram.messenger import MessagesController, UserConfig, ApplicationLoader, LocaleController, AndroidUtilities, MessagesStorage, ChatMessageSharedResources, SharedConfig, NotificationCenter
from org.telegram.messenger import UserObject, ChatObject, ImageLocation, MessageObject, DialogObject, BotWebViewVibrationEffect, SendMessagesHelper, CodeHighlighting, AccountInstance, Emoji
from org.telegram.ui.Components import EditTextBoldCursor, URLSpanUserMention
from org.telegram.tgnet import TLRPC
from org.telegram.tgnet.tl import TL_account
from org.telegram.messenger import ContactsController
from org.telegram.ui.ActionBar import ActionBarPopupWindow, Theme, ActionBarMenuItem, ActionBarMenuSubItem
from org.telegram.ui.Components import AvatarDrawable, BackupImageView, LayoutHelper, UItem, AnimatedEmojiSpan
from org.telegram.ui import ChatActivity, ProfileActivity, TopicsFragment, DialogsActivity, LaunchActivity
from org.telegram.ui.ActionBar import BaseFragment
from com.google.android.exoplayer2.util import Consumer

from file_utils import get_cache_dir, ensure_dir_exists

import hashlib
import uuid

try:
    import quantahut
    if hasattr(quantahut, '__version__') and quantahut.__version__ < "1.5.2":
        raise Exception(f"QuantaHut {quantahut.__version__} is too old. Need 1.5.1+")
    from quantahut import export_plugin_settings
    from ui.quanta import MultiSelector, BottomSheet, ExpandableSwitch
except ImportError:
    raise Exception("QuantaHut is required but not installed. Install it first. (Don't report this as a bug - it's your fault.)")

QuantaHut = quantahut

__id__ = "ui_tweaks"
__name__ = "UiTweaks"
__type__ = "plugin"
__description__ = "Well sometimes you just need to tweak things... (requires [QuantaHut](https://t.me/QuantaPlugins/228))"
__version__ = "1.8.4"
__author__ = "@luvztroy"
__min_version__ = "12.2.10"
__icon__ = "luvztroyIcons/13"
__dependencies__ = ["quantahut"]



CUSTOM_CODE_ID = 99999
CUSTOM_MENTION_ID = 99998
DEBOUNCE_TIME = 0.5
MKSTATS_API_URL = os.getenv("MKSTATS_API_URL", "https://mkstats.mk69.su/api")
MKSTATS_PING_INTERVAL = int(os.getenv("MKSTATS_PING_INTERVAL", "1500"))

def generate_user_hash(device_id: str, plugin_id: str) -> str:
    payload = f"{device_id}:{plugin_id}:mkstats:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def _normalize_api_base(api_url: str) -> str:
    base = api_url.rstrip("/")
    if base.endswith("/api"):
        return f"{base}/v1"
    return base

def _post_json(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url, data=data, headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(request, timeout=10) as response:
        body = response.read().decode("utf-8")
    return json.loads(body)

class MkStatsCoreClient:
    def __init__(self, api_url: str, plugin_id: str, version: str, user_hash: str) -> None:
        self.api_base = _normalize_api_base(api_url)
        self.plugin_id = plugin_id
        self.version = version
        self.user_hash = user_hash

    def handshake(self) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.version,
            "user_hash": self.user_hash,
        }
        return _post_json(f"{self.api_base}/handshake", payload)

    def send_ping(self, install_token: str, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.version,
            "user_hash": self.user_hash,
            "install_token": install_token,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/data", payload)

    def send_event(self, install_token: str, event: str, count: int = 1, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.version,
            "user_hash": self.user_hash,
            "install_token": install_token,
            "event": event,
            "count": count,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/event", payload)



def getString(key: str, default: str = None) -> str:
    fallback = default if default is not None else key
    try:
        selected_language = get_selected_language_preference()
        if selected_language:
            return quantahut.get_localized_string("UiTweaks", key, fallback)
        else:
            current_language = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
            if current_language == "en":
                return fallback
            return quantahut.get_localized_string("UiTweaks", key, fallback)
    except:
        return fallback

def get_selected_language_preference():
    try:
        from base_plugin import PluginsController
        from hook_utils import get_private_field
        prefs = get_private_field(PluginsController.getInstance(), "preferences")
        return prefs.getString("plugin_setting_ui_tweaks_selected_language", None)
    except Exception as e:
        return None


def _find_class_silent(class_name: str):
    try:
        return jclass(class_name)
    except Exception:
        return None


def _get_private_field_silent(obj, field_name: str):
    try:
        clazz = obj.getClass()
        field = None
        current = clazz
        while current is not None:
            try:
                field = current.getDeclaredField(field_name)
                break
            except Exception:
                current = current.getSuperclass()
        if field is None:
            return None
        field.setAccessible(True)
        return field.get(obj)
    except Exception:
        return None

def set_selected_language_preference(lang_code):
    try:
        from base_plugin import PluginsController
        from hook_utils import get_private_field
        prefs = get_private_field(PluginsController.getInstance(), "preferences")
        prefs.edit().putString("plugin_setting_ui_tweaks_selected_language", lang_code).apply()
    except Exception as e:
        pass



TL_documentAttributeSticker = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeSticker')
TL_documentAttributeAudio = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeAudio')
TL_documentAttributeVideo = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeVideo')
TL_documentAttributeAnimated = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeAnimated')


class NonClickablePreviewDispatchTouchHook:
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            fragment_view = param.thisObject
            if not fragment_view:
                return
            
            chat_activity_field = fragment_view.getClass().getDeclaredField("this$0")
            chat_activity_field.setAccessible(True)
            chat_activity = chat_activity_field.get(fragment_view)
            if not chat_activity:
                return
            
            parent_layout_field = chat_activity.getClass().getSuperclass().getDeclaredField("parentLayout")
            parent_layout_field.setAccessible(True)
            parent_layout = parent_layout_field.get(chat_activity)
            if not parent_layout:
                return
            
            is_preview_method = parent_layout.getClass().getDeclaredMethod("isInPreviewMode")
            is_preview_method.setAccessible(True)
            in_preview_mode = is_preview_method.invoke(parent_layout)
            
            if in_preview_mode:
                try:
                    allow_field = chat_activity.getClass().getDeclaredField("allowExpandPreviewByClick")
                    allow_field.setAccessible(True)
                    allow_expand = allow_field.getBoolean(chat_activity)
                    
                    if allow_expand:
                        allow_field.setBoolean(chat_activity, False)
                except:
                    pass
        except Exception as e:
            pass


class NonClickablePreviewPresentFragmentHook:
    @hook_filters(HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def after_hooked_method(self, param):
        try:
            fragment = param.thisObject
            preview_fragment = param.args[0]
            preview_menu = param.args[1]
            
            if not preview_fragment or not preview_menu:
                return
                
            ChatActivity = jclass("org.telegram.ui.ChatActivity")
            if not isinstance(preview_fragment, ChatActivity):
                return
                
            try:
                allow_field = preview_fragment.getClass().getDeclaredField("allowExpandPreviewByClick")
                allow_field.setAccessible(True)
                allow_field.setBoolean(preview_fragment, False)
            except:
                pass

            try:
                chat_list_field = preview_fragment.getClass().getDeclaredField("chatListView")
                chat_list_field.setAccessible(True)
                chat_list_view = chat_list_field.get(preview_fragment)
                if chat_list_view is not None:
                    try:
                        chat_list_view.setOnItemClickListener(None)
                    except:
                        pass
                    try:
                        chat_list_view.setOnItemLongClickListener(None)
                    except:
                        pass
                    try:
                        chat_list_view.setClickable(False)
                    except:
                        pass
                    try:
                        chat_list_view.setLongClickable(False)
                    except:
                        pass
            except:
                pass

            dialog_id = preview_fragment.getDialogId()
            
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            
            if DialogObject.isUserDialog(dialog_id):
                user = MessagesController.getInstance(fragment.currentAccount).getUser(dialog_id)
                if not user:
                    return
                self._add_open_profile_item(fragment, preview_menu, dialog_id)
                self._add_open_chat_item(fragment, preview_menu, dialog_id)
            else:
                chat_id_for_lookup = -dialog_id
                chat = MessagesController.getInstance(fragment.currentAccount).getChat(chat_id_for_lookup)
                if not chat:
                    return
                self._add_open_profile_item(fragment, preview_menu, dialog_id)
                self._add_open_chat_item(fragment, preview_menu, dialog_id)
        except:
            pass
    
    def _add_open_profile_item(self, fragment, preview_menu, dialog_id):
        try:
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            R = jclass("org.telegram.messenger.R")
            
            item_text = getString("open_profile", "Open Profile")
            item_icon = R.drawable.msg_openprofile
            
            open_profile_item = ActionBarMenuSubItem(fragment.getParentActivity(), False, False)
            open_profile_item.setTextAndIcon(item_text, item_icon)
            open_profile_item.setMinimumWidth(160)
            
            fragment_ref = weakref.ref(fragment)
            def on_open_profile_click(*args, ref=fragment_ref, did=dialog_id):
                f = ref()
                if f:
                    self._open_profile(f, did)
            click_listener = OnClickListener(on_open_profile_click)
            open_profile_item.setOnClickListener(click_listener)
            
            preview_menu.addView(open_profile_item)
        except:
            pass
    
    def _add_open_chat_item(self, fragment, preview_menu, dialog_id):
        try:
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            R = jclass("org.telegram.messenger.R")
            
            item_text = getString("open_chat", "Open Chat")
            item_icon = R.drawable.msg_msgbubble3
            
            open_chat_item = ActionBarMenuSubItem(fragment.getParentActivity(), False, False)
            open_chat_item.setTextAndIcon(item_text, item_icon)
            open_chat_item.setMinimumWidth(160)
            
            fragment_ref = weakref.ref(fragment)
            def on_open_chat_click(*args, ref=fragment_ref):
                f = ref()
                if f:
                    self._open_chat(f)
            click_listener = OnClickListener(on_open_chat_click)
            open_chat_item.setOnClickListener(click_listener)
            
            preview_menu.addView(open_chat_item)
        except:
            pass
    
    def _open_chat(self, fragment):
        try:
            parent_layout = fragment.getParentLayout()
            if parent_layout:
                parent_layout.expandPreviewFragment()
        except:
            pass
    
    def _open_profile(self, fragment, dialog_id):
        try:
            fragment.finishPreviewFragment()
            
            Bundle = jclass("android.os.Bundle")
            args = Bundle()
            args.putBoolean("expandPhoto", False)
            
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            if DialogObject.isUserDialog(dialog_id):
                args.putLong("user_id", dialog_id)
            else:
                chat_id_for_bundle = -dialog_id
                args.putLong("chat_id", chat_id_for_bundle)
            
            ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
            present_fragment_method = fragment.getClass().getDeclaredMethod("presentFragment", jclass("org.telegram.ui.ActionBar.BaseFragment"))
            present_fragment_method.setAccessible(True)
            present_fragment_method.invoke(fragment, ProfileActivity(args))
        except:
            pass


class AddToFolderAllTabsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            
            add_to_folder_item_field = dialogs_activity.getClass().getDeclaredField("addToFolderItem")
            add_to_folder_item_field.setAccessible(True)
            add_to_folder_item = add_to_folder_item_field.get(dialogs_activity)
            
            if add_to_folder_item is None:
                return
            
            filter_tabs_view_field = dialogs_activity.getClass().getDeclaredField("filterTabsView")
            filter_tabs_view_field.setAccessible(True)
            filter_tabs_view = filter_tabs_view_field.get(dialogs_activity)
            
            folder_id_field = dialogs_activity.getClass().getDeclaredField("folderId")
            folder_id_field.setAccessible(True)
            folder_id = folder_id_field.getInt(dialogs_activity)
            
            selected_dialogs_field = dialogs_activity.getClass().getDeclaredField("selectedDialogs")
            selected_dialogs_field.setAccessible(True)
            selected_dialogs = selected_dialogs_field.get(dialogs_activity)
            
            FiltersListBottomSheetClass = find_class("org.telegram.ui.Components.FiltersListBottomSheet")
            if FiltersListBottomSheetClass:
                can_add_filters = FiltersListBottomSheetClass.getCanAddDialogFilters(dialogs_activity, selected_dialogs)
                has_available_folders = can_add_filters is not None and not can_add_filters.isEmpty()
            else:
                has_available_folders = False
            
            should_show = False
            
            if folder_id == 1:
                should_show = True
            elif (filter_tabs_view is not None and 
                  filter_tabs_view.getVisibility() == View.VISIBLE and 
                  has_available_folders):
                should_show = True
            
            if should_show:
                add_to_folder_item.setVisibility(View.VISIBLE)
            else:
                add_to_folder_item.setVisibility(View.GONE)
                
        except Exception:
            pass

class UnreadCountHook:
    def __init__(self, plugin_instance):
        super().__init__(plugin_instance)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            show_message_count = self.plugin.get_setting("unread_message_count", False)
            show_chat_count = self.plugin.get_setting("unread_chat_count", False)
            exclude_archived = self.plugin.get_setting("exclude_archived_from_count", False)
            process_counts = show_message_count or show_chat_count

            exclude_archived = self.plugin.get_setting("exclude_archived_from_count", False)
            process_counts = show_message_count or show_chat_count

            if not (process_counts or exclude_archived):
                return

            messages_storage = param.thisObject
            apply = param.args[0] if len(param.args) > 0 else False
            from org.telegram.messenger import UserConfig; current_account = UserConfig.selectedAccount
            from java import jclass; MessagesController = jclass("org.telegram.messenger.MessagesController"); messages_controller = MessagesController.getInstance(current_account)

            if process_counts:
                dialog_filters_field = messages_controller.getClass().getDeclaredField("dialogFilters"); dialog_filters_field.setAccessible(True); dialog_filters = dialog_filters_field.get(messages_controller)

                for i in range(dialog_filters.size()):
                    try:
                        filter_dialog = dialog_filters.get(i)

                        dialogs_field = filter_dialog.getClass().getDeclaredField("dialogs"); dialogs_field.setAccessible(True); dialogs = dialogs_field.get(filter_dialog)

                        if dialogs is None or dialogs.size() == 0:
                            continue

                        unread_count = 0; muted_excluded = 0; muted_with_mentions = 0; non_muted_counted = 0

                        for j in range(dialogs.size()):
                            dialog = dialogs.get(j)

                            dialog_unread_count = dialog.unread_count; dialog_unread_mentions = dialog.unread_mentions_count

                            if dialog_unread_count == 0 and dialog_unread_mentions == 0:
                                continue

                            if exclude_archived and hasattr(dialog, 'folder_id') and dialog.folder_id != 0:
                                continue

                            dialog_id = dialog.id; is_muted = messages_controller.isDialogMuted(dialog_id, 0)

                            if is_muted:
                                if show_message_count and not show_chat_count:
                                    unread_count += dialog_unread_count + dialog_unread_mentions
                                elif dialog_unread_mentions > 0 and show_chat_count and not show_message_count:
                                    unread_count += 1
                                muted_excluded += 1
                                continue

                            if show_message_count:
                                unread_count += dialog_unread_count
                            elif show_chat_count:
                                unread_count += 1
                            non_muted_counted += 1

                        filter_dialog.unreadCount = unread_count; filter_dialog.pendingUnreadCount = unread_count

                    except Exception:
                        continue

            if exclude_archived:
                try:
                    pending_archive_count_field = messages_storage.getClass().getDeclaredField("pendingArchiveUnreadCount")
                    pending_archive_count_field.setAccessible(True)
                    pending_archive_count_field.setInt(messages_storage, 0)

                    archive_count_field = messages_storage.getClass().getDeclaredField("archiveUnreadCount")
                    archive_count_field.setAccessible(True)
                    archive_count_field.setInt(messages_storage, 0)
                except Exception:
                    pass

                if not process_counts:
                    try:
                        from org.telegram.messenger import NotificationCenter
                        notification_center = NotificationCenter.getInstance(current_account)
                        notification_center.postNotificationName(NotificationCenter.dialogsUnreadCounterChanged, current_account)
                    except Exception:
                        pass

            if process_counts:
                main_unread_count_field = messages_storage.getClass().getDeclaredField("pendingMainUnreadCount")
                main_unread_count_field.setAccessible(True)
                previous_pending = main_unread_count_field.getInt(messages_storage)

                previous_main = None
                main_unread_count_apply_field = None
                if apply:
                    main_unread_count_apply_field = messages_storage.getClass().getDeclaredField("mainUnreadCount")
                    main_unread_count_apply_field.setAccessible(True)
                    previous_main = main_unread_count_apply_field.getInt(messages_storage)

                main_dialogs_method = messages_controller.getClass().getMethod("getAllDialogs")
                main_dialogs = main_dialogs_method.invoke(messages_controller)

                filtered_count = 0
                if main_dialogs is not None:
                    for k in range(main_dialogs.size()):
                        dialog = main_dialogs.get(k)
                        dialog_unread_count = dialog.unread_count
                        dialog_unread_mentions = dialog.unread_mentions_count

                        if dialog_unread_count == 0 and dialog_unread_mentions == 0:
                            continue

                        if exclude_archived and hasattr(dialog, 'folder_id') and dialog.folder_id != 0:
                            continue

                        dialog_id = dialog.id
                        is_muted = messages_controller.isDialogMuted(dialog_id, 0)

                        if is_muted:
                            if show_message_count and not show_chat_count:
                                filtered_count += dialog_unread_count + dialog_unread_mentions
                            elif dialog_unread_mentions > 0 and show_chat_count and not show_message_count:
                                filtered_count += 1
                            continue

                        if show_message_count:
                            filtered_count += dialog_unread_count
                        elif show_chat_count:
                            filtered_count += 1

                main_unread_count_field.setInt(messages_storage, filtered_count)

                if apply and main_unread_count_apply_field is not None:
                    main_unread_count_apply_field.setInt(messages_storage, filtered_count)

                should_notify = filtered_count != previous_pending or (apply and previous_main is not None and filtered_count != previous_main)

                if should_notify:
                    try:
                        from org.telegram.messenger import NotificationCenter
                        notification_center = NotificationCenter.getInstance(current_account)
                        notification_center.postNotificationName(NotificationCenter.dialogsUnreadCounterChanged, current_account)
                    except Exception:
                        pass
            
        except Exception:
            pass


class ContactStatusUpdateRowsIdsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        plugin = self._plugin_ref()
        if not plugin:
            return
        activity = param.thisObject
        state = plugin.contact_status_activity_state.setdefault(activity, {"mutualRow": -1})

        state["shouldInsertMutual"] = False

        user = self._get_profile_user(activity)
        if not user or not getattr(user, "mutual_contact", False):
            state["mutualRow"] = -1
            return

        state["shouldInsertMutual"] = True

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        plugin = self._plugin_ref()
        if not plugin:
            return
        activity = param.thisObject
        state = plugin.contact_status_activity_state.get(activity)
        if not state:
            return

        if not state.get("shouldInsertMutual"):
            state["mutualRow"] = -1
            state.pop("shouldInsertMutual", None)
            return

        insert_position = self._calculate_insert_position(activity)
        if insert_position == -1:
            state["mutualRow"] = -1
            state.pop("shouldInsertMutual", None)
            return

        state["mutualRow"] = insert_position
        state.pop("shouldInsertMutual", None)

        row_count = self._get_int_field(activity, "rowCount")
        if row_count != -1:
            self._set_int_field(activity, "rowCount", row_count + 1)

        try:
            activity_class = activity.getClass()
            fields = activity_class.getDeclaredFields()
            for i in range(len(fields)):
                field = fields[i]
                name = field.getName()
                if "Row" not in name and "row" not in name:
                    continue
                if name in ("rowCount", "phoneRow", "mutualRow"):
                    continue
                field_type = field.getType()
                INTEGER_CLASS = jclass("java.lang.Integer")
                if field_type != INTEGER_CLASS.TYPE and field_type != INTEGER_CLASS:
                    continue
                field.setAccessible(True)
                value_obj = field.get(activity)
                if value_obj is None:
                    continue
                try:
                    value = int(value_obj)
                except Exception:
                    continue
                if value >= state["mutualRow"] and value != -1:
                    try:
                        if field_type == INTEGER_CLASS.TYPE:
                            field.setInt(activity, value + 1)
                        else:
                            field.set(activity, INTEGER_CLASS(value + 1))
                    except Exception:
                        pass
        except Exception:
            pass

    def _get_profile_user(self, activity):
        try:
            user_id = self._get_long_field(activity, "userId")
            if user_id == 0:
                return None
            from org.telegram.messenger import MessagesController, UserConfig
            account = UserConfig.selectedAccount
            controller = MessagesController.getInstance(account)
            if not controller:
                return None
            try:
                user_id_int = int(user_id)
            except Exception:
                user_id_int = user_id
            user = controller.getUser(user_id_int)
            if user:
                return user
            user_full = self._get_object_field(activity, "userInfo")
            if user_full and getattr(user_full, "user", None):
                return user_full.user
        except Exception:
            return None

    def _get_int_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getInt(obj)
        except Exception:
            return -1

    def _set_int_field(self, obj, name, value):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            field.setInt(obj, value)
        except Exception:
            pass

    def _get_long_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getLong(obj)
        except Exception:
            return 0

    def _get_object_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.get(obj)
        except Exception:
            return None

    def _calculate_insert_position(self, activity):
        anchors = [
            "phoneRow",
        ]
        for name in anchors:
            value = self._get_int_field(activity, name)
            if value != -1:
                return value + 1

        fallback_anchors = [
            "bizHoursRow",
            "bizLocationRow",
            "usernameRow",
            "userInfoRow",
            "birthdayRow",
            "infoHeaderRow",
            "infoHeaderRowEmpty",
        ]
        for name in fallback_anchors:
            value = self._get_int_field(activity, name)
            if value != -1:
                return value + 1

        info_end_row = self._get_int_field(activity, "infoEndRow")
        if info_end_row != -1:
            return info_end_row + 1

        return -1


class ContactStatusListAdapterGetItemViewTypeHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        plugin = self._plugin_ref()
        if not plugin:
            return
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = plugin.contact_status_activity_state.get(activity)
        if not state:
            return
        position_arg = param.args[0]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        if position == state.get("mutualRow", -1):
            try:
                INTEGER_CLASS = jclass("java.lang.Integer")
                param.setResult(INTEGER_CLASS(2))
            except Exception:
                param.setResult(2)

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None



class ContactStatusListAdapterBindViewHolderHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def after_hooked_method(self, param):
        position_arg = param.args[1]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        plugin = self._plugin_ref()
        if not plugin:
            return
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = plugin.contact_status_activity_state.get(activity)
        if not state or position != state.get("mutualRow", -1):
            return

        try:
            holder = param.args[0]
            item_view = holder.itemView
            from org.telegram.ui.Cells import TextDetailCell
            if isinstance(item_view, TextDetailCell):
                item_view.setTextAndValue(
                    getString("mutual_contact", "Mutual contact"),
                    getString("both_saved_as_contacts", "Both saved as contacts"),
                    True
                )
        except Exception:
            pass

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class UiTweaksPlugin(BasePlugin):

    def _mkstats_get_setting(self, key: str, default):
        try:
            if hasattr(self, "get_setting"):
                return self.get_setting(key, default)
            if hasattr(self, "getsetting"):
                return self.getsetting(key, default)
        except Exception:
            pass
        return default

    def _mkstats_set_setting(self, key: str, value, reload_settings: bool = False):
        try:
            if hasattr(self, "set_setting"):
                return self.set_setting(key, value, reload_settings=reload_settings)
            if hasattr(self, "setsetting"):
                return self.setsetting(key, value, reloadsettings=reload_settings)
        except Exception:
            pass
        return None

    def _mkstats_get_device_id(self) -> str:
        device_id = self._mkstats_get_setting("mkstats_device_id", "")
        if not device_id:
            device_id = uuid.uuid4().hex
            self._mkstats_set_setting("mkstats_device_id", device_id, reload_settings=False)
        return device_id

    def _mkstats_event(self, event: str, count: int = 1) -> None:
        if not event:
            return

        def _send():
            try:
                if not hasattr(self, "_mkstats_client"):
                    return
                if not getattr(self, "_mkstats_token", ""):
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                if self._mkstats_token:
                    self._mkstats_client.send_event(self._mkstats_token, event, count=count)
            except Exception as exc:
                self.log(f"UiTweaks: event error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)

        try:
            threading.Thread(target=_send, daemon=True).start()
        except Exception:
            pass

    def _mkstats_loop(self):
        while not self._mkstats_stop.is_set():
            try:
                if not self._mkstats_token:
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                    else:
                        self.log("UiTweaks: handshake response missing token")

                if self._mkstats_token:
                    self._mkstats_client.send_ping(self._mkstats_token)
            except Exception as exc:
                self.log(f"UiTweaks: error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)
            self._mkstats_stop.wait(MKSTATS_PING_INTERVAL)

    def _mkstats_start(self):
        try:
            device_id = self._mkstats_get_device_id()
            user_hash = generate_user_hash(device_id, __id__)
            self._mkstats_client = MkStatsCoreClient(MKSTATS_API_URL, __id__, __version__, user_hash)
            self._mkstats_stop = threading.Event()
            self._mkstats_token = self._mkstats_get_setting("mkstats_install_token", "")
            self._mkstats_thread = threading.Thread(target=self._mkstats_loop, daemon=True)
            self._mkstats_thread.start()
            self.log(f"UiTweaks: client started ({self._mkstats_client.api_base})")
        except Exception:
            pass

    def __init__(self):
        super().__init__()
        
        self._class_cache = {}

        self.hook_dialogs_ref = None
        self.hook_dialogs_destroy_ref = None
        self.hook_dialog_cell_ref = None
        self.hook_gif_spoiler_ref = None
        self.hook_gif_dismiss_ref = None
        self.hook_process_external_url_ref = None
        self.hook_drawer_icon_ref = None
        self.hook_swipe_prevention_ref = None
        self.hook_star_reaction_menu_ref = None
        self.hook_star_reaction_visible_list_ref = None
        self.hook_article_viewer_ref = None
        self.hook_webapp_swipe_prevention_ref = None
        self.hook_download_manager_ref = None
        self.hook_proxy_button_ref = None
        self.current_popup = None
        self._cached_accounts = None
        self.hook_phone_number_ref = None
        self.hook_messages_controller_ref = None
        self.hook_update_bot_button_ref = None
        self.hook_call_buttons_ref = None
        self.hook_group_voice_chat_icon_ref = None
        self.hook_voice_message_control_ref = None
        self.hook_voice_message_time_display_ref = None
        self.hook_video_message_control_ref = None
        self.create_view_hook_ref = None
        self.destroy_hook_ref = None
        self._current_chat_activity_ref = None
        self._current_back_button_ref = None
        self.counter_views = {}
        self._unhook_layout = None
        self.hook_add_to_folder_all_tabs_ref = None
        self.forced_scroll_offset = 200
        
        self.unhook_send_message = None
        self.unhook_deeplink = None
        self.unhook_set_command = None
        self.hook_handler = None
        self.command_from_message_click = False
        self.hook_link_confirmation_ref = None
        self.hook_disable_topic_swipe_ref = None
        self.hook_select_all_media_ref = None
        self.hook_account_visibility_drawer_ref = None
        self.hook_account_visibility_profile_ref = None
        self.hook_fill_action_mode_menu_ref = None
        self.hook_perform_menu_action_ref = None
        self.hook_message_preview_view_ref = None
        self.hook_share_sheet_folders_ref = None
        self.hook_star_reaction_gradient_ref = None
        self.hook_star_reaction_layout_draw_ref = None
        self.hook_disable_auto_web_login_ref = None

        self.hook_prefer_common_groups_tab_ref = None
        self.hook_non_clickable_dispatch_ref = None
        self.hook_non_clickable_present_ref = None
        self.hook_non_clickable_present_ref2 = None
        self.hook_birthday_alert_ref = None
        self.hook_forward_confirmation_ref = None
        self.hook_join_confirmation_ref = None
        self.hook_send_typing_refs = None
        self.hook_open_link_internally_ref = None

        self.hook_browser_open_url_ref = None
        self.hook_code_formatting_ref = None
        self.hook_sender_select_popup_ref = None
        self.hook_unread_count_ref = None
        self.contact_status_update_rows_hook = None
        self.contact_status_get_item_view_type_hook = None
        self.contact_status_bind_view_holder_hook = None
        self.contact_status_activity_state = {}
        
        self.no_quote_forward_menu_handle = None
        self.repeat_menu_handle = None
        
        self.hook_search_by_user_id_ref = None
        self.hook_settings_header_ref = None
        self.added_send_media_buttons = set()
        self._no_quote_buttons_created = set()
        self._no_quote_button_cache = {}

        self._select_all_id = 1000
        self._select_all_added_modes = set()
        
        self._goto_items_added = set()
        
        self.hooked_activities = set()
        self.hook_chat_activity_cleanup_ref = None
        
       
        self.hidden_folders_data = {}
        self.hide_all_chats_folder = {}
        self.hook_folder_visibility_ref = None

        self.hook_gift_drawer_reset_ref = None
        self.hook_gift_drawer_click_ref = None
        self.hook_gift_drawer_cell_ref = None
        
        self.hook_ai_summarize_create_view_ref = None
        self.hook_ai_summarize_item_click_ref = None
        self.ai_summarize_menu_id = 99997
        self.ai_summarize_hooked_activities = set()
        
        self.goto_message_menu_id = 99996
        self.chat_action_bar_hooked_activities = set()
        
        self.hook_ai_role_limit_constructor_ref = None
        self.hook_ai_role_limit_settext_ref = None
        
        self.hook_sleep_timer_ref = None
        self.hook_sleep_timer_click_ref = None
        self.sleep_timer_active = False
        self._sleep_handler = None
        self._sleep_runnable = None
        
        self.hook_adaptive_audio_ref = None
        
        self.hook_music_speed_control_ref = None
        
        self.hook_custom_saved_messages_ref = None
        self.custom_saved_chat_id = None
        
        self.hook_disable_emoji_suggestions_ref = None
        self.hook_message_swipe_action_ref = None
        self.hook_join_request_direct_profile_ref = None
        self.hook_search_filter_open_search_ref = None
        self.hook_search_filter_send_request_ref = None
        self.search_filter_current = 0
        self.search_filter_buttons = {}
        
        self.hook_play_sound_ref = None
        self.hook_soundpool_load_ref = None
        self.ios_sound_path = None
        
        self.hook_in_message_translation_alert_ref = None
        
        self.hook_owner_channels_ref = None
        self.hook_remove_from_folders_ref = None
        self._remove_from_folders_state = {}
        
        self.hook_bookmark_create_view_ref = None
        self.hook_bookmark_action_bar_ref = None
        self._bookmark_helper = None
        self._bookmark_fragment = None
        self._bookmark_delegate = None
        self._bookmark_menu_handle = None
        self.hook_in_message_translation_revert_ref = None
        self._in_message_translated = set()
        self.soundpool_instance = None
        self.ios_sound_id = None
        
        self.hook_search_links_ref = None
        self.hook_enter_view_constructor_ref = None
        self.hook_send_message_params_ref = None
        
        self.hook_reactions_container_ref = None
        
        self.hook_unify_username_behavior_process_click_ref = None
        self.hook_unify_username_behavior_bind_ref = None
        
        self.hook_edit_file_name_ref = None
        self._last_item_options = None
        self._menu_item_added = False
        self._message_send_preview = None
        
        self.hook_custom_privacy_ref = None
        self._custom_privacy_item_id = 100

        self.hook_account_switcher_update_send_as_ref = None
        self.hook_account_switcher_set_default_send_as_ref = None
        self._account_switcher_chat_info = None
        self._account_switcher_user_to_account = {}
        self._account_switcher_hooked_views = set()
        self._account_switcher_popup = None
        self._account_switcher_chat_view_accounts = {}



    def log(self, message: str):
        if self.get_setting("show_logs", False):
            log(f"[UiTweaks] {message}")
    
    def _perform_haptic(self, host=None):
        try:
            root = None
            if host:
                get_pa = getattr(host, 'getParentActivity', None)
                if callable(get_pa):
                    act = get_pa()
                    if act:
                        root = act.getWindow().getDecorView()
                if root is None and hasattr(host, 'getWindow'):
                    root = host.getWindow().getDecorView()
            if root is None:
                cf = get_last_fragment()
                if cf:
                    act = cf.getParentActivity()
                    if act:
                        root = act.getWindow().getDecorView()
            if root:
                flags = HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                root.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags)
        except:
            pass
    
    def _get_launch_activity(self, host=None):
        try:
            la = LaunchActivity.instance
        except:
            la = None
        if not la and host:
            try:
                pa = host.getParentActivity()
                if pa:
                    la = pa
            except:
                pass
        return la



    def on_plugin_load(self):

        self._mkstats_start()

        self.log(f"UiTweaks {__version__} loaded")

        if self.get_setting("random_header_sticker", False):
            try:
                import random
                random_index = random.randint(0, 36)
                random_icon = f"MyLittleMsMizukiPt1/{random_index}"
                plugin = PluginsController.getInstance().plugins.get("ui_tweaks")
                if plugin:
                    plugin.setIcon(random_icon)
            except:
                pass
        self.custom_saved_chat_id = self.get_setting("custom_saved_chat_id", None)
        self.add_on_send_message_hook()
        self._load_hidden_folders()
        self._setup_quanta_file_hook()
        global uitweaks_plugin_instance
        uitweaks_plugin_instance = weakref.ref(self)
        
        self.current_mode = self.get_setting("forward_mode", "forward")
        
        self._send_comments_bypass = False
        self._send_comments_pending = {}
        
        self.hook_hide_via_bot_ref = None
        
        self.update_available = False
        self.latest_version = None
        self.changelog = None
        self.download_url = None
        self.checking_update = False
        
        self.hook_always_visible_schedule_button_ref = None
        self.hook_remove_greeting_sticker_ref = None
        self.hook_remove_https_from_links_ref = None
        self.hook_share_alert_forward_open_ref = None
        self.hook_share_alert_forward_process_ref = None

        self.hook_recent_chats_fragment_drawer_reset_ref = None
        self.hook_recent_chats_fragment_drawer_click_ref = None
        self.hook_recent_chats_fragment_drawer_cell_ref = None
        self.hook_recent_chats_fragment_activity_resume_refs = None
        self._recent_chats_fragment_data = {}
        self._recent_chats_fragment = None
        self._recent_chats_fragment_visible = False



        self.lifecycle_hook_resume = None
        self.lifecycle_hook_pause = None
        
        try:
            locale_controller = LocaleController.getInstance()
            current_language = locale_controller.getCurrentLocaleInfo().getLangCode()
            self.log(f"Language detected: {current_language}")
        except Exception as e:
            current_language = "en"
            self.log(f"Language detection failed: {e}, using default: {current_language}")
        try:
            _pref_lang = get_selected_language_preference()
            if _pref_lang:
                self.log(f"[Diag] overriding detected language with stored preference: {_pref_lang}")
                current_language = _pref_lang
        except Exception as e:
            self.log(f"[Diag] failed to apply stored preference override: {e}")
        
        
        
        self.hook_handler = ConfirmationHook(self)
        self.add_hook("TL_messages_forwardMessages")



        self._apply_hooks()
        self._setup_confirmation_hooks()
        self._setup_deeplink_hooks()
        self._setup_open_profile_hooks()
        self._setup_open_link_internally_hook()
        self._setup_settings_header_hook()
        
        if self.get_setting("enable_goto_message", False):
            self._hook_goto_message()
        

        
        if self.get_setting("enable_reply_private_chat", False):
            self._add_reply_private_chat_menu_item()
        
        if self.get_setting("enable_no_quote_forward", False):
            self._add_no_quote_forward_menu_item()

        if self.get_setting("enable_select_all_dialogs", False):
            self._setup_select_all_dialogs()
        


        
        try:
            run_on_queue(self._perform_heavy_operations, PLUGINS_QUEUE, 2000)
        except Exception as e:
            run_on_ui_thread(self._perform_heavy_operations, 3000)
        
        
        self._check_for_updates_on_load()

    def _setup_select_all_dialogs(self):
        try:
            DialogsActivityCls = find_class("org.telegram.ui.DialogsActivity")
            CreateActionMode = DialogsActivityCls.getClass().getDeclaredMethod("createActionMode", find_class("java.lang.String").getClass())
            CreateActionMode.setAccessible(True)
            ActionBarMenuCls = find_class("org.telegram.ui.ActionBar.ActionBarMenu")
            OnItemClick = ActionBarMenuCls.getClass().getDeclaredMethod("onItemClick", find_class("java.lang.Integer").TYPE)
            OnItemClick.setAccessible(True)

            class _UT_AddSelectAllMenu:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)

                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        dlg = param.thisObject
                        actionBar = getattr(dlg, "actionBar", None)
                        if actionBar is None:
                            return
                        actionMode = actionBar.getActionMode()
                        if actionMode is None:
                            return
                        try:
                            hc = actionMode.hashCode()
                            plugin = self._plugin_ref()
                            if not plugin:
                                return
                            if hc in plugin._select_all_added_modes:
                                return
                        except Exception:
                            pass
                        otherItem = None
                        for i in range(actionMode.getChildCount()):
                            child = actionMode.getChildAt(i)
                            if child is not None and child.getClass().getName().endswith("ActionBarMenuItem"):
                                try:
                                    if hasattr(child, "hasSubMenu") and child.hasSubMenu():
                                        otherItem = child
                                        break
                                except Exception:
                                    pass
                        if otherItem is None:
                            return
                        try:
                            popup = get_private_field(otherItem, "popupLayout")
                            if popup is not None:
                                for k in range(popup.getItemsCount()):
                                    v = popup.getItemAt(k)
                                    if v is not None and v.getTag() == plugin._select_all_id:
                                        plugin._select_all_added_modes.add(hc)
                                        return
                        except Exception:
                            pass
                        title = getString("select_all", "Select all")
                        otherItem.addSubItem(plugin._select_all_id, R_tg.drawable.msg_select_between_solar, title)
                        try:
                            plugin._select_all_added_modes.add(hc)
                        except Exception:
                            pass
                    except Exception:
                        pass

            class _UT_InterceptSelectAllClick:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)

                @hook_filters(HookFilter.ArgumentNotNull(0))
                def before_hooked_method(self, param):
                    try:
                        plugin = self._plugin_ref()
                        if not plugin:
                            return
                        itemId = int(param.args[0])
                        if itemId != plugin._select_all_id:
                            return
                        menu = param.thisObject
                        actionBar = get_private_field(menu, "parentActionBar")
                        if actionBar is None:
                            return
                        fragment = get_private_field(actionBar, "parentFragment")
                        if fragment is None:
                            return
                        if fragment.getClass().getName() != "org.telegram.ui.DialogsActivity":
                            return
                        dlg = fragment

                        viewPages = get_private_field(dlg, "viewPages")
                        adapter = None
                        listView = None
                        if viewPages is not None:
                            try:
                                vp0 = viewPages[0]
                                adapter = get_private_field(vp0, "dialogsAdapter") or getattr(vp0, "dialogsAdapter", None)
                                listView = get_private_field(vp0, "listView") or getattr(vp0, "listView", None)
                            except Exception:
                                pass
                        if adapter is None or listView is None:
                            try:
                                GetListView = dlg.getClass().getDeclaredMethod("getListView")
                                GetListView.setAccessible(True)
                                listView = GetListView.invoke(dlg)
                                adapter = listView.getAdapter() if listView is not None else None
                            except Exception:
                                pass
                        selected = get_private_field(dlg, "selectedDialogs")
                        if adapter is None or listView is None or selected is None:
                            return

                        DialogsActivityCls2 = dlg.getClass()
                        ShowOrUpdate = None
                        methods = DialogsActivityCls2.getDeclaredMethods()
                        for m in methods:
                            try:
                                if m.getName() == "showOrUpdateActionMode" and len(m.getParameterTypes()) == 2:
                                    ShowOrUpdate = m
                                    break
                            except Exception:
                                pass
                        if ShowOrUpdate is None:
                            return
                        ShowOrUpdate.setAccessible(True)

                        LongClass = find_class("java.lang.Long")
                        DialogInterface = find_class("org.telegram.tgnet.TLRPC$Dialog")

                        state = {"index": 0}
                        state["count"] = adapter.getItemCount()
                        BATCH_SIZE = 24
                        MAX_LOAD_ATTEMPTS = 8
                        state["load_attempts"] = 0
                        initial_adapter = adapter

                        def step():
                            try:
                                if listView.getAdapter() != initial_adapter:
                                    return
                                actionBar2 = getattr(dlg, "actionBar", None)
                                actionMode2 = actionBar2.getActionMode() if actionBar2 is not None else None
                                if actionMode2 is None:
                                    return
                     
                                try:
                                    if not actionBar2.isActionModeShowed():
                                        return
                                except Exception:
                                    pass

                                done = False
                                for _ in range(BATCH_SIZE):
                                    i = state["index"]
                                    if i >= state.get("count", 0):
                                        def _attempt_load_more():
                                            try:
                                                if listView.getAdapter() != initial_adapter:
                                                    return
                                                actionBar3 = getattr(dlg, "actionBar", None)
                                                actionMode3 = actionBar3.getActionMode() if actionBar3 is not None else None
                                                if actionMode3 is None:
                                                    return
                                  
                                                try:
                                                    if not actionBar3.isActionModeShowed():
                                                        return
                                                except Exception:
                                                    pass
                                                try:
                                                    pos = max(0, state.get("count", 0) - 1)
                                                    listView.scrollToPosition(pos)
                                                except Exception:
                                                    pass
                                                def _check_new_count():
                                                    try:
                                                        new_count = adapter.getItemCount()
                                                        if new_count > state.get("count", 0):
                                                            state["count"] = new_count
                                                            state["load_attempts"] = 0
                                                            run_on_ui_thread(step)
                                                        else:
                                                            state["load_attempts"] = state.get("load_attempts", 0) + 1
                                                            if state["load_attempts"] < MAX_LOAD_ATTEMPTS:
                                                                run_on_ui_thread(_attempt_load_more, 200)
                                                            else:
                                                                try:
                                                                    update_counters = dlg.getClass().getDeclaredMethod("updateCounters", find_class("java.lang.Boolean").TYPE)
                                                                    update_counters.setAccessible(True)
                                                                    update_counters.invoke(dlg, True)
                                                                except Exception:
                                                                    pass
                                                    except Exception:
                                                        pass
                                                run_on_ui_thread(_check_new_count, 200)
                                            except Exception:
                                                pass
                                        _attempt_load_more()
                                        return
                                    try:
                                        item = adapter.getItem(i)
                                        state["index"] = i + 1
                                        if item is None:
                                            continue
                                        try:
                                            if not DialogInterface.isInstance(item):
                                                continue
                                        except Exception:
                                            if not str(item.getClass().getName()).startswith("org.telegram.tgnet.TLRPC$"):
                                                continue
                                        did = getattr(item, "id", None)
                                        if did is None:
                                            continue
                                        try:
                                            if selected.contains(LongClass.valueOf(did)):
                                                continue
                                        except Exception:
                                            try:
                                                if selected.contains(jlong(did)):
                                                    continue
                                            except Exception:
                                                pass
                                        holder = listView.findViewHolderForAdapterPosition(i)
                                        cellView = holder.itemView if holder is not None else None
                                        ShowOrUpdate.invoke(dlg, jlong(did), cellView)
                                    except Exception:
                                        pass

                                if done:
                                    try:
                                        update_counters = dlg.getClass().getDeclaredMethod("updateCounters", find_class("java.lang.Boolean").TYPE)
                                        update_counters.setAccessible(True)
                                        update_counters.invoke(dlg, True)
                                    except Exception:
                                        pass
                                else:
                                    run_on_ui_thread(step)
                            except Exception:
                                pass

                        run_on_ui_thread(step)
                    except Exception:
                        pass

            self.hook_method(CreateActionMode, _UT_AddSelectAllMenu(self))
            self.hook_method(OnItemClick, _UT_InterceptSelectAllClick(self), priority=10)
        except Exception as e:
            try:
                pass
            except Exception:
                pass

    def _perform_heavy_operations(self):
        try:
            start_time = time.time()
            timeout = 30
            
            if time.time() - start_time > timeout:
                return
                
            
            if time.time() - start_time > timeout:
                return
                
                    
        except Exception as e:
            pass





    def _recent_chats_fragment_get_data(self, account):
        try:
            if account in self._recent_chats_fragment_data:
                return self._recent_chats_fragment_data[account]
            raw = self.get_setting(f"recent_chats_fragment_data_{account}", "")
            if raw:
                self._recent_chats_fragment_data[account] = json.loads(base64.b64decode(raw).decode())
            else:
                self._recent_chats_fragment_data[account] = {"ids": [], "ts": {}}
        except Exception:
            self._recent_chats_fragment_data[account] = {"ids": [], "ts": {}}
        return self._recent_chats_fragment_data[account]

    def _recent_chats_fragment_save_data(self, account):
        try:
            if account not in self._recent_chats_fragment_data:
                return
            raw = base64.b64encode(json.dumps(self._recent_chats_fragment_data[account]).encode()).decode()
            self.set_setting(f"recent_chats_fragment_data_{account}", raw)
        except Exception:
            pass

    def _recent_chats_fragment_add_dialog(self, account, dialog_id):
        try:
            MAX_RECENT = 50
            data = self._recent_chats_fragment_get_data(account)
            ids = data.get("ids") or []
            if dialog_id in ids:
                ids.remove(dialog_id)
            ids.insert(0, dialog_id)
            ts = data.get("ts") or {}
            while len(ids) > MAX_RECENT:
                rem = ids.pop()
                ts.pop(str(rem), None)
            try:
                now = get_connections_manager().getCurrentTime()
            except Exception:
                now = int(time.time())
            ts[str(dialog_id)] = now
            data["ids"] = ids
            data["ts"] = ts
            self._recent_chats_fragment_data[account] = data
            self._recent_chats_fragment_save_data(account)
        except Exception:
            pass

    def _recent_chats_fragment_clear(self, account):
        try:
            self._recent_chats_fragment_data[account] = {"ids": [], "ts": {}}
            self._recent_chats_fragment_save_data(account)
        except Exception:
            pass

    def _recent_chats_fragment_fmt_time(self, ts):
        try:
            try:
                now = get_connections_manager().getCurrentTime()
            except Exception:
                now = int(time.time())
            diff = now - int(ts)
            if diff < 60:
                return "just now"
            if diff < 3600:
                return f"{diff//60}m ago"
            if diff < 86400:
                return f"{diff//3600}h ago"
            if diff < 604800:
                return f"{diff//86400}d ago"
            from java.util import Date
            from java.text import SimpleDateFormat
            return SimpleDateFormat("MMM d").format(Date(int(ts) * 1000))
        except Exception:
            return ""

    def _recent_chats_fragment_get_chat_type(self, dialog_id, account):
        try:
            TAB_ALL = 0
            TAB_CHANNELS = 1
            TAB_GROUPS = 2
            TAB_BOTS = 3
            TAB_USERS = 4
            if dialog_id < 0:
                chat = MessagesController.getInstance(account).getChat(-dialog_id)
                if chat:
                    if chat.broadcast:
                        return TAB_CHANNELS
                    return TAB_GROUPS
            else:
                user = MessagesController.getInstance(account).getUser(dialog_id)
                if user:
                    if user.bot:
                        return TAB_BOTS
                    return TAB_USERS
        except Exception:
            pass
        return 0

    def _recent_chats_fragment_make_cell(self, ctx, dialog_id, account, div):
        try:
            cell = jclass("org.telegram.ui.Cells.UserCell")(ctx, 6, 0, False)
            ts = self._recent_chats_fragment_get_data(account).get("ts", {}).get(str(dialog_id))
            status = f"last opened {self._recent_chats_fragment_fmt_time(ts)}" if ts else None
            obj = MessagesController.getInstance(account).getChat(-dialog_id) if dialog_id < 0 else MessagesController.getInstance(account).getUser(dialog_id)
            if not obj:
                return None
            cell.setData(obj, None, status, 0, div)
            plugin = self

            def click(v):
                try:
                    frag = plugin._recent_chats_fragment
                    if not frag:
                        return
                    plugin._recent_chats_fragment_visible = False
                    plugin._recent_chats_fragment = None
                    b = Bundle()
                    if dialog_id < 0:
                        chat_id = -dialog_id
                        b.putLong("chat_id", chat_id)
                        if MessagesController.getInstance(account).isForum(chat_id):
                            frag.presentFragment(TopicsFragment(b), True)
                        else:
                            frag.presentFragment(ChatActivity(b), True)
                    else:
                        b.putLong("user_id", dialog_id)
                        frag.presentFragment(ChatActivity(b), True)
                except Exception:
                    pass

            cell.setOnClickListener(OnClickListener(click))
            cell.setBackground(Theme.getSelectorDrawable(False))
            return cell
        except Exception:
            return None

    def _recent_chats_fragment_make_delegate(self, account):
        plugin = self
        TAB_ALL = 0
        TAB_CHANNELS = 1
        TAB_GROUPS = 2
        TAB_BOTS = 3
        TAB_USERS = 4
        MENU_CLEAR = 1

        class Delegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):
            def __init__(s):
                super().__init__()
                s.acc = account
                s.box = None
                s.scroll_view = None
                s.tabs_view = None
                s.current_tab = TAB_ALL
                s.root = None

            def getTitle(s):
                return getString("recent_chats", "Recent Chats")

            def beforeCreateView(s):
                return None

            def afterCreateView(s, v):
                try:
                    if plugin._recent_chats_fragment:
                        m = plugin._recent_chats_fragment.getActionBarMenu()
                        if m:
                            m.addItem(MENU_CLEAR, R_tg.drawable.msg_reset_solar)
                    ctx = plugin._recent_chats_fragment.getParentActivity() if plugin._recent_chats_fragment else None
                    if not ctx:
                        return None

                    s.root = FrameLayout(ctx)
                    s.root.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))

                    main_layout = LinearLayout(ctx)
                    main_layout.setOrientation(LinearLayout.VERTICAL)
                    main_layout.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))

                    s.tabs_view = s._create_tabs(ctx)
                    if s.tabs_view:
                        main_layout.addView(s.tabs_view, LayoutHelper.createLinear(-1, 44))

                    s.box = LinearLayout(ctx)
                    s.box.setOrientation(LinearLayout.VERTICAL)
                    s.box.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))

                    s.scroll_view = ScrollView(ctx)
                    s.scroll_view.addView(s.box)
                    s.scroll_view.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))

                    main_layout.addView(s.scroll_view, LayoutHelper.createLinear(-1, 0, 1.0))
                    s.root.addView(main_layout, LayoutHelper.createFrame(-1, -1))

                    s._fill(ctx)
                    return s.root
                except Exception:
                    return None

            def _create_tabs(s, ctx):
                try:
                    ScrollSlidingTextTabStrip = jclass("org.telegram.ui.Components.ScrollSlidingTextTabStrip")
                    tabs_view = ScrollSlidingTextTabStrip(ctx, None)
                    tabs_view.setBackgroundColor(Theme.getColor(Theme.key_actionBarDefault))
                    tabs_view.addTextTab(TAB_ALL, "All")
                    tabs_view.addTextTab(TAB_CHANNELS, "Channels")
                    tabs_view.addTextTab(TAB_GROUPS, "Groups")
                    tabs_view.addTextTab(TAB_BOTS, "Bots")
                    tabs_view.addTextTab(TAB_USERS, "Users")

                    delegate_ref = s
                    TabStripDelegate = jclass("org.telegram.ui.Components.ScrollSlidingTextTabStrip$ScrollSlidingTabStripDelegate")

                    class TabsDelegate(dynamic_proxy(TabStripDelegate)):
                        def onPageSelected(self, page, forward):
                            delegate_ref.current_tab = page
                            ctx2 = plugin._recent_chats_fragment.getParentActivity() if plugin._recent_chats_fragment else None
                            if ctx2:
                                delegate_ref._fill(ctx2)

                        def onPageScrolled(self, progress):
                            pass

                        def onSamePageSelected(self):
                            pass

                        def showOptions(self, page, view):
                            return False

                        def canReorder(self, page):
                            return False

                    tabs_view.setDelegate(TabsDelegate())
                    tabs_view.finishAddingTabs()
                    return tabs_view
                except Exception:
                    return None

            def _fill(s, ctx):
                try:
                    if not s.box:
                        return
                    s.box.removeAllViews()
                    ids = plugin._recent_chats_fragment_get_data(s.acc).get("ids", [])
                    if s.current_tab != TAB_ALL:
                        ids = [did for did in ids if plugin._recent_chats_fragment_get_chat_type(did, s.acc) == s.current_tab]
                    for i, did in enumerate(ids):
                        c = plugin._recent_chats_fragment_make_cell(ctx, did, s.acc, i < len(ids) - 1)
                        if c:
                            s.box.addView(c)
                    if not ids:
                        t = TextView(ctx)
                        tab_names = {TAB_ALL: "", TAB_CHANNELS: "channel ", TAB_GROUPS: "group ", TAB_BOTS: "bot ", TAB_USERS: "user "}
                        t.setText(f"No {tab_names.get(s.current_tab, '')}chats")
                        t.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                        t.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                        t.setGravity(Gravity.CENTER)
                        s.box.addView(t, LayoutHelper.createLinear(-1, 200, Gravity.CENTER))
                except Exception:
                    pass

            def onFragmentCreate(s):
                pass

            def onFragmentDestroy(s):
                try:
                    if s.box:
                        s.box.removeAllViews()
                        if s.box.getParent():
                            s.box.getParent().removeView(s.box)
                        s.box = None
                    if s.scroll_view:
                        s.scroll_view.removeAllViews()
                        if s.scroll_view.getParent():
                            s.scroll_view.getParent().removeView(s.scroll_view)
                        s.scroll_view = None
                    if s.tabs_view:
                        if s.tabs_view.getParent():
                            s.tabs_view.getParent().removeView(s.tabs_view)
                        s.tabs_view = None
                    if s.root:
                        s.root.removeAllViews()
                        s.root = None
                except Exception:
                    pass
                plugin._recent_chats_fragment = None
                plugin._recent_chats_fragment_visible = False

            def onBackPressed(s):
                plugin._recent_chats_fragment_visible = False
                plugin._recent_chats_fragment = None
                return None

            def fillItems(s, i, a):
                pass

            def onClick(s, i, v, p, x, y):
                pass

            def onLongClick(s, i, v, p, x, y):
                return False

            def onMenuItemClick(s, mid):
                if mid == MENU_CLEAR and plugin._recent_chats_fragment:
                    ctx = plugin._recent_chats_fragment.getParentActivity()
                    if not ctx:
                        return
                    b = AlertDialogBuilder(ctx)
                    b.set_title(getString("clear_recent_chats", "Clear Recent Chats"))
                    b.set_message(getString("clear_recent_chats_confirm", "Are you sure you want to clear all recent chats?"))

                    def yes(d, w):
                        plugin._recent_chats_fragment_clear(s.acc)
                        if s.box:
                            s._fill(ctx)
                        d.dismiss()

                    def no(d, w):
                        d.dismiss()

                    b.set_positive_button(getString("clear", "Clear"), yes)
                    b.set_negative_button(getString("cancel", "Cancel"), no)
                    b.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
                    b.show()

        return Delegate()

    def _recent_chats_fragment_open(self):
        if self._recent_chats_fragment_visible:
            return

        def run():
            try:
                frag = get_last_fragment()
                if not frag:
                    return
                acc = UserConfig.selectedAccount
                self._recent_chats_fragment = UniversalFragment(self._recent_chats_fragment_make_delegate(acc))
                self._recent_chats_fragment_visible = True
                frag.presentFragment(self._recent_chats_fragment)
            except Exception:
                self._recent_chats_fragment_visible = False

        run_on_ui_thread(run)

    def _hook_recent_chats_fragment(self):
        try:
            if not self.hook_recent_chats_fragment_drawer_reset_ref:
                DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
                resetItems_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("resetItems")
                resetItems_method.setAccessible(True)

                class DrawerResetHook:
                    def __init__(self, plugin):
                        self._plugin_ref = weakref.ref(plugin)

                    @hook_filters(HookFilter.Condition("param.thisObject != null"))
                    def after_hooked_method(self, param):
                        try:
                            plugin = self._plugin_ref()
                            if not plugin or not plugin.get_setting("recent_chats_fragment", False):
                                return
                            adapter = param.thisObject
                            items_field = adapter.getClass().getDeclaredField("items")
                            items_field.setAccessible(True)
                            items = items_field.get(adapter)
                            if items is None:
                                return
                            current_account = UserConfig.selectedAccount
                            if not UserConfig.getInstance(current_account).isClientActivated():
                                return
                            Item = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter$Item")
                            text = getString("recent_chats", "Recent Chats")
                            icon = R_tg.drawable.msg_topics_solar
                            items.add(0, Item(1004, text, icon))
                        except Exception:
                            pass

                self.hook_recent_chats_fragment_drawer_reset_ref = self.hook_method(resetItems_method, DrawerResetHook(self))

            if not self.hook_recent_chats_fragment_drawer_click_ref:
                DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
                click_method = DrawerLayoutAdapter.getClass().getDeclaredMethod(
                    "click",
                    jclass("android.view.View"),
                    jclass("java.lang.Integer").TYPE
                )
                click_method.setAccessible(True)

                class DrawerClickHook:
                    def __init__(self, plugin):
                        self._plugin_ref = weakref.ref(plugin)

                    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(1))
                    def before_hooked_method(self, param):
                        try:
                            plugin = self._plugin_ref()
                            if not plugin or not plugin.get_setting("recent_chats_fragment", False):
                                return
                            adapter = param.thisObject
                            position = int(param.args[1])
                            getId_method = adapter.getClass().getDeclaredMethod("getId", jclass("java.lang.Integer").TYPE)
                            getId_method.setAccessible(True)
                            from java.lang import Integer
                            item_id = getId_method.invoke(adapter, Integer(position))
                            if int(item_id) == 1004:
                                if plugin._recent_chats_fragment_visible:
                                    param.setResult(True)
                                    return
                                plugin._recent_chats_fragment_open()
                                param.setResult(True)
                        except Exception:
                            pass

                self.hook_recent_chats_fragment_drawer_click_ref = self.hook_method(click_method, DrawerClickHook(self))

            try:
                if not self.hook_recent_chats_fragment_drawer_cell_ref:
                    DrawerCell = find_class("org.telegram.ui.Cells.DrawerUserCell")
                    if DrawerCell:
                        setText_method = DrawerCell.getClass().getDeclaredMethod("setText", jclass("java.lang.CharSequence"))
                        setText_method.setAccessible(True)

                        class DrawerCellHook:
                            def __init__(self, plugin):
                                self._plugin_ref = weakref.ref(plugin)

                            def before_hooked_method(self, param):
                                try:
                                    plugin = self._plugin_ref()
                                    if not plugin or not plugin.get_setting("recent_chats_fragment", False):
                                        return
                                except Exception:
                                    pass

                        self.hook_recent_chats_fragment_drawer_cell_ref = self.hook_method(setText_method, DrawerCellHook(self))
            except Exception:
                pass

            if not self.hook_recent_chats_fragment_activity_resume_refs:
                self.hook_recent_chats_fragment_activity_resume_refs = []

                def _hook_on_resume(class_name, getter):
                    try:
                        C = find_class(class_name)
                        if not C:
                            return
                        m = C.getClass().getDeclaredMethod("onResume")
                        m.setAccessible(True)

                        class ResumeHook:
                            def __init__(self, plugin):
                                self._plugin_ref = weakref.ref(plugin)
                                self._getter = getter

                            def after_hooked_method(self, param):
                                try:
                                    plugin = self._plugin_ref()
                                    if not plugin or not plugin.get_setting("recent_chats_fragment", False):
                                        return
                                    obj = param.thisObject
                                    if not obj:
                                        return
                                    plugin._recent_chats_fragment_add_dialog(obj.getCurrentAccount(), self._getter(obj))
                                except Exception:
                                    pass

                        self.hook_recent_chats_fragment_activity_resume_refs.append(self.hook_method(m, ResumeHook(self)))
                    except Exception:
                        pass

                _hook_on_resume("org.telegram.ui.ChatActivity", lambda a: a.getDialogId())
                _hook_on_resume("org.telegram.ui.ProfileActivity", lambda a: a.getDialogId())
                _hook_on_resume("org.telegram.ui.TopicsFragment", lambda a: -a.getChatId())

        except Exception:
            pass



    def _setup_settings_header_hook(self):
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            if not PSA:
                return
            method = PSA.getClass().getDeclaredMethod("fillItems", find_class("java.util.ArrayList"), find_class("org.telegram.ui.Components.UniversalAdapter"))
            method.setAccessible(True)
            self.hook_settings_header_ref = self.hook_method(method, UiTweaksSettingsHeaderHook(self))
        except:
            pass

    def _create_settings_header(self, context):
        try:
            from android.widget import FrameLayout, TextView
            from android.view import Gravity
            from android.util import TypedValue
            from org.telegram.messenger import AndroidUtilities, MediaDataController, ImageLocation
            from org.telegram.ui.ActionBar import Theme
            from org.telegram.ui.Components import LayoutHelper, BackupImageView
            
            container = FrameLayout(context)
            
            if self.get_setting("enable_header_particles", True):
                try:
                    from org.telegram.ui.Components.Premium import StarParticlesView

                    particlesView = StarParticlesView(context)
                    particlesView.setClipWithGradient()
                    particlesView.drawable.colorKey = Theme.key_premiumStarGradient2
                    particlesView.drawable.isCircle = True
                    particlesView.drawable.centerOffsetY = AndroidUtilities.dp(0)
                    particlesView.drawable.minLifeTime = 2000
                    particlesView.drawable.randLifeTime = 3000
                    particlesView.drawable.useRotate = False
                    particlesView.drawable.updateColors()
                    container.addView(particlesView, LayoutHelper.createFrame(-1, 220, Gravity.CENTER_HORIZONTAL | Gravity.TOP, 0, 0, 0, 0))

                    run_on_ui_thread(lambda: particlesView.flingParticles(360), 200)
                except: pass
            
            imageView = BackupImageView(context)
            imageView.setRoundRadius(AndroidUtilities.dp(54))
            
            def try_load_sticker(img):
                import random
                is_random = self.get_setting("random_header_sticker", False)
                
                if is_random:
                    pack_name = "MyLittleMsMizukiPt1"
                else:
                    pack_name = "luvztroyIcons"
                
                ss = MediaDataController.getInstance(0).getStickerSetByName(pack_name) or MediaDataController.getInstance(0).getStickerSetByEmojiOrName(pack_name)
                if ss and ss.documents and ss.documents.size() > 0:
                    if is_random:
                        sticker_index = random.randint(0, ss.documents.size() - 1)
                    else:
                        sticker_index = min(13, ss.documents.size() - 1)
                    img.setImage(ImageLocation.getForDocument(ss.documents.get(sticker_index)), "108_108", None, None, 0, 1)
                    return True
                return False
            
            is_random_mode = self.get_setting("random_header_sticker", False)
            if not try_load_sticker(imageView):
                pack_to_load = "MyLittleMsMizukiPt1" if is_random_mode else "luvztroyIcons"
                MediaDataController.getInstance(0).loadStickersByEmojiOrName(pack_to_load, False, False)
                run_on_ui_thread(lambda: try_load_sticker(imageView), 1500)
            
            container.addView(imageView, LayoutHelper.createFrame(108, 108, Gravity.CENTER | Gravity.TOP, 0, 20, 0, 0))
            
            title = TextView(context)
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22)
            title.setText(f"UiTweaks {__version__}")
            title.setSingleLine(True)
            title.setGravity(Gravity.CENTER)
            container.addView(title, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 50, 145, 50, 0))
            
            subtitle = TextView(context)
            subtitle.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            subtitle.setText("An experimental plugin for exteraGram based on python!")
            subtitle.setGravity(Gravity.CENTER)
            container.addView(subtitle, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 60, 180, 60, 27))
            
            try:
                from android_utils import OnLongClickListener, OnClickListener
                from java import dynamic_proxy
                from android.view import View, MotionEvent
                
                plugin_ref = self
                
                def on_sticker_long_click(view):
                    plugin_ref._perform_haptic(view)
                    current = plugin_ref.get_setting("random_header_sticker", False)
                    plugin_ref.set_setting("random_header_sticker", not current)
                    try_load_sticker(imageView)
                    return True
                
                def on_sticker_click(view):
                    if plugin_ref.get_setting("random_header_sticker", False):
                        try_load_sticker(imageView)
                
                class BounceTouchListener(dynamic_proxy(View.OnTouchListener)):
                    def onTouch(self, v, event):
                        action = event.getAction()
                        if action == MotionEvent.ACTION_DOWN:
                            v.animate().scaleX(0.9).scaleY(0.9).setDuration(100).start()
                        elif action == MotionEvent.ACTION_UP or action == MotionEvent.ACTION_CANCEL:
                            v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).start()
                        return False
                
                imageView.setOnTouchListener(BounceTouchListener())
                imageView.setOnLongClickListener(OnLongClickListener(on_sticker_long_click))
                imageView.setOnClickListener(OnClickListener(on_sticker_click))
            except: pass
            
            return container
        except:
            return None

    def _create_general_settings(self):
        return [
            Header(text=getString("security_and_privacy", "Security & Privacy")),
            self.Quanta_switch("confirm_deeplinks", getString("confirm_deeplinks", "Confirm Telegram Deep Links"), False, lambda v: self._apply_hooks(), link_alias="confirm_deeplinks"),
            self.Quanta_switch("confirm_ayugram_deeplinks", getString("confirm_ayugram_deeplinks", "Confirm AyuGram Deep Links"), False, lambda v: self._apply_hooks(), link_alias="confirm_ayugram_deeplinks"),
            self.Quanta_switch("disable_auto_web_login", getString("disable_auto_web_login", "Disable Auto Web Login"), False, lambda v: self._apply_hooks(), link_alias="disable_auto_web_login"),
            self.Quanta_switch("custom_privacy", getString("custom_privacy", "Custom Privacy"), False, lambda v: self._apply_hooks(), link_alias="custom_privacy"),

            self.Quanta_switch("hide_phone_number", getString("hide_phone_number", "Hide Phone Number in Profiles"), False, lambda v: self._apply_hooks(), link_alias="hide_phone_number"),
            Divider(text=getString("hide_phone_number_info", "This will hide the recipient's phone number from their profile.")),
            
            Header(text=getString("profile_and_chats", "Profile & Chats")),
            self.Quanta_switch("hide_birthday_alert", getString("hide_birthday_alert", "Hide Birthday Alert"), False, lambda v: self._apply_hooks(), link_alias="hide_birthday_alert"),
            self.Quanta_switch("prefer_common_groups_tab", getString("prefer_common_groups_tab", "Prefer Common Groups Tab"), False, lambda v: self._apply_hooks(), link_alias="prefer_common_groups_tab"),
            Divider(text=getString("prefer_common_groups_tab_info", "Automatically selects the Groups tab instead of Gifts tab in user profiles when both are available.")),
            
            
            Header(text=getString("navigation_controls", "Navigation Controls")),
            ExpandableSwitch(
                key="navigation_controls_enabled",
                text=getString("navigation_controls_switch", "Swipe Gesture Controls"),
                collapsed=True,
                children=[
                    Switch(key="prevent_swipe_while_editing", text=getString("prevent_swipe_while_editing", "While Editing"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="prevent_swipe_while_typing", text=getString("prevent_swipe_while_typing", "While Typing"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="disable_article_viewer_swipe", text=getString("disable_article_viewer_swipe", "Article Viewer"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="prevent_webapp_swipe_down", text=getString("prevent_webapp_swipe_down", "Webapp Bots"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="disable_topics_swipe", text=getString("disable_topics_swipe", "Topics"), default=False, on_change=lambda v: self._apply_hooks()),
                ],
                link_alias="navigation_controls_enabled"
            ),
            Divider(text=getString("navigation_controls_info", "This will prevent the Telegram navigation gestures to work from these scenarios.")),
            
            Header(text=getString("quick_access", "Quick Access")),
            self.Quanta_switch("fab_settings_shortcut", getString("fab_settings_shortcut", "FAB Shortcut"), False, lambda v: self._apply_hooks(), link_alias="fab_settings_shortcut"),
            self.Quanta_selector("fab_action_selector", getString("fab_action_selector", "Action"), [getString("fab_action_uitweaks_settings", "UiTweaks Settings"), getString("fab_action_archived_chats", "Archived Chats")], 0, lambda v: self._apply_hooks(), link_alias="fab_action_selector") if self.get_setting("fab_settings_shortcut", False) else None,
            self.Quanta_switch("quick_access_gift_market", getString("quick_access_gift_market", "Quick Access to Gift Market"), False, lambda v: self._apply_hooks(), link_alias="quick_access_gift_market"),
            self.Quanta_switch("recent_chats_fragment", getString("recent_chats_fragment", "Recent Chats Manager"), False, lambda v: self._apply_hooks(), link_alias="recent_chats_fragment"),

            Header(text=getString("general", "General")),
            self.Quanta_switch("enable_select_all_media", getString("enable_select_all_media", "Select All Media Button"), False, lambda v: self._apply_hooks(), link_alias="enable_select_all_media"),
            self.Quanta_switch("enable_sleep_timer", getString("sleep_timer", "Music Sleep Timer"), False, lambda v: self._apply_hooks(), link_alias="enable_sleep_timer"),
            self.Quanta_switch("disable_emoji_suggestions", getString("disable_emoji_suggestions", "Disable Emoji Suggestions"), False, lambda v: self._apply_hooks(), link_alias="disable_emoji_suggestions"),
            self.Quanta_switch("remove_greeting_sticker", getString("remove_greeting_sticker", "Remove Greeting Sticker"), False, lambda v: self._apply_hooks(), link_alias="remove_greeting_sticker"),
            self.Quanta_switch("remove_https_from_links", getString("remove_https_from_links", "Remove HTTPS From Links"), False, lambda v: self._apply_hooks(), link_alias="remove_https_from_links"),
            self.Quanta_switch("show_owner_channels", getString("show_owner_channels", "Owned channels/groups like TDesktop"), False, lambda v: self._apply_hooks(), link_alias="show_owner_channels"),
            self.Quanta_switch("remove_from_folders_on_leave", getString("remove_from_folders_on_leave", "Remove chat from folders on leave"), False, lambda v: self._apply_hooks(), link_alias="remove_from_folders_on_leave"),
            self.Quanta_switch("enable_music_speed_control", getString("enable_music_speed_control", "Music Speed Control"), False, lambda v: self._apply_hooks(), link_alias="enable_music_speed_control"),
            Divider(text=getString("music_speed_control_info", "Enable playback speed control for all music files regardless of duration.")) if self.get_setting("enable_music_speed_control", False) else None,

        ]

    def _create_miscellaneous_settings(self):
        return [ 
            Header(text=getString("chats", "Chats")),
            self.Quanta_switch("enable_message_preview_enhancement", getString("message_preview_send_button", "Share media from link preview"), False, lambda v: self._apply_hooks(), link_alias="enable_message_preview_enhancement"),
            self.Quanta_switch("enable_share_sheet_folders", getString("add_folders_to_share_sheet", "Folders in direct share sheet"), False, lambda v: self._apply_hooks(), link_alias="enable_share_sheet_folders"),
            self.Quanta_switch("enable_sender_select_enhancement", getString("sender_select_improvements", "Send message as menu improvements"), False, lambda v: self._apply_hooks(), link_alias="enable_sender_select_enhancement"),
            Divider(text=getString("sender_select_subtext", "Show personal account in \"send message as\" menu where you are the owner of the group")),
            self.Quanta_switch("enable_join_request_direct_profile", getString("join_request_direct_profile", "Open user profile directly from join requests"), False, lambda v: self._apply_hooks(), link_alias="enable_join_request_direct_profile"),

            Header(text=getString("chat_list", "Chat List")),
            self.Quanta_switch("enable_select_all_dialogs", getString("select_all_dialogs_menu", "Select All Chats"), False, lambda v: self._apply_hooks(), link_alias="enable_select_all_dialogs"),
            self.Quanta_switch("enable_add_to_folder_all_tabs", getString("add_to_folder_all_tabs", "Add to Folder in All Tabs"), False, lambda v: self._apply_hooks(), link_alias="enable_add_to_folder_all_tabs"),
            
            Header(text=getString("account_and_display", "Account & Display")),
            self.Quanta_switch("enable_non_clickable_preview", getString("non_clickable_preview", "Non-Clickable Chat Preview"), False, lambda v: self._apply_hooks(), link_alias="enable_non_clickable_preview"),
            self.Quanta_switch("enable_account_visibility", getString("account_visibility", "Account Visibility"), False, lambda v: self._apply_hooks(), link_alias="enable_account_visibility"),
            Divider(text=getString("account_visibility_subtext", "Hide/show accounts by long-pressing theme button")),
            
            Header(text=getString("advanced", "Advanced")),
            self.Quanta_switch("enable_ai_role_limit", getString("ai_role_limit", "AI Role Limit Increaser"), False, lambda v: self._apply_hooks(), link_alias="enable_ai_role_limit"),
            self.Quanta_switch("enable_search_by_user_id", getString("search_by_user_id", "Search by User ID"), False, lambda v: self._apply_hooks(), link_alias="enable_search_by_user_id"),
        ]

    def _create_appearance_settings(self):
        settings = []
        
        settings.extend([
            Header(text=getString("hide_elements", "Hide Elements")),
            self.Quanta_switch("hide_bot_open", getString("hide_bot_open", "Bot 'Open' button in chat list"), False, lambda v: self._apply_hooks(), link_alias="hide_bot_open"),
            self.Quanta_switch("hide_archived_chats", getString("hide_archived_chats", "Hide Archived Chats"), False, lambda v: self._apply_hooks(), link_alias="hide_archived_chats"),
            self.Quanta_switch("hide_archived_from_drawer", getString("hide_archived_from_drawer", "Hide from drawer"), False, lambda v: self._on_hide_archived_from_drawer_change(v), link_alias="hide_archived_from_drawer") if self.get_setting("hide_archived_chats", False) else None,
            Divider(text=getString("hide_archived_chats_info", "This will remove archived chats cell from the chat list by filtering them out of the dialogs query.")),
        ])

        settings.extend([
            Header(text=getString("profile", "Profile")),
            self.Quanta_switch("enable_contact_status_in_profile", getString("contact_status_in_profile", "Mutual Contact in Profile"), False, lambda v: self._apply_hooks(), link_alias="enable_contact_status_in_profile"),
            self.Quanta_switch("enable_unify_username_behavior", getString("unify_username_behavior", "Unify Username Behavior"), False, lambda v: self._apply_hooks(), link_alias="enable_unify_username_behavior"),
        ])
        
        settings.extend([
            Header(text=getString("action_bar", "Action Bar")),
            self.Quanta_switch("always_show_download_manager", getString("always_show_download_manager", "Always Show Download Manager"), False, lambda v: self._apply_hooks(), link_alias="always_show_download_manager"),
            self.Quanta_switch("always_show_proxy_button", getString("always_show_proxy_button", "Always Show Proxy Button"), False, lambda v: self._apply_hooks(), link_alias="always_show_proxy_button"),
            Divider(text=getString("menu_visibility_info", "This will force the buttons to always show in the action bar.")),
        ])
        
        settings.extend([
            Header(text=getString("Indicators", "Indicators")),
            self.Quanta_switch("unread_badge_on_back_button", getString("unread_badge_on_back_button", "Unread Badge on Back Button"), False, lambda v: self._apply_hooks(), link_alias="unread_badge_on_back_button"),
        ])

        
        settings.extend([
            Header(text=getString("manage_folders", "Manage Folders")),
            self.Quanta_switch("unread_chat_count", getString("unread_chat_count", "Show Unread Chat Count"), False, lambda v: self._apply_hooks(), link_alias="unread_chat_count"),
            self.Quanta_switch("unread_message_count", getString("unread_message_count", "Show Unread Message Count"), False, lambda v: self._apply_hooks(), link_alias="unread_message_count"),
            self.Quanta_switch("exclude_archived_from_count", getString("exclude_archived_from_count", "Exclude Archived Chats from Count"), False, lambda v: self._apply_hooks(), link_alias="exclude_archived_from_count"),
            Divider(text=getString("unread_count_info", "Adjust how unread counters behave in folders. When both are enabled, only non-muted chats are counted.")),
            self.Quanta_switch("hidefolders_enabled", getString("hide_folders", "Hide Folders"), False, lambda v: self._toggle_hide_folders(v), link_alias="hide_folders"),
            self.Quanta_text(text=getString("select_folders", "Select Folders"), on_click=lambda v: self._show_folder_selector(), link_alias="select_folders") if self.get_setting("hidefolders_enabled", False) else None,
            Divider(text=getString("hide_folders_info", "Hide specific folders from the folder list. Select which folders to hide.")) if self.get_setting("hidefolders_enabled", False) else None,
        ])

        return settings

    def _create_chats_settings(self):
        settings = []
        
        settings.extend([
            Header(text=getString("input_field", "Input Field")),
            self.Quanta_switch("hide_bot_button", getString("hide_bot_button", "Hide Bot Button in Input Field"), False, lambda v: self._apply_hooks(), link_alias="hide_bot_button"),
            self.Quanta_switch("typing_instead_sticker", getString("typing_instead_sticker", "Typing Instead of Choosing Sticker"), False, lambda v: self._apply_hooks(), link_alias="typing_instead_sticker"),
            self.Quanta_switch("enable_code_formatting", getString("code_formatting_menu", "Code & Mention Formatting"), False, lambda v: self._apply_hooks(), link_alias="enable_code_formatting"),
            self.Quanta_switch("always_visible_schedule_button", getString("always_visible_schedule_button", "Always Visible Schedule Button"), False, lambda v: self._apply_hooks(), link_alias="always_visible_schedule_button"),
        ])
        
        settings.extend([
            Header(text=getString("message_reactions", "Message Reactions")),
            ExpandableSwitch(
                key="hide_star_reaction",
                text=getString("hide_star_reaction", "Hide Star Reaction"),
                collapsed=True,
                children=[
                    Switch(key="star_reaction_hide_menu", text=getString("item_reaction_menu", "Reaction Menu"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="star_reaction_hide_cells", text=getString("item_message_cells", "Message Cells"), default=False, on_change=lambda v: self._apply_hooks()),
                ],
                link_alias="hide_star_reaction"
            ),
            self.Quanta_text(text=getString("pinned_reactions", "Pinned Reactions"),on_click=lambda v: self._open_pinned_reactions_settings_ui(),link_alias="pinned_reactions"),
        ])
        
        settings.extend([
            Header(text=getString("message_actions", "Message Actions")),
            ExpandableSwitch(
                key="enable_confirmation_settings",
                text=getString("enable_confirmation_settings", "Confirmation Settings"),
                collapsed=True,
                children=[
                    Switch(key="confirm_stickers", text=getString("item_stickers", "Stickers"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_voice", text=getString("item_voice_messages", "Voice Messages"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_commands", text=getString("item_bot_commands", "Bot Commands"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_round_video", text=getString("item_video_messages", "Video Messages"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_video_file", text=getString("item_video_files", "Video Files"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_photo", text=getString("item_photos", "Photos"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_document", text=getString("item_documents", "Documents"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_gif", text=getString("item_gifs", "GIFs"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_forward", text=getString("item_forward", "Forward"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_join_chat", text=getString("item_join_chat", "Join Chat"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="confirm_external_links", text=getString("item_external_links", "External Links"), default=False, on_change=lambda v: self._apply_hooks()),
                ],
                link_alias="enable_confirmation_settings"
            ),
            self.Quanta_switch("enable_reply_private_chat", getString("enable_reply_private_chat", "Enable Reply in Private Chat"), False, lambda v: self._update_reply_private_chat_menu_item(), link_alias="enable_reply_private_chat"),

            self.Quanta_switch("send_comments_after_forward", getString("send_comments_after_forward", "Send Comments After Forward"), False, lambda v: self._apply_hooks(), link_alias="send_comments_after_forward"),
            self.Quanta_switch("enable_no_quote_forward", getString("enable_no_quote_forward", "Enable No-Quote Forward"), False, lambda v: self._update_no_quote_forward_menu_item(), link_alias="enable_no_quote_forward"),
            self.Quanta_switch("enable_message_repeat", getString("enable_message_repeat", "Enable Message Repeat"), False, lambda v: self._update_message_repeat_menu_item(), link_alias="enable_message_repeat"),
            Selector(key="swipe_action", text=getString("swipe_action", "Message Swipe Action"), default=0, items=[getString("swipe_reply", "Reply"), getString("swipe_save", "Save"), getString("swipe_translate", "Translate"), getString("swipe_direct_share", "Direct Share")]),
            Selector(key="manual_translation_behavior", text=getString("manual_translation_behavior", "Manual Translation Behavior"), default=0, items=[getString("translation_popup", "Popup"), getString("translation_in_message", "In Message")], on_change=lambda v: self._apply_hooks()),
            self.Quanta_switch("enable_edit_file_name", getString("enable_edit_file_name", "Edit File Name"), False, lambda v: self._apply_hooks(), link_alias="enable_edit_file_name"),
            self.Quanta_switch("enable_delete_with_duration", getString("enable_delete_with_duration", "Delete with Duration Selection"), False, lambda v: self._apply_delete_with_duration_hooks(), link_alias="enable_delete_with_duration"),
            Divider(text=getString("delete_with_duration_info", "Adds duration selection when banning/restricting users after deleting their messages.")) if self.get_setting("enable_delete_with_duration", False) else None,
        ])
        
        settings.extend([
            Header(text=getString("media_playback", "Media Playback")),
            ExpandableSwitch(
                key="dont_auto_play_enabled",
                text=getString("dont_auto_play_enabled", "Don't Auto Play Next"),
                collapsed=True,
                children=[
                    Switch(key="dont_auto_play_next_voice", text=getString("dont_auto_play_voice", "Voice Messages"), default=False, on_change=lambda v: self._apply_hooks()),
                    Switch(key="dont_auto_play_next_video", text=getString("dont_auto_play_video", "Video Messages"), default=False, on_change=lambda v: self._apply_hooks()),
                ],
                link_alias="dont_auto_play_enabled"
            ),
            Divider(text=getString("dont_auto_play_info", "Prevents automatic playback of the next voice or video message in a chat, giving you control over when media plays.")),
            self.Quanta_switch("enable_adaptive_audio_length", getString("enable_adaptive_audio_length", "Adaptive Audio Message Length"), False, lambda v: self._apply_hooks(), link_alias="enable_adaptive_audio_length"),
            Divider(text=getString("adaptive_audio_length_info", "The audio message bubble length will depend on the recording duration and automatically adjust to the screen width.")) if self.get_setting("enable_adaptive_audio_length", False) else None,
        ])
        
        settings.extend([
            Header(text=getString("general", "General")),
            self.Quanta_switch("enable_goto_message", getString("enable_goto_message", "Search by Message ID"), False, lambda v: self._apply_hooks(), link_alias="enable_goto_message"),
            self.Quanta_switch("hide_via_bot", getString("hide_via_bot", "Hide 'Via Bot' caption"), False, lambda v: self._apply_hooks(), link_alias="hide_via_bot"),
            self.Quanta_switch("enable_gif_spoiler", getString("gif_spoiler_caption", "GIF Spoiler & Caption"), False, lambda v: self._apply_hooks(), link_alias="enable_gif_spoiler"),
            self.Quanta_switch("enable_ai_summarize", getString("enable_ai_summarize", "Summarize Chat"), False, lambda v: self._apply_hooks(), link_alias="enable_ai_summarize"),
            self.Quanta_switch("enable_search_filter", getString("enable_search_filter", "Search Filter"), False, lambda v: self._apply_hooks(), link_alias="enable_search_filter"),
            self.Quanta_switch("enable_old_forward", getString("enable_old_forward", "Classic Forward Sheet"), False, lambda v: self._handle_forward_mode_change("enable_old_forward", v), link_alias="enable_old_forward"),
            self.Quanta_switch("enable_share_alert_forward", getString("enable_share_alert_forward", "ShareAlert for All Forwards"), False, lambda v: self._handle_forward_mode_change("enable_share_alert_forward", v), link_alias="enable_share_alert_forward"),
            self.Quanta_switch("enable_bookmark_chat", getString("enable_bookmark_chat", "Bookmark Chat"), False, lambda v: self._apply_hooks(), link_alias="enable_bookmark_chat"),
            self.Quanta_switch("disable_link_preview", getString("disable_link_preview", "Disable Link Preview"), False, lambda v: self._apply_hooks(), link_alias="disable_link_preview"),
            EditText(key="disable_link_preview_exclude_pattern", hint=getString("disable_link_preview_pattern_hint", "Regex pattern to exclude"), default="", max_length=500, multiline=True) if self.get_setting("disable_link_preview", False) else None,
            Divider(text=getString("disable_link_preview_info", "You can exclude links that match the regex pattern. Use regex101.com to check your pattern")) if self.get_setting("disable_link_preview", False) else None,
            self.Quanta_switch("enable_account_switcher", getString("enable_account_switcher", "Account Switcher"), False, lambda v: self._apply_hooks(), link_alias="enable_account_switcher"),
        ])
        
        settings.extend([
            Header(text=getString("saved_messages", "Saved Messages")),
            self.Quanta_switch("enable_custom_saved_messages", getString("enable_custom_saved_messages", "Custom Saved Messages"), False, lambda v: self._apply_hooks(), link_alias="enable_custom_saved_messages"),
        ])
        
        if self.get_setting("enable_custom_saved_messages", False):
            settings.append(
                self.Quanta_text(text=getString("selected_chat", "Selected Chat") + f": {self._get_custom_saved_chat_name()}", on_click=lambda v: self._select_custom_saved_chat(), link_alias="select_custom_saved_chat")
            )
        
        settings.extend([
            Header(text=getString("notifications", "Notifications")),
            self.Quanta_selector("notification_sound", getString("notification_sound", "Sound Type"), [getString("sound_disable", "Disable"), getString("sound_default", "Default"), getString("sound_ios", "iOS")], 1, lambda v: self._on_notification_sound_change(v), link_alias="notification_sound"),
            self.Quanta_selector("in_chat_vibration", getString("in_chat_vibration", "In-Chat Vibration"), [getString("vibrate_disable", "Disable"), getString("vibrate_click", "1"), getString("vibrate_wave", "2"), getString("vibrate_keyboard", "3"), getString("vibrate_long", "4")], 0, lambda v: self._on_vibration_change(v), link_alias="in_chat_vibration"),


        ])
        
        return settings

    def _create_others_settings(self):
        settings = []
        
        show_branch_selector = self.get_setting("show_branch_selector", False)
        
        settings.extend([
            Header(text=getString("support", "Support Development")),
            Text(text=getString("boosty", "Boosty"), icon="boosty_icon", on_click=lambda v: self._open_boosty(), link_alias="boosty"),
            Text(text=getString("ton_keeper", "Ton Keeper"), icon="ton_icon", on_click=lambda v: self._copy_ton_address(), link_alias="ton_keeper"),
            Text(text=getString("know_more", "Know more"), icon="msg_info", accent=True, on_click=lambda v: self._show_donation_info(), on_long_click=lambda v: self._toggle_branch_selector()),
            Divider(text=getString("another_services", "If the provided services are not available in your country, you can contact me via [direct message](https://t.me/luvztroy)")),

            


            Text(text=getString("export_settings", "Export Settings"), icon="msg_photo_rotate_solar", on_click=lambda v: self._export_settings(), link_alias="export_settings"),
            
            Text(text=getString("reset_shared_preferences", "Reset Shared Preferences"), icon="msg_delete", red=True, on_click=lambda v: self._reset_all_preferences, link_alias="reset_shared_preferences"),
            Divider(text=getString("reset_preferences_description", "Reset all application settings including themes, language, notifications, and user configurations. This action cannot be undone.")),
        ])
        
        if show_branch_selector:
            settings.extend([
                Header(text=getString("auto_update", "Auto Update")),
                self.Quanta_selector("update_branch", getString("update_branch", "Update Branch"), [getString("branch_main", "Main"), getString("branch_beta", "Beta")], 0, link_alias="update_branch"),
                Divider(text=getString("update_branch_info", "Select which branch to receive updates. Beta may contain experimental features and bugs."))
            ])
        
        settings.extend([
            Text(text=getString("Language", "Language"), icon="msg_language", on_click=lambda v: self._open_language(), link_alias="language"),
            self.Quanta_switch("enable_header_particles", getString("particles", "Particles"), default=True, icon="msg_settings_ny", link_alias="enable_header_particles"),
            self.Quanta_switch("show_logs", getString("enable_debug_logging", "Debug Logging"), default=False, icon="msg_emoji_objects_solar", link_alias="show_logs"),
        ])
        
        
        return settings

    def Quanta_switch(self, key, text, default=True, on_change=None, subtext=None, link_alias=None, on_long_click=None, icon=None):
        try:
            return Switch(key=key, text=text, icon=icon, link_alias=link_alias, default=default, on_change=on_change, subtext=subtext, on_long_click=on_long_click) if link_alias else Switch(key=key, text=text, icon=icon, default=default, on_change=on_change, subtext=subtext, on_long_click=on_long_click)
        except Exception:
            return Switch(key=key, text=text, icon=icon, default=default, on_change=on_change, subtext=subtext) if subtext else Switch(key=key, text=text, icon=icon, default=default)

    def Quanta_selector(self, key, text, items, default=0, on_change=None, link_alias=None):
        try:
            return Selector(key=key, text=text, items=items, link_alias=link_alias, default=default, on_change=on_change) if link_alias else Selector(key=key, text=text, items=items, default=default, on_change=on_change)
        except Exception:
            return Selector(key=key, text=text, items=items, default=default, on_change=on_change)

    def Quanta_text(self, text, icon=None, link_alias=None, create_sub_fragment=None, on_click=None, accent=None):
        try:
            return Text(text=text, icon=icon, link_alias=link_alias, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent) if link_alias else Text(text=text, icon=icon, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent)
        except Exception:
            return Text(text=text, icon=icon, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent) if any([icon, create_sub_fragment, on_click, accent]) else Text(text=text, icon=icon)

    def create_settings(self):
        return [
            Header(text=getString("uitweaks_settings", "Categories")),
            
            self.Quanta_text(
                text=getString("general", "General"),
                icon="msg_media_solar",
                link_alias="general",
                create_sub_fragment=self._create_general_settings
            ),
            
            self.Quanta_text(
                text=getString("appearance", "Appearance"), 
                icon="msg_theme",
                link_alias="appearance",
                create_sub_fragment=self._create_appearance_settings   
            ),
            
            self.Quanta_text(
                text=getString("chats", "Chats"),
                icon="msg_msgbubble3_solar",
                link_alias="chats",
                create_sub_fragment=self._create_chats_settings 
            ),
            
            self.Quanta_text(
                text=getString("miscellaneous", "Miscellaneous"),
                icon="msg_reactions_solar",
                link_alias="miscellaneous",
                create_sub_fragment=self._create_miscellaneous_settings
            ),

            self.Quanta_text(
                text=getString("others", "Others"),
                icon="msg_fave_solar",
                link_alias="others",
                create_sub_fragment=self._create_others_settings   
            ),
            
            
            Header(text=getString("links", "Links")),
            Text(text=getString("channel", "Channel"), icon="msg_channel_solar", on_click=lambda v: self._open_channel()),
            Text(text=getString("chats", "Chats"), icon="msg_groups_solar", on_click=lambda v: self._open_group()),
            Text(text=getString("tips_and_tricks", "Tips and Tricks"), icon="menu_feature_reactions_solar", on_click=lambda v: self._open_tips()),
            Text(text=getString("crowdin", "Crowdin"), icon="msg_translate_solar", on_click=lambda v: self._open_translation()),
        ]

    def _collect_all_settings_with_values(self):
        settings = {}
        
        def extract_settings(items):
            for item in items or []:
                if hasattr(item, 'key') and item.key:
                    settings[item.key] = self.get_setting(item.key, getattr(item, 'default', None))
                if hasattr(item, 'create_sub_fragment'):
                    try:
                        extract_settings(item.create_sub_fragment())
                    except:
                        pass
        
        extract_settings(self.create_settings())
        
        if hasattr(self, '_multi_selector_settings'):
            for key in self._multi_selector_settings:
                if key not in settings:
                    settings[key] = self.get_setting(key, False)
        
        return settings
    
    def _export_settings(self):
        export_plugin_settings("ui_tweaks", "UiTweaks", __version__)
    
    def _toggle_branch_selector(self):
        current = self.get_setting("show_branch_selector", False)
        self.set_setting("show_branch_selector", not current, reload_settings=True)
        
        if not current:
            BulletinHelper.show_success(getString("branch_selector_enabled", "Branch selector enabled!"))
        else:
            BulletinHelper.show_info(getString("branch_selector_disabled", "Branch selector hidden"))
    

    
    def _on_hide_archived_from_drawer_change(self, value):
        if value:
            self.set_setting("fab_action_selector", 1)
        else:
            self.set_setting("fab_action_selector", 0)
        self._apply_hooks()
    
    def _setup_quanta_file_hook(self):
        try:
            from java.lang import Class
            from java import jclass
            AndroidUtilitiesClass = Class.forName("org.telegram.messenger.AndroidUtilities")
            MessageObjectClass = Class.forName("org.telegram.messenger.MessageObject")
            ActivityClass = Class.forName("android.app.Activity")
            ResourcesProviderClass = Class.forName("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            open_for_view = AndroidUtilitiesClass.getDeclaredMethod(
                "openForView",
                MessageObjectClass,
                ActivityClass,
                ResourcesProviderClass,
                jclass("java.lang.Boolean").TYPE,
            )
            open_for_view.setAccessible(True)
            class OpenForViewHook:
                def __init__(hook_self):
                    hook_self.plugin = self
                @hook_filters(HookFilter.ArgumentNotNull(0))
                def before_hooked_method(hook_self, param):
                    try:
                        if len(param.args) >= 1:
                            msg = param.args[0]
                            if msg and hasattr(msg, "getDocumentName"):
                                name = msg.getDocumentName()
                                if name and str(name).lower().endswith(".quanta"):
                                    hook_self.plugin._show_import_bottom_sheet(msg)
                                    param.setResult(False)
                    except Exception as e:
                        pass
            self.hook_method(open_for_view, OpenForViewHook())
        except Exception as e:
            pass
    
    def _show_import_bottom_sheet(self, message_object):
        def show_sheet():
            try:
                from com.exteragram.messenger.utils import ChatUtils
                from file_utils import read_file
                
                changes_count = 0
                try:
                    file_path = ChatUtils.getInstance().getPathToMessage(message_object)
                    if file_path:
                        content = read_file(file_path)
                        if content:
                            backup_data = json.loads(content)
                            
                            if backup_data.get("plugin") != "UiTweaks":
                                BulletinHelper.show_error(getString("not_uitweaks_settings_file", "Not a UiTweaks settings file"))
                                return
                            
                            settings = backup_data.get("settings", {})
                            controller = PluginsController.getInstance()
                            engine = controller.getPluginEngine("ui_tweaks")
                            
                            if engine and settings:
                                current_settings = engine.getAllPluginSettings("ui_tweaks")
                                for key, value in settings.items():
                                    current_value = current_settings.get(key) if current_settings else None
                                    if current_value != value:
                                        changes_count += 1
                except Exception:
                    changes_count = 1
                
                if changes_count == 0:
                    BulletinHelper.show_error(getString("settings_same_as_current", "It looks like the settings are the same as the current ones."))
                    return
                
                subtitle = getString("changes_will_be_applied_singular", "{count} change will be applied to the current settings.").format(count=changes_count) if changes_count == 1 else getString("changes_will_be_applied_plural", "{count} changes will be applied to the current settings.").format(count=changes_count)
                
                def on_import_click():
                    self._import_from_message(message_object)
                
                BottomSheet(
                    title=getString("apply_settings_confirmation", "Are you sure you want to apply these settings?"),
                    subtitle=subtitle,
                    button_text=getString("yes_apply", "Yes, apply"),
                    button2_text=getString("no_leave_as_is", "No, leave as is"),
                    show_close_button=False,
                    raw_resource=R_tg.raw.email_check_inbox,
                    on_button_click=on_import_click,
                    on_button2_click=lambda: None
                )
                
            except Exception as e:
                pass
        
        run_on_ui_thread(show_sheet)
    
    def _import_from_message(self, message_object):
        try:
            from com.exteragram.messenger.utils import ChatUtils
            from file_utils import read_file
            
            file_path = ChatUtils.getInstance().getPathToMessage(message_object)
            if not file_path:
                return
            
            content = read_file(file_path)
            if not content:
                return
            
            backup_data = json.loads(content)

            if backup_data.get("plugin") != "UiTweaks":
                BulletinHelper.show_error(getString("not_uitweaks_settings_file", "Not a UiTweaks settings file"))
                return
            
            settings = backup_data.get("settings", {})
            controller = PluginsController.getInstance()
            engine = controller.getPluginEngine("ui_tweaks")
            imported_count = 0
            
            if engine and settings:
                for key, value in settings.items():
                    try:
                        engine.setPluginSetting("ui_tweaks", key, value)
                        imported_count += 1
                    except Exception:
                        pass
                
                controller.loadPluginSettings("ui_tweaks")
            
            BulletinHelper.show_success(getString("imported_settings_count", "Imported {count} settings").format(count=imported_count))
            
        except Exception as e:
            BulletinHelper.show_error(getString("failed_to_import_settings", "Failed to import settings"))
    
    def _reset_all_preferences(self):
        fragment = get_last_fragment()
        if not fragment:
            return

        builder = AlertDialogBuilder(fragment.getParentActivity())
        builder.set_title(getString("warning", "Warning"))
        builder.set_message(getString("reset_confirmation", "Are you sure you want to reset?"))
        builder.set_positive_button(getString("reset_all", "Reset All"), lambda bld, which: (self._perform_reset(), bld.dismiss()))
        builder.set_negative_button(getString("cancel", "Cancel"), lambda bld, which: bld.dismiss())
        builder.show()

    def _perform_reset(self):
        try:
            from org.telegram.messenger import UserConfig
            account = UserConfig.selectedAccount
            
            settings = jclass("org.telegram.messenger.MessagesController").getInstance(account).getMainSettings()
            count = settings.getAll().size()
            log(f"Total preferences found: {count}")
            
            def perform_reset():
                settings.edit().clear().apply()
                jclass("org.telegram.messenger.BirthdayController").getInstance(account).check()
                log(f"Successfully cleared {count} preferences")
                from quantahut import restart_app
                restart_app()
            
            def undo_reset():
                log("Reset operation cancelled by user")
            
            BulletinHelper.show_undo(
                getString("shared_preferences_reset_success", "Reset {count} preferences? App will restart.").format(count=count),
                on_undo=undo_reset,
                on_action=perform_reset,
                fragment=get_last_fragment()
            )
            
        except Exception as e:
            log(f"Reset failed: {str(e)}")
            BulletinHelper.show_error(getString("reset_failed", "Reset failed: {error}").format(error=str(e)))
    
    def _restart_after_bulletin(self):
        from quantahut import restart_app
        restart_app()
    
    def _open_boosty(self):
        from android.content import Intent
        from android.net import Uri
        
        intent = Intent(Intent.ACTION_VIEW)
        intent.setData(Uri.parse("https://boosty.to/luvztroy/donate"))
        get_last_fragment().getParentActivity().startActivity(intent)
    
    def _copy_ton_address(self):
        clipboard = get_last_fragment().getParentActivity().getSystemService(Context.CLIPBOARD_SERVICE)
        clipboard.setPrimaryClip(ClipData.newPlainText("TON Address", "UQAZFPWF06gVehwcXlYDj3AWgx6i0x0VwUZOOUJ0A_gTcshN"))
        BulletinHelper.show_copied_to_clipboard(getString("ton_address_copied", "TON address copied to clipboard"))
    
    def _open_channel(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaPlugins", fragment, 1)
        except Exception as e:
            self.log(f"Error opening channel: {e}")
    
    def _open_group(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaPlayground", fragment, 1)
        except Exception as e:
            self.log(f"Error opening group: {e}")
    
    def _open_tips(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaTips", fragment, 1)
        except Exception as e:
            self.log(f"Error opening tips: {e}")

    def _open_translation(self):
        from android.content import Intent
        from android.net import Uri
        intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://crowdin.com/project/uitweaks"))
        get_last_fragment().getParentActivity().startActivity(intent)     
    
    def _open_language(self):
        try:
            from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment
            from java import dynamic_proxy
            from org.telegram.ui.Components import UItem
            from org.telegram.messenger import R
            from ui.bulletin import BulletinHelper
            from base_plugin import PluginsController
            from hook_utils import get_private_field
            
            plugin = self
            
            class LanguageSelectorDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):
                def __init__(self):
                    super().__init__()
                    self.fragment = None
                    try:
                        prefs = get_private_field(PluginsController.getInstance(), "preferences")
                        self.selected_language = prefs.getString("plugin_setting_ui_tweaks_selected_language", None) or "en"
                    except:
                        self.selected_language = "en"
                
                def getTitle(self):
                    return getString("select_language", "Select Language")
                
                def beforeCreateView(self):
                    return None
                
                def afterCreateView(self, view):
                    return view
                
                def onFragmentCreate(self):
                    pass
                
                def onFragmentDestroy(self):
                    pass
                
                def onMenuItemClick(self, id):
                    pass
                
                def fillItems(self, items, adapter):
                    items.add(UItem.asHeader(getString("available_languages", "Available Languages")))
                    
                    default_item = UItem.asRadio(-1, getString("default", "Default"), getString("english", "English"))
                    default_item.checked = (self.selected_language == "en" or not self.selected_language)
                    items.add(default_item)
                    
                    languages = quantahut.available_languages if quantahut and hasattr(quantahut, 'available_languages') else []
                    if not languages:
                        items.add(UItem.asButton(-2, getString("loading", "Loading...")))
                    else:
                        for i, lang in enumerate(languages):
                            lang_code = lang.get("code", "")
                            
                            if lang_code == "en":
                                continue
                            
                            native_name = lang.get("display_name", lang_code)

                            try:
                                from java.util import Locale
                                clean_code = lang_code.replace("-raw", "")
                                parts = clean_code.split("-")
                                if len(parts) == 1:
                                    locale = Locale(parts[0])
                                else:
                                    locale = Locale(parts[0], parts[1] if len(parts) > 1 else "")
                                english_name = locale.getDisplayLanguage(Locale.ENGLISH)
                            except:
                                english_name = lang_code.replace("-raw", "").title()
                            
                            item = UItem.asRadio(i, english_name, native_name)
                            item.checked = (lang_code == self.selected_language)
                            items.add(item)
                    
                    items.add(UItem.asShadow(None))
                    items.add(UItem.asHeader(getString("localization_options", "Localization Options")))
                    items.add(UItem.asButton(-3, getString("refresh_localization", "Refresh Localization")))
                    items.add(UItem.asShadow(getString("refresh_localization_info", "Force update the localization for the selected language.")))
                
                def onClick(self, item, view, position, x, y):
                    item_id = item.id
                    
                    def save_lang(code):
                        try:
                            prefs = get_private_field(PluginsController.getInstance(), "preferences")
                            prefs.edit().putString("plugin_setting_ui_tweaks_selected_language", code).apply()
                        except:
                            pass
                    
                    def refresh_and_finish(msg):
                        PluginsController.getInstance().loadPluginSettings("ui_tweaks")
                        PluginsController.getInstance().loadPluginSettings("quantahut")
                        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginSettingsRegistered, "ui_tweaks")
                        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginSettingsRegistered, "quantahut")
                        try:
                            if quantahut and hasattr(quantahut, 'QuantaHut') and hasattr(quantahut.QuantaHut, 'instance') and quantahut.QuantaHut.instance:
                                quantahut.QuantaHut.instance._update_restart_menu_item()
                        except:
                            pass
                        if self.fragment:
                            self.fragment.finishFragment()
                        BulletinHelper.show_simple(msg, R.raw.contact_check, get_last_fragment())
                    
                    if item_id == -1:
                        self.selected_language = "en"
                        save_lang("en")
                        refresh_and_finish(getString("language_changed_to", "Language changed to") + " English")
                        return
                    
                    if item_id == -3:
                        lang_code = self.selected_language or "en"
                        if lang_code == "en":
                            BulletinHelper.show_simple(getString("no_localization_for_english", "No localization needed for English"), R.raw.info, self.fragment)
                            return
                        
                        BulletinHelper.show_simple(getString("refreshing_localization", "Refreshing localization..."), R.raw.info, self.fragment)
                        
                        def do_refresh():
                            try:
                                quantahut.github_localization.download_localization("UiTweaks", lang_code, force_refresh=True)
                                run_on_ui_thread(lambda: refresh_and_finish(getString("localization_refreshed", "Localization refreshed successfully")))
                            except Exception as e:
                                err_msg = str(e)
                                plugin.log(f"Refresh localization error: {err_msg}")
                                run_on_ui_thread(lambda: BulletinHelper.show_simple(getString("refresh_failed", "Refresh failed") + f": {err_msg}", R.raw.error, self.fragment))
                        
                        import threading
                        threading.Thread(target=do_refresh, daemon=True).start()
                        return
                    
                    languages = quantahut.available_languages if quantahut and hasattr(quantahut, 'available_languages') else []
                    if item_id >= 0 and item_id < len(languages):
                        lang = languages[item_id]
                        lang_code = lang.get("code")
                        lang_display = lang.get("display_name", lang_code)
                        self.selected_language = lang_code
                        save_lang(lang_code)
                        
                        if self.fragment:
                            try:
                                self.fragment.listView.getAdapter().update(False)
                            except:
                                pass
                        
                        def do_download():
                            try:
                                quantahut.github_localization.download_localization("UiTweaks", lang_code)
                                run_on_ui_thread(lambda: refresh_and_finish(getString("language_changed_to", "Language changed to") + f" {lang_display}"))
                            except:
                                run_on_ui_thread(lambda: BulletinHelper.show_simple(getString("download_failed", "Download failed"), R.raw.error, self.fragment))
                        
                        import threading
                        threading.Thread(target=do_download, daemon=True).start()
                
                def onLongClick(self, item, view, position, x, y):
                    return False
                
                def onBackPressed(self):
                    return None
            
            delegate = LanguageSelectorDelegate()
            fragment = UniversalFragment(delegate)
            delegate.fragment = fragment
            last_fragment = get_last_fragment()
            if last_fragment:
                last_fragment.presentFragment(fragment)
        except Exception as e:
            self.log(f"Error opening language selector: {e}")
    
    def _show_donation_info(self):
        try:
            self.log("Opening donation info bottom sheet")
            BottomSheet(
                title=getString("donation_info_title", "About Donations"),
                description=getString("donation_info_description", 
                    "Donations are a way to appreciate the effort behind this Plugin. They dont grant special privileges, though you may request a feature as thanks."),
                github_url=None,
                plugin_name="UiTweaks_DonationInfo",
                sticker_pack="luvztroyIcons",
                sticker_index=15,
                button_text=getString("understood", "Understood"),
                show_user_avatar=False,
                description_centered=True
            )
        except Exception as e:
            self.log(f"Error showing donation info bottom sheet: {e}")
    
    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.START:
            if self.get_setting("hidefolders_enabled", False):
                try:
                    self._hook_folder_visibility()
                    
                    from android.os import Handler, Looper
                    from android_utils import R
                    
                    def post_notification():
                        try:
                            NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(
                                NotificationCenter.dialogFiltersUpdated
                            )
                        except Exception:
                            pass
                    
                    Handler(Looper.getMainLooper()).postDelayed(R(post_notification), 100)
                except Exception:
                    pass
        
        elif event_type == AppEvent.RESUME:
            if self.get_setting("hide_archived_chats", False) and self.get_setting("hide_archived_from_drawer", False):
                try:
                    from android.os import Handler, Looper
                    from android_utils import R
                    
                    def refresh_drawer():
                        try:
                            from org.telegram.ui import LaunchActivity
                            if (hasattr(LaunchActivity, 'instance') and LaunchActivity.instance):
                                drawer_adapter = get_private_field(LaunchActivity.instance, "drawerLayoutAdapter")
                                if drawer_adapter and hasattr(drawer_adapter, 'notifyDataSetChanged'):
                                    drawer_adapter.notifyDataSetChanged()
                        except Exception:
                            pass
                    
                    Handler(Looper.getMainLooper()).postDelayed(R(refresh_drawer), 500)
                except Exception:
                    pass

    def _check_for_updates_on_load(self):
        def delayed_check():
            time.sleep(5)
            
            try:
                if hasattr(quantahut, 'QuantaHut'):
                    qh_instance = quantahut.QuantaHut.instance if hasattr(quantahut.QuantaHut, 'instance') else None
                    if qh_instance and hasattr(qh_instance, 'update_available') and qh_instance.update_available:
                        self.log("QuantaHut update is available, skipping UiTweaks update check")
                        return
            except Exception:
                pass
            
            self.log("Auto-checking for UiTweaks updates...")
            self._check_for_updates(show_on_load=True)
        
        thread = threading.Thread(target=delayed_check)
        thread.daemon = True
        thread.start()
    
    def _check_for_updates(self, show_on_load=False):
        if self.checking_update:
            self.log("Already checking for updates...")
            return
        
        self.checking_update = True
        self.log("Checking for updates...")
        
        CHANNEL_USERNAME = "QuantaConfig"
        
        def on_update_info_received(uitweaks_version, quantahut_version, pack, sticker_index, text_msg_id, messages, commit_check=False):
            try:
                changelog_text = "No changelog available"
                
                if text_msg_id:
                    for i in range(messages.size()):
                        msg = messages.get(i)
                        if msg.id == text_msg_id:
                            if hasattr(msg, 'message') and msg.message:
                                try:
                                    from org.telegram.messenger import MessageObject
                                    from android.text import SpannableStringBuilder
                                    
                                    text = str(msg.message)
                                    entities = msg.entities if hasattr(msg, 'entities') else None
                                    
                                    if entities and entities.size() > 0:
                                        ssb = SpannableStringBuilder(text)
                                        MessageObject.addEntitiesToText(ssb, entities, False, False, False, False)
                                        changelog_text = ssb
                                        self.changelog_entities = entities
                                    else:
                                        changelog_text = text
                                        self.changelog_entities = None
                                except:
                                    changelog_text = str(msg.message)
                                    self.changelog_entities = None
                            break
                
                self.changelog = changelog_text
                
                branch_index = self.get_setting("update_branch", 0)
                branch = "main" if branch_index == 0 else "Beta"
                
                def check_update(latest_ver, current_ver, filename, ts_key):
                    if latest_ver and self._is_newer_version(latest_ver, current_ver):
                        return True, latest_ver, None
                    elif latest_ver == current_ver and commit_check:
                        github_ts = self._get_github_commit_timestamp(branch, filename)
                        stored_ts = self.get_setting(ts_key, None)
                        if github_ts and (not stored_ts or github_ts != stored_ts):
                            self.log(f"Commit-based update for {filename}: github={github_ts}, stored={stored_ts}")
                            return True, latest_ver, github_ts
                    return False, latest_ver, None
                
                uitweaks_update, self.latest_version, self._pending_commit_ts = check_update(
                    uitweaks_version, __version__, "UiTweaks.plugin", "last_uitweaks_commit_ts"
                )
                
                quantahut_current = "0.0.0"
                try:
                    quantahut_current = quantahut.__version__
                except:
                    pass
                
                quantahut_update, self.quantahut_latest_version, self._pending_quantahut_commit_ts = check_update(
                    quantahut_version, quantahut_current, "QuantaHut.plugin", "last_quantahut_commit_ts"
                )
                
                self.uitweaks_update_available = uitweaks_update
                self.quantahut_update_available = quantahut_update
                self.update_available = uitweaks_update or quantahut_update
                
                if self.update_available:
                    updates = []
                    if uitweaks_update:
                        updates.append(f"UiTweaks {uitweaks_version}")
                    if quantahut_update:
                        updates.append(f"QuantaHut {quantahut_version}")
                    self.log(f"Update available: {', '.join(updates)}")
                else:
                    self.log("Already up to date")
                
                self.uitweaks_download_url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/refs/heads/{branch}/UiTweaks.plugin"
                self.quantahut_download_url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/refs/heads/{branch}/QuantaHut.plugin"
                
                if self.update_available and show_on_load:
                    run_on_ui_thread(lambda: self._show_update_bottom_sheet(
                        pack, sticker_index, False, 160
                    ))
                
            except Exception as e:
                self.log(f"Error processing update info: {e}")
            finally:
                self.checking_update = False
        
        def fetch_channel_messages():
            try:
                from org.telegram.tgnet import TLRPC
                from client_utils import get_account_instance, send_request, RequestCallback
                
                account = get_account_instance()
                branch_index = self.get_setting("update_branch", 0)
                update_tag = "update_stable" if branch_index == 0 else "update_beta"
                
                def on_channel_resolved(chat):
                    if not chat:
                        self.checking_update = False
                        return
                    
                    req = TLRPC.TL_messages_getHistory()
                    req.peer = TLRPC.TL_inputPeerChannel()
                    req.peer.channel_id = chat.id
                    req.peer.access_hash = chat.access_hash
                    req.offset_id = 0
                    req.limit = 100
                    
                    def handle_response(response, error):
                        if error or not response:
                            self.checking_update = False
                            return
                        
                        try:
                            messages = response.messages
                            update_info = {}
                            
                            def parse_update_fields(msg_text):
                                info = {}
                                for line in msg_text.split('\n'):
                                    if '=' in line:
                                        k, v = line.split('=', 1)
                                        k, v = k.strip(), v.strip()
                                        if k == 'version': info['version'] = v
                                        elif k == 'version2': info['version2'] = v
                                        elif k == 'sticker': info['sticker'] = int(v)
                                        elif k == 'text': info['text'] = int(v)
                                        elif k == 'pack': info['pack'] = v
                                        elif k == 'available_language': info['lang_id'] = int(v)
                                        elif k == 'isDev' and v: info['dev_ids'] = [int(x.strip()) for x in v.split(',') if x.strip()]
                                        elif k == 'commit': info['commit_check'] = v.lower() == 'true'
                                return info
                            
                            current_user_id = None
                            try:
                                from org.telegram.messenger import UserConfig
                                current_user_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
                            except:
                                pass
                            
                            for i in range(messages.size()):
                                msg = messages.get(i)
                                if not (hasattr(msg, 'message') and msg.message):
                                    continue
                                msg_text = str(msg.message)
                                
                                if msg_text.startswith("update_dev"):
                                    info = parse_update_fields(msg_text)
                                    dev_ids = info.get('dev_ids', [])
                                    if current_user_id and current_user_id in dev_ids:
                                        self.log(f"Dev update found for user {current_user_id}")
                                        update_info = info
                                        break
                                
                                elif msg_text.startswith(update_tag) and not update_info:
                                    update_info = parse_update_fields(msg_text)
                                    break
                            
                            if update_info.get('lang_id'):
                                self.log(f"Found available_language={update_info['lang_id']}")
                                try:
                                    if hasattr(quantahut, 'QuantaHut') and hasattr(quantahut.QuantaHut, 'instance'):
                                        quantahut.QuantaHut.instance._load_available_languages(update_info['lang_id'])
                                except Exception as e:
                                    self.log(f"Error loading languages: {e}")
                            
                            if update_info.get('version') or update_info.get('version2'):
                                on_update_info_received(
                                    update_info.get('version'), update_info.get('version2'),
                                    update_info.get('pack'), update_info.get('sticker'),
                                    update_info.get('text'), messages, update_info.get('commit_check', False)
                                )
                            else:
                                self.checking_update = False
                        except Exception as e:
                            self.checking_update = False
                    
                    send_request(req, RequestCallback(handle_response))
                
                def resolve_channel():
                    from java import dynamic_proxy, jclass
                    Consumer = jclass("com.google.android.exoplayer2.util.Consumer")
                    
                    class ResolveCallback(dynamic_proxy(Consumer)):
                        def accept(self_cb, peer_id):
                            if peer_id and peer_id < 0:
                                run_on_ui_thread(lambda: on_channel_resolved(messages_controller.getChat(-peer_id)))
                            else:
                                self.checking_update = False
                    
                    messages_controller = account.getMessagesController()
                    messages_controller.getUserNameResolver().resolve(CHANNEL_USERNAME, ResolveCallback())
                
                run_on_ui_thread(resolve_channel)
                
            except Exception as e:
                self.checking_update = False
        
        thread = threading.Thread(target=fetch_channel_messages)
        thread.daemon = True
        thread.start()
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        try:
            def clean_version(version):
                version = version.split('-')[0].split(' ')[0].strip()
                return version
            
            v1_clean = clean_version(version1)
            v2_clean = clean_version(version2)
            
            v1_parts = [int(x) for x in v1_clean.split('.')]
            v2_parts = [int(x) for x in v2_clean.split('.')]
            
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts += [0] * (max_len - len(v1_parts))
            v2_parts += [0] * (max_len - len(v2_parts))
            
            if v1_parts > v2_parts:
                return 1
            elif v1_parts < v2_parts:
                return -1
            else:
                return 0
        except Exception as e:
            self.log(f"Error comparing versions: {e}")
            return 0
    
    def _is_newer_version(self, latest: str, current: str) -> bool:
        return self._compare_versions(latest, current) > 0
    
    def _get_github_commit_timestamp(self, branch: str = "main", filename: str = "UiTweaks.plugin") -> Optional[str]:
        try:
            url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/{branch}/{filename}"
            req = urllib.request.Request(url, method='HEAD', headers={"User-Agent": "UiTweaks-Plugin"})
            with urllib.request.urlopen(req, timeout=15) as response:
                etag = response.headers.get('ETag') or response.headers.get('Last-Modified')
                if etag:
                    self.log(f"GitHub {filename} ETag: {etag[:20]}...")
                    return etag
        except Exception as e:
            self.log(f"Error fetching GitHub file info: {e}")
        return None
    
    def _show_update_bottom_sheet(self, sticker_pack, sticker_index, sticker_circle, sticker_size):
        if not self.update_available:
            return
        
        self.log("Showing update bottom sheet")
        
        try:
            uitweaks_update = getattr(self, 'uitweaks_update_available', False)
            quantahut_update = getattr(self, 'quantahut_update_available', False)
            
            if uitweaks_update and quantahut_update:
                subtitle = f"UiTweaks {self.latest_version}  QuantaHut {self.quantahut_latest_version}"
            elif uitweaks_update:
                subtitle = f"UiTweaks {self.latest_version}"
            else:
                subtitle = f"QuantaHut {self.quantahut_latest_version}"
            
            BottomSheet(
                title="Update Available",
                subtitle=subtitle,
                description=self.changelog,
                description_entities=getattr(self, 'changelog_entities', None),
                sticker_pack=sticker_pack,
                sticker_index=sticker_index,
                sticker_circle=sticker_circle,
                sticker_size=sticker_size,
                button_text="Update Now",
                show_close_button=False,
                on_button_click=self._download_and_install_update,
                title_subtitle_gap=5
            )
        except Exception as e:
            self.log(f"Error showing update sheet: {e}")
    
    def _download_and_install_update(self):
        uitweaks_update = getattr(self, 'uitweaks_update_available', False)
        quantahut_update = getattr(self, 'quantahut_update_available', False)
        
        plugins_to_update = []
        if uitweaks_update:
            plugins_to_update.append("UiTweaks")
        if quantahut_update:
            plugins_to_update.append("QuantaHut")
        
        self.log(f"Starting update for: {', '.join(plugins_to_update)}")
        BulletinHelper.show_info(f"Downloading {', '.join(plugins_to_update)}...")
        
        def download_thread():
            try:
                from com.exteragram.messenger.plugins import PluginsController, PluginsConstants
                from org.telegram.messenger import ApplicationLoader, Utilities
                from java import dynamic_proxy, jclass
                
                plugins_dir = os.path.join(str(ApplicationLoader.applicationContext.getFilesDir()), "plugins")
                updated_plugins = []
                
                if uitweaks_update:
                    self.log("Downloading UiTweaks...")
                    with urllib.request.urlopen(self.uitweaks_download_url, timeout=30) as response:
                        uitweaks_content = response.read()
                    
                    uitweaks_temp = os.path.join(plugins_dir, "ui_tweaks_update.tmp")
                    with open(uitweaks_temp, 'wb') as f:
                        f.write(uitweaks_content)
                    updated_plugins.append(("UiTweaks", uitweaks_temp, self.latest_version))
                
                if quantahut_update:
                    self.log("Downloading QuantaHut...")
                    with urllib.request.urlopen(self.quantahut_download_url, timeout=30) as response:
                        quantahut_content = response.read()
                    
                    quantahut_temp = os.path.join(plugins_dir, "quantahut_update.tmp")
                    with open(quantahut_temp, 'wb') as f:
                        f.write(quantahut_content)
                    updated_plugins.append(("QuantaHut", quantahut_temp, self.quantahut_latest_version))
                
                try:
                    from org.telegram.messenger import LocaleController
                    lang = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
                    self.log(f"OTA: Downloading localization for lang={lang}")
                    if lang and lang != "en":
                        quantahut.github_localization.download_localization("UiTweaks", lang, force_refresh=True)
                        self.log(f"OTA: Localization download completed for {lang}")
                except Exception as e:
                    self.log(f"OTA: Localization download failed: {e}")
                
                success_count = [0]
                total_plugins = len(updated_plugins)
                
                def install_next(index):
                    if index >= total_plugins:
                        if success_count[0] == total_plugins:
                            names = " & ".join([p[0] for p in updated_plugins])
                            run_on_ui_thread(lambda: BulletinHelper.show_success(f"{names} updated!"))
                        return
                    
                    name, temp_file, version = updated_plugins[index]
                    
                    class Callback(dynamic_proxy(Utilities.Callback)):
                        def run(self_cb, error):
                            if error:
                                run_on_ui_thread(lambda: BulletinHelper.show_error(f"{name} update failed: {error}"))
                            else:
                                success_count[0] += 1
                                self.log(f"{name} updated to v{version}")

                                if name == "UiTweaks" and hasattr(self, '_pending_commit_ts') and self._pending_commit_ts:
                                    self.set_setting("last_uitweaks_commit_ts", self._pending_commit_ts)
                                    self._pending_commit_ts = None
                                if name == "QuantaHut" and hasattr(self, '_pending_quantahut_commit_ts') and self._pending_quantahut_commit_ts:
                                    self.set_setting("last_quantahut_commit_ts", self._pending_quantahut_commit_ts)
                                    self._pending_quantahut_commit_ts = None
                            try:
                                os.remove(temp_file)
                            except:
                                pass
                            install_next(index + 1)
                    
                    class Runnable(dynamic_proxy(jclass("java.lang.Runnable"))):
                        def run(self_r):
                            PluginsController.engines.get(PluginsConstants.PYTHON).loadPluginFromFile(temp_file, None, Callback())
                    
                    Utilities.pluginsQueue.postRunnable(Runnable())
                
                install_next(0)
                
            except Exception as e:
                self.log(f"Update failed: {e}")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Update failed: {e}"))
        
        threading.Thread(target=download_thread, daemon=True).start()


    def on_plugin_unload(self):

        if hasattr(self, "_mkstats_stop"):
            self._mkstats_stop.set()
            self.log("UiTweaks: stop requested")
            try:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                    self._mkstats_thread.join(timeout=1.0)
            except Exception:
                pass

        if hasattr(self, '_sleep_handler') and self._sleep_handler:
            self._sleep_handler.removeCallbacksAndMessages(None)
            self._sleep_handler = None
        if hasattr(self, '_sleep_runnable'):
            self._sleep_runnable = None
        


        self._unhook_all()
        
        self._current_chat_activity_ref = None
        self._current_back_button_ref = None
        self.counter_views.clear()
        
        self._remove_reply_private_chat_menu_item()
        self._remove_no_quote_forward_menu_item()
        self._remove_message_repeat_menu_item()
        self._no_quote_buttons_created.clear()
        
        if hasattr(self, '_goto_plugin_menu_id') and self._goto_plugin_menu_id:
            self.remove_menu_item(self._goto_plugin_menu_id)
            self._goto_plugin_menu_id = None
        
        if hasattr(self, 'hook_gif_spoiler_ref') and self.hook_gif_spoiler_ref:
            if hasattr(self.hook_gif_spoiler_ref, 'cleanup_menu_items'):
                self.hook_gif_spoiler_ref.cleanup_menu_items()
        
        try:
            from quantahut import cleanup_quantahut_hooks
            cleanup_quantahut_hooks(self)
        except Exception:
            pass
            
        if hasattr(self, 'recent_manager') and self.recent_manager:
            self.recent_manager.cleanup()
            self.recent_manager.recent_dialogs.clear()
        
        if hasattr(self, 'popup_manager') and self.popup_manager:
            self.popup_manager.destroy()
        
        self._cleanup_activity_resources()
        
        if hasattr(self, 'contact_status_activity_state'):
            self.contact_status_activity_state.clear()
        
        if hasattr(self, '_class_cache'):
            self._class_cache.clear()
        
        if hasattr(self, '_in_message_translated'):
            self._in_message_translated.clear()
        
        global uitweaks_plugin_instance
        uitweaks_plugin_instance = None



    def _cleanup_activity_resources(self):
        try:
            sets_to_clear = [
                'hooked_activities',
                'added_send_media_buttons',
                '_no_quote_buttons_created',
                '_select_all_added_modes',
                '_goto_items_added',
                'ai_summarize_hooked_activities',
                'chat_action_bar_hooked_activities',
            ]
            for set_name in sets_to_clear:
                if hasattr(self, set_name):
                    s = getattr(self, set_name)
                    if s:
                        s.clear()
            
            dicts_to_clear = [
                '_no_quote_button_cache',
                'search_filter_buttons',
                'contact_status_activity_state',
            ]
            for dict_name in dicts_to_clear:
                if hasattr(self, dict_name):
                    d = getattr(self, dict_name)
                    if d:
                        d.clear()
        except Exception as e:
            self.log(f"Error cleaning up activity resources: {e}")

    def _get_class(self, class_name: str):
        if class_name in self._class_cache:
            return self._class_cache[class_name]
        
        cls = find_class(class_name)
        if cls is not None:
            self._class_cache[class_name] = cls
        return cls


    def _open_archived_chats(self, context):
        from client_utils import get_last_fragment
        from java import jclass
        
        fragment = get_last_fragment()
        if fragment:
            bundle = jclass("android.os.Bundle")()
            bundle.putInt("folderId", 1)
            
            dialogs_activity = jclass("org.telegram.ui.DialogsActivity")(bundle)
            fragment.presentFragment(dialogs_activity)
    
    def _open_archived_chats_from_fab(self, dialogs_activity):
        from java import jclass
        
        try:
            bundle = jclass("android.os.Bundle")()
            bundle.putInt("folderId", 1)
            
            archived_dialogs_activity = jclass("org.telegram.ui.DialogsActivity")(bundle)
            dialogs_activity.presentFragment(archived_dialogs_activity)
        except Exception as e:
            pass
    def _unhook_all(self):
        self.log("Unhooking all methods")
        for ref_attr in (
            "hook_dialogs_ref",
            "hook_dialogs_destroy_ref",
            "hook_dialog_cell_ref",
            "hook_swipe_prevention_ref",
            "hook_star_reaction_menu_ref",
            "hook_star_reaction_visible_list_ref",
            "hook_star_reaction_gradient_ref",
            "hook_star_reaction_layout_draw_ref",
            "hook_link_confirmation_ref",
            "hook_article_viewer_ref",
            "hook_webapp_swipe_prevention_ref",
            "hook_download_manager_ref",
            "hook_proxy_button_ref",
            "hook_phone_number_ref",
            "hook_messages_controller_ref",
            "hook_update_bot_button_ref",
            "hook_voice_message_control_ref",
            "hook_voice_message_time_display_ref",
            "hook_video_message_control_ref",
            "hook_forward_confirmation_ref",
            "hook_join_confirmation_ref",
            "hook_send_typing_refs",
            "hook_gif_spoiler_ref",
            "hook_gif_dismiss_ref",
            "hook_process_external_url_ref",
            "hook_fill_action_mode_menu_ref",
            "hook_perform_menu_action_ref",
            "hook_drawer_icon_ref",

            "hook_call_buttons_ref",
            "hook_group_voice_chat_icon_ref",
            "hook_message_preview_view_ref",
            "hook_browser_open_url_ref",
            "hook_disable_auto_web_login_ref",
            "hook_prefer_common_groups_tab_ref",
            "hook_non_clickable_dispatch_ref",
            "hook_non_clickable_present_ref",
            "hook_non_clickable_present_ref2",
            "hook_birthday_alert_ref",
            "hook_code_formatting_ref",
            "hook_sender_select_popup_ref",
            "hook_share_sheet_folders_ref",
            "hook_disable_topic_swipe_ref",
            "hook_account_visibility_drawer_ref",
            "hook_account_visibility_profile_ref",
            "contact_status_update_rows_hook",
            "contact_status_get_item_view_type_hook",
            "contact_status_bind_view_holder_hook",
            "safe_mode_hook_ref",
            "hook_folder_visibility_ref",
            "hook_search_by_user_id_ref",
            "hook_gift_drawer_reset_ref",
            "hook_no_quote_pause_ref",
            "hook_gift_drawer_click_ref",
            "hook_gift_drawer_cell_ref",
            "hook_ai_summarize_create_view_ref",
            "hook_ai_summarize_item_click_ref",
            "delete_with_duration_fillitems_ref",
            "delete_with_duration_onclick_ref",
            "hook_ai_role_limit_constructor_ref",
            "hook_ai_role_limit_settext_ref",
            "hook_select_all_media_ref",
            "hook_always_visible_schedule_button_ref",
            "hook_remove_greeting_sticker_ref",
            "hook_remove_https_from_links_ref",
            "hook_sleep_timer_ref",
            "hook_sleep_timer_click_ref",
            "hook_adaptive_audio_ref",
            "hook_music_speed_control_ref",
            "hook_custom_saved_messages_ref",
            "hook_disable_emoji_suggestions_ref",
            "hook_message_swipe_action_ref",
            "hook_join_request_direct_profile_ref",
            "hook_search_filter_open_search_ref",
            "hook_search_filter_send_request_ref",
            "create_view_hook_ref",
            "destroy_hook_ref",

            "hook_check_send_button_ref",
            "hook_unread_count_ref",
            "hook_add_to_folder_all_tabs_ref",
            "hook_play_sound_ref",
            "hook_soundpool_load_ref",
            "hook_search_links_ref",
            "hook_enter_view_constructor_ref",
            "hook_send_message_params_ref",
            "hook_reactions_container_ref",
            "hook_share_alert_forward_open_ref",
            "hook_share_alert_forward_process_ref",
            "hook_unify_username_behavior_process_click_ref",
            "hook_unify_username_behavior_bind_ref",
            "hook_edit_file_name_ref",
            "hook_send_comments_after_forward_ref",
            "hook_in_message_translation_alert_ref",
            "hook_in_message_translation_revert_ref",
            "hook_hide_via_bot_ref",
            "hook_owner_channels_ref",
            "hook_remove_from_folders_ref",
            "hook_bookmark_create_view_ref",
            "hook_bookmark_action_bar_ref",
            "hook_custom_privacy_ref",

            "hook_account_switcher_update_send_as_ref",
            "hook_account_switcher_set_default_send_as_ref",

            "hook_recent_chats_fragment_drawer_reset_ref",
            "hook_recent_chats_fragment_drawer_click_ref",
            "hook_recent_chats_fragment_drawer_cell_ref",
            "hook_recent_chats_fragment_activity_resume_refs",

            "lifecycle_hook_resume",
            "lifecycle_hook_pause",
        ):
            ref = getattr(self, ref_attr, None)
            if ref:
                if isinstance(ref, list):
                    for r in ref:
                        if r:
                            self.unhook_method(r)
                else:
                    self.unhook_method(ref)
                setattr(self, ref_attr, None)
        
        if self.unhook_send_message:
            self.unhook_method(self.unhook_send_message)
            self.unhook_send_message = None
        if hasattr(self, 'unhook_deeplink') and self.unhook_deeplink:
            self.unhook_method(self.unhook_deeplink)
            self.unhook_deeplink = None
        if hasattr(self, 'unhook_set_command') and self.unhook_set_command:
            self.unhook_method(self.unhook_set_command)
            self.unhook_set_command = None
        if self._unhook_layout:
            self.unhook_method(self._unhook_layout)
            self._unhook_layout = None
        if hasattr(self, 'hook_chat_activity_cleanup_ref') and self.hook_chat_activity_cleanup_ref:
            self.unhook_method(self.hook_chat_activity_cleanup_ref)
            self.hook_chat_activity_cleanup_ref = None

        try:
            self._recent_chats_fragment = None
            self._recent_chats_fragment_visible = False
        except Exception:
            pass

    def _hook_chat_activity_cleanup(self):
        try:
            if self.hook_chat_activity_cleanup_ref:
                return
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            destroy_method = ChatActivityClass.getClass().getDeclaredMethod("onFragmentDestroy")
            destroy_method.setAccessible(True)
            self.hook_chat_activity_cleanup_ref = self.hook_method(
                destroy_method,
                ChatActivityCleanupHook(self)
            )
        except Exception:
            pass

    def _apply_hooks(self):
        self._unhook_all()
        self._hook_chat_activity_cleanup()
        try:
            if (self.get_setting("hide_bot_open", False) or 
                self.get_setting("fab_settings_shortcut", False)):
                self._hook_dialogs_activity()
                if self.get_setting("hide_bot_open", False):
                    self._hook_dialog_cell()
            if self.get_setting("prevent_swipe_while_editing", False) or self.get_setting("prevent_swipe_while_typing", False):
                self._hook_swipe_prevention()
            if self.get_setting("disable_article_viewer_swipe", False):
                self._hook_article_viewer()
            if self.get_setting("prevent_webapp_swipe_down", False):
                self._hook_webapp_swipe_prevention()
            if self.get_setting("enable_code_formatting", False):
                self._hook_code_formatting()
            if self.get_setting("hide_star_reaction", False):
                hide_menu = self.get_setting("star_reaction_hide_menu", False)
                hide_cells = self.get_setting("star_reaction_hide_cells", False)
                
                if hide_menu: 
                    self._hook_star_reaction_menu()
                
                if hide_cells: 
                    self._hook_star_reaction_layout()
            else:
                self._remove_star_reaction_hooks()
            if self.get_setting("always_show_download_manager", False):
                self._hook_download_manager()
            if self.get_setting("always_show_proxy_button", False):
                self._hook_proxy_button()
            if self.get_setting("hide_phone_number", False):
                self._hook_phone_number()
            if self.get_setting("hide_archived_chats", False):
                if self.get_setting("hide_archived_from_drawer", False):
                    self._hook_messages_controller()
                else:
                    self._hook_messages_controller()
                    self._hook_chat_utils_has_archived()
                    self._hook_extera_config_archived()
            if self.get_setting("enable_ai_summarize", False):
                self._hook_ai_summarize()
            if self.get_setting("enable_goto_message", False):
                self._hook_goto_message()
            if self.get_setting("enable_delete_with_duration", False):
                self._hook_delete_with_duration()
            if self.get_setting("dont_auto_play_enabled", False):
                if self.get_setting("dont_auto_play_next_voice", False):
                    self._hook_voice_message_control()
                if self.get_setting("dont_auto_play_next_video", False):
                    self._hook_video_message_control()
            if self.get_setting("unread_badge_on_back_button", False):
                self._hook_unread_badge()
            if self.get_setting("hide_bot_button", False):
                self._hook_update_bot_button()
            if self.get_setting("confirm_forward", True):
                self._hook_forward_confirmation()
            if self.get_setting("confirm_join_chat", False):
                self._hook_join_confirmation()
            if self.get_setting("enable_no_quote_forward", False):
                self._hook_actions_buttons_layout()
            if self.get_setting("typing_instead_sticker", False):
                self._hook_send_typing_method()

            if self.get_setting("hide_birthday_alert", False):
                self._hook_birthday_alert()
            
            if self.get_setting("disable_auto_web_login", False):
                self._hook_disable_auto_web_login()

            if self.get_setting("prefer_common_groups_tab", False):
                self._hook_prefer_common_groups_tab()
            
            if self.get_setting("enable_gif_spoiler", False):
                self._hook_gif_spoiler()
            
            if self.get_setting("enable_confirmation_settings", False) and self.get_setting("confirm_external_links", False):
                self._hook_process_external_url()
            
            if self.get_setting("enable_message_preview_enhancement", False):
                self._hook_message_preview_view()
            
            if self.get_setting("enable_sender_select_enhancement", False):
                self._hook_sender_select_popup()
            
            if self.get_setting("enable_share_sheet_folders", False):
                self._hook_share_sheet_folders()
            
            if self.get_setting("enable_non_clickable_preview", False):
                self._hook_non_clickable_preview()
            
            if self.get_setting("disable_topics_swipe", False):
                self._hook_disable_topic_swipe()
            
            if self.get_setting("enable_account_visibility", False):
                self._hook_account_visibility()
            
            if self.get_setting("enable_add_to_folder_all_tabs", False):
                self._hook_add_to_folder_all_tabs()
            
            if self.get_setting("unread_chat_count", False) or self.get_setting("unread_message_count", False) or self.get_setting("exclude_archived_from_count", False):
                self._hook_unread_count()
            
            if self.get_setting("enable_contact_status_in_profile", False):
                self._hook_contact_status_in_profile()
            
            if self.get_setting("enable_unify_username_behavior", False):
                self._hook_unify_username_behavior()
            
            if self.get_setting("hidefolders_enabled", False):
                self._hook_folder_visibility()
            
            if self.get_setting("enable_search_by_user_id", False):
                self._hook_search_by_user_id()
            
            if self.get_setting("quick_access_gift_market", False):
                self._hook_gift_drawer()

            if self.get_setting("recent_chats_fragment", False):
                self._hook_recent_chats_fragment()
            
            if self.get_setting("enable_ai_role_limit", False):
                self._hook_ai_role_limit()
            
            if self.get_setting("enable_select_all_media", False):
                self._hook_select_all_media()
            
            if self.get_setting("always_visible_schedule_button", False):
                self._hook_always_visible_schedule_button()

            if self.get_setting("enable_sleep_timer", False):
                self._hook_sleep_timer()
            
            if self.get_setting("enable_adaptive_audio_length", False):
                self._hook_adaptive_audio_length()
            
            if self.get_setting("enable_music_speed_control", False):
                self._hook_music_speed_control()
            
            if self.get_setting("enable_custom_saved_messages", False):
                self._hook_custom_saved_messages()
            
            if self.get_setting("disable_emoji_suggestions", False):
                self._hook_disable_emoji_suggestions()
            
            if self.get_setting("enable_message_repeat", False):
                self._update_message_repeat_menu_item()
            
            if self.get_setting("swipe_action", 0) != 0:
                self._hook_message_swipe_action()
            
            if self.get_setting("remove_greeting_sticker", False):
                self._hook_remove_greeting_sticker()
            
            if self.get_setting("remove_https_from_links", False):
                self._hook_remove_https_from_links()
            
            if self.get_setting("enable_join_request_direct_profile", False):
                self._hook_join_request_direct_profile()
            
            if self.get_setting("enable_search_filter", False):
                self._hook_search_filter()
            
            if self.get_setting("notification_sound", 1) != 1 or self.get_setting("in_chat_vibration", 0) != 0:
                self._ensure_ios_sound()
                self._hook_play_in_chat_sound()
                if self.get_setting("notification_sound", 1) == 2:
                    self._hook_soundpool_load()
            
            if self.get_setting("disable_link_preview", False):
                self._hook_disable_link_preview()
            
            if self.get_setting("pinned_reactions_enabled_chats", "true") == "true" or self.get_setting("pinned_reactions_enabled_channels", "true") == "true":
                self._hook_pinned_reactions()
            
            if self.get_setting("enable_share_alert_forward", False):
                self._hook_share_alert_forward()
            
            if self.get_setting("enable_edit_file_name", False):
                self._hook_edit_file_name()
            
            if self.get_setting("send_comments_after_forward", False):
                self._hook_send_comments_after_forward()
            
            if self.get_setting("hide_via_bot", False):
                self._hook_hide_via_bot()

            if self.get_setting("manual_translation_behavior", 0) == 1:
                self._hook_in_message_translation()

            if self.get_setting("show_owner_channels", False):
                self._hook_owner_channels()

            if self.get_setting("remove_from_folders_on_leave", False):
                self._hook_remove_from_folders()

            if self.get_setting("enable_bookmark_chat", False):
                self._hook_bookmark_chat()

            if self.get_setting("custom_privacy", False):
                self._hook_custom_privacy()

            if self.get_setting("enable_account_switcher", False):
                self._hook_account_switcher()



        except Exception as e:
            pass



    def _hook_account_switcher(self):
        try:
            if self.hook_account_switcher_update_send_as_ref:
                return
            clazz = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            for m in clazz.getClass().getDeclaredMethods():
                if m.getName() == "updateSendAsButton" and len(m.getParameterTypes()) == 2:
                    m.setAccessible(True)
                    self.hook_account_switcher_update_send_as_ref = self.hook_method(m, _AccountSwitcherUpdateSendAsHook(self))
                    break
            clazz2 = find_class("org.telegram.messenger.MessagesController")
            for m in clazz2.getClass().getDeclaredMethods():
                if m.getName() == "setDefaultSendAs" and len(m.getParameterTypes()) == 2:
                    m.setAccessible(True)
                    self.hook_account_switcher_set_default_send_as_ref = self.hook_method(m, _AccountSwitcherSetDefaultSendAsHook(self))
                    break
        except:
            pass

    def _account_switcher_get_accounts(self):
        accounts = []
        for i in range(16):
            cfg = UserConfig.getInstance(i)
            if cfg and cfg.isClientActivated():
                u = cfg.getCurrentUser()
                if u:
                    accounts.append((i, u))
        return accounts

    def _account_switcher_setup_for_private_chat(self, enter_view):
        try:
            from org.telegram.ui.Components import SenderSelectView, LayoutHelper
            from org.telegram.tgnet import TLRPC
            vid = id(enter_view)
            pf = get_private_field(enter_view, "parentFragment")
            if not pf:
                return
            cu = get_private_field(pf, "currentUser")
            if not cu:
                return
            if cu.bot:
                return
            my_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
            if cu.id == my_id:
                return
            accounts = self._account_switcher_get_accounts()
            if len(accounts) <= 1:
                return
            ssv = get_private_field(enter_view, "senderSelectView")
            if ssv:
                dialog_id = pf.getDialogId()
                frag_account = get_private_field(pf, "currentAccount")
                if frag_account is not None:
                    view_account = frag_account
                else:
                    view_account = self._account_switcher_chat_view_accounts.get(dialog_id, UserConfig.selectedAccount)
                view_user = UserConfig.getInstance(view_account).getCurrentUser()
                if view_user:
                    ssv.setAvatar(view_user)
            if vid in self._account_switcher_hooked_views:
                return
            self._account_switcher_chat_info = {
                'dialog_id': pf.getDialogId(),
                'user_id': cu.id,
                'user': cu
            }
            peers = TLRPC.TL_channels_sendAsPeers()
            peers.peers = ArrayList()
            for acc_num, user in accounts:
                sp = TLRPC.TL_sendAsPeer()
                sp.peer = TLRPC.TL_peerUser()
                sp.peer.user_id = user.id
                sp.premium_required = False
                peers.peers.add(sp)
                self._account_switcher_user_to_account[user.id] = acc_num
            if not ssv:
                ctx = enter_view.getContext()
                ssv = SenderSelectView(ctx)
                my_user = UserConfig.getInstance(UserConfig.selectedAccount).getCurrentUser()
                if my_user:
                    ssv.setAvatar(my_user)
                ssv.setVisibility(View.VISIBLE)
                container = get_private_field(enter_view, "messageEditTextContainer")
                if container:
                    container.addView(ssv, LayoutHelper.createFrame(32, 32, Gravity.BOTTOM | Gravity.LEFT, 8, 8, 8, 8))
                    set_private_field(enter_view, "senderSelectView", ssv)
                    plugin = self
                    ev = enter_view
                    parent_frag = pf
                    p = peers
                    ssv.setOnClickListener(OnClickListener(lambda v: plugin._account_switcher_show_popup(ev, parent_frag, p, v)))
            self._account_switcher_hooked_views.add(vid)
        except:
            pass

    def _account_switcher_show_popup(self, enter_view, parent_fragment, peers, anchor_view):
        try:
            from android.util import TypedValue
            from android.graphics import PorterDuff, PorterDuffColorFilter, Rect
            from org.telegram.ui.ActionBar import Theme, ActionBarPopupWindow
            from org.telegram.ui.Components import SimpleAvatarView
            from org.telegram.messenger import R, AndroidUtilities, UserObject
            from com.exteragram.messenger import ExteraConfig
            from androidx.dynamicanimation.animation import SpringAnimation, DynamicAnimation
            from android.widget import PopupWindow
            try:
                anchor_view.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
            except:
                pass
            ctx = enter_view.getContext()
            current_account = get_private_field(enter_view, "currentAccount")
            container = FrameLayout(ctx)
            container.setLayoutParams(LayoutHelper.createFrame(-2, -2))
            bg = ctx.getResources().getDrawable(R.drawable.popup_fixed_alert3).mutate()
            bg.setColorFilter(PorterDuffColorFilter(Theme.getColor(Theme.key_actionBarDefaultSubmenuBackground), PorterDuff.Mode.MULTIPLY))
            container.setBackground(bg)
            padding = Rect()
            bg.getPadding(padding)
            container.setPadding(padding.left, padding.top, padding.right, padding.bottom)
            linear = LinearLayout(ctx)
            linear.setOrientation(LinearLayout.VERTICAL)
            container.addView(linear)
            header = TextView(ctx)
            header.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            header.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            header.setText("Switch Account")
            header.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            header.setPadding(AndroidUtilities.dp(18), AndroidUtilities.dp(10), AndroidUtilities.dp(18), AndroidUtilities.dp(10))
            linear.addView(header)
            accounts = self._account_switcher_get_accounts()
            AVATAR_SIZE = 40
            for acc_num, user in accounts:
                is_current = (acc_num == UserConfig.selectedAccount)
                item = LinearLayout(ctx)
                item.setOrientation(LinearLayout.HORIZONTAL)
                item.setGravity(Gravity.CENTER_VERTICAL)
                item.setPadding(AndroidUtilities.dp(14), AndroidUtilities.dp(7), AndroidUtilities.dp(14), AndroidUtilities.dp(7))
                if not is_current:
                    item.setBackgroundDrawable(Theme.createSelectorDrawable(Theme.getColor(Theme.key_listSelector), 2))
                avatar = SimpleAvatarView(ctx)
                avatar.setAvatarCorners(ExteraConfig.getAvatarCorners(AVATAR_SIZE))
                avatar.setAvatar(user)
                item.addView(avatar, LayoutHelper.createLinear(AVATAR_SIZE, AVATAR_SIZE))
                text_container = LinearLayout(ctx)
                text_container.setOrientation(LinearLayout.VERTICAL)
                item.addView(text_container, LayoutHelper.createLinear(0, -1, 1.0, 12, 0, 0, 0))
                name = TextView(ctx)
                name.setTextColor(Theme.getColor(Theme.key_actionBarDefaultSubmenuItem))
                name.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                name.setMaxLines(1)
                name.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                name.setText(UserObject.getUserName(user))
                text_container.addView(name)
                phone_text = TextView(ctx)
                from androidx.core.graphics import ColorUtils
                phone_text.setTextColor(ColorUtils.setAlphaComponent(Theme.getColor(Theme.key_actionBarDefaultSubmenuItem), 0x66))
                phone_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
                phone_text.setMaxLines(1)
                from android.text import TextUtils
                phone_text.setEllipsize(TextUtils.TruncateAt.END)
                if user.username:
                    phone_text.setText(f"@{user.username}")
                else:
                    phone_text.setText(f"Account {acc_num}")
                text_container.addView(phone_text)
                linear.addView(item, LayoutHelper.createLinear(-1, -2))
                plugin = self
                captured_acc = acc_num
                def make_click_listener(acc_to_switch):
                    return OnClickListener(lambda v: plugin._account_switcher_on_item_click(acc_to_switch))
                item.setOnClickListener(make_click_listener(captured_acc))
            self._account_switcher_popup = ActionBarPopupWindow(container, -2, -2)
            self._account_switcher_popup.setDismissAnimationDuration(220)
            self._account_switcher_popup.setOutsideTouchable(True)
            self._account_switcher_popup.setClippingEnabled(True)
            self._account_switcher_popup.setFocusable(True)
            self._account_switcher_popup.setInputMethodMode(ActionBarPopupWindow.INPUT_METHOD_NOT_NEEDED)
            self._account_switcher_popup.setAnimationEnabled(False)
            ssv_ref = get_private_field(enter_view, "senderSelectView")
            class DismissListener(dynamic_proxy(PopupWindow.OnDismissListener)):
                def onDismiss(self):
                    if ssv_ref:
                        ssv_ref.setProgress(0)
            self._account_switcher_popup.setOnDismissListener(DismissListener())
            container.measure(
                View.MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000), View.MeasureSpec.AT_MOST),
                View.MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000), View.MeasureSpec.AT_MOST)
            )
            location = [0, 0]
            anchor_view.getLocationInWindow(location)
            height = container.getMeasuredHeight()
            x = location[0] - AndroidUtilities.dp(4)
            y = location[1] - height - AndroidUtilities.dp(4)
            ssv = get_private_field(enter_view, "senderSelectView")
            if ssv:
                ssv.setProgress(1)
            self._account_switcher_popup.showAtLocation(anchor_view, Gravity.LEFT | Gravity.TOP, x, y)
            container.setPivotX(AndroidUtilities.dp(8))
            container.setPivotY(container.getMeasuredHeight() - AndroidUtilities.dp(8))
            SPRING_STIFFNESS = 750.0
            SCALE_START = 0.5
            container.setScaleX(SCALE_START)
            container.setScaleY(SCALE_START)
            container.setAlpha(SCALE_START)
            spring_x = SpringAnimation(container, DynamicAnimation.SCALE_X, 1.0)
            spring_x.getSpring().setStiffness(SPRING_STIFFNESS)
            spring_x.getSpring().setDampingRatio(1.0)
            spring_x.start()
            spring_y = SpringAnimation(container, DynamicAnimation.SCALE_Y, 1.0)
            spring_y.getSpring().setStiffness(SPRING_STIFFNESS)
            spring_y.getSpring().setDampingRatio(1.0)
            spring_y.start()
            spring_alpha = SpringAnimation(container, DynamicAnimation.ALPHA, 1.0)
            spring_alpha.getSpring().setStiffness(SPRING_STIFFNESS)
            spring_alpha.getSpring().setDampingRatio(1.0)
            spring_alpha.start()
        except:
            pass

    def _account_switcher_on_item_click(self, acc_to_switch):
        if self._account_switcher_popup:
            self._account_switcher_popup.dismiss()
            self._account_switcher_popup = None
        self._account_switcher_switch_to_account(acc_to_switch)

    def _account_switcher_switch_to_account(self, acc):
        try:
            if not self._account_switcher_chat_info:
                return
            target_user_id = self._account_switcher_chat_info['user_id']
            target_user = self._account_switcher_chat_info.get('user')
            dialog_id = self._account_switcher_chat_info['dialog_id']
            self._account_switcher_chat_view_accounts[dialog_id] = acc
            self._account_switcher_hooked_views.clear()
            try:
                f = get_last_fragment()
                if not f:
                    return
                if target_user:
                    target_mc = MessagesController.getInstance(acc)
                    target_mc.putUser(target_user, False)
                args = Bundle()
                args.putLong("user_id", target_user_id)
                new_chat = ChatActivity(args)
                new_chat.setCurrentAccount(acc)
                ConnectionsManagerClass = find_class("org.telegram.tgnet.ConnectionsManager")
                if ConnectionsManagerClass:
                    ConnectionsManagerClass.getInstance(acc).setAppPaused(False, False)
                f.presentFragment(new_chat, True)
            except:
                pass
        except:
            pass

    def _add_reply_private_chat_menu_item(self):
        try:
            self.reply_private_chat_menu_handle = quantahut.utilities.register_message_menu_item(
                text=getString("reply_in_private_chat", "Reply in private chat"),
                option_id=2033,
                icon_res=R_tg.drawable.msg_reply_solar,
                condition_predicate=lambda m: (m is not None and not m.isOut() and self._is_group_chat(m) and hasattr(m.messageOwner.from_id, 'user_id') and m.messageOwner.from_id.user_id),
                on_click=self._on_reply_private_chat_click,
                insert_at_top=True
            )
        except Exception:
            pass

    def _remove_reply_private_chat_menu_item(self):
        try:
            if hasattr(self, 'reply_private_chat_menu_handle') and self.reply_private_chat_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.reply_private_chat_menu_handle)
                self.reply_private_chat_menu_handle = None
        except Exception:
            pass

    def _update_reply_private_chat_menu_item(self):
        if self.get_setting("enable_reply_private_chat", False):
            if not hasattr(self, 'reply_private_chat_menu_item_id') or not self.reply_private_chat_menu_item_id:
                self._add_reply_private_chat_menu_item()
        else:
            self._remove_reply_private_chat_menu_item()

    def _is_group_chat(self, message):
        try:
            if not message or not message.messageOwner:
                return False
            chat_id = message.messageOwner.peer_id.channel_id if hasattr(message.messageOwner.peer_id, 'channel_id') and message.messageOwner.peer_id.channel_id else message.messageOwner.peer_id.chat_id if hasattr(message.messageOwner.peer_id, 'chat_id') and message.messageOwner.peer_id.chat_id else 0
            return chat_id != 0
        except Exception:
            return False
    
    def _on_reply_private_chat_click(self, chat_activity, message):
        try:
            if not message or not chat_activity:
                return
            sender_id = message.messageOwner.from_id.user_id if message.messageOwner.from_id else 0
            if not sender_id:
                return
            from android.os import Bundle
            chat_args = Bundle()
            chat_args.putLong("user_id", sender_id)
            private_chat = ChatActivity(chat_args)
            chat_activity.presentFragment(private_chat)
            try:
                if (getattr(private_chat, 'chatActivityEnterView', None) is not None and 
                    getattr(chat_activity, 'chatActivityEnterView', None) is not None):
                    original_text = chat_activity.chatActivityEnterView.getFieldText()
                    if original_text:
                        private_chat.chatActivityEnterView.setFieldText(original_text)
                private_chat.replyingTopMessage = message
                private_chat.showFieldPanelForReplyQuote(message, None)
            except Exception:
                pass
        except Exception:
            pass
    
    
    def _add_no_quote_forward_menu_item(self):
        try:
            self.no_quote_forward_menu_handle = quantahut.utilities.register_message_menu_item(
                text=getString("no_quote_forward", "NoQuote forward"),
                option_id=9999,
                icon_res=R_tg.drawable.media_share,
                condition_predicate=lambda m: m is not None and not self._is_service_message(m) and not self._is_failed_message(m) and not self._is_scheduled_message(m),
                on_click=self._on_no_quote_forward_click,
                insert_at_top=True
            )
        except Exception:
            pass

    def _is_service_message(self, message):
        try:
            from org.telegram.tgnet import TLRPC
            return message and hasattr(message, 'messageOwner') and isinstance(message.messageOwner, TLRPC.TL_messageService)
        except Exception:
            return False
    
    def _is_failed_message(self, message):
        try:
            if not message or not hasattr(message, 'messageOwner') or not message.messageOwner:
                return False
            
            message_owner = message.messageOwner
            return (hasattr(message_owner, 'send_state') and message_owner.send_state == 2) or \
                   (hasattr(message_owner, 'id') and message_owner.id < 0)
        except Exception:
            return False
    
    def _is_scheduled_message(self, message):
        try:
            return message and hasattr(message, 'scheduled') and message.scheduled
        except Exception:
            return False

    def _remove_no_quote_forward_menu_item(self):
        try:
            if hasattr(self, 'no_quote_forward_menu_handle') and self.no_quote_forward_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.no_quote_forward_menu_handle)
                self.no_quote_forward_menu_handle = None
        except Exception:
            pass

    def _update_no_quote_forward_menu_item(self):
        if self.get_setting("enable_no_quote_forward", False):
            if not hasattr(self, 'no_quote_forward_menu_handle') or not self.no_quote_forward_menu_handle:
                self._add_no_quote_forward_menu_item()
        else:
            self._remove_no_quote_forward_menu_item()

    def _on_no_quote_forward_click(self, chat_activity, message):
        if not chat_activity:
            return
            
        from java.util import ArrayList
        messages_to_forward = ArrayList()
        
        if message and hasattr(message, 'getGroupId') and message.getGroupId() != 0:
            group_id = message.getGroupId()
            
            try:
                messagesDict = get_private_field(chat_activity, "messagesDict")
                if messagesDict is not None and len(messagesDict) > 0:
                    for a in range(len(messagesDict)):
                        if messagesDict[a] is None:
                            continue
                        msg_dict = messagesDict[a]
                        
                        keys_to_check = []
                        try:
                            size = msg_dict.size()
                            for idx in range(size):
                                keys_to_check.append(msg_dict.keyAt(idx))
                        except:
                            pass
                        
                        for key in keys_to_check:
                            try:
                                msg = msg_dict.get(key)
                                if msg and hasattr(msg, 'getGroupId') and msg.getGroupId() == group_id:
                                    messages_to_forward.add(msg)
                            except:
                                pass
                else:
                    messages_to_forward.add(message)
            except:
                messages_to_forward.add(message)
        else:
            if message:
                messages_to_forward.add(message)
        
        if messages_to_forward.size() == 0 and hasattr(chat_activity, 'selectedObjects') and chat_activity.selectedObjects:
            for obj in chat_activity.selectedObjects:
                messages_to_forward.add(obj)
        
        if messages_to_forward.size() == 0 and message:
            messages_to_forward.add(message)
        
        if not messages_to_forward or messages_to_forward.size() == 0:
            return
        
        if hasattr(chat_activity, 'getCurrentChat') and chat_activity.getCurrentChat():
            current_chat = chat_activity.getCurrentChat()
            if chat_activity.getMessagesController().isChatNoForwards(current_chat):
                return
        
        from android.os import Bundle
        
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("canSelectTopics", True)
        args.putInt("dialogsType", 3)
        
        dialogs_fragment = DialogsActivity(args)
        
        from java import dynamic_proxy
        
        class NoQuoteForwardDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
            def __init__(self, messages, chat_activity, plugin_instance):
                super().__init__()
                self.messages = messages
                self.chat_activity = chat_activity
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def didSelectDialogs(self, fragment1, dids, message_text, *args):
                plugin = self.plugin_ref()
                if plugin is None or self.chat_activity is None:
                    return True
                    
                if dids.size() > 1 or dids.get(0).dialogId == self.chat_activity.getUserConfig().getClientUserId() or message_text:
                    for i in range(dids.size()):
                        dialog = dids.get(i)
                        did = dialog.dialogId
                        topic_id = dialog.topicId if hasattr(dialog, 'topicId') and dialog.topicId else 0
                        
                        send_helper = self.chat_activity.getSendMessagesHelper()
                        if send_helper:
                            send_helper.sendMessage(self.messages, did, True, False, True, topic_id, 0)
                    
                    fragment1.finishFragment()
                    
                    if dids.size() > 1:
                        from org.telegram.messenger import LocaleController, AndroidUtilities
                        messages_count = self.messages.size() if self.messages else 1
                        if messages_count <= 1:
                            text = AndroidUtilities.replaceTags(LocaleController.formatPluralString("FwdMessageToManyChats", dids.size()))
                        else:
                            text = AndroidUtilities.replaceTags(LocaleController.formatPluralString("FwdMessagesToManyChats", dids.size()))
                        from ui.bulletin import BulletinHelper
                        from org.telegram.messenger import R as R_tg
                        BulletinHelper.show_simple(text, R_tg.raw.forward, self.chat_activity)
                    
                else:
                    did = dids.get(0).dialogId
                    args1 = Bundle()

                    args1.putBoolean("scrollToTopOnResume", True)
                    
                    if DialogObject.isEncryptedDialog(did):
                        args1.putInt("enc_id", DialogObject.getEncryptedChatId(did))
                    elif DialogObject.isUserDialog(did):
                        args1.putLong("user_id", did)
                    else:
                        args1.putLong("chat_id", -did)
                    
                    if not self.chat_activity.getMessagesController().checkCanOpenChat(args1, fragment1):
                        return True
                    
                    self.chat_activity.getNotificationCenter().postNotificationName(NotificationCenter.closeChats)
                    
                    new_chat_activity = ChatActivity(args1)
                    
                    ForumUtilities = plugin._get_class("org.telegram.ui.Components.Forum.ForumUtilities")
                    if ForumUtilities:
                        ForumUtilities.applyTopic(new_chat_activity, dids.get(0))
                    
                    fragment1.presentFragment(new_chat_activity, True)

                    new_chat_activity.showFieldPanelForForward(True, self.messages)
                    params = get_private_field(new_chat_activity, "messagePreviewParams")
                    if params is not None:
                        try:
                            set_private_field(params, "hideForwardSendersName", True)
                        except:
                            pass
                
                return True
            
            def canSelectStories(self):
                return False
        
        delegate = NoQuoteForwardDelegate(messages_to_forward, chat_activity, self)
        dialogs_fragment.setDelegate(delegate)
        
        chat_activity.presentFragment(dialogs_fragment)

        self.current_mode = "forward"

    def _open_no_quote_forward(self, ca):
        self._open_custom_forward(ca, False)

    def _open_hide_caption_forward(self, ca):
        self._open_custom_forward(ca, True)

    def _open_custom_forward(self, ca, hide_cap):
        try:
            msgs = self._collect_selected_messages(ca)
            if not msgs or msgs.size() == 0:
                return
            
            if hasattr(ca, 'getCurrentChat') and ca.getCurrentChat():
                if ca.getMessagesController().isChatNoForwards(ca.getCurrentChat()):
                    return
            
            from android.os import Bundle
            args = Bundle()
            args.putBoolean("onlySelect", True)
            args.putBoolean("canSelectTopics", True)
            args.putInt("dialogsType", 3)
            
            frag = DialogsActivity(args)
            
            from java import dynamic_proxy
            
            class FwdDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
                def __init__(s, m, c, p, hc):
                    super().__init__()
                    s.m = m
                    s.c = c
                    s.p = weakref.ref(p)
                    s.hc = hc
                
                def didSelectDialogs(s, f, dids, txt, *args):
                    pl = s.p()
                    if pl is None:
                        return True
                    
                    if dids.size() > 1 or dids.get(0).dialogId == s.c.getUserConfig().getClientUserId() or txt:
                        for i in range(dids.size()):
                            d = dids.get(i)
                            tid = d.topicId if hasattr(d, 'topicId') and d.topicId else 0
                            sh = s.c.getSendMessagesHelper()
                            if sh:
                                sh.sendMessage(s.m, d.dialogId, True, False, True, tid, 0)
                        
                        f.finishFragment()
                        
                        if dids.size() > 1:
                            from org.telegram.messenger import LocaleController, AndroidUtilities
                            cnt = s.m.size() if s.m else 1
                            key = "FwdMessageToManyChats" if cnt <= 1 else "FwdMessagesToManyChats"
                            txt = AndroidUtilities.replaceTags(LocaleController.formatPluralString(key, dids.size()))
                            from ui.bulletin import BulletinHelper
                            from org.telegram.messenger import R as R_tg
                            BulletinHelper.show_simple(txt, R_tg.raw.forward, s.c)
                    else:
                        did = dids.get(0).dialogId
                        a1 = Bundle()
                        a1.putBoolean("scrollToTopOnResume", True)
                        
                        if DialogObject.isEncryptedDialog(did):
                            a1.putInt("enc_id", DialogObject.getEncryptedChatId(did))
                        elif DialogObject.isUserDialog(did):
                            a1.putLong("user_id", did)
                        else:
                            a1.putLong("chat_id", -did)
                        
                        if not s.c.getMessagesController().checkCanOpenChat(a1, f):
                            return True
                        
                        s.c.getNotificationCenter().postNotificationName(NotificationCenter.closeChats)
                        
                        nca = ChatActivity(a1)
                        
                        FU = pl._get_class("org.telegram.ui.Components.Forum.ForumUtilities")
                        if FU:
                            FU.applyTopic(nca, dids.get(0))
                        
                        f.presentFragment(nca, True)
                        nca.showFieldPanelForForward(True, s.m)
                        pr = get_private_field(nca, "messagePreviewParams")
                        if pr:
                            try:
                                set_private_field(pr, "hideForwardSendersName", True)
                                if s.hc:
                                    set_private_field(pr, "hideCaption", True)
                            except:
                                pass
                    
                    return True
                
                def canSelectStories(s):
                    return False
            
            frag.setDelegate(FwdDelegate(msgs, ca, self, hide_cap))
            ca.presentFragment(frag)
        except Exception:
            pass

    def _collect_selected_messages(self, chat_activity):
        try:
            from java.util import ArrayList
            selectedIds = get_private_field(chat_activity, "selectedMessagesIds")
            messagesDict = get_private_field(chat_activity, "messagesDict")
            arr = ArrayList()
            if selectedIds is not None and messagesDict is not None:
                for a in range(2):
                    ids = selectedIds[a]
                    if ids is None:
                        continue
                    size = ids.size()
                    keys = []
                    for idx in range(size):
                        keys.append(ids.keyAt(idx))
                    try:
                        keys.sort()
                    except Exception:
                        pass
                    for key in keys:
                        msg = messagesDict[a].get(key)
                        if msg is not None:
                            arr.add(msg)
            return arr
        except Exception:
            return None


    def _can_use_repeat(self, message):
        try:
            if not message or not message.messageOwner:
                return True
            
            from client_utils import get_messages_controller
            mc = get_messages_controller()
            if not mc:
                return True
            
            if mc.isChatNoForwards(message.getChatId()):
                return False
            
            if message.messageOwner.noforwards:
                return False
            
            chat_id = message.getChatId()
            if chat_id != 0:
                chat = mc.getChat(chat_id)
                if chat:
                    ChatObject = find_class("org.telegram.messenger.ChatObject")
                    if ChatObject.isChannel(chat) and not ChatObject.isMegagroup(chat):
                        return ChatObject.canPost(chat)
            return True
        except Exception:
            return True

    def _add_message_repeat_menu_item(self):
        try:
            self.repeat_menu_handle = quantahut.utilities.register_message_menu_item(
                text=getString("message_repeat", "Repeat"),
                option_id=2035,
                icon_res=R_tg.drawable.msg_addbot_solar,
                condition_predicate=lambda m: (
                    m is not None and 
                    not self._is_service_message(m) and 
                    not self._is_failed_message(m) and 
                    not self._is_scheduled_message(m) and
                    self._can_use_repeat(m)
                ),
                on_click=self._on_message_repeat_click,
                insert_at_top=False
            )
        except Exception:
            pass

    def _remove_message_repeat_menu_item(self):
        try:
            if hasattr(self, 'repeat_menu_handle') and self.repeat_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.repeat_menu_handle)
                self.repeat_menu_handle = None
        except Exception:
            pass

    def _update_message_repeat_menu_item(self):
        if self.get_setting("enable_message_repeat", False):
            if not hasattr(self, 'repeat_menu_handle') or not self.repeat_menu_handle:
                self._add_message_repeat_menu_item()
        else:
            self._remove_message_repeat_menu_item()

    def _on_message_repeat_click(self, chat_activity, message, grouped_messages=None):
        try:
            if not message or not chat_activity:
                return
            
            current_account = get_account_instance().getCurrentAccount()
            send_helper = SendMessagesHelper.getInstance(current_account)
            account_instance = AccountInstance.getInstance(current_account)
            
            try:
                dialog_id = chat_activity.getDialogId()
            except Exception:
                return
            
            topic_id = 0
            try:
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'getTopicId'):
                    topic_id = current_fragment.getTopicId()
            except Exception:
                pass
            
            reply_to_msg = None
            if topic_id != 0:
                try:
                    topic = account_instance.getMessagesController().getTopicsController().findTopic(-dialog_id, topic_id)
                    if topic and topic.topicStartMessage:
                        reply_to_msg = MessageObject(current_account, topic.topicStartMessage, False, False)
                        reply_to_msg.isTopicMainMessage = True
                except Exception:
                    pass
            
            from java.util import ArrayList
            messages_to_forward = ArrayList()
            
            if grouped_messages and not grouped_messages.isDocuments:
                for msg in grouped_messages.messages:
                    messages_to_forward.add(msg)
            else:
                messages_to_forward.add(message)
            
            send_helper.sendMessage(
                messages_to_forward,
                dialog_id,
                False,
                False,
                True,
                0,
                reply_to_msg,
                topic_id,
                0,
                0,
                None
            )
        except Exception:
            pass

    
    def _hook_actions_buttons_layout(self):
        try:
            ChatActivityActionsButtonsLayoutClass = self._get_class(
                "org.telegram.ui.Components.chat.layouts.ChatActivityActionsButtonsLayout"
            )
            
            if ChatActivityActionsButtonsLayoutClass is None:
                return
            
            ContextClass = self._get_class("android.content.Context")
            ResourcesProviderClass = self._get_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            ColorProviderClass = self._get_class("org.telegram.ui.Components.blur3.drawable.color.BlurredBackgroundColorProvider")
            BlurredBackgroundDrawableViewFactoryClass = self._get_class("org.telegram.ui.Components.blur3.BlurredBackgroundDrawableViewFactory")
            
            constructor = ChatActivityActionsButtonsLayoutClass.getClass().getDeclaredConstructor(
                ContextClass,
                ResourcesProviderClass,
                ColorProviderClass,
                BlurredBackgroundDrawableViewFactoryClass
            )
            constructor.setAccessible(True)
            
            class LayoutConstructorHook:
                def __init__(hook_self):
                    hook_self.plugin = self
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(hook_self, param):
                    try:
                        layout = param.thisObject
                        hook_self.plugin._setup_forward_button(layout)
                        hook_self.plugin._hook_add_to_selected_messages(layout)
                    except Exception as e:
                        pass
            
            self._unhook_layout = self.hook_method(constructor, LayoutConstructorHook())
            
        except Exception as e:
            pass
    
    def _setup_forward_button(self, layout):
        try:
            ViewOnClickListenerClass = self._get_class("android.view.View$OnClickListener")
            setForwardButtonMethod = layout.getClass().getDeclaredMethod(
                "setForwardButtonOnClickListener",
                ViewOnClickListenerClass
            )
            setForwardButtonMethod.setAccessible(True)
            
            plugin_ref = self
            
            class SetForwardListenerHook:
                def __init__(hook_self):
                    hook_self.plugin = plugin_ref
                    hook_self.layout = layout
                
                @hook_filters(HookFilter.ArgumentNotNull(0))
                def before_hooked_method(hook_self, param):
                    try:
                        original_listener = param.args[0]
                        
                        def open_old_share_sheet():
                            try:
                                from client_utils import get_last_fragment
                                from java.lang import Boolean
                                chat_activity = get_last_fragment()
                                if chat_activity:
                                    openForwardMethod = chat_activity.getClass().getDeclaredMethod("openForward", Boolean.TYPE)
                                    openForwardMethod.setAccessible(True)
                                    openForwardMethod.invoke(chat_activity, True)
                            except Exception as e:
                                pass
                        
                        def wrapped_click(view):
                            try:
                                plugin = hook_self.plugin
                                use_old_share_sheet = plugin.get_setting("enable_old_forward", False)
                                
                                if plugin.current_mode == "no_quote":
                                    from client_utils import get_last_fragment
                                    chat_activity = get_last_fragment()
                                    if chat_activity:
                                        plugin._open_no_quote_forward(chat_activity)
                                    return
                                elif plugin.current_mode == "hide_caption":
                                    from client_utils import get_last_fragment
                                    chat_activity = get_last_fragment()
                                    if chat_activity:
                                        plugin._open_hide_caption_forward(chat_activity)
                                    return
                                
                                if use_old_share_sheet:
                                    open_old_share_sheet()
                                else:
                                    if original_listener is not None:
                                        original_listener.onClick(view)
                            except Exception as e:
                                if original_listener is not None:
                                    original_listener.onClick(view)
                        
                        param.args[0] = OnClickListener(wrapped_click)
                    except Exception as e:
                        pass
            
            self.hook_method(setForwardButtonMethod, SetForwardListenerHook())
            
            forward_button = layout.getForwardButton()
            
            if forward_button is None:
                return
            
            def on_forward_long_click(view):
                try:
                    plugin_ref._perform_haptic(layout)
                    plugin_ref._show_mode_selector_dialog(view, layout)
                    return True
                except Exception as e:
                    return False
            
            forward_button.setOnLongClickListener(OnLongClickListener(on_forward_long_click))
            self._update_forward_button_text(layout)
            
            self._hook_open_forward()
            
        except Exception as e:
            pass
    
    def _hook_open_forward(self):
        try:
            if self.hook_open_forward_ref:
                return
            
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            from java.lang import Boolean
            openForwardMethod = ChatActivityClass.getClass().getDeclaredMethod("openForward", Boolean.TYPE)
            openForwardMethod.setAccessible(True)
            
            plugin_ref = self
            
            class OpenForwardHook:
                def __init__(hook_self):
                    super().__init__(plugin_ref)
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def before_hooked_method(hook_self, param):
                    try:
                        plugin = hook_self.plugin
                        if plugin is None:
                            return
                        
                        if plugin._forward_from_button:
                            if plugin.current_mode in ("no_quote", "hide_caption"):
                                plugin._active_forward_mode = plugin.current_mode
                            else:
                                plugin._active_forward_mode = None
                        else:
                            plugin._active_forward_mode = None
                        
                        plugin._forward_from_button = False
                    except Exception:
                        pass
            
            self.hook_open_forward_ref = self.hook_method(openForwardMethod, OpenForwardHook())
        except Exception:
            pass
    
    def _hook_add_to_selected_messages(self, layout):
        try:
            addToSelectedMessagesMethod = layout.getClass().getDeclaredMethod(
                "addToSelectedMessages",
                find_class("org.telegram.messenger.MessageObject")
            )
            addToSelectedMessagesMethod.setAccessible(True)
            
            plugin_ref = self
            
            class AddToSelectedMessagesHook:
                def __init__(hook_self):
                    super().__init__(plugin_ref)
                
                @hook_filters(HookFilter.ArgumentNotNull(0))
                def before_hooked_method(hook_self, param):
                    try:
                        message = param.args[0]
                        if message is None:
                            hook_self.plugin.current_mode = "forward"
                    except Exception:
                        pass
            
            self.hook_method(addToSelectedMessagesMethod, AddToSelectedMessagesHook())
        except Exception as e:
            pass
    
    def _show_mode_selector_dialog(self, button_view, layout):
        def show_dialog():
            try:
                from android.widget import LinearLayout
                from org.telegram.ui.ActionBar import AlertDialog, Theme
                from org.telegram.messenger import AndroidUtilities
                
                self.current_mode = self.get_setting("forward_mode", "forward")
                
                context = button_view.getContext()
                
                builder = AlertDialog.Builder(context)
                builder.setTitle(getString("forward_mode", "Forward Mode"))
                
                linear_layout = LinearLayout(context)
                linear_layout.setOrientation(LinearLayout.VERTICAL)
                builder.setView(linear_layout)
                
                options = [getString("forward_option", "Forward"), getString("no_quote_option", "No Quote"), getString("hide_caption_option", "Hide Caption")]
                current_index = 0 if self.current_mode == "forward" else (1 if self.current_mode == "no_quote" else 2)
                
                RadioColorCellClass = find_class("org.telegram.ui.Cells.RadioColorCell")
                
                for i in range(len(options)):
                    cell = RadioColorCellClass(context)
                    cell.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
                    cell.setTag(i)
                    cell.setCheckColor(
                        Theme.getColor(Theme.key_radioBackground),
                        Theme.getColor(Theme.key_dialogRadioBackgroundChecked)
                    )
                    cell.setTextAndValue(options[i], i == current_index)
                    cell.setBackground(Theme.getSelectorDrawable(False))
                    linear_layout.addView(cell)
                    
                    plugin_ref = self
                    layout_ref = layout
                    
                    def create_click_listener(index):
                        def on_click(v):
                            try:
                                if index == 0:
                                    plugin_ref.current_mode = "forward"
                                elif index == 1:
                                    plugin_ref.current_mode = "no_quote"
                                elif index == 2:
                                    plugin_ref.current_mode = "hide_caption"
                                
                                plugin_ref.set_setting("forward_mode", plugin_ref.current_mode)
                                plugin_ref._update_forward_button_text(layout_ref)
                                builder.getDismissRunnable().run()
                            except Exception as e:
                                pass
                        return on_click
                    
                    cell.setOnClickListener(OnClickListener(create_click_listener(i)))
                
                builder.setNegativeButton("Cancel", None)
                builder.show()
                
            except Exception as e:
                pass
        
        run_on_ui_thread(show_dialog)
    
    def _update_forward_button_text(self, layout):
        def update_text():
            try:
                forwardButton_field = layout.getClass().getDeclaredField("forwardButton")
                forwardButton_field.setAccessible(True)
                button_holder = forwardButton_field.get(layout)
                
                if button_holder is None:
                    return
                
                textView_field = button_holder.getClass().getDeclaredField("textView")
                textView_field.setAccessible(True)
                text_view = textView_field.get(button_holder)
                
                if text_view is None:
                    return
                
                if self.current_mode == "no_quote":
                    text_view.setText(getString("no_quote_option", "No Quote"))
                elif self.current_mode == "hide_caption":
                    text_view.setText(getString("hide_caption_option", "Hide Caption"))
                else:
                    text_view.setText(getString("forward_option", "Forward"))
                
            except Exception as e:
                pass
        
        run_on_ui_thread(update_text)
    
    def _hook_add_to_folder_all_tabs(self):
        try:
            DialogsActivityClass = self._get_class("org.telegram.ui.DialogsActivity")
            if not DialogsActivityClass:
                return
            
            try:
                BooleanTYPE = self._get_class("java.lang.Boolean").TYPE
                updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters", BooleanTYPE)
            except:
                try:
                    updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters")
                except:
                    IntegerTYPE = self._get_class("java.lang.Integer").TYPE
                    updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters", IntegerTYPE)
            
            updateCountersMethod.setAccessible(True)
            
            self.hook_add_to_folder_all_tabs_ref = self.hook_method(
                updateCountersMethod,
                AddToFolderAllTabsHook(self),
                priority=0
            )
            
        except Exception:
            pass
    
    def _hook_unread_count(self):
        try:
            MessagesStorageClass = self._get_class("org.telegram.messenger.MessagesStorage")
            if not MessagesStorageClass:
                return

            BooleanTYPE = self._get_class("java.lang.Boolean").TYPE
            calcUnreadCountersMethod = MessagesStorageClass.getClass().getDeclaredMethod("calcUnreadCounters", BooleanTYPE)
            calcUnreadCountersMethod.setAccessible(True)

            self.hook_unread_count_ref = self.hook_method(calcUnreadCountersMethod, UnreadCountHook(self), priority=0)

            if self.get_setting("exclude_archived_from_count", False):
                try:
                    from org.telegram.messenger import UserConfig
                    current_account = UserConfig.selectedAccount
                    messages_storage = MessagesStorageClass.getInstance(current_account)
                    calcUnreadCountersMethod.invoke(messages_storage, True)
                except Exception:
                    pass

        except Exception:
            pass
    
    def _hook_contact_status_in_profile(self):
        try:
            ProfileActivity = self._get_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivity:
                return

            java_class = ProfileActivity.getClass()

            try:
                update_rows = java_class.getDeclaredMethod("updateRowsIds")
                update_rows.setAccessible(True)
                self.contact_status_update_rows_hook = self.hook_method(
                    update_rows,
                    ContactStatusUpdateRowsIdsHook(self),
                    priority=0,
                )
            except Exception:
                pass

            ListAdapter = self._get_class("org.telegram.ui.ProfileActivity$ListAdapter")
            if not ListAdapter:
                return

            try:
                int_type = jclass("java.lang.Integer").TYPE
                view_group = jclass("android.view.ViewGroup")
                view_holder = jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")

                list_adapter_class = ListAdapter.getClass()

                get_item_view_type = list_adapter_class.getDeclaredMethod("getItemViewType", int_type)
                get_item_view_type.setAccessible(True)
                self.contact_status_get_item_view_type_hook = self.hook_method(
                    get_item_view_type,
                    ContactStatusListAdapterGetItemViewTypeHook(self),
                    priority=0,
                )

                on_bind_view_holder = list_adapter_class.getDeclaredMethod(
                    "onBindViewHolder",
                    view_holder,
                    int_type,
                )
                on_bind_view_holder.setAccessible(True)
                self.contact_status_bind_view_holder_hook = self.hook_method(
                    on_bind_view_holder,
                    ContactStatusListAdapterBindViewHolderHook(self),
                    priority=0,
                )
            except Exception:
                pass

        except Exception:
            pass
    
    def _hook_unify_username_behavior(self):
        try:
            ProfileActivityClass = self._get_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivityClass:
                return
            
            ViewClass = self._get_class("android.view.View")
            from java.lang import Integer, Float, Boolean
            
            try:
                process_click_method = ProfileActivityClass.getClass().getDeclaredMethod(
                    "processOnClickOrPress",
                    Integer.TYPE,
                    ViewClass,
                    Float.TYPE,
                    Float.TYPE,
                    Boolean.TYPE
                )
                process_click_method.setAccessible(True)
                self.hook_unify_username_behavior_process_click_ref = self.hook_method(
                    process_click_method,
                    UnifyUsernameProcessClickHook()
                )
            except Exception:
                pass
            
            ListAdapterClass = self._get_class("org.telegram.ui.ProfileActivity$ListAdapter")
            if not ListAdapterClass:
                return
            
            RecyclerViewHolder = self._get_class("androidx.recyclerview.widget.RecyclerView$ViewHolder")
            from java.lang import Integer
            
            try:
                bind_method = ListAdapterClass.getClass().getDeclaredMethod(
                    "onBindViewHolder",
                    RecyclerViewHolder,
                    Integer.TYPE
                )
                bind_method.setAccessible(True)
                self.hook_unify_username_behavior_bind_ref = self.hook_method(
                    bind_method,
                    UnifyUsernameBindViewHook(self)
                )
            except Exception:
                pass
        
        except Exception:
            pass
    
    def _hook_edit_file_name(self):
        try:
            from org.telegram.ui import MessageSendPreview
            from org.telegram.ui.Components import ItemOptions
            
            set_item_options_method = MessageSendPreview.getClass().getDeclaredMethod("setItemOptions", ItemOptions)
            
            handler = EditFileNameSetItemOptionsHook(self)
            self.hook_edit_file_name_ref = self.hook_method(set_item_options_method, handler)
            
        except Exception:
            pass
    
    def _hook_send_comments_after_forward(self):
        self.hook_send_comments_after_forward_ref = self.add_hook("TL_messages_forwardMessages")
    
    def _hook_hide_via_bot(self):
        try:
            send_messages_helper_class = find_class("org.telegram.messenger.SendMessagesHelper")
            if send_messages_helper_class is None:
                return
            
            handler = HideViaBotHook(self)
            self.hook_hide_via_bot_ref = self.hook_all_methods(send_messages_helper_class, "prepareSendingBotContextResult", handler)
        except Exception:
            pass
    
    def _has_document_selected(self):
        try:
            from org.telegram.ui import ChatActivity
            
            fragment = get_last_fragment()
            if fragment is None or not isinstance(fragment, ChatActivity):
                return False
            
            chat_attach_alert = get_private_field(fragment, "chatAttachAlert")
            if chat_attach_alert is None:
                return False
            
            current_layout = get_private_field(chat_attach_alert, "currentAttachLayout")
            if current_layout is None:
                return False
            
            document_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertDocumentLayout")
            if document_layout_class and isinstance(current_layout, document_layout_class):
                selected_files = get_private_field(current_layout, "selectedFilesOrder")
                return selected_files is not None and not selected_files.isEmpty()
            
            audio_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertAudioLayout")
            if audio_layout_class and isinstance(current_layout, audio_layout_class):
                selected_audios = get_private_field(current_layout, "selectedAudiosOrder")
                return selected_audios is not None and not selected_audios.isEmpty()
            
            return False
            
        except Exception:
            return False
    
    def _on_edit_filename_click(self, options_instance, message_send_preview=None):
        try:
            if message_send_preview is not None:
                try:
                    message_send_preview.dismiss()
                except Exception:
                    pass
            
            from org.telegram.ui import ChatActivity
            fragment = get_last_fragment()
            
            if fragment is None or not isinstance(fragment, ChatActivity):
                return
            
            chat_attach_alert = get_private_field(fragment, "chatAttachAlert")
            if chat_attach_alert is None:
                return
            
            current_layout = get_private_field(chat_attach_alert, "currentAttachLayout")
            if current_layout is None:
                return
            
            file_path = None
            
            document_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertDocumentLayout")
            if document_layout_class and isinstance(current_layout, document_layout_class):
                selected_files_order = get_private_field(current_layout, "selectedFilesOrder")
                if selected_files_order is not None and not selected_files_order.isEmpty():
                    file_path = selected_files_order.get(0)
            
            if file_path is None:
                audio_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertAudioLayout")
                if audio_layout_class and isinstance(current_layout, audio_layout_class):
                    selected_audios_order = get_private_field(current_layout, "selectedAudiosOrder")
                    if selected_audios_order is not None and not selected_audios_order.isEmpty():
                        audio_entry = selected_audios_order.get(0)
                        if audio_entry is not None:
                            file_path = audio_entry.path
            
            if file_path is None:
                return
            
            import os
            filename = os.path.basename(file_path)
            
            def show_dialog():
                self._show_filename_edit_dialog(filename, file_path, current_layout)
            
            run_on_ui_thread(show_dialog)
            
        except Exception:
            pass
    
    def _show_filename_edit_dialog(self, original_filename, file_path, document_layout):
        from ui.alert import AlertDialogBuilder
        from client_utils import get_last_fragment
        from org.telegram.ui.Components import EditTextBoldCursor
        from org.telegram.ui.ActionBar import Theme
        from org.telegram.messenger import AndroidUtilities
        from android.text import InputType
        from android.util import TypedValue
        from android.widget import FrameLayout
        from android.view import Gravity
        from android_utils import run_on_ui_thread
        
        fragment = get_last_fragment()
        if fragment is None:
            return
        
        activity = fragment.getParentActivity()
        if activity is None:
            return

        edit_text = EditTextBoldCursor(activity)
        edit_text.setHint(getString("file_name", "File Name"))
        edit_text.setText(original_filename)
        edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
        edit_text.setMaxLines(1)
        edit_text.setSingleLine(True)
        edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
        edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
        edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
        edit_text.setBackground(Theme.createEditTextDrawable(activity, True))
        edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
        edit_text.setCursorSize(AndroidUtilities.dp(20))
        edit_text.setCursorWidth(1.5)
        edit_text.setPadding(0, 0, 0, 0)
        edit_text.setFocusable(True)
        
        builder = AlertDialogBuilder(activity)
        builder.set_title(getString("edit_file_name", "Edit File Name"))
        builder.set_message(getString("enter_new_file_name", "Enter the new file name"))
        builder.set_view(edit_text)
        
        plugin_ref = self
        
        def on_save(dialog, which):
            input_text = str(edit_text.getText()).strip()
            plugin_ref._apply_filename_change(
                input_text,
                file_path,
                document_layout,
                dialog
            )
        
        def on_cancel_click(dialog, which):
            try:
                AndroidUtilities.hideKeyboard(edit_text)
            except Exception:
                pass
            dialog.dismiss()
        
        builder.set_positive_button(getString("swipe_save", "Save"), on_save)
        builder.set_negative_button(getString("cancel", "Cancel"), on_cancel_click)
        
        dialog = builder.show()
        
        def apply_layout_params():
            try:
                layout_params = edit_text.getLayoutParams()
                if layout_params is not None:
                    if isinstance(layout_params, FrameLayout.LayoutParams):
                        layout_params.gravity = Gravity.CENTER_HORIZONTAL
                    
                    if hasattr(layout_params, 'rightMargin'):
                        layout_params.rightMargin = AndroidUtilities.dp(24)
                        layout_params.leftMargin = AndroidUtilities.dp(24)
                        layout_params.height = AndroidUtilities.dp(36)
                        layout_params.bottomMargin = AndroidUtilities.dp(15)
                    edit_text.setLayoutParams(layout_params)
                
                edit_text.requestFocus()
                text_length = edit_text.getText().length() if edit_text.getText() else 0
                edit_text.setSelection(0, text_length)
            except Exception:
                pass
        
        run_on_ui_thread(apply_layout_params, 100)
    
    def _apply_filename_change(self, new_filename, old_path, current_layout, dialog):
        try:
            if not new_filename or len(new_filename.strip()) == 0:
                dialog.dismiss()
                return
            
            new_filename = new_filename.strip()
            
            import os
            import shutil
            
            document_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertDocumentLayout")
            audio_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertAudioLayout")
            
            if document_layout_class and isinstance(current_layout, document_layout_class):
                old_dir = os.path.dirname(old_path)
                new_path = os.path.join(old_dir, new_filename)
                
                if os.path.exists(old_path):
                    shutil.copy2(old_path, new_path)
                    
                    selected_files_order = get_private_field(current_layout, "selectedFilesOrder")
                    selected_files = get_private_field(current_layout, "selectedFiles")
                    
                    if selected_files_order and selected_files:
                        selected_files_order.set(0, new_path)
                        
                        old_list_item = selected_files.get(old_path)
                        if old_list_item:
                            selected_files.remove(old_path)
                            
                            from java.io import File
                            new_file = File(new_path)
                            old_list_item.file = new_file
                            old_list_item.title = new_filename
                            
                            selected_files.put(new_path, old_list_item)
                            
                            def refresh_list():
                                try:
                                    list_adapter = get_private_field(current_layout, "listAdapter")
                                    if list_adapter:
                                        list_adapter.notifyDataSetChanged()
                                except Exception:
                                    pass
                            
                            run_on_ui_thread(refresh_list)
            
            elif audio_layout_class and isinstance(current_layout, audio_layout_class):

                # Fuck android storage access restrictions (we must copy the file to cache dir for renaming)
                
                from file_utils import get_cache_dir, ensure_dir_exists
                
                cache_dir = get_cache_dir()
                temp_dir = os.path.join(cache_dir, "renamed_files")
                ensure_dir_exists(temp_dir)
                new_path = os.path.join(temp_dir, new_filename)
                
                if os.path.exists(old_path):
                    shutil.copy2(old_path, new_path)
                    
                    selected_audios_order = get_private_field(current_layout, "selectedAudiosOrder")
                    
                    if selected_audios_order and not selected_audios_order.isEmpty():
                        audio_entry = selected_audios_order.get(0)
                        
                        if audio_entry:
                            audio_entry.path = new_path
                            audio_entry.title = new_filename
                            
                            msg_obj = audio_entry.messageObject
                            if msg_obj:
                                msg = msg_obj.messageOwner
                                if msg:
                                    msg.attachPath = new_path
                                    
                                    if msg.media and msg.media.document and msg.media.document.attributes:
                                        attrs = msg.media.document.attributes
                                        for i in range(attrs.size()):
                                            attr = attrs.get(i)
                                            attr_class_name = type(attr).__name__
                                            
                                            if "TL_documentAttributeFilename" in attr_class_name:
                                                attr.file_name = new_filename
                                            
                                            if "TL_documentAttributeAudio" in attr_class_name:
                                                name_without_ext = new_filename
                                                if "." in name_without_ext:
                                                    name_without_ext = name_without_ext.rsplit(".", 1)[0]
                                                attr.title = name_without_ext
                            
                            def refresh_list():
                                try:
                                    list_adapter = get_private_field(current_layout, "listAdapter")
                                    if list_adapter:
                                        list_adapter.notifyDataSetChanged()
                                except Exception:
                                    pass
                            
                            run_on_ui_thread(refresh_list)
            
            dialog.dismiss()
            
        except Exception:
            pass
    
  
    def _load_hidden_folders(self):
        try:
            data_str = self.get_setting("hidefolders_data", "{}")
            self.hidden_folders_data = json.loads(data_str)
            
            all_chats_str = self.get_setting("hidefolders_allchats", "{}")
            self.hide_all_chats_folder = json.loads(all_chats_str)
        except Exception:
            self.hidden_folders_data = {}
            self.hide_all_chats_folder = {}
    
    def _save_hidden_folders(self):
        try:
            self.set_setting("hidefolders_data", json.dumps(self.hidden_folders_data))
            self.set_setting("hidefolders_allchats", json.dumps(self.hide_all_chats_folder))
        except Exception:
            pass
    
    def _get_account_key(self):
        try:
            user_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
            return f"_{user_id}"
        except Exception:
            return "_default"
    
    def _get_hidden_folders_for_account(self):
        key = self._get_account_key()
        if key not in self.hidden_folders_data:
            self.hidden_folders_data[key] = []
        return self.hidden_folders_data[key]
    
    def _is_folder_hidden(self, filter_id):
        hidden_folders = self._get_hidden_folders_for_account()
        return filter_id in hidden_folders
    
    def _is_all_chats_hidden(self):
        key = self._get_account_key()
        return self.hide_all_chats_folder.get(key, False)
    
    def _show_folder_selector(self):
        try:
            controller = MessagesController.getInstance(UserConfig.selectedAccount)
            filters_field = controller.getClass().getDeclaredField("dialogFilters")
            filters_field.setAccessible(True)
            filters = filters_field.get(controller)

            if filters is None:
                filters = controller.getDialogFilters()

            hidden_folders = self._get_hidden_folders_for_account()

            items = []
            keys = []
            key_to_folder = {}

            for i in range(filters.size()):
                filter_obj = filters.get(i)
                if filter_obj.isDefault():
                    continue

                key = f"hidefolders_folder_{filter_obj.id}"
                keys.append(key)
                items.append(str(filter_obj.name))
                key_to_folder[key] = filter_obj.id

            if not items:
                return

            for key in keys:
                folder_id = key_to_folder[key]
                self.set_setting(key, folder_id in hidden_folders)

            def on_selection_change(selected_keys):
                try:
                    account_key = self._get_account_key()
                    new_hidden = [key_to_folder[key] for key in selected_keys if key in key_to_folder]
                    self.hidden_folders_data[account_key] = new_hidden
                    self._save_hidden_folders()
                    self._hook_folder_visibility(post_notification=True)
                    return False
                except Exception:
                    return False

            MultiSelector(
                items=items,
                title=getString("hide_folders_title", "Hide Folders"),
                subtitle=getString("hide_folders_subtitle", "Select folders to hide"),
                setting_keys=keys,
                plugin_instance=self,
                on_selection_change=on_selection_change,
                action_text=getString("apply", "Apply")
            )
        except Exception:
            pass
    
    def _toggle_hide_folders(self, enabled):
        self.set_setting("hidefolders_enabled", enabled)
        self._hook_folder_visibility(post_notification=True)
    
    def _post_update_notification(self):
        try:
            from android.os import Handler, Looper
            from android_utils import R
            
            def post_update():
                try:
                    NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(
                        NotificationCenter.dialogFiltersUpdated
                    )
                except:
                    pass
            
            Handler(Looper.getMainLooper()).post(R(post_update))
        except Exception:
            pass
    
    def _hook_folder_visibility(self, post_notification=False):
        try:
            if not self.get_setting("hidefolders_enabled", False):
                return
                
            MessagesControllerClass = find_class("org.telegram.messenger.MessagesController")
            if not MessagesControllerClass:
                return
            
            from org.telegram.messenger import UserConfig
            current_account = UserConfig.selectedAccount
            controller = MessagesControllerClass.getInstance(current_account)
            
            hidden_folders = self._get_hidden_folders_for_account()
            hide_all_chats = self._is_all_chats_hidden()
            
            if not hidden_folders and not hide_all_chats:
                frozen_field = controller.getClass().getDeclaredField("frozenDialogFilters")
                frozen_field.setAccessible(True)
                frozen_field.set(controller, None)
                return
            
            dialog_filters_field = controller.getClass().getDeclaredField("dialogFilters")
            dialog_filters_field.setAccessible(True)
            original_filters = dialog_filters_field.get(controller)
            
            if original_filters is None or original_filters.size() == 0:
                return
            
            from java.util import ArrayList
            filtered_list = ArrayList()
            for i in range(original_filters.size()):
                filter_item = original_filters.get(i)
                try:
                    is_default = filter_item.isDefault()
                except:
                    is_default = False
                if is_default and hide_all_chats:
                    continue
                if not is_default and filter_item.id in hidden_folders:
                    continue
                filtered_list.add(filter_item)
            
            frozen_field = controller.getClass().getDeclaredField("frozenDialogFilters")
            frozen_field.setAccessible(True)
            frozen_field.set(controller, filtered_list)
            
            if post_notification:
                self._post_update_notification()
            
        except Exception:
            pass
    
    def _hook_search_by_user_id(self):
        try:
            MentionsAdapterClass = self._get_class("org.telegram.ui.Adapters.MentionsAdapter")
            if not MentionsAdapterClass:
                return
            
            IntegerClass = self._get_class("java.lang.Integer")
            BooleanClass = self._get_class("java.lang.Boolean")
            
            java_class = MentionsAdapterClass.getClass()
            search_method = java_class.getDeclaredMethod(
                "searchUsernameOrHashtag",
                self._get_class("java.lang.CharSequence"),
                IntegerClass.TYPE,
                self._get_class("java.util.ArrayList"),
                BooleanClass.TYPE,
                BooleanClass.TYPE
            )
            search_method.setAccessible(True)
            
            class SearchHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                
                @hook_filters(HookFilter.ArgumentNotNull(0))
                def before_hooked_method(self, param):
                    try:
                        if not hasattr(self, 'pending_user'):
                            self.pending_user = None
                        if not hasattr(self, 'pending_chat'):
                            self.pending_chat = None
                        
                        char_sequence = param.args[0]
                        for_search = param.args[4] if len(param.args) > 4 else False
                        
                        if not for_search or char_sequence is None:
                            self.pending_user = None
                            self.pending_chat = None
                            return
                        
                        if isinstance(char_sequence, str):
                            text = char_sequence.strip()
                        else:
                            text = str(char_sequence).strip()
                        
                        if text.startswith("@"):
                            text = text[1:]
                        
                        if text and text.isdigit() and len(text) <= 20:
                            try:
                                user_id = int(text)
                                current_account = UserConfig.selectedAccount
                                user = MessagesController.getInstance(current_account).getUser(user_id)
                                chat = MessagesController.getInstance(current_account).getChat(user_id)
                                
                                if chat is None and text.startswith("100") and len(text) > 10:
                                    chat_id = int(text[3:])
                                    chat = MessagesController.getInstance(current_account).getChat(chat_id)
                                
                                if user is not None:
                                    self.pending_user = user
                                elif chat is not None:
                                    self.pending_chat = chat
                                
                            except:
                                pass
                                
                    except:
                        pass
                
                def after_hooked_method(self, param):
                    try:
                        if self.pending_user is None and self.pending_chat is None:
                            return
                        
                        adapter = param.thisObject
                        
                        try:
                            parent_fragment_field = adapter.getClass().getDeclaredField("parentFragment")
                            parent_fragment_field.setAccessible(True)
                            chat_activity = parent_fragment_field.get(adapter)
                            
                            if chat_activity:
                                plugin = self._plugin_ref()
                                if not plugin:
                                    return
                                search_user_method = chat_activity.getClass().getDeclaredMethod(
                                    "searchUserMessages",
                                    plugin._get_class("org.telegram.tgnet.TLRPC$User"),
                                    plugin._get_class("org.telegram.tgnet.TLRPC$Chat")
                                )
                                search_user_method.setAccessible(True)
                                
                                if self.pending_user:
                                    search_user_method.invoke(chat_activity, self.pending_user, None)
                                elif self.pending_chat:
                                    search_user_method.invoke(chat_activity, None, self.pending_chat)
                                
                        except:
                            pass
                        
                        self.pending_user = None
                        self.pending_chat = None
                                
                    except:
                        pass
            
            self.hook_search_by_user_id_ref = self.hook_method(search_method, SearchHook(self))
            
        except:
            pass
    
    def _hook_ai_role_limit(self):
        try:
            NEW_LIMIT = 9999
            
            CodepointsLengthInputFilterClass = self._get_class("org.telegram.ui.Components.CodepointsLengthInputFilter")
            if not CodepointsLengthInputFilterClass:
                return
            
            class LimitHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        obj = param.thisObject
                        obj_class = obj.getClass()
                        superclass = obj_class.getSuperclass()
                        mMax_field = superclass.getDeclaredField("mMax")
                        mMax_field.setAccessible(True)
                        current_max = mMax_field.getInt(obj)
                        
                        if current_max == 1024:
                            from java.lang.reflect import Field, Modifier
                            modifiers_field = Field.getClass().getDeclaredField("accessFlags")
                            modifiers_field.setAccessible(True)
                            modifiers_field.setInt(mMax_field, mMax_field.getModifiers() & ~Modifier.FINAL)
                            mMax_field.setInt(obj, NEW_LIMIT)
                    except:
                        pass
            
            from java.lang import Integer
            java_class = CodepointsLengthInputFilterClass.getClass()
            constructor = java_class.getDeclaredConstructor(Integer.TYPE)
            self.hook_ai_role_limit_constructor_ref = self.hook_method(constructor, LimitHook(self))
            
            class SetTextHook:
                @hook_filters(HookFilter.ArgumentNotNull(0))
                def before_hooked_method(self, param):
                    try:
                        if len(param.args) > 0 and param.args[0]:
                            text = str(param.args[0])
                            if "1024" in text:
                                new_text = text.replace("1024", str(NEW_LIMIT))
                                param.args[0] = new_text
                    except:
                        pass
            
            OutlineTextContainerViewClass = find_class("org.telegram.ui.Components.OutlineTextContainerView")
            if OutlineTextContainerViewClass:
                StringClass = find_class("java.lang.String")
                setText_method = OutlineTextContainerViewClass.getClass().getDeclaredMethod("setText", StringClass)
                self.hook_ai_role_limit_settext_ref = self.hook_method(setText_method, SetTextHook())
                logging.info(f"Hook registered: _hook_ai_role_limit_settext")
            
        except:
            pass
    
    def _hook_sleep_timer(self):
        try:
            AudioPlayerAlert = find_class("org.telegram.ui.Components.AudioPlayerAlert")
            if not AudioPlayerAlert:
                return
            Context = jclass("android.content.Context")
            Theme_ResourcesProvider = jclass("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            
            constructor = AudioPlayerAlert.getClass().getDeclaredConstructor(Context, Theme_ResourcesProvider)
            constructor.setAccessible(True)
            self.hook_sleep_timer_ref = self.hook_method(constructor, SleepTimerConstructorHook(self))
            
            from java.lang import Integer
            onSubItemClick = AudioPlayerAlert.getClass().getDeclaredMethod("onSubItemClick", Integer.TYPE)
            onSubItemClick.setAccessible(True)
            self.hook_sleep_timer_click_ref = self.hook_method(onSubItemClick, SleepTimerClickHook(self))
        except Exception as e:
            pass
    
    def _hook_adaptive_audio_length(self):
        try:
            ChatMessageCellClass = self._get_class("org.telegram.ui.Cells.ChatMessageCell")
            if not ChatMessageCellClass:
                return
            
            self.hook_adaptive_audio_ref = self.hook_all_methods(
                ChatMessageCellClass,
                "setMessageContent",
                AdaptiveAudioHook(self),
                priority=50
            )
            logging.info(f"Hook registered: _hook_adaptive_audio")
            
        except:
            pass
    
    def _hook_music_speed_control(self):
        try:
            FragmentContextViewClass = self._get_class("org.telegram.ui.Components.FragmentContextView")
            if not FragmentContextViewClass:
                return
            
            methods = FragmentContextViewClass.getClass().getDeclaredMethods()
            for m in methods:
                if m.getName() == "checkPlayer" and len(m.getParameterTypes()) == 1:
                    self.hook_music_speed_control_ref = self.hook_method(m, MusicSpeedControlHook(self))
                    logging.info(f"Hook registered: _hook_music_speed_control")
                    break
        except:
            pass
    
    def _hook_custom_saved_messages(self):
        ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
        if not ChatActivityClass:
            return
        
        from java import jclass
        method = ChatActivityClass.getClass().getDeclaredMethod(
            "forwardMessages",
            jclass("java.util.ArrayList"),
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Integer").TYPE,
            jclass("java.lang.Long").TYPE,
            jclass("java.lang.Long").TYPE
        )
        method.setAccessible(True)
        
        plugin_ref = weakref.ref(self)
        
        class CustomSavedMessagesHook:
            @hook_filters(HookFilter.Condition("param.thisObject != null"))
            def before_hooked_method(self, param):
                plugin = plugin_ref()
                if plugin and len(param.args) >= 6:
                    client_id = param.thisObject.getUserConfig().getClientUserId()
                    if param.args[5] == client_id:
                        custom_id = plugin._get_custom_saved_chat_id()
                        if custom_id != client_id:
                            param.args[5] = custom_id
        
        self.hook_custom_saved_messages_ref = self.hook_method(method, CustomSavedMessagesHook())
    
    def _get_custom_saved_chat_id(self):
        if self.get_setting("enable_custom_saved_messages", False) and self.custom_saved_chat_id:
            return self.custom_saved_chat_id
        return UserConfig.getInstance(UserConfig.selectedAccount).clientUserId
    
    def _handle_forward_mode_change(self, setting_key, enabled):
        if enabled:
            other_key = "enable_share_alert_forward" if setting_key == "enable_old_forward" else "enable_old_forward"
            self.set_setting(other_key, False, reload_settings=True)
        self._apply_hooks()
    
    def _select_custom_saved_chat(self):
        fragment = get_last_fragment()
        if not fragment:
            return
        
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("allowGlobalSearch", False)
        args.putBoolean("resetDelegate", False)
        args.putBoolean("closeFragment", True)
        
        dialogs_activity = DialogsActivity(args)
        
        from java import dynamic_proxy
        plugin_ref = weakref.ref(self)
        
        class CustomSavedChatDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
            def __init__(self, plugin_instance):
                super().__init__()
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def didSelectDialogs(self, fragment, dids, message, *args):
                plugin = self.plugin_ref()
                if plugin and dids and dids.size() > 0:
                    plugin.custom_saved_chat_id = dids.get(0).dialogId
                    plugin.set_setting("custom_saved_chat_id", plugin.custom_saved_chat_id, reload_settings=True)
                    fragment.finishFragment(True)
                return True
            
            def canSelectStories(self):
                return False
        
        dialogs_activity.setDelegate(CustomSavedChatDelegate(self))
        fragment.presentFragment(dialogs_activity)
    
    def _get_custom_saved_chat_name(self):
        if not self.custom_saved_chat_id:
            return "Not selected"
        
        mc = MessagesController.getInstance(UserConfig.selectedAccount)
        if self.custom_saved_chat_id < 0:
            chat = mc.getChat(-self.custom_saved_chat_id)
            return getattr(chat, 'title', "Unknown") if chat else "Unknown"
        
        user = mc.getUser(self.custom_saved_chat_id)
        if user:
            return f"{getattr(user, 'first_name', '') or ''} {getattr(user, 'last_name', '') or ''}".strip() or "Unknown"
        return "Unknown"
    
    def _hook_disable_emoji_suggestions(self):
        try:
            SuggestEmojiViewClass = self._get_class("org.telegram.ui.Components.SuggestEmojiView")
            if not SuggestEmojiViewClass:
                return
            
            JavaClass = SuggestEmojiViewClass.getClass()
            
            update_method = JavaClass.getDeclaredMethod("update")
            self.hook_disable_emoji_suggestions_ref = self.hook_method(update_method, DisableEmojiSuggestionsHook())
            
            fire_update_method = JavaClass.getDeclaredMethod("fireUpdate")
            self.hook_method(fire_update_method, DisableFireUpdateHook())
            
            StringClass = self._get_class("java.lang.String")
            searchKeywords_method = JavaClass.getDeclaredMethod("searchKeywords", StringClass)
            self.hook_method(searchKeywords_method, DisableEmojiSuggestionsHook())
            
            searchAnimated_method = JavaClass.getDeclaredMethod("searchAnimated", StringClass)
            self.hook_method(searchAnimated_method, DisableEmojiSuggestionsHook())
        except Exception as e:
            pass
    
    def _hook_message_swipe_action(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            MessageObjectClass = self._get_class("org.telegram.messenger.MessageObject")
            
            show_reply_method = ChatActivityClass.getClass().getDeclaredMethod("showFieldPanelForReply", MessageObjectClass)
            show_reply_method.setAccessible(True)
            
            handler_instance = SwipeReplyHook(self)
            self.hook_message_swipe_action_ref = self.hook_method(show_reply_method, handler_instance, priority=10)
            
            try:
                MotionEventClass = self._get_class("android.view.MotionEvent")
                ViewClass = self._get_class("android.view.View")
                dispatch_touch_method = ViewClass.getClass().getDeclaredMethod("dispatchTouchEvent", MotionEventClass)
                dispatch_touch_method.setAccessible(True)
                
                motion_handler = MotionEventSwipeHook(self)
                self.hook_method(dispatch_touch_method, motion_handler, priority=10)
            except Exception as e:
                pass
            
        except Exception as e:
            pass
    
    def _save_to_saved_messages(self, chat_activity, message_object):
        try:
            current_account = UserConfig.selectedAccount
            saved_messages_id = UserConfig.getInstance(current_account).getClientUserId()
            
            messages_list = jclass("java.util.ArrayList")()
            messages_list.add(message_object)
            
            send_helper = get_send_messages_helper()
            send_helper.sendMessage(messages_list, saved_messages_id, False, False, True, 0, 0)
            
            try:
                BulletinHelper.show_simple(
                    LocaleController.getString("FwdMessageToSavedMessages", R_tg.string.FwdMessageToSavedMessages),
                    R_tg.raw.saved_messages,
                    chat_activity
                )
            except Exception as bulletin_error:
                pass
            
        except Exception as e:
            pass
    
    def _show_translate_alert(self, chat_activity, message_object):
        try:
            message_text = message_object.messageOwner.message
            if not message_text:
                return
            
            current_account = UserConfig.selectedAccount
            TranslateAlert2 = jclass("org.telegram.ui.Components.TranslateAlert2")
            to_lang = TranslateAlert2.getToLanguage()
            from_lang = None
            
            entities = message_object.messageOwner.entities if message_object.messageOwner.entities else jclass("java.util.ArrayList")()
            
            try:
                field = chat_activity.getClass().getDeclaredField("selectedObject")
                field.setAccessible(True)
                field.set(chat_activity, message_object)
            except: pass
            
            TranslateAlert2.showAlert(
                chat_activity.getParentActivity(),
                chat_activity,
                current_account,
                from_lang,
                to_lang,
                message_text,
                entities,
                False,
                None,
                None
            )
            
        except Exception as e:
            pass
    
    def _show_share_alert(self, chat_activity, message_object):
        try:
            current_chat = get_private_field(chat_activity, "currentChat")
            is_channel = ChatObject.isChannel(current_chat) if current_chat else False
            class_guid = get_private_field(chat_activity, "classGuid")
            
            messages_list = jclass("java.util.ArrayList")()
            messages_list.add(message_object)
            
            ShareAlert = jclass("org.telegram.ui.Components.ShareAlert")
            share_alert = ShareAlert(
                chat_activity.getParentActivity(),
                messages_list,
                None,
                is_channel,
                None,
                False
            )
            
            chat_activity.showDialog(share_alert)
            
            AndroidUtilities.setAdjustResizeToNothing(chat_activity.getParentActivity(), class_guid)
            chat_activity.getFragmentView().requestLayout()
            
        except Exception as e:
            pass
    
    def _hook_in_message_translation(self):
        try:
            if self.hook_in_message_translation_alert_ref:
                return
            
            TranslateAlert2 = jclass("org.telegram.ui.Components.TranslateAlert2")
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            TranslatorUtils = jclass("com.exteragram.messenger.utils.text.TranslatorUtils")
            ChatUtils = jclass("com.exteragram.messenger.utils.ChatUtils")
            ChatMessageCell = jclass("org.telegram.ui.Cells.ChatMessageCell")
            
            plugin = self
            
            class InMessageTranslationCallback(dynamic_proxy(find_class("com.exteragram.messenger.utils.text.TranslatorUtils$TranslateCallback"))):
                def __init__(cb, msg, lang, activity):
                    super().__init__()
                    cb.msg, cb.lang, cb.activity = msg, lang, activity
                
                def onSuccess(cb, *a):
                    try:
                        txt, ent = (a[0], None) if len(a) == 1 and isinstance(a[0], str) else \
                                   (a[0].result.get(0).text, a[0].result.get(0).entities) if len(a) == 2 and a[0] and not a[1] and a[0].result and not a[0].result.isEmpty() else (None, None)
                        if txt: cb._apply(txt, ent)
                    except: pass
                
                def onFailed(cb): pass
                def onReqId(cb, _): pass
                
                def _apply(cb, txt, ent):
                    try:
                        mo = cb.msg.messageOwner
                        if not mo: return
                        te = TLRPC.TL_textWithEntities()
                        te.text, te.entities = txt, ent if ent else jclass("java.util.ArrayList")()
                        mo.translatedText, mo.translatedToLanguage = te, cb.lang
                        plugin._in_message_translated.add((cb.msg.getDialogId(), cb.msg.getId()))
                        def ui():
                            try:
                                cb.msg.translated = True
                                cb.msg.applyNewText(txt)
                                cb.msg.generateCaption()
                                if cb.activity:
                                    lv = get_private_field(cb.activity, "chatListView")
                                    if lv:
                                        for i in range(lv.getChildCount()):
                                            c = lv.getChildAt(i)
                                            if isinstance(c, ChatMessageCell) and c.getMessageObject() and c.getMessageObject().getId() == cb.msg.getId():
                                                c.invalidate(); break
                            except: pass
                        run_on_ui_thread(ui)
                    except: pass
            
            class InMessageAlertHook(MethodHook):
                def __init__(h): h.pending = None
                
                def before_hooked_method(h, p):
                    try:
                        if len(p.args) < 7: return
                        f = p.args[1]
                        if not f or not isinstance(f, ChatActivityClass): return
                        obj = get_private_field(f, "selectedObject")
                        if not obj:
                            try:
                                fld = f.getClass().getDeclaredField("selectedObject")
                                fld.setAccessible(True)
                                obj = fld.get(f)
                            except: pass
                        if not obj: return
                        txt = next((a for a in p.args if a and hasattr(a, '__class__') and ('String' in a.__class__.__name__ or 'CharSequence' in a.__class__.__name__ or isinstance(a, str)) and len(str(a)) > 5), None)
                        if not txt:
                            txt = ChatUtils.getInstance().getMessageText(obj, None)
                        if not txt or not len(str(txt)): return
                        TranslatorUtils.translate(txt, TranslateAlert2.getToLanguage(), InMessageTranslationCallback(obj, TranslateAlert2.getToLanguage(), f))
                        h.pending = True
                    except: pass
                
                def after_hooked_method(h, p):
                    try:
                        if h.pending:
                            a = p.getResult()
                            if a: a.dismiss()
                            h.pending = None
                    except: pass
            
            class InMessageBlockRevertHook(MethodHook):
                def before_hooked_method(h, p):
                    try:
                        m = p.thisObject
                        if m and (m.getDialogId(), m.getId()) in plugin._in_message_translated and m.translated and m.messageOwner and m.messageOwner.translatedText:
                            p.setResult(False)
                    except: pass
            
            self.hook_in_message_translation_alert_ref = self.hook_all_methods(TranslateAlert2, "showAlert", InMessageAlertHook())
            self.hook_in_message_translation_revert_ref = self.hook_all_methods(MessageObject, "updateTranslation", InMessageBlockRevertHook())
            
        except Exception:
            pass
    
    def _hook_remove_https_from_links(self):
        try:
            ClipboardManagerClass = find_class("android.content.ClipboardManager")
            ClipDataClass = find_class("android.content.ClipData")
            set_primary_clip_method = ClipboardManagerClass.getClass().getDeclaredMethod("setPrimaryClip", ClipDataClass)
            self.hook_remove_https_from_links_ref = self.hook_method(set_primary_clip_method, RemoveHttpsHook())
        except Exception as e:
            pass
    
    def _hook_join_request_direct_profile(self):
        try:
            delegate_class = find_class("org.telegram.ui.Delegates.MemberRequestsDelegate")
            
            if not delegate_class:
                return
            
            view_class = find_class("android.view.View")
            int_type = jclass("java.lang.Integer").TYPE
            
            method = delegate_class.getClass().getDeclaredMethod(
                "onItemClick",
                view_class,
                int_type
            )
            
            if not method:
                return
                
            self.hook_join_request_direct_profile_ref = self.hook_method(method, DirectProfileHook(self))
            
        except Exception:
            pass
    
    def _on_notification_sound_change(self, value):
        self._play_preview(value)
        self._apply_hooks()
    
    def _on_vibration_change(self, value):
        self._vibrate_preview(value)
        self._apply_hooks()
    
    def _ensure_ios_sound(self):
        try:
            from file_utils import get_files_dir
            files_dir = get_files_dir()
            self.ios_sound_path = os.path.join(files_dir, "custom_received.mp3")
            
            if not os.path.exists(self.ios_sound_path):
                branch_index = self.get_setting("update_branch", 0)
                branch = "main" if branch_index == 0 else "Beta"
                IOS_SOUND_URL = f"https://raw.githubusercontent.com/luvztroy/UiTweaks/{branch}/Assets/Audio/Custom%20received.mp3"
                urllib.request.urlretrieve(IOS_SOUND_URL, self.ios_sound_path)
        except Exception as e:
            pass
    
    def _hook_play_in_chat_sound(self):
        try:
            NotificationsController = self._get_class("org.telegram.messenger.NotificationsController")
            if not NotificationsController:
                return
            
            java_class = NotificationsController.getClass()
            method = java_class.getDeclaredMethod("playInChatSound")
            method.setAccessible(True)
            
            self.hook_play_sound_ref = self.hook_method(method, PlaySoundHook(self))
        except Exception as e:
            pass
    
    def _hook_soundpool_load(self):
        try:
            SoundPool = jclass("android.media.SoundPool")
            java_class = SoundPool.getClass()
            
            Context = jclass("android.content.Context")
            int_type = jclass("java.lang.Integer").TYPE
            
            method = java_class.getDeclaredMethod("load", Context, int_type, int_type)
            method.setAccessible(True)
            
            self.hook_soundpool_load_ref = self.hook_method(method, SoundPoolLoadHook(self))
        except Exception as e:
            pass
    
    def _vibrate_preview(self, vibrate_type):
        try:
            if vibrate_type == 0:
                return
            
            Vibrator = jclass("android.os.Vibrator")
            ApplicationLoader = self._get_class("org.telegram.messenger.ApplicationLoader")
            context = ApplicationLoader.applicationContext
            vibrator = context.getSystemService("vibrator")
            
            if vibrate_type == 1:
                vibrator.vibrate(30)
            elif vibrate_type == 2:
                vibrator.vibrate(50)
            elif vibrate_type == 3:
                pattern = [0, 50, 50, 50]
                vibrator.vibrate(pattern, -1)
            elif vibrate_type == 4:
                vibrator.vibrate(200)
        except Exception as e:
            pass
    
    def _play_preview(self, sound_type):
        try:
            if sound_type == 0:
                return
            
            from android.media import MediaPlayer
            ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
            context = ApplicationLoader.applicationContext
            
            mp = None
            
            if sound_type == 1:
                R = find_class("org.telegram.messenger.R")
                mp = MediaPlayer.create(context, R.raw.sound_in)
            elif sound_type == 2:
                if os.path.exists(self.ios_sound_path):
                    mp = MediaPlayer()
                    mp.setDataSource(self.ios_sound_path)
                    mp.prepare()
            
            if mp:
                mp.start()
        except Exception as e:
            pass
    
    def play_ios_sound(self, soundpool):
        try:
            if not os.path.exists(self.ios_sound_path):
                return
            
            if self.soundpool_instance != soundpool or self.ios_sound_id is None:
                self.soundpool_instance = soundpool
                self.ios_sound_id = soundpool.load(self.ios_sound_path, 1)
            
            if self.ios_sound_id:
                AudioManager = find_class("android.media.AudioManager")
                ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
                context = ApplicationLoader.applicationContext
                audio_manager = context.getSystemService("audio")
                
                max_volume = audio_manager.getStreamMaxVolume(AudioManager.STREAM_NOTIFICATION)
                current_volume = audio_manager.getStreamVolume(AudioManager.STREAM_NOTIFICATION)
                volume_ratio = float(current_volume) / float(max_volume) if max_volume > 0 else 1.0
                
                soundpool.play(self.ios_sound_id, volume_ratio, volume_ratio, 1, 0, 1.0)
        except Exception as e:
            pass
    
    def _open_pinned_reactions_settings_ui(self, view=None):
        try:
            from client_utils import get_last_fragment
            from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment
            
            fragment = get_last_fragment()
            if fragment is None:
                return
            
            delegate = PinnedReactionsDelegate(self)
            custom_fragment = UniversalFragment(delegate)
            fragment.presentFragment(custom_fragment)
            
        except Exception:
            pass
    
    def _normalize_emoji(self, emoji_str):
        normalized = emoji_str.replace("\uFE0F", "")
        
        skin_tones = ["\U0001F3FB", "\U0001F3FC", "\U0001F3FD", "\U0001F3FE", "\U0001F3FF"]
        for tone in skin_tones:
            normalized = normalized.replace(tone, "")
        
        return normalized
    
    def _hook_pinned_reactions(self):
        try:
            ReactionsContainerLayoutClass = jclass("org.telegram.ui.Components.ReactionsContainerLayout")
            
            Boolean = jclass("java.lang.Boolean")
            
            setVisibleReactionsList = ReactionsContainerLayoutClass.getClass().getDeclaredMethod(
                "setVisibleReactionsList",
                jclass("java.util.List"),
                Boolean.TYPE
            )
            setVisibleReactionsList.setAccessible(True)
            
            self.hook_reactions_container_ref = self.hook_method(setVisibleReactionsList, SetVisibleReactionsListHook(self))
        except Exception:
            pass
    
    def get_pinned_reactions(self, is_channel):
        if is_channel:
            if self.get_setting("pinned_reactions_enabled_channels", "true") != "true":
                return []
            reactions_json = self.get_setting("pinned_reactions_channels", "[]")
        else:
            if self.get_setting("pinned_reactions_enabled_chats", "true") != "true":
                return []
            reactions_json = self.get_setting("pinned_reactions_chats", "[]")
        
        try:
            reactions_data = json.loads(reactions_json)
            return self._json_to_visible_reactions(reactions_data)
        except Exception:
            return []
    
    def save_pinned_reactions(self, is_channel, reactions_list):
        normalized_reactions = []
        for reaction in reactions_list[:7]:
            if "emoticon" in reaction:
                normalized_reactions.append({
                    "emoticon": self._normalize_emoji(reaction["emoticon"])
                })
            else:
                normalized_reactions.append(reaction)
        
        reactions_json = json.dumps(normalized_reactions)
        
        if is_channel:
            self.set_setting("pinned_reactions_channels", reactions_json)
        else:
            self.set_setting("pinned_reactions_chats", reactions_json)
    
    def _json_to_visible_reactions(self, reactions_data):
        VisibleReaction = jclass("org.telegram.ui.Components.Reactions.ReactionsLayoutInBubble$VisibleReaction")
        String = jclass("java.lang.String")
        visible_reactions = []
        
        for reaction_dict in reactions_data:
            try:
                reaction = VisibleReaction()
                
                if "emoticon" in reaction_dict:
                    normalized_emoji = self._normalize_emoji(reaction_dict["emoticon"])
                    reaction.emojicon = normalized_emoji
                    java_string = String(normalized_emoji)
                    reaction.hash = java_string.hashCode()
                elif "document_id" in reaction_dict:
                    reaction.documentId = reaction_dict["document_id"]
                    reaction.hash = reaction.documentId
                else:
                    continue
                
                visible_reactions.append(reaction)
            except Exception:
                continue
        
        return visible_reactions
    
    def _hook_share_alert_forward(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            activity_class = ChatActivity.getClass()
            
            method1 = activity_class.getDeclaredMethod("openForward", jclass("java.lang.Boolean").TYPE)
            method1.setAccessible(True)
            self.hook_share_alert_forward_open_ref = self.hook_method(method1, OpenForwardHook())
            
            method2 = activity_class.getDeclaredMethod("processSelectedOption", jclass("java.lang.Integer").TYPE)
            method2.setAccessible(True)
            self.hook_share_alert_forward_process_ref = self.hook_method(method2, ProcessSelectedOptionHook())
        except Exception:
            pass
    
    def _hook_disable_link_preview(self):
        try:
            self._hook_chat_activity_search_links()
            self._hook_chat_activity_enter_view_constructor()
            self._hook_send_message_params_init()
        except Exception as e:
            pass
    
    def _hook_chat_activity_search_links(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                return
            
            CharSequence = jclass("java.lang.CharSequence")
            boolean_type = jclass("java.lang.Boolean").TYPE
            
            search_links_method = ChatActivity.getClass().getDeclaredMethod(
                "searchLinks", 
                CharSequence, 
                boolean_type
            )
            search_links_method.setAccessible(True)
            
            self.hook_search_links_ref = self.hook_method(search_links_method, SearchLinksReplacement(self))
            
        except Exception as e:
            pass
    
    def _hook_chat_activity_enter_view_constructor(self):
        try:
            ChatActivityEnterView = self._get_class("org.telegram.ui.Components.ChatActivityEnterView")
            if not ChatActivityEnterView:
                return
            
            constructors = ChatActivityEnterView.getClass().getDeclaredConstructors()
            for constructor in constructors:
                try:
                    constructor.setAccessible(True)
                    self.hook_enter_view_constructor_ref = self.hook_method(constructor, EnterViewConstructorHook())
                except:
                    continue
                    
        except Exception as e:
            pass
    
    def _hook_send_message_params_init(self):
        try:
            SendMessagesHelper = self._get_class("org.telegram.messenger.SendMessagesHelper")
            if not SendMessagesHelper:
                return
            
            inner_classes = SendMessagesHelper.getClass().getDeclaredClasses()
            SendMessageParams = None
            for inner_class in inner_classes:
                if inner_class.getSimpleName() == "SendMessageParams":
                    SendMessageParams = inner_class
                    break
            
            if not SendMessageParams:
                return
            
            methods = SendMessageParams.getDeclaredMethods()
            for method in methods:
                try:
                    if method.getName() == "of" and method.getReturnType() == SendMessageParams:
                        method.setAccessible(True)
                        self.hook_send_message_params_ref = self.hook_method(method, SendMessageParamsHook())
                except:
                    continue
                    
        except Exception as e:
            pass
    
    def _hook_search_filter(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            String_class = jclass("java.lang.String")
            open_search_method = ChatActivityClass.getClass().getDeclaredMethod(
                "openSearchWithText",
                String_class
            )
            
            if open_search_method:
                self.hook_search_filter_open_search_ref = self.hook_method(open_search_method, SearchFilterOpenSearchHook(self))
            
            ConnectionsManagerClass = self._get_class("org.telegram.tgnet.ConnectionsManager")
            if ConnectionsManagerClass:
                TLObject_class = self._get_class("org.telegram.tgnet.TLObject")
                RequestDelegate_class = self._get_class("org.telegram.tgnet.RequestDelegate")
                int_type = jclass("java.lang.Integer").TYPE
                
                try:
                    send_request_method = ConnectionsManagerClass.getClass().getDeclaredMethod(
                        "sendRequest",
                        TLObject_class, RequestDelegate_class, int_type
                    )
                    
                    if send_request_method:
                        self.hook_search_filter_send_request_ref = self.hook_method(send_request_method, SearchFilterSendRequestHook(self))
                except:
                    pass
                
        except:
            pass
    
    def _create_search_filter_button(self, chat_activity):
        try:
            activity_id = id(chat_activity)
            if activity_id in self.search_filter_buttons:
                return
            
            context = chat_activity.getParentActivity()
            if not context:
                return
            
            search_container = get_private_field(chat_activity, "searchContainer")
            
            if not search_container:
                return
            
            search_filter_button = ImageView(context)
            search_filter_button.setScaleType(ImageView.ScaleType.CENTER)
            search_filter_button.setImageResource(R_tg.drawable.menu_tag_filter_solar)
            
            color = Theme.getColor(Theme.key_chat_searchPanelIcons)
            from android.graphics import PorterDuff, PorterDuffColorFilter
            search_filter_button.setColorFilter(PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY))
            
            selector_color = Theme.getColor(Theme.key_actionBarActionModeDefaultSelector)
            search_filter_button.setBackgroundDrawable(Theme.createSelectorDrawable(selector_color, 1))
            
            chat_activity_ref = weakref.ref(chat_activity)
            def on_search_filter_click(v, ref=chat_activity_ref):
                ca = ref()
                if ca:
                    self._show_search_filter_selector(ca)
            search_filter_button.setOnClickListener(OnClickListener(on_search_filter_click))
            
            left_margin = 48
            try:
                search_user_button = get_private_field(chat_activity, "searchUserButton")
                if search_user_button:
                    left_margin = 96
                    self._hook_user_search_button_for_filter(search_user_button, search_filter_button, chat_activity)
            except:
                pass
            
            search_container.addView(
                search_filter_button,
                LayoutHelper.createFrame(48, 48, Gravity.LEFT | Gravity.TOP, left_margin, 0, 0, 0)
            )
            
            self.search_filter_buttons[activity_id] = search_filter_button
            
            try:
                search_count_text = get_private_field(chat_activity, "searchCountText")
                if search_count_text:
                    current_padding_left = search_count_text.getPaddingLeft()
                    new_padding_left = current_padding_left + AndroidUtilities.dp(48)
                    search_count_text.setPadding(
                        new_padding_left,
                        search_count_text.getPaddingTop(),
                        search_count_text.getPaddingRight(),
                        search_count_text.getPaddingBottom()
                    )
            except:
                pass
            
        except:
            pass
    
    def _hook_user_search_button_for_filter(self, user_button, filter_button, chat_activity):
        try:
            from android.view import View
            
            original_listener = None
            try:
                ViewClass = find_class("android.view.View")
                mListenerInfoField = ViewClass.getClass().getDeclaredField("mListenerInfo")
                mListenerInfoField.setAccessible(True)
                listenerInfo = mListenerInfoField.get(user_button)
                
                if listenerInfo:
                    ListenerInfoClass = find_class("android.view.View$ListenerInfo")
                    mOnClickListenerField = ListenerInfoClass.getClass().getDeclaredField("mOnClickListener")
                    mOnClickListenerField.setAccessible(True)
                    original_listener = mOnClickListenerField.get(listenerInfo)
            except:
                pass
            
            plugin_ref = self
            
            def on_user_button_click(v):
                try:
                    plugin_ref.search_filter_current = SEARCH_FILTER_NONE
                    plugin_ref.set_setting("messages_search_filter", SEARCH_FILTER_NONE)
                    
                    if filter_button:
                        filter_button.setVisibility(View.GONE)
                    
                    if original_listener:
                        original_listener.onClick(v)
                except:
                    pass
            
            user_button.setOnClickListener(OnClickListener(on_user_button_click))
        except:
            pass
    
    def _show_search_filter_selector(self, chat_activity):
        try:
            activity = chat_activity.getParentActivity()
            if not activity:
                return
            
            filter_names = [
                getString("search_filter_none", "None"),
                getString("search_filter_photos", "Photos"),
                getString("search_filter_videos", "Videos"),
                getString("search_filter_voice_messages", "Voice Messages"),
                getString("search_filter_video_messages", "Video Messages"),
                getString("search_filter_files", "Files"),
                getString("search_filter_music", "Music"),
                getString("search_filter_gifs", "GIFs"),
                getString("search_filter_geolocation", "Geolocation"),
                getString("search_filter_contacts", "Contacts"),
                getString("search_filter_my_mentions", "My Mentions")
            ]
            
            filter_values = [
                SEARCH_FILTER_NONE, SEARCH_FILTER_PHOTOS, SEARCH_FILTER_VIDEOS, SEARCH_FILTER_VOICE_MESSAGES,
                SEARCH_FILTER_VIDEO_MESSAGES, SEARCH_FILTER_FILES, SEARCH_FILTER_MUSIC, SEARCH_FILTER_GIFS,
                SEARCH_FILTER_GEO, SEARCH_FILTER_CONTACTS, SEARCH_FILTER_MENTIONS
            ]
            
            current_index = filter_values.index(self.search_filter_current) if self.search_filter_current in filter_values else 0
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(getString("search_filter", "Search Filter"))
            
            linear_layout = LinearLayout(activity)
            linear_layout.setOrientation(LinearLayout.VERTICAL)
            builder.set_view(linear_layout)
            
            RadioColorCellClass = find_class("org.telegram.ui.Cells.RadioColorCell")
            
            dialog_ref = [None]
            
            for i in range(len(filter_names)):
                cell = RadioColorCellClass(activity)
                cell.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
                cell.setTag(i)
                cell.setCheckColor(
                    Theme.getColor(Theme.key_radioBackground),
                    Theme.getColor(Theme.key_dialogRadioBackgroundChecked)
                )
                cell.setTextAndValue(filter_names[i], i == current_index)
                cell.setBackground(Theme.getSelectorDrawable(False))
                linear_layout.addView(cell)
                
                plugin_ref = self
                
                def create_click_listener(index):
                    def on_click(v):
                        try:
                            selected_filter = filter_values[index]
                            plugin_ref.search_filter_current = selected_filter
                            plugin_ref.set_setting("messages_search_filter", selected_filter)
                            
                            chat_activity.openSearchWithText(None)
                            
                            def jump_to_first():
                                try:
                                    from org.telegram.messenger import AccountInstance
                                    account_num = chat_activity.getCurrentAccount()
                                    account = AccountInstance.getInstance(account_num)
                                    media_data_controller = account.getMediaDataController()
                                    
                                    guid = chat_activity.getClassGuid()
                                    media_data_controller.jumpToSearchedMessage(guid, 0)
                                except:
                                    pass
                            
                            from android_utils import R
                            AndroidUtilities.runOnUIThread(R(jump_to_first), 500)
                            
                            if dialog_ref[0]:
                                dialog_ref[0].dismiss()
                        except:
                            pass
                    return on_click
                
                cell.setOnClickListener(OnClickListener(create_click_listener(i)))
            
            builder.set_negative_button(getString("cancel", "Cancel"), None)
            dialog_ref[0] = builder.show()
            
        except:
            pass
    
    def _get_search_filter_type(self):
        try:
            if self.search_filter_current == SEARCH_FILTER_PHOTOS:
                return TLRPC.TL_inputMessagesFilterPhotos()
            elif self.search_filter_current == SEARCH_FILTER_VIDEOS:
                return TLRPC.TL_inputMessagesFilterVideo()
            elif self.search_filter_current == SEARCH_FILTER_VOICE_MESSAGES:
                return TLRPC.TL_inputMessagesFilterVoice()
            elif self.search_filter_current == SEARCH_FILTER_VIDEO_MESSAGES:
                return TLRPC.TL_inputMessagesFilterRoundVideo()
            elif self.search_filter_current == SEARCH_FILTER_FILES:
                return TLRPC.TL_inputMessagesFilterDocument()
            elif self.search_filter_current == SEARCH_FILTER_MUSIC:
                return TLRPC.TL_inputMessagesFilterMusic()
            elif self.search_filter_current == SEARCH_FILTER_GIFS:
                return TLRPC.TL_inputMessagesFilterGif()
            elif self.search_filter_current == SEARCH_FILTER_GEO:
                return TLRPC.TL_inputMessagesFilterGeo()
            elif self.search_filter_current == SEARCH_FILTER_CONTACTS:
                return TLRPC.TL_inputMessagesFilterContacts()
            elif self.search_filter_current == SEARCH_FILTER_MENTIONS:
                return TLRPC.TL_inputMessagesFilterMyMentions()
            else:
                return TLRPC.TL_inputMessagesFilterEmpty()
        except:
            return TLRPC.TL_inputMessagesFilterEmpty()
    
    def _hook_remove_greeting_sticker(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            BooleanTYPE = self._get_class("java.lang.Boolean").TYPE
            create_empty_view_method = ChatActivityClass.getClass().getDeclaredMethod(
                "createEmptyView",
                BooleanTYPE
            )
            create_empty_view_method.setAccessible(True)
            
            self.hook_remove_greeting_sticker_ref = self.hook_method(create_empty_view_method, RemoveGreetingStickerHook())
        except Exception as e:
            pass
    
    def _hook_select_all_media(self):
        try:
            SharedMediaLayoutClass = self._get_class("org.telegram.ui.Components.SharedMediaLayout")
            if not SharedMediaLayoutClass:
                return
            
            plugin_ref = weakref.ref(self)
            
            class SharedMediaLayoutHook:
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        plugin = plugin_ref()
                        if plugin:
                            plugin._add_select_all_button(param.thisObject)
                    except:
                        pass
            
            for constructor in SharedMediaLayoutClass.getClass().getDeclaredConstructors():
                if len(constructor.getParameterTypes()) >= 5:
                    constructor.setAccessible(True)
                    self.hook_select_all_media_ref = self.hook_method(constructor, SharedMediaLayoutHook())
                    break
        except:
            pass
    
    def _add_select_all_button(self, shared_media_layout):
        try:
            action_mode_layout = get_private_field(shared_media_layout, "actionModeLayout")
            action_mode_views = get_private_field(shared_media_layout, "actionModeViews")
            if not action_mode_layout or action_mode_views is None:
                return
            
            select_all_item = ActionBarMenuItem(
                action_mode_layout.getContext(), None,
                Theme.getColor(Theme.key_actionBarActionModeDefaultSelector),
                Theme.getColor(Theme.key_actionBarActionModeDefaultIcon), False
            )
            select_all_item.setIcon(R_tg.drawable.msg_select_between_solar)
            select_all_item.setContentDescription("Select All")
            select_all_item.setDuplicateParentStateEnabled(False)
            shared_media_layout_ref = weakref.ref(shared_media_layout)
            def on_select_all_click(v, ref=shared_media_layout_ref):
                sml = ref()
                if sml:
                    self._select_all_media(sml)
            select_all_item.setOnClickListener(OnClickListener(on_select_all_click))
            
            action_mode_layout.addView(select_all_item, 2, LinearLayout.LayoutParams(AndroidUtilities.dp(54), LinearLayout.LayoutParams.MATCH_PARENT))
            action_mode_views.add(2, select_all_item)
        except:
            pass
    
    def _scroll_and_select(self, shared_media_layout, current_page, selected_files, dialog_id, shared_media_data, media_type):
        try:
            list_view = get_private_field(current_page, "listView")
            if not list_view:
                return
            
            messages = get_private_field(shared_media_data[media_type], "messages")
            total_count = get_private_field(shared_media_data[media_type], "totalCount")
            
            state = {"index": 0, "count": messages.size() if messages else 0, "load_attempts": 0}
            BATCH_SIZE = 20
            MAX_LOAD_ATTEMPTS = 5
            MAX_SELECTION = 100
            
            plugin_ref = weakref.ref(self)
            shared_media_ref = weakref.ref(shared_media_layout)
            
            def step():
                try:
                    plugin = plugin_ref()
                    shared_media = shared_media_ref()
                    if not plugin or not shared_media:
                        return
                    
                    messages_now = get_private_field(shared_media_data[media_type], "messages")
                    if not messages_now:
                        return
                    
                    done = False
                    for _ in range(BATCH_SIZE):
                        i = state["index"]
                        if i >= state["count"]:
                            if state["count"] < total_count and state["count"] < MAX_SELECTION:
                                def attempt_load():
                                    try:
                                        pos = max(0, state["count"] - 1)
                                        list_view.scrollToPosition(pos)
                                        
                                        def check_new_count():
                                            try:
                                                new_messages = get_private_field(shared_media_data[media_type], "messages")
                                                new_count = new_messages.size() if new_messages else 0
                                                if new_count > state["count"]:
                                                    state["count"] = new_count
                                                    state["load_attempts"] = 0
                                                    run_on_ui_thread(step)
                                                else:
                                                    state["load_attempts"] += 1
                                                    if state["load_attempts"] < MAX_LOAD_ATTEMPTS:
                                                        run_on_ui_thread(attempt_load, 300)
                                            except:
                                                pass
                                        run_on_ui_thread(check_new_count, 300)
                                    except:
                                        pass
                                attempt_load()
                            else:
                                def scroll_to_start():
                                    try:
                                        list_view.scrollToPosition(0)
                                    except:
                                        pass
                                run_on_ui_thread(scroll_to_start, 200)
                            return
                        
                        if selected_files[0].size() + selected_files[1].size() >= MAX_SELECTION:
                            def scroll_to_start():
                                try:
                                    list_view.scrollToPosition(0)
                                except:
                                    pass
                            run_on_ui_thread(scroll_to_start, 200)
                            return
                        
                        try:
                            message_obj = messages_now.get(i)
                            state["index"] = i + 1
                            if message_obj:
                                load_index = 0 if message_obj.getDialogId() == dialog_id else 1
                                if selected_files[load_index].indexOfKey(message_obj.getId()) < 0:
                                    selected_files[load_index].put(message_obj.getId(), message_obj)
                        except:
                            pass
                    
                    selected_messages_count_text_view = get_private_field(shared_media, "selectedMessagesCountTextView")
                    if selected_messages_count_text_view:
                        selected_messages_count_text_view.setNumber(selected_files[0].size() + selected_files[1].size(), True)
                    
                    adapter = list_view.getAdapter()
                    if adapter:
                        adapter.notifyDataSetChanged()
                    
                    run_on_ui_thread(step)
                except:
                    pass
            
            run_on_ui_thread(step)
        except:
            pass
    
    def _select_all_media(self, shared_media_layout):
        try:
            media_pages = get_private_field(shared_media_layout, "mediaPages")
            if not media_pages:
                return
            
            scroll_sliding_tab = get_private_field(shared_media_layout, "scrollSlidingTextTabStrip")
            current_tab_id = scroll_sliding_tab.getCurrentTabId() if scroll_sliding_tab else 0
            
            current_page = None
            for page in media_pages:
                if page and get_private_field(page, "selectedType") == current_tab_id:
                    current_page = page
                    break
            
            if not current_page:
                return
            
            list_view = get_private_field(current_page, "listView")
            selected_files = get_private_field(shared_media_layout, "selectedFiles")
            dialog_id = get_private_field(shared_media_layout, "dialog_id")
            shared_media_data = get_private_field(shared_media_layout, "sharedMediaData")
            
            if not list_view or not selected_files or not shared_media_data:
                return
            
            media_type = get_private_field(current_page, "selectedType")
            if media_type >= len(shared_media_data):
                return
            
            messages = get_private_field(shared_media_data[media_type], "messages")
            if not messages:
                return
            
            total_count = get_private_field(shared_media_data[media_type], "totalCount")
            
            self._scroll_and_select(shared_media_layout, current_page, selected_files, dialog_id, shared_media_data, media_type)
        except:
            pass
    
    def _hook_always_visible_schedule_button(self):
        try:
            ChatActivityEnterViewClass = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            if not ChatActivityEnterViewClass:
                return
            
            update_schedule_button_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod(
                "updateScheduleButton",
                find_class("java.lang.Boolean").TYPE
            )
            update_schedule_button_method.setAccessible(True)
            self.hook_always_visible_schedule_button_ref = self.hook_method(update_schedule_button_method, AlwaysVisibleScheduleButtonHook(self))
            
            check_send_button_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod(
                "checkSendButton",
                find_class("java.lang.Boolean").TYPE
            )
            check_send_button_method.setAccessible(True)
            self.hook_check_send_button_ref = self.hook_method(check_send_button_method, CheckSendButtonHook(self))
            
        except Exception as e:
            self.log(f"Error hooking always visible schedule button: {e}")
    
    def _hook_gift_drawer(self):
        try:
            DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
            resetItems_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("resetItems")
            resetItems_method.setAccessible(True)
            
            class DrawerResetHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        items_field = adapter.getClass().getDeclaredField("items")
                        items_field.setAccessible(True)
                        items = items_field.get(adapter)
                        
                        if items is None:
                            return
                        
                        insert_position = -1
                        found_bots = False
                        
                        for i in range(items.size()):
                            item = items.get(i)
                            if item is not None:
                                try:
                                    bot_field = item.getClass().getDeclaredField("bot")
                                    bot_field.setAccessible(True)
                                    bot = bot_field.get(item)
                                    if bot is not None:
                                        found_bots = True
                                except:
                                    pass
                            elif found_bots and item is None:
                                insert_position = i
                                break
                        
                        if insert_position == -1:
                            insert_position = 0
                        
                        current_account = UserConfig.selectedAccount
                        if not UserConfig.getInstance(current_account).isClientActivated():
                            return
                        
                        Item = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter$Item")
                        gift_icon = R_tg.drawable.menu_gift
                        gift_text = LocaleController.getString(R_tg.string.Gift2TitleSelf1)
                        gift_item = Item(1003, gift_text, gift_icon)
                        items.add(insert_position, gift_item)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_reset_ref = self.hook_method(resetItems_method, DrawerResetHook(self))
            self._hook_gift_drawer_click()
            self._hook_gift_drawer_cell()
            
        except Exception:
            pass
    
    def _hook_gift_drawer_click(self):
        try:
            DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
            click_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("click", 
                jclass("android.view.View"), 
                jclass("java.lang.Integer").TYPE)
            click_method.setAccessible(True)
            
            class DrawerClickHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
                def before_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        position = int(param.args[1])
                        
                        getId_method = adapter.getClass().getDeclaredMethod("getId", jclass("java.lang.Integer").TYPE)
                        getId_method.setAccessible(True)
                        
                        from java.lang import Integer
                        item_id = getId_method.invoke(adapter, Integer(position))
                        
                        if item_id == 1003:
                            self._open_gift_sheet()
                            param.setResult(True)
                            
                    except Exception:
                        pass
                
                def _open_gift_sheet(self):
                    try:
                        def open_sheet():
                            try:
                                current_account = UserConfig.selectedAccount
                                client_user_id = UserConfig.getInstance(current_account).getClientUserId()
                                
                                if not hasattr(LaunchActivity, 'instance') or LaunchActivity.instance is None:
                                    return
                                
                                launch_activity = LaunchActivity.instance
                                
                                getSafeLastFragment_method = launch_activity.getClass().getDeclaredMethod("getSafeLastFragment")
                                getSafeLastFragment_method.setAccessible(True)
                                last_fragment = getSafeLastFragment_method.invoke(launch_activity)
                                
                                if last_fragment is None or last_fragment.getContext() is None:
                                    return
                                
                                GiftSheet = jclass("org.telegram.ui.Gifts.GiftSheet")
                                gift_sheet = GiftSheet(
                                    last_fragment.getContext(),
                                    current_account,
                                    client_user_id,
                                    None,
                                    None
                                )
                                gift_sheet.show()
                                
                            except Exception:
                                pass
                        
                        run_on_ui_thread(open_sheet)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_click_ref = self.hook_method(click_method, DrawerClickHook(self))
            
        except Exception:
            pass
    
    def _hook_gift_drawer_cell(self):
        try:
            DrawerActionCell = jclass("org.telegram.ui.Cells.DrawerActionCell")
            onDraw_method = DrawerActionCell.getClass().getDeclaredMethod("onDraw", jclass("android.graphics.Canvas"))
            onDraw_method.setAccessible(True)
            
            class DrawerCellDrawHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
                def after_hooked_method(self, param):
                    try:
                        cell = param.thisObject
                        canvas = param.args[0]
                        
                        currentId_field = cell.getClass().getDeclaredField("currentId")
                        currentId_field.setAccessible(True)
                        current_id = currentId_field.getInt(cell)
                        
                        if current_id != 1003:
                            return
                        
                        from org.telegram.ui.Stars import StarsController
                        from android.graphics import RectF
                        
                        current_account = UserConfig.selectedAccount
                        balance = StarsController.getInstance(current_account).getBalance()
                        if balance is None:
                            return
                        
                        counter = balance.amount
                        text = str(counter)
                        
                        star_drawable = cell.getContext().getResources().getDrawable(R_tg.drawable.star_small_inner).mutate()
                        star_size = AndroidUtilities.dp(17)
                        
                        countTop = AndroidUtilities.dp(12.5)
                        textWidth = int(Theme.dialogs_countTextPaint.measureText(text))
                        countWidth = max(AndroidUtilities.dp(10), textWidth + star_size + AndroidUtilities.dp(4))
                        countLeft = cell.getMeasuredWidth() - countWidth - AndroidUtilities.dp(25)
                        
                        x = countLeft - AndroidUtilities.dp(5.5)
                        
                        rect = RectF()
                        rect.set(x, countTop, x + countWidth + AndroidUtilities.dp(14), countTop + AndroidUtilities.dp(23))
                        
                        canvas.drawRoundRect(rect, 11.5 * AndroidUtilities.density, 11.5 * AndroidUtilities.density, Theme.dialogs_countGrayPaint)
                        
                        text_x = rect.left + (rect.width() - textWidth - star_size - AndroidUtilities.dp(4)) / 2
                        canvas.drawText(text, text_x, countTop + AndroidUtilities.dp(16), Theme.dialogs_countTextPaint)
                        
                        star_x = int(text_x + textWidth + AndroidUtilities.dp(4))
                        star_y = int(countTop + (AndroidUtilities.dp(23) - star_size) / 2)
                        star_drawable.setBounds(star_x, star_y, star_x + star_size, star_y + star_size)
                        star_drawable.draw(canvas)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_cell_ref = self.hook_method(onDraw_method, DrawerCellDrawHook(self))
            
        except Exception:
            pass
    
    def pre_request_hook(self, request_name: str, account: int, request):
        
        if request_name == "TL_messages_forwardMessages" and self.get_setting("send_comments_after_forward", False):
            if not hasattr(request, "to_peer") or request.to_peer is None:
                return HookResult()
            try:
                peer = DialogObject.getPeerDialogId(request.to_peer)
            except Exception:
                return HookResult()
            if not peer:
                return HookResult()
            entry = self._send_comments_pending.pop(peer, None)
            if entry is not None:
                params, acc = entry
                def after_forward():
                    def send_on_main_thread():
                        self._send_comments_bypass = True
                        try:
                            SendMessagesHelper.getInstance(acc).sendMessage(params)
                        except Exception:
                            pass
                        finally:
                            self._send_comments_bypass = False
                    run_on_ui_thread(send_on_main_thread)
                run_on_queue(after_forward, PLUGINS_QUEUE, 400)
            return HookResult()
        
        return HookResult()
    
    def on_send_message_hook(self, account: int, params: any):
        from base_plugin import HookResult, HookStrategy
        message = getattr(params, "message", "")
        
        if not isinstance(message, str) or not message:
            return HookResult()
        
        if self.get_setting("send_comments_after_forward", False) and not self._send_comments_bypass:
            if not hasattr(params, "message") or not isinstance(params.message, str):
                return HookResult()
            if not params.message:
                return HookResult()
            if not hasattr(params, "peer") or not params.peer:
                return HookResult()
            if hasattr(params, 'replyToStoryItem') and params.replyToStoryItem is not None:
                return HookResult() # Skip story replies - they don't use forward RPC, so intercepting them causes the message to be canceled but never sent
            try:
                LaunchActivity = jclass("org.telegram.ui.LaunchActivity")
                ChatActivity = jclass("org.telegram.ui.ChatActivity")
                DialogsActivity = jclass("org.telegram.ui.DialogsActivity")
                ShareAlert = jclass("org.telegram.ui.Components.ShareAlert")
                fragment = LaunchActivity.getLastFragment()
            except Exception:
                return HookResult()
            if fragment is None:
                return HookResult()
            should_intercept = False
            try:
                if isinstance(fragment, ChatActivity):
                    preview = get_private_field(fragment, "messagePreviewParams")
                    if preview is not None:
                        forward = getattr(preview, "forwardMessages", None)
                        if forward is not None:
                            messages = getattr(forward, "messages", None)
                            try:
                                has_forward = messages is not None and not messages.isEmpty()
                            except Exception:
                                has_forward = False
                            if has_forward:
                                should_intercept = True
                    
                    visibleDialog = get_private_field(fragment, "visibleDialog")
                    if visibleDialog is not None and isinstance(visibleDialog, ShareAlert):
                        sendingMessageObjects = get_private_field(visibleDialog, "sendingMessageObjects")
                        if sendingMessageObjects is not None and not sendingMessageObjects.isEmpty():
                            should_intercept = True
                
                elif isinstance(fragment, DialogsActivity):
                    dialogs_type = get_private_field(fragment, "dialogsType")
                    forward_type = getattr(DialogsActivity, "DIALOGS_TYPE_FORWARD", None)
                    if dialogs_type == forward_type:
                        should_intercept = True
            
            except Exception:
                should_intercept = False
            
            if not should_intercept:
                return HookResult()
            
            peer = params.peer
            self._send_comments_pending[peer] = (params, account)
            return HookResult(strategy=HookStrategy.CANCEL)
        
        return HookResult()


    def _setup_confirmation_hooks(self):
        try:
            send_helper_instance = get_send_messages_helper()
            if not send_helper_instance:
                pass
                return
            send_helper_class = send_helper_instance.getClass()

            send_params_class = jclass("org.telegram.messenger.SendMessagesHelper$SendMessageParams")

            send_message_method = send_helper_class.getDeclaredMethod("sendMessage", send_params_class)
            send_message_method.setAccessible(True)

            self.unhook_send_message = self.hook_method(send_message_method, self.hook_handler)
            pass
            
            chat_enter_view_class = self._get_class("org.telegram.ui.Components.ChatActivityEnterView")
            set_command_method = chat_enter_view_class.getClass().getDeclaredMethod("setCommand", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("java.lang.String").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE)
            set_command_method.setAccessible(True)
            
            self.unhook_set_command = self.hook_method(set_command_method, SetCommandHook(self))
            
        except Exception as e:
            pass

    def _setup_deeplink_hooks(self):
        try:
            if self.get_setting("confirm_deeplinks", False) or self.get_setting("confirm_ayugram_deeplinks", False):
                launch_activity_cls = self._get_class("org.telegram.ui.LaunchActivity")
                
                method = launch_activity_cls.getClass().getDeclaredMethod("handleIntent", 
                    self._get_class("android.content.Intent").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                
                self.unhook_deeplink = self.hook_method(method, DeepLinkHook(self))
                pass
                
        except Exception as e:
            pass


    def _hook_dialogs_activity(self):
        try:
            cls = self._get_class("org.telegram.ui.DialogsActivity")
            method = cls.getClass().getDeclaredMethod("onResume")
            ref = self.hook_method(method, DialogsActivityHook(self))
            self.hook_dialogs_ref = ref
            
            try:
                destroy_method = cls.getClass().getDeclaredMethod("onDestroy")
                destroy_ref = self.hook_method(destroy_method, DialogsActivityDestroyHook(self))
                self.hook_dialogs_destroy_ref = destroy_ref
            except Exception:
                pass
                
        except Exception as e:
            pass

    def _hook_dialog_cell(self):
        try:
            cls = self._get_class("org.telegram.ui.Cells.DialogCell")
            boolean_class = self._get_class("java.lang.Boolean").TYPE
            method = cls.getClass().getDeclaredMethod("setOpenBotButton", boolean_class)
            if method is not None:
                ref = self.hook_method(method, DialogCellHook(self))
                self.hook_dialog_cell_ref = ref
            pass
        except Exception as e:
            pass






    def _hook_swipe_prevention(self):
        try:
            cls = self._get_class("org.telegram.ui.ChatActivity")
            if cls:
                method = cls.getClass().getDeclaredMethod("isSwipeBackEnabled", 
                    self._get_class("android.view.MotionEvent").getClass())
                method.setAccessible(True)
                ref = self.hook_method(method, SwipePreventionHook(self))
                self.hook_swipe_prevention_ref = ref
            pass
        except Exception as e:
            pass

    def _setup_fab_settings_listener(self, dialogs_activity):
        try:
            large_btn = get_private_field(dialogs_activity, "floatingButtonContainer")
            if large_btn is None:
                return
            
            if hasattr(large_btn, '_uitweaks_listener_set'):
                return
            
            def handle_fab_long_press(*args):
                try:
                    try:
                        root = dialogs_activity.getParentActivity().getWindow().getDecorView()
                        flags = HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                        root.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags)
                    except:
                        pass
                    
                    action = self.get_setting("fab_action_selector", 0)
                    
                    if self.get_setting("hide_archived_chats", False) and not self.get_setting("hide_archived_from_drawer", False):
                        action = 0
                    
                    if action == 0:
                        java_plugin = PluginsController.getInstance().plugins.get(__id__)
                        if java_plugin:
                            dialogs_activity.presentFragment(PluginSettingsActivity(java_plugin))
                    elif action == 1:
                        self._open_archived_chats_from_fab(dialogs_activity)
                except Exception as e:
                    pass
            
            large_btn.setOnLongClickListener(OnLongClickListener(handle_fab_long_press))
            large_btn._uitweaks_listener_set = True
        except Exception as e:
            pass

    def _hook_article_viewer(self):
        try:
            from android.view import MotionEvent
            cls = find_class("org.telegram.ui.ArticleViewer$WindowView")
            method = cls.getClass().getDeclaredMethod("handleTouchEvent", MotionEvent)
            method.setAccessible(True)
            ref = self.hook_method(method, ArticleViewerFixHook(self))
            self.hook_article_viewer_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_webapp_swipe_prevention(self):
        try:
            swipe_cls = self._get_class("org.telegram.ui.bots.ChatAttachAlertBotWebViewLayout$WebViewSwipeContainer")
            context_class = jclass("android.content.Context")
            method = swipe_cls.getClass().getDeclaredConstructor(context_class)
            ref = self.hook_method(method, WebAppSwipePreventionHook(self))
            self.hook_webapp_swipe_prevention_ref = ref
        except Exception as e:
            pass

    def _hook_download_manager(self):
        try:
            from java import jclass
            cls = jclass("org.telegram.messenger.DownloadController")
            method = cls.getClass().getDeclaredMethod("hasUnviewedDownloads")
            ref = self.hook_method(method, DownloadManagerHook(self))
            self.hook_download_manager_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_birthday_alert(self):
        try:
            DialogsActivityClass = self._get_class("org.telegram.ui.DialogsActivity")
            if not DialogsActivityClass:
                return
            
            updateDialogsHintMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateDialogsHint")
            updateDialogsHintMethod.setAccessible(True)
            
            ref = self.hook_method(updateDialogsHintMethod, BirthdayAlertHook(self))
            self.hook_birthday_alert_ref = ref
        except Exception as e:
            pass

    def _hook_proxy_button(self):
        try:
            from java import jclass
            cls = jclass("org.telegram.ui.DialogsActivity")
            method = cls.getClass().getDeclaredMethod("updateProxyButton", jclass("java.lang.Boolean").TYPE, jclass("java.lang.Boolean").TYPE)
            ref = self.hook_method(method, ProxyButtonHook(self))
            self.hook_proxy_button_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_star_reaction_menu(self):
        try:
            reaction_menu_class = self._get_class("org.telegram.ui.Components.ReactionsContainerLayout")
            method = reaction_menu_class.getClass().getDeclaredMethod("setMessage", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("org.telegram.tgnet.TLRPC$ChatFull").getClass(),
                self._get_class("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, StarReactionMenuHook(self))
            self.hook_star_reaction_menu_ref = ref
            
            method2 = reaction_menu_class.getClass().getDeclaredMethod("setVisibleReactionsList", 
                self._get_class("java.util.List").getClass(),
                self._get_class("java.lang.Boolean").TYPE)
            method2.setAccessible(True)
            ref2 = self.hook_method(method2, StarReactionVisibleListHook(self))
            self.hook_star_reaction_visible_list_ref = ref2
            
            method3 = reaction_menu_class.getClass().getDeclaredMethod("dispatchDraw", 
                self._get_class("android.graphics.Canvas").getClass())
            method3.setAccessible(True)
            ref3 = self.hook_method(method3, StarReactionGradientHook(self))
            self.hook_star_reaction_gradient_ref = ref3
            pass
            
        except Exception as e:
            pass

    def _hook_star_reaction_layout(self):
        try:
            reactions_layout_class = self._get_class("org.telegram.ui.Components.Reactions.ReactionsLayoutInBubble")
            set_message_method = reactions_layout_class.getClass().getDeclaredMethod("setMessage", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider").getClass())
            set_message_method.setAccessible(True)
            ref = self.hook_method(set_message_method, StarReactionLayoutDrawHook(self))
            self.hook_star_reaction_layout_draw_ref = ref
        except Exception as e:
            pass

    def _remove_star_reaction_hooks(self):
        for ref_attr in ("hook_star_reaction_menu_ref", "hook_star_reaction_visible_list_ref", "hook_star_reaction_gradient_ref", "hook_star_reaction_layout_draw_ref"):
            ref = getattr(self, ref_attr, None)
            if ref:
                self.unhook_method(ref)
                setattr(self, ref_attr, None)


    def _hide_elements_on_start(self):
        try:
            fragment = get_last_fragment()
            
            if fragment is not None and fragment.getClass().getSimpleName() == "DialogsActivity":
                action_bar_field = fragment.getClass().getSuperclass().getDeclaredField("actionBar")
                action_bar_field.setAccessible(True)
                action_bar = action_bar_field.get(fragment)
                
                if action_bar is not None:
                    pass
        except Exception as e:
            pass


    def _hide_bot_open_buttons_on_resume(self, dialogs_activity):
        try:
            pass
        except Exception as e:
            pass






    def _setup_open_link_internally_hook(self):
        try:
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            chat_message_cell_class = self._get_class("org.telegram.ui.Cells.ChatMessageCell")
            character_style_class = self._get_class("android.text.style.CharacterStyle")
            
            string_class = self._get_class("java.lang.String")
            int_class = self._get_class("java.lang.Integer").TYPE
            
            try:
                method = chat_activity_class.getClass().getDeclaredMethod(
                    "openLinkInternally",
                    string_class.getClass(),
                    chat_message_cell_class.getClass(),
                    character_style_class.getClass(),
                    int_class,
                    int_class
                )
                method.setAccessible(True)
                self.hook_open_link_internally_ref = self.hook_method(method, OpenLinkInternallyHook(self))
                pass
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _setup_browser_open_url_hook(self):
        try:
            browser_class = self._get_class("org.telegram.messenger.browser.Browser")
            context_class = self._get_class("android.content.Context")
            uri_class = self._get_class("android.net.Uri")
            progress_class = self._get_class("org.telegram.messenger.browser.Browser$Progress")
            method = browser_class.getClass().getDeclaredMethod(
                "openUrl",
                context_class.getClass(),
                uri_class.getClass(),
                bool,
                bool,
                bool,
                progress_class.getClass(),
                str,
                bool,
                bool,
                bool
            )
            method.setAccessible(True)
            self.hook_browser_open_url_ref = self.hook_method(method, BrowserOpenUrlHook(self))
            pass
        except Exception as e:
            pass


    def _setup_open_profile_hooks(self):

        pass

    def _hook_phone_number(self):
        try:
            PhoneFormat = jclass("org.telegram.PhoneFormat.PhoneFormat")
            method = PhoneFormat.getClass().getDeclaredMethod("format", jclass("java.lang.String"))
            method.setAccessible(True)
            self.hook_phone_number_ref = self.hook_method(method, PhoneFormatHook(self))
        except:
            pass

    def _hook_messages_controller(self):
        try:
            from java import jclass
            
            method = jclass("org.telegram.messenger.MessagesController").getClass().getDeclaredMethod("getDialogs", jclass("java.lang.Integer").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, MessagesControllerGetDialogsHook(self))
            
            self.hook_messages_controller_ref = ref
            pass

                
        except Exception as e:
            pass

    def _hook_chat_utils_has_archived(self):
        try:
            from java import jclass
            
            chat_utils_class = jclass("com.exteragram.messenger.utils.ChatUtils")
            method = chat_utils_class.getClass().getDeclaredMethod("hasArchivedChats")
            method.setAccessible(True)
            ref = self.hook_method(method, ChatUtilsHasArchivedHook(self))
            
            self.hook_chat_utils_has_archived_ref = ref
        except Exception as e:
            pass

    def _hook_extera_config_archived(self):
        try:
            from java import jclass
            
            extera_config_class = jclass("com.exteragram.messenger.ExteraConfig")
            method = extera_config_class.getClass().getDeclaredMethod("setObj", jclass("java.lang.String"), jclass("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, ExteraConfigArchivedHook(self))
            
            self.hook_extera_config_archived_ref = ref
        except Exception as e:
            pass

    def _hook_send_typing_method(self):
        try:
            from java import jclass
            from java.lang import Long, Integer, String as JString
            
            method = jclass("org.telegram.messenger.MessagesController").getClass().getDeclaredMethod(
                "sendTyping", 
                Long.TYPE, Long.TYPE, Integer.TYPE, JString, Integer.TYPE
            )
            method.setAccessible(True)
            ref = self.hook_method(method, MessagesControllerSendTypingHook(self))
            
            if not hasattr(self, 'hook_send_typing_refs'):
                self.hook_send_typing_refs = []
            self.hook_send_typing_refs.append(ref)
        except Exception:
            pass

    def _hook_update_bot_button(self):
        try:
            ChatActivityEnterView = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            boolean_class = find_class("java.lang.Boolean").TYPE
            method = ChatActivityEnterView.getClass().getDeclaredMethod("updateBotButton", boolean_class)
            method.setAccessible(True)
            self.hook_update_bot_button_ref = self.hook_method(method, UpdateBotButtonHook(self))
            pass
        except Exception as e:
            pass



    def _hook_voice_message_control(self):
        try:
            MediaControllerClass = jclass("org.telegram.messenger.MediaController")
            java_class = MediaControllerClass.getClass()
            
            method = java_class.getDeclaredMethod(
                "cleanupPlayer", 
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_voice_message_control_ref = self.hook_method(method, VoiceMessageControlHook(self))
            pass
            
        except Exception as e:
            pass

    def _hook_video_message_control(self):
        try:
            MediaControllerClass = jclass("org.telegram.messenger.MediaController")
            java_class = MediaControllerClass.getClass()
            
            method = java_class.getDeclaredMethod(
                "cleanupPlayer", 
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_video_message_control_ref = self.hook_method(method, VideoMessageControlHook(self))
            pass
            
        except Exception as e:
            pass

    def _apply_delete_with_duration_hooks(self):
        if hasattr(self, 'delete_with_duration_fillitems_ref') and self.delete_with_duration_fillitems_ref:
            self.unhook_method(self.delete_with_duration_fillitems_ref)
            self.delete_with_duration_fillitems_ref = None
        if hasattr(self, 'delete_with_duration_onclick_ref') and self.delete_with_duration_onclick_ref:
            self.unhook_method(self.delete_with_duration_onclick_ref)
            self.delete_with_duration_onclick_ref = None
        
        if self.get_setting("enable_delete_with_duration", False):
            self._hook_delete_with_duration()

    def _hook_delete_with_duration(self):
        try:
            DeleteMessagesBottomSheet = self._get_class("org.telegram.ui.Components.DeleteMessagesBottomSheet")
            ArrayList = self._get_class("java.util.ArrayList")
            UniversalAdapter = self._get_class("org.telegram.ui.Components.UniversalAdapter")
            UItem = self._get_class("org.telegram.ui.Components.UItem")
            View = self._get_class("android.view.View")
            Integer = self._get_class("java.lang.Integer")
            Float = self._get_class("java.lang.Float")
            
            if not DeleteMessagesBottomSheet:
                self.log("Failed to find DeleteMessagesBottomSheet class")
                return
            
            fillItems_method = DeleteMessagesBottomSheet.getClass().getDeclaredMethod("fillItems", ArrayList.getClass(), UniversalAdapter.getClass())
            fillItems_method.setAccessible(True)
            
            onClick_method = DeleteMessagesBottomSheet.getClass().getDeclaredMethod("onClick", UItem.getClass(), View.getClass(), Integer.TYPE, Float.TYPE, Float.TYPE)
            onClick_method.setAccessible(True)
            
            self.delete_with_duration_fillitems_ref = self.hook_method(fillItems_method, DeleteWithDurationFillItemsHook(self))
            self.delete_with_duration_onclick_ref = self.hook_method(onClick_method, DeleteWithDurationOnClickHook(self))
            
        except Exception as e:
            self.log(f"Failed to hook delete with duration: {e}")
            import traceback
            traceback.print_exc()


    def _hook_unread_badge(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            ContextClass = self._get_class("android.content.Context")
            create_view_method = ChatActivityClass.getClass().getDeclaredMethod(
                "createView", 
                ContextClass
            )
            create_view_method.setAccessible(True)
            self.create_view_hook_ref = self.hook_method(
                create_view_method,
                CreateViewHook(self)
            )
            
            destroy_method = ChatActivityClass.getClass().getDeclaredMethod("onFragmentDestroy")
            destroy_method.setAccessible(True)
            self.destroy_hook_ref = self.hook_method(
                destroy_method,
                FragmentDestroyHook(self)
            )
            
        except Exception as e:
            pass

    def _hook_gif_spoiler(self):
        try:
            SHOW_SHEET_RUNNABLE = self._get_class("org.telegram.ui.ContentPreviewViewer$1")
            method = SHOW_SHEET_RUNNABLE.getClass().getDeclaredMethod("run")
            method.setAccessible(True)
            self.hook_gif_spoiler_ref = self.hook_method(method, GifSpoilerHook(self))
            
            ContentPreviewViewer = find_class("org.telegram.ui.ContentPreviewViewer")
            dismiss_method = ContentPreviewViewer.getClass().getDeclaredMethod("dismissPopupWindow")
            dismiss_method.setAccessible(True)
            self.hook_gif_dismiss_ref = self.hook_method(dismiss_method, GifDismissHook(self))
            self.log("GIF Menu: Hooked both show and dismiss methods")
        except Exception as e:
            self.log(f"GIF Menu: Error hooking GIF methods: {e}")
            pass

    def _hook_process_external_url(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            method = ChatActivityClass.getClass().getDeclaredMethod(
                "processExternalUrl", 
                self._get_class("java.lang.Integer").TYPE,
                self._get_class("java.lang.String").getClass(),
                self._get_class("android.text.style.CharacterStyle").getClass(),
                self._get_class("org.telegram.ui.Cells.ChatMessageCell").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_process_external_url_ref = self.hook_method(method, ProcessExternalUrlHook(self))
        except Exception as e:
            pass


    def _hook_forward_confirmation(self):
        try:
            if getattr(self, 'hook_forward_confirmation_ref', None):
                return
            chat_cls = self._get_class("org.telegram.ui.ChatActivity")
            method = chat_cls.getClass().getDeclaredMethod(
                "forwardMessages",
                self._get_class("java.util.ArrayList").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Integer").TYPE,
                self._get_class("java.lang.Long").TYPE
            )
            method.setAccessible(True)
            self.hook_forward_confirmation_ref = self.hook_method(method, ForwardConfirmationHook(self, method))
            pass
        except Exception as e:
            pass

    def _hook_join_confirmation(self):
        try:
            if getattr(self, 'hook_join_confirmation_ref', None):
                return
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            context_class = self._get_class("android.content.Context")
            
            if not chat_activity_class or not context_class:
                return

            create_view_method = chat_activity_class.getClass().getDeclaredMethod("createView", context_class)
            self.hook_join_confirmation_ref = self.hook_method(create_view_method, JoinConfirmationHook(self))
            
        except Exception as e:
            pass

    def _hook_code_formatting(self):
        try:
            ChatActivity = self._get_class("org.telegram.ui.ChatActivity")
            EditTextCaption = self._get_class("org.telegram.ui.Components.EditTextCaption")
            
            if ChatActivity is None or EditTextCaption is None:
                return
            
            boolean_type = self._get_class("java.lang.Boolean").TYPE
            fillActionModeMenu_method = None
            
            try:
                fillActionModeMenu_method = ChatActivity.getClass().getDeclaredMethod("fillActionModeMenu", 
                    self._get_class("android.view.Menu"), 
                    jclass("org.telegram.tgnet.TLRPC$EncryptedChat"), 
                    boolean_type,
                    boolean_type)
            except Exception:
                try:
                    fillActionModeMenu_method = ChatActivity.getClass().getDeclaredMethod("fillActionModeMenu", 
                        self._get_class("android.view.Menu"), 
                        jclass("org.telegram.tgnet.TLRPC$EncryptedChat"), 
                        boolean_type)
                except Exception:
                    pass

            if fillActionModeMenu_method:
                fillActionModeMenu_method.setAccessible(True)
                self.hook_fill_action_mode_menu_ref = self.hook_method(fillActionModeMenu_method, FillActionModeMenuHook(self))
            
            performMenuAction_method = EditTextCaption.getClass().getDeclaredMethod("performMenuAction", 
                self._get_class("java.lang.Integer").TYPE)
            performMenuAction_method.setAccessible(True)
            
            self.hook_perform_menu_action_ref = self.hook_method(performMenuAction_method, PerformMenuActionHook(self))
            
        except Exception as e:
            traceback.print_exc()

    def _make_selected_code(self, edit_text):
        try:
            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            
            if start < 0 or end < 0 or start == end:
                return
            
            context = edit_text.getContext()
            
            language_edit_text = EditTextBoldCursor(context)
            language_edit_text.setHint(getString("Language", "Language"))
            language_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
            language_edit_text.setMaxLines(1)
            language_edit_text.setSingleLine(True)
            language_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            language_edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            language_edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            language_edit_text.setBackground(Theme.createEditTextDrawable(context, True))
            language_edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            language_edit_text.setCursorSize(AndroidUtilities.dp(20))
            language_edit_text.setCursorWidth(1.5)
            language_edit_text.setPadding(0, 0, 0, 0)
            language_edit_text.setFocusable(True)
            
            try:
                text = edit_text.getText()
                if text:
                    code_spans = text.getSpans(start, end, CodeHighlighting.Span)
                    if code_spans:
                        for span in code_spans:
                            if span.lng:
                                language_edit_text.setText(span.lng)
                                break
            except:
                pass
            
            def on_ok_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(language_edit_text)
                    language = language_edit_text.getText().toString()
                    self._apply_code_formatting(edit_text, start, end, language)
                except Exception:
                    pass
                dialog.dismiss()
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(language_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
            
            builder = AlertDialogBuilder(context)
            builder.set_title(getString("create_code_dialog_title", "Create Code"))
            builder.set_view(language_edit_text)
            builder.set_negative_button(getString("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(getString("ok", "OK"), on_ok_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = language_edit_text.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        language_edit_text.setLayoutParams(layout_params)
                    
                    language_edit_text.requestFocus()
                    text_length = language_edit_text.getText().length() if language_edit_text.getText() else 0
                    language_edit_text.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(language_edit_text)
                except Exception:
                    pass
            
            run_on_ui_thread(apply_layout_params, delay=100)
            
        except Exception as e:
            traceback.print_exc()
    
    def _apply_code_formatting(self, edit_text, start, end, language):
        try:
            editable = edit_text.getText()
            if editable is None:
                return
            
            try:
                code_spans = editable.getSpans(start, end, CodeHighlighting.Span)
                if code_spans:
                    for span in code_spans:
                        editable.removeSpan(span)
            except:
                pass
            
            code_span = CodeHighlighting.Span(True, 0, None, language, editable.subSequence(start, end).toString())
            editable.setSpan(code_span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            
            try:
                delegate = get_private_field(edit_text, "delegate")
                if delegate and hasattr(delegate, 'onSpansChanged'):
                    delegate.onSpansChanged()
            except:
                pass
            
        except Exception as e:
            traceback.print_exc()
    
    def _make_selected_mention(self, edit_text):
        try:
            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            
            if start < 0 or end < 0 or start == end:
                return
            
            context = edit_text.getContext()
            
            mention_edit_text = EditTextBoldCursor(context)
            mention_edit_text.setHint(getString("id_hint", "ID"))
            mention_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
            mention_edit_text.setMaxLines(1)
            mention_edit_text.setSingleLine(True)
            mention_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            mention_edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            mention_edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            mention_edit_text.setBackground(Theme.createEditTextDrawable(context, True))
            mention_edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            mention_edit_text.setCursorSize(AndroidUtilities.dp(20))
            mention_edit_text.setCursorWidth(1.5)
            mention_edit_text.setPadding(0, 0, 0, 0)
            mention_edit_text.setFocusable(True)
            
            try:
                text = edit_text.getText()
                if text:
                    mention_spans = text.getSpans(start, end, URLSpanUserMention)
                    if mention_spans:
                        for span in mention_spans:
                            if span.getURL():
                                mention_edit_text.setText(span.getURL())
                                break
            except:
                pass
            
            def on_ok_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(mention_edit_text)
                    mention_id = mention_edit_text.getText().toString()
                    self._apply_mention_formatting(edit_text, start, end, mention_id)
                except Exception:
                    pass
                dialog.dismiss()
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(mention_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
            
            builder = AlertDialogBuilder(context)
            builder.set_title(getString("create_mention_dialog_title", "Create Mention"))
            builder.set_view(mention_edit_text)
            builder.set_negative_button(getString("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(getString("ok", "OK"), on_ok_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = mention_edit_text.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        mention_edit_text.setLayoutParams(layout_params)
                    
                    mention_edit_text.requestFocus()
                    text_length = mention_edit_text.getText().length() if mention_edit_text.getText() else 0
                    mention_edit_text.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(mention_edit_text)
                except Exception:
                    pass
            
            run_on_ui_thread(apply_layout_params, delay=100)
            
        except Exception as e:
            traceback.print_exc()
    
    def _apply_mention_formatting(self, edit_text, start, end, mention_id):
        try:
            editable = edit_text.getText()
            if editable is None:
                return
            
            try:
                character_spans = editable.getSpans(start, end, CharacterStyle)
                if character_spans:
                    for span in character_spans:
                        span_start = editable.getSpanStart(span)
                        span_end = editable.getSpanEnd(span)
                        editable.removeSpan(span)
                        if span_start < start:
                            editable.setSpan(span, span_start, start, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        if span_end > end:
                            editable.setSpan(span, end, span_end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except:
                pass
            
            try:
                mention_span = URLSpanUserMention(mention_id, 3)
                editable.setSpan(mention_span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except:
                pass
            
            try:
                delegate = get_private_field(edit_text, "delegate")
                if delegate and hasattr(delegate, 'onSpansChanged'):
                    delegate.onSpansChanged()
            except:
                pass
            
        except Exception as e:
            traceback.print_exc()



    def _hook_message_preview_view(self):
        try:
            if getattr(self, 'hook_message_preview_view_ref', None):
                return
                
            cls = self._get_class("org.telegram.ui.Components.MessagePreviewView")
            context_class = jclass("android.content.Context")
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            params_class = self._get_class("org.telegram.messenger.MessagePreviewParams")
            user_class = self._get_class("org.telegram.tgnet.TLRPC$User")
            chat_class = self._get_class("org.telegram.tgnet.TLRPC$Chat")
            int_class = jclass("java.lang.Integer").TYPE
            boolean_class = jclass("java.lang.Boolean").TYPE
            resources_class = self._get_class("org.telegram.ui.Components.MessagePreviewView$ResourcesDelegate")
            
            method = cls.getClass().getDeclaredConstructor(
                context_class, chat_activity_class, params_class, user_class, 
                chat_class, int_class, resources_class, int_class, boolean_class
            )
            self.hook_message_preview_view_ref = self.hook_method(method, MessagePreviewViewHook(self))
        except:
            pass

    def _add_send_media_button(self, preview_view):
        try:
            message_preview_params = get_private_field(preview_view, "messagePreviewParams")
            if not message_preview_params or not message_preview_params.webpage:
                return

            webpage = message_preview_params.webpage
            if not (webpage.photo or webpage.document):
                return

            context = preview_view.getContext()
            resources_provider = get_private_field(preview_view, "resourcesProvider")
            
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            send_button = ActionBarMenuSubItem(context, False, False, resources_provider)
            
            R = jclass("org.telegram.messenger.R")
            
            if webpage.document:
                if hasattr(message_preview_params, 'isVideo') and message_preview_params.isVideo:
                    text = getString("send_video", "Send Video")
                else:
                    text = getString("send_file", "Send File")
            else:
                text = getString("send_photo", "Send Photo")
            
            send_button.setTextAndIcon(text, R.drawable.msg_send)
            send_button.setVisibility(1 if (webpage.document or webpage.photo) else 8)
            
            def send_media(view=None):
                run_on_ui_thread(lambda: self._send_media(preview_view, webpage))
            
            send_button.setOnClickListener(OnClickListener(send_media))
            
            menu = self._find_send_media_menu(preview_view)
            if menu and hasattr(menu, 'addView'):
                LayoutHelper = jclass("org.telegram.ui.Components.LayoutHelper")
                menu.addView(send_button, LayoutHelper.createLinear(-1, 48))
                self.added_send_media_buttons.add(preview_view)
        except:
            pass

    def _find_send_media_menu(self, view):
        try:
            if hasattr(view, 'getChildCount'):
                for i in range(view.getChildCount()):
                    child = view.getChildAt(i)
                    if child:
                        if "ActionBarPopupWindowLayout" in child.getClass().getSimpleName() and hasattr(child, 'addView'):
                            return child
                        menu = self._find_send_media_menu(child)
                        if menu:
                            return menu
            return None
        except:
            return None

    def _create_send_message_params_document(self, document, dialog_id, user_reply_to_msg, topic_reply_to_msg, caption, parent, has_spoiler):
        try:
            return SendMessagesHelper.SendMessageParams.of(
                document, None, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                0,
                parent, 
                None, 
                False, 
                has_spoiler
            )
        except:
            return SendMessagesHelper.SendMessageParams.of(
                document, None, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                parent, 
                None, 
                False, 
                has_spoiler
            )

    def _create_send_message_params_photo(self, photo, dialog_id, user_reply_to_msg, topic_reply_to_msg, caption, parent, has_spoiler):
        try:
            return SendMessagesHelper.SendMessageParams.of(
                photo, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                0,
                parent, 
                False, 
                has_spoiler
            )
        except:
            return SendMessagesHelper.SendMessageParams.of(
                photo, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                parent, 
                False, 
                has_spoiler
            )

    def _send_media(self, preview_view, webpage):
        try:
            from client_utils import get_last_fragment
            current_fragment = get_last_fragment()
            if not current_fragment:
                return

            dialog_id_field = current_fragment.getClass().getDeclaredField("dialog_id")
            dialog_id_field.setAccessible(True)
            dialog_id = dialog_id_field.getLong(current_fragment)
            if not dialog_id:
                return

            message_preview_params = get_private_field(preview_view, "messagePreviewParams")
            is_video = False
            if message_preview_params and hasattr(message_preview_params, 'isVideo'):
                is_video = message_preview_params.isVideo

            if is_video and webpage.document:
                params = self._create_send_message_params_document(
                    webpage.document, dialog_id, None, None, None, webpage, False
                )
            elif webpage.photo:
                params = self._create_send_message_params_photo(
                    webpage.photo, dialog_id, None, None, None, webpage, False
                )
            elif webpage.document:
                params = self._create_send_message_params_document(
                    webpage.document, dialog_id, None, None, None, webpage, False
                )
            else:
                return

            send_helper = get_send_messages_helper()
            if send_helper:
                send_helper.sendMessage(params)
                try:
                    if hasattr(preview_view, 'dismiss'):
                        preview_view.dismiss(True)
                except:
                    pass

        except:
            pass

    def show_goto_message_dialog(self, chat_activity):
        try:
            if not chat_activity:
                return
                
            fragment = self._resolve_target_fragment(chat_activity)
            if not fragment:
                return
                
            activity = fragment.getParentActivity()
            if not activity:
                return
            
            current_activity = chat_activity
            
            message_id_edit_text = EditTextBoldCursor(activity)
            message_id_edit_text.setHint(getString("id_hint", "ID"))
            message_id_edit_text.setInputType(InputType.TYPE_CLASS_NUMBER)
            message_id_edit_text.setMaxLines(1)
            message_id_edit_text.setSingleLine(True)
            message_id_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            message_id_edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            message_id_edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            message_id_edit_text.setBackground(Theme.createEditTextDrawable(activity, True))
            message_id_edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            message_id_edit_text.setCursorSize(AndroidUtilities.dp(20))
            message_id_edit_text.setCursorWidth(1.5)
            message_id_edit_text.setPadding(0, 0, 0, 0)
            message_id_edit_text.setFocusable(True)
            
            def close_dialog_and_menu(dialog, message_id=None):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
                try:
                    if current_activity:
                        header_item = self.header_item_field.get(current_activity) if self.header_item_field else None
                        if header_item:
                            header_item.closeSubMenu()
                except Exception:
                    pass
                if message_id:
                    target_fragment = self._resolve_target_fragment(current_activity) if current_activity else fragment
                    if target_fragment:
                        run_on_ui_thread(lambda: self.scroll_to_message(target_fragment, message_id))
            
            def on_search_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                    
                    editable = message_id_edit_text.getText()
                    if editable is not None:
                        message_id_text = editable.toString().strip()
                        numeric_only = ''.join(c for c in message_id_text if c.isdigit())
                        if numeric_only:
                            message_id = self._validate_message_id(numeric_only)
                            if message_id:
                                close_dialog_and_menu(dialog, message_id)
                                return
                except Exception as e:
                    uitweaks_log(f"Error in on_search_click: {e}")
                close_dialog_and_menu(dialog)
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                except Exception:
                    pass
                close_dialog_and_menu(dialog)
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(getString("search_messages", "Search Messages"))
            builder.set_view(message_id_edit_text)
            builder.set_negative_button(getString("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(getString("search", "Search"), on_search_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = message_id_edit_text.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        message_id_edit_text.setLayoutParams(layout_params)
                    
                    message_id_edit_text.requestFocus()
                    text_length = message_id_edit_text.getText().length() if message_id_edit_text.getText() else 0
                    message_id_edit_text.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(message_id_edit_text)
                except Exception as e:
                    uitweaks_log(f"Error applying layout params: {e}")
            
            run_on_ui_thread(apply_layout_params, delay=100)
            
        except Exception as e:
            uitweaks_log(f"Error in show_goto_message_dialog: {e}")
    
    def scroll_to_message(self, chat_activity, message_id):
        try:
            if not message_id or message_id <= 0 or not chat_activity:
                return
            chat_activity.scrollToMessageId(message_id, 0, False, 0, False, 0)
        except Exception as e:
            uitweaks_log(f"Error in scroll_to_message: {e}")
    
    def _resolve_target_fragment(self, chat_activity):
        if not chat_activity:
            return get_last_fragment()
        if hasattr(chat_activity, 'fragment') and chat_activity.fragment:
            return chat_activity.fragment
        elif hasattr(chat_activity, 'getParentActivity'):
            return chat_activity
        return get_last_fragment()
    
    def _validate_message_id(self, message_id_text):
        if not message_id_text or not message_id_text.strip():
            return None
        try:
            message_id = int(message_id_text.strip())
            return message_id if message_id > 0 else None
        except ValueError:
            return None

    def _update_goto_message_menu_item(self):
        try:
            self._goto_items_added.clear()
            self._add_goto_message_plugin_subitem()
        except Exception as e:
            uitweaks_log(f"Error in _update_goto_message_menu_item: {e}")
    
    def cleanup_activity_references(self, activity_id):
        try:
            sets_to_check = [
                '_goto_items_added',
                'hooked_activities',
                'added_send_media_buttons',
                '_no_quote_buttons_created',
                '_select_all_added_modes',
                'ai_summarize_hooked_activities',
                'chat_action_bar_hooked_activities',
            ]
            for set_name in sets_to_check:
                if hasattr(self, set_name):
                    s = getattr(self, set_name)
                    if s and activity_id in s:
                        s.discard(activity_id)
            
            dicts_to_check = [
                '_no_quote_button_cache',
                'search_filter_buttons',
                'contact_status_activity_state',
            ]
            for dict_name in dicts_to_check:
                if hasattr(self, dict_name):
                    d = getattr(self, dict_name)
                    if d and activity_id in d:
                        del d[activity_id]
        except Exception as e:
            self.log(f"Error in cleanup_activity_references: {e}")

    
    def _create_summarizer_role(self):
        try:
            from com.exteragram.messenger.ai import AiController
            from com.exteragram.messenger.ai.data import Role
            
            controller = AiController.getInstance()
            
            role_name = "Quanta!"
            existing_role = None
            
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == role_name:
                        existing_role = role
                        break
            
            if existing_role is None:
                default_prompt = """You are an expert at summarizing chat conversations. Analyze the messages and create a concise summary using paragraphs with bold headings for different topics. Do not use bullet points. Keep it clear and organized, highlighting key points, decisions, and action items. Mention important participants when relevant. Keep the summary within 3-5 paragraphs."""
                
                new_role = Role(role_name, default_prompt)
                controller.addRole(new_role)
        except:
            pass
    
    def _hook_ai_summarize(self):
        self._create_summarizer_role()
        self._hook_chat_action_bar_items()
    
    def _hook_goto_message(self):
        self._hook_chat_action_bar_items()
    
    def _hook_chat_action_bar_items(self):
        if hasattr(self, 'hook_ai_summarize_create_view_ref') and self.hook_ai_summarize_create_view_ref:
            self.chat_action_bar_hooked_activities.clear()
            return
        
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                return
            
            createViewMethod = ChatActivity.getClass().getDeclaredMethod("createView", jclass("android.content.Context"))
            createViewMethod.setAccessible(True)
            self.hook_ai_summarize_create_view_ref = self.hook_method(createViewMethod, ChatActionBarItemsHook(self))
        except Exception as e:
            self.log(f"Error hooking Chat Action Bar Items: {e}")

    def _hook_disable_auto_web_login(self):
        try:
            BrowserClass = self._get_class("org.telegram.messenger.browser.Browser")
            if not BrowserClass:
                return

            java_browser_class = BrowserClass.getClass()
            
            try:
                method = java_browser_class.getDeclaredMethod("openUrl",
                    self._get_class("android.content.Context").getClass(),
                    self._get_class("android.net.Uri").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    self._get_class("java.lang.String").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                self.hook_disable_auto_web_login_ref = self.hook_method(method, DisableAutoWebLoginHook(self))
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _hook_prefer_common_groups_tab(self):
        try:
            SharedMediaLayoutClass = self._get_class("org.telegram.ui.Components.SharedMediaLayout")
            if not SharedMediaLayoutClass:
                return

            java_class = SharedMediaLayoutClass.getClass()
            
            try:
                method = java_class.getDeclaredMethod("setUserInfo", 
                    self._get_class("org.telegram.tgnet.TLRPC$UserFull").getClass())
                method.setAccessible(True)
                self.hook_prefer_common_groups_tab_ref = self.hook_method(method, PreferCommonGroupsTabHook(self))
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _hook_sender_select_popup(self):
        try:
            SenderSelectPopupClass = self._get_class("org.telegram.ui.Components.SenderSelectPopup")
            if not SenderSelectPopupClass:
                return

            constructor = SenderSelectPopupClass.getClass().getDeclaredConstructor(
                jclass("android.content.Context"),
                jclass("org.telegram.ui.ChatActivity"),
                jclass("org.telegram.messenger.MessagesController"),
                jclass("org.telegram.tgnet.TLRPC$ChatFull"),
                jclass("org.telegram.tgnet.TLRPC$TL_channels_sendAsPeers"),
                jclass("org.telegram.ui.Components.SenderSelectPopup$OnSelectCallback")
            )
            constructor.setAccessible(True)
            self.hook_method(constructor, SendAsPopupHook(self))

            MessagesControllerClass = self._get_class("org.telegram.messenger.MessagesController")
            method = MessagesControllerClass.getClass().getDeclaredMethod("setDefaultSendAs", jclass("java.lang.Long").TYPE, jclass("java.lang.Long").TYPE)
            method.setAccessible(True)
            self.hook_method(method, SetDefaultSendAsHook(self))

        except Exception:
            pass

    def _hook_share_sheet_folders(self):
        try:
            share_alert_class = self._get_class("org.telegram.ui.Components.ShareAlert")
            if not share_alert_class:
                return
            
            bottom_sheet_class = self._get_class("org.telegram.ui.ActionBar.BottomSheet")
            if not bottom_sheet_class:
                return
                
            show_method = bottom_sheet_class.getClass().getDeclaredMethod("show")
            show_method.setAccessible(True)
            
            class ShareAlertShowHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                    self.processed_instances = set()
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        bottom_sheet_instance = param.thisObject
                        
                        if share_alert_class.getClass().isInstance(bottom_sheet_instance):
                            instance_id = id(bottom_sheet_instance)
                            if instance_id in self.processed_instances:
                                return
                            self.processed_instances.add(instance_id)
                            
                            plugin = self._plugin_ref()
                            if not plugin:
                                return
                            plugin._add_folder_tabs_to_share_alert(bottom_sheet_instance)
                    except:
                        pass
            
            hook = self.hook_method(show_method, ShareAlertShowHook(self))
            if hook:
                self.hook_share_sheet_folders_ref = hook
        except:
            pass

    def _add_folder_tabs_to_share_alert(self, share_alert):
        try:
            search_field = get_private_field(share_alert, "searchView")
            if not search_field or hasattr(search_field, '_folders_added'):
                return
            
            current_account = get_private_field(share_alert, "currentAccount")
            if current_account is None:
                return
            
            folders = MessagesController.getInstance(current_account).getDialogFilters()
            folder_count = folders.size() if folders else 0
            
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()

            valid_folders = []
            for i in range(folder_count):
                folder = folders.get(i)
                if self._count_forwardable_chats_in_folder(folder, all_dialogs, current_account) > 0:
                    valid_folders.append(folder)
            
            has_archived = self._has_archived_chats_forwardable(all_dialogs, current_account)
            total_tabs = len(valid_folders) + (1 if has_archived else 0)
            
            if total_tabs <= 1:
                return
            
            context = search_field.getContext()
            
            filter_tabs_view = LinearLayout(context)
            filter_tabs_view.setOrientation(LinearLayout.HORIZONTAL)
            filter_tabs_view.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
            filter_tabs_view.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
            
            scroll_view = HorizontalScrollView(context)
            scroll_view.setHorizontalScrollBarEnabled(False)
            scroll_view.setLayoutParams(ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(40)
            ))
            
            tabs_container = LinearLayout(context)
            tabs_container.setOrientation(LinearLayout.HORIZONTAL)
            tabs_container.setLayoutParams(ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                AndroidUtilities.dp(40)
            ))

            scroll_view.addView(tabs_container)
            filter_tabs_view.addView(scroll_view)
            
            set_private_field(filter_tabs_view, '_tabs_container', tabs_container)
            
            tab_containers = []
            for i in range(total_tabs):
                if i < len(valid_folders):
                    folder = valid_folders[i]
                    tab_text = getString("all_chats", "All Chats") if folder.isDefault() else (folder.name if hasattr(folder, 'name') else f"Folder {i}")
                    folder_obj = folder
                    is_archived = False
                else:
                    tab_text = getString("archived", "Archived")
                    folder_obj = None
                    is_archived = True

                tab_container = LinearLayout(context)
                tab_container.setOrientation(LinearLayout.HORIZONTAL)
                tab_container.setGravity(Gravity.CENTER)
                tab_container.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                tab_container.setLayoutParams(LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    AndroidUtilities.dp(32)
                ))

                tab_bg = GradientDrawable()
                tab_bg.setShape(GradientDrawable.RECTANGLE)
                tab_bg.setCornerRadius(AndroidUtilities.dp(16))
                
                tab_bg.setColor(Theme.getColor(Theme.key_dialogSearchBackground))
                tab_container.setBackground(tab_bg)

                has_entities = False
                if folder_obj:
                    try:
                        has_entities = folder_obj.entities and folder_obj.entities.size() > 0
                    except:
                        pass
                
                if has_entities:
                    tab_view = AnimatedEmojiSpan.TextViewEmojis(context)
                    from android.text import SpannableStringBuilder
                    text = SpannableStringBuilder(tab_text)
                    text = Emoji.replaceEmoji(text, tab_view.getPaint().getFontMetricsInt(), False)
                    text = MessageObject.replaceAnimatedEmoji(text, folder_obj.entities, tab_view.getPaint().getFontMetricsInt())
                    tab_view.setText(text)
                else:
                    tab_view = TextView(context)
                    tab_view.setText(tab_text)
                
                tab_view.setTextColor(Theme.getColor(Theme.key_actionBarTabActiveText if i == 0 else Theme.key_actionBarTabUnactiveText))
                tab_view.setTextSize(14)
                tab_view.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
                tab_view.setIncludeFontPadding(False)
                tab_view.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)

                def click_handler(*args, folder_index=i, folder=folder_obj, archived=is_archived):
                    self._on_folder_tab_clicked(share_alert, folder_index, folder, tabs_container, archived)
                
                click_listener = OnClickListener(click_handler)
                tab_container.setOnClickListener(click_listener)

                tab_container.addView(tab_view)
                tabs_container.addView(tab_container)
                tab_containers.append(tab_container)
                if i < total_tabs - 1:
                    margin_view = View(context)
                    margin_view.setLayoutParams(LinearLayout.LayoutParams(
                        AndroidUtilities.dp(4),
                        AndroidUtilities.dp(1)
                    ))
                    tabs_container.addView(margin_view)

            
            set_private_field(filter_tabs_view, '_tab_containers', tab_containers)
            
            frame_layout = get_private_field(share_alert, "frameLayout")
            search_view = get_private_field(share_alert, "searchView")
            shadows = get_private_field(share_alert, "shadow")
            
            if not frame_layout or not search_view:
                return

            from android.widget import FrameLayout
            
            frame_layout_params = frame_layout.getLayoutParams()
            if frame_layout_params:
                frame_layout_params.height = AndroidUtilities.dp(106)
                frame_layout.setLayoutParams(frame_layout_params)
            
            search_params = search_view.getLayoutParams()
            if isinstance(search_params, FrameLayout.LayoutParams):
                search_params.height = ViewGroup.LayoutParams.MATCH_PARENT
                search_params.gravity = Gravity.TOP | Gravity.LEFT
                search_view.setLayoutParams(search_params)
            
            search_view.addView(
                filter_tabs_view,
                FrameLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT, 
                    AndroidUtilities.dp(48),
                    Gravity.BOTTOM
                )
            )
            
            if shadows and len(shadows) > 0 and shadows[0]:
                shadow_params = shadows[0].getLayoutParams()
                if isinstance(shadow_params, FrameLayout.LayoutParams):
                    shadow_params.topMargin = AndroidUtilities.dp(106)
                    shadows[0].setLayoutParams(shadow_params)

            grid_view = get_private_field(share_alert, "gridView")
            if grid_view:
                 grid_params = grid_view.getLayoutParams()
                 if isinstance(grid_params, FrameLayout.LayoutParams):
                     grid_params.topMargin = AndroidUtilities.dp(50)
                     grid_view.setLayoutParams(grid_params)

            search_grid_view = get_private_field(share_alert, "searchGridView")
            if search_grid_view:
                 search_grid_params = search_grid_view.getLayoutParams()
                 if isinstance(search_grid_params, FrameLayout.LayoutParams):
                     search_grid_params.topMargin = AndroidUtilities.dp(50)
                     search_grid_view.setLayoutParams(search_grid_params)

            frame_layout.requestLayout()
            search_view.requestLayout()
            if grid_view:
                grid_view.requestLayout()

            set_private_field(search_view, '_folders_added', True)
            
        except:
            pass
    
    def _get_folders_padding(self):
        return AndroidUtilities.dp(96)
    
    def _update_tab_styles(self, tabs_container, selected_index):
        try:
            tab_containers = []
            child_count = tabs_container.getChildCount()
            for i in range(child_count):
                child = tabs_container.getChildAt(i)
                if isinstance(child, LinearLayout):
                    tab_containers.append(child)
            
            
            for i, tab_container in enumerate(tab_containers):
                text_view = tab_container.getChildAt(0)
                
                tab_bg = GradientDrawable()
                tab_bg.setShape(GradientDrawable.RECTANGLE)
                tab_bg.setCornerRadius(AndroidUtilities.dp(16))
                
                tab_bg.setColor(Theme.getColor(Theme.key_dialogSearchBackground))
                
                text_view.setTextColor(Theme.getColor(Theme.key_actionBarTabActiveText if i == selected_index else Theme.key_actionBarTabUnactiveText))
                
                tab_container.setBackground(tab_bg)
                
        except:
            pass
    
    def _on_folder_tab_clicked(self, share_alert, folder_index, folder, tabs_container, is_archived=False):
        try:
            current_account = get_private_field(share_alert, "currentAccount")
            list_adapter = get_private_field(share_alert, "listAdapter")
            if current_account is None or not list_adapter:
                return

            self._update_tab_styles(tabs_container, folder_index)

            if is_archived:
                self._apply_archived_filter(share_alert, list_adapter, current_account)
            else:
                self._apply_folder_filter(share_alert, list_adapter, folder, current_account)

        except:
            pass
    
    def _apply_folder_filter(self, share_alert, list_adapter, folder, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            
            dialogs_list = get_private_field(list_adapter, "dialogs")
            dialogs_map = get_private_field(list_adapter, "dialogsMap")
            if not dialogs_list or not dialogs_map:
                return
            
            dialogs_list.clear()
            dialogs_map.clear()
            
            dialog_count = all_dialogs.size()
            for i in range(dialog_count):
                dialog = all_dialogs.get(i)
                if folder.isDefault() or self._dialog_matches_folder(dialog, folder, current_account):
                    if self._can_forward_to_chat(dialog, current_account):
                        dialogs_list.add(dialog)
                        dialogs_map.put(dialog.id, dialog)
            
            list_adapter.notifyDataSetChanged()
            
            self._apply_forced_scroll_offset(share_alert)
                    
        except:
            pass
    
    def _dialog_matches_folder(self, dialog, folder, current_account):
        try:
            if folder.isDefault():
                return True
            
            from org.telegram.messenger import AccountInstance
            return folder.includesDialog(AccountInstance.getInstance(current_account), dialog.id)
            
        except:
            return False
    
    def _has_archived_chats(self, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            for i in range(all_dialogs.size()):
                if all_dialogs.get(i).folder_id == 1:
                    return True
            return False
        except:
            return False
    
    def _has_archived_chats_forwardable(self, all_dialogs, current_account):
        try:
            for i in range(all_dialogs.size()):
                dialog = all_dialogs.get(i)
                if dialog.folder_id == 1 and self._can_forward_to_chat(dialog, current_account):
                    return True
            return False
        except:
            return False
    
    def _count_forwardable_chats_in_folder(self, folder, all_dialogs, current_account):
        try:
            from org.telegram.messenger import AccountInstance
            count = 0
            for i in range(all_dialogs.size()):
                dialog = all_dialogs.get(i)
                if dialog.folder_id == 1:
                    continue
                if folder.isDefault() or folder.includesDialog(AccountInstance.getInstance(current_account), dialog.id):
                    if self._can_forward_to_chat(dialog, current_account):
                        count += 1
            return count
        except:
            return 0
    
    def _apply_archived_filter(self, share_alert, list_adapter, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            dialogs_list = get_private_field(list_adapter, "dialogs")
            dialogs_map = get_private_field(list_adapter, "dialogsMap")
            if not dialogs_list or not dialogs_map:
                return
            
            dialogs_list.clear()
            dialogs_map.clear()
            
            for i in range(all_dialogs.size()):
                dialog = all_dialogs.get(i)
                if dialog.folder_id == 1:
                    if self._can_forward_to_chat(dialog, current_account):
                        dialogs_list.add(dialog)
                        dialogs_map.put(dialog.id, dialog)
            
            list_adapter.notifyDataSetChanged()
            
            self._apply_forced_scroll_offset(share_alert)
        except:
            pass
    
    def _can_forward_to_chat(self, dialog, current_account):
        try:
            if not dialog:
                return False
            
            from org.telegram.messenger import DialogObject
            if DialogObject.isEncryptedDialog(dialog.id):
                return True
            
            if DialogObject.isChannel(dialog):
                chat = MessagesController.getInstance(current_account).getChat(-dialog.id)
                if not chat:
                    return False
                
                from org.telegram.messenger import ChatObject
                
                if chat.megagroup:
                    return not chat.gigagroup or ChatObject.hasAdminRights(chat)
                else:
                    return ChatObject.hasAdminRights(chat) and ChatObject.canPost(chat)
            
            return True
        except:
            return False
    
    def _apply_forced_scroll_offset(self, share_alert):
        try:
            grid_view = get_private_field(share_alert, "gridView")
            if not grid_view:
                return
                
            layout_manager = grid_view.getLayoutManager()
            if not layout_manager:
                return
                
            layout_manager.scrollToPositionWithOffset(0, -self.forced_scroll_offset)
        except Exception as e:
            pass

    def _hook_non_clickable_preview(self):
        try:
            BaseFragmentClass = jclass("org.telegram.ui.ActionBar.BaseFragment")
            methods = BaseFragmentClass.getClass().getDeclaredMethods()
            present_method = None
            for m in methods:
                if m.getName() == "presentFragmentAsPreviewWithMenu":
                    present_method = m
                    break
            if present_method is None:
                raise Exception("presentFragmentAsPreviewWithMenu not found on BaseFragment")
            present_method.setAccessible(True)
            self.hook_non_clickable_present_ref = self.hook_method(present_method, NonClickablePreviewPresentFragmentHook())
        except:
            pass

        try:
            ActionBarLayout = jclass("org.telegram.ui.ActionBar.ActionBarLayout")
            methods2 = ActionBarLayout.getClass().getDeclaredMethods()
            present_method2 = None
            for m in methods2:
                if m.getName() == "presentFragmentAsPreviewWithMenu":
                    present_method2 = m
                    break
            if present_method2 is None:
                raise Exception("presentFragmentAsPreviewWithMenu not found on ActionBarLayout")
            present_method2.setAccessible(True)
            self.hook_non_clickable_present_ref2 = self.hook_method(present_method2, NonClickablePreviewPresentFragmentHook())
        except:
            pass

        try:
            ChatActivityClass = jclass("org.telegram.ui.ChatActivity")
            inner_classes = ChatActivityClass.getClass().getDeclaredClasses()
            fragment_view_class = None
            for c in inner_classes:
                if "ChatActivityFragmentView" in c.getSimpleName():
                    fragment_view_class = c
                    break
            if fragment_view_class is None:
                raise Exception("ChatActivityFragmentView not found")
            
            dispatch_method = fragment_view_class.getDeclaredMethod("dispatchTouchEvent", jclass("android.view.MotionEvent"))
            dispatch_method.setAccessible(True)
            self.hook_non_clickable_dispatch_ref = self.hook_method(dispatch_method, NonClickablePreviewDispatchTouchHook())
        except:
            pass

    def _hook_disable_topic_swipe(self):
        try:
            TouchHelperCallbackClass = self._get_class("org.telegram.ui.TopicsFragment$TouchHelperCallback")
            if not TouchHelperCallbackClass:
                return
            
            getMovementFlagsMethod = TouchHelperCallbackClass.getClass().getDeclaredMethod(
                "getMovementFlags",
                jclass("androidx.recyclerview.widget.RecyclerView"),
                jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")
            )
            getMovementFlagsMethod.setAccessible(True)
            
            class DisableTopicSwipeHook:
                def __init__(self, plugin_instance):
                    super().__init__(plugin_instance)
                
                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def before_hooked_method(self, param):
                    param.setResult(jclass("java.lang.Integer")(0))
                    param.returnEarly = True
            
            self.hook_disable_topic_swipe_ref = self.hook_method(getMovementFlagsMethod, DisableTopicSwipeHook(self))
            
        except Exception:
            pass

    def _hook_account_visibility(self):
        try:
            self.hidden_accounts = self.load_hidden_accounts()
            
            if drawer_adapter_class := self._get_class("org.telegram.ui.Adapters.DrawerLayoutAdapter"):
                self.hook_drawer_adapter(drawer_adapter_class)
            if profile_cell_class := self._get_class("org.telegram.ui.Cells.DrawerProfileCell"):
                self.hook_profile_cell(profile_cell_class)
        except Exception:
            pass

    def load_hidden_accounts(self):
        try:
            settings = self.get_setting("hidden_accounts", "[]")
            import json
            return json.loads(settings)
        except:
            return []

    def save_hidden_accounts(self):
        import json
        self.set_setting("hidden_accounts", json.dumps(self.hidden_accounts))

    def hook_drawer_adapter(self, drawer_adapter_class):
        try:
            method = drawer_adapter_class.getClass().getDeclaredMethod("notifyDataSetChanged")
            method.setAccessible(True)

            class DrawerAdapterHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)

                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        plugin = self._plugin_ref()
                        if not plugin:
                            return
                        adapter = param.thisObject
                        hidden_accounts = plugin.hidden_accounts
                        if not hidden_accounts:
                            return
                        
                        account_numbers = get_private_field(adapter, "accountNumbers")
                        if not account_numbers:
                            return
                        
                        from org.telegram.messenger import UserConfig
                        current_account = UserConfig.selectedAccount
                        iterator = account_numbers.iterator()
                        while iterator.hasNext():
                            account_num = iterator.next()
                            if str(account_num) in hidden_accounts and account_num != current_account:
                                iterator.remove()

                    except:
                        pass

            self.hook_account_visibility_drawer_ref = self.hook_method(method, DrawerAdapterHook(self))
        except:
            pass

    def hook_profile_cell(self, profile_cell_class):
        try:
            constructors = profile_cell_class.getClass().getDeclaredConstructors()
            method = constructors[0]
            method.setAccessible(True)

            class ProfileCellHook:
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)

                @hook_filters(HookFilter.Condition("param.thisObject != null"))
                def after_hooked_method(self, param):
                    try:
                        plugin = self._plugin_ref()
                        if not plugin:
                            return
                        profile_cell = param.thisObject
                        plugin.replace_theme_button_listener(profile_cell)
                    except:
                        pass

            self.hook_account_visibility_profile_ref = self.hook_method(method, ProfileCellHook(self))
        except:
            pass

    def replace_theme_button_listener(self, profile_cell):
        try:
            if dark_theme_view := get_private_field(profile_cell, "darkThemeView"):
                def account_visibility_handler(*args):
                    try:
                        self._perform_haptic()
                        self.toggle_all_other_accounts()
                    except:
                        pass
                
                from android_utils import OnLongClickListener
                dark_theme_view.setOnLongClickListener(OnLongClickListener(account_visibility_handler))
        except:
            pass

    def toggle_all_other_accounts(self):
        try:
            accounts = self.get_account_info()
            if len(accounts) <= 1:
                return

            other_accounts = [acc for acc in accounts if not acc['is_current']]
            any_hidden = any(acc['hidden'] for acc in other_accounts)
            
            for account in other_accounts:
                self.toggle_account_visibility(account['number'], not any_hidden)
            
        except:
            pass

    def toggle_account_visibility(self, account_number, hidden):
        account_str = str(account_number)
        if hidden:
            if account_str not in self.hidden_accounts:
                self.hidden_accounts.append(account_str)
        else:
            if account_str in self.hidden_accounts:
                self.hidden_accounts.remove(account_str)
        self.save_hidden_accounts()
        self.refresh_drawer()

    def refresh_drawer(self):
        try:
            from android_utils import run_on_ui_thread
            run_on_ui_thread(self._refresh_drawer_impl, delay=100)
        except:
            pass
    
    def _refresh_drawer_impl(self):
        try:
            from org.telegram.ui import LaunchActivity
            if (hasattr(LaunchActivity, 'instance') and LaunchActivity.instance and 
                (drawer_adapter := get_private_field(LaunchActivity.instance, "drawerLayoutAdapter")) and
                hasattr(drawer_adapter, 'notifyDataSetChanged')):
                drawer_adapter.notifyDataSetChanged()
                return
        except:
            pass
    
    def get_account_info(self):
        accounts = []
        try:
            from org.telegram.messenger import UserConfig
            current_account = UserConfig.selectedAccount
            
            for account_id in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    if (config := UserConfig.getInstance(account_id)).isClientActivated():
                        if user := config.getCurrentUser():
                            first_name = getattr(user, 'first_name', 'Unknown')
                            last_name = getattr(user, 'last_name', '')
                            name = f"{first_name} {last_name}".strip() or f"Account {account_id}"
                            
                            is_current = (account_id == current_account)
                            if is_current:
                                name += " (Current)"
                            
                            accounts.append({
                                'number': account_id,
                                'name': name,
                                'user_id': user.id,
                                'hidden': str(account_id) in self.hidden_accounts,
                                'is_current': is_current
                            })
                except:
                    continue
        except:
            pass
        
        return accounts
    
    def _hook_owner_channels(self):
        if self.hook_owner_channels_ref:
            return
        try:
            f = get_last_fragment()
            if not f:
                return
            a = f.getParentActivity()
            if not a or "LaunchActivity" not in a.getClass().getName():
                return
            
            sm_field = a.getClass().getDeclaredField("sideMenu")
            sm_field.setAccessible(True)
            menu = sm_field.get(a)
            if not menu:
                return
            
            ad_field = a.getClass().getDeclaredField("drawerLayoutAdapter")
            ad_field.setAccessible(True)
            adapter = ad_field.get(a)
            
            orig_listener = None
            try:
                lf = menu.getClass().getSuperclass().getDeclaredField("onItemLongClickListener")
                lf.setAccessible(True)
                orig_listener = lf.get(menu)
            except:
                pass
            
            Listener = find_class("org.telegram.ui.Components.RecyclerListView$OnItemLongClickListener")
            plugin_ref = weakref.ref(self)
            activity = a
            
            class OwnerChannelsLongClickListener(dynamic_proxy(Listener)):
                def onItemClick(self, v, p):
                    try:
                        plugin = plugin_ref()
                        if not plugin or not plugin.get_setting("show_owner_channels", False):
                            if orig_listener:
                                return orig_listener.onItemClick(v, p)
                            return False
                        
                        i = adapter.getId(p) if adapter else -1
                        if i == 2:
                            plugin._owner_channels_show_options(activity, True)
                            return True
                        if i == 4:
                            plugin._owner_channels_show_options(activity, False)
                            return True
                        if orig_listener:
                            return orig_listener.onItemClick(v, p)
                    except:
                        pass
                    return False
            
            menu.setOnItemLongClickListener(OwnerChannelsLongClickListener())

        except:
            pass
    
    def _owner_channels_show_options(self, ctx, is_group):
        try:
            from org.telegram.tgnet import SerializedData
            type_name = getString("groups", "Groups") if is_group else getString("channels", "Channels")
            
            b = AlertDialogBuilder(ctx)
            b.set_title(type_name)
            
            items = [
                type_name + " " + getString("where_im_admin", "where I'm admin"),
                getString("my_prefix", "My ") + type_name
            ]
            
            def on_item_click(dialog, which):
                try:
                    dialog.dismiss()
                    is_owner_only = (which == 1)
                    self._owner_channels_open_dialogs_activity(ctx, is_group, is_owner_only)
                except:
                    pass
            
            b.set_items(items, on_item_click)
            b.set_negative_button(getString("cancel", "Cancel"), lambda d, _: d.dismiss())
            b.show()
        except:
            pass
    
    def _owner_channels_open_dialogs_activity(self, ctx, is_group, is_owner_only):
        try:
            from org.telegram.tgnet import SerializedData
            f = get_last_fragment()
            if not f:
                return
            
            try:
                dlc_field = f.getParentActivity().getClass().getDeclaredField("drawerLayoutContainer")
                dlc_field.setAccessible(True)
                dlc = dlc_field.get(f.getParentActivity())
                if dlc:
                    dlc.closeDrawer(False)
            except:
                pass
            
            if is_group:
                request_peer = TLRPC.TL_requestPeerTypeChat()
            else:
                request_peer = TLRPC.TL_requestPeerTypeBroadcast()
            
            if is_owner_only:
                request_peer.creator = True
            else:
                admin_rights = TLRPC.TL_chatAdminRights()
                admin_rights.other = True
                request_peer.user_admin_rights = admin_rights
            
            buffer = SerializedData()
            request_peer.serializeToStream(buffer)
            request_peer_bytes = buffer.toByteArray()
            buffer.cleanup()
            
            args = Bundle()
            args.putBoolean("onlySelect", True)
            args.putInt("dialogsType", 15)
            args.putByteArray("requestPeerType", request_peer_bytes)
            
            if is_group:
                args.putBoolean("allowChannels", False)
                args.putBoolean("allowUsers", False)
                args.putBoolean("allowBots", False)
                args.putBoolean("allowGroups", True)
                args.putBoolean("allowMegagroups", True)
                args.putBoolean("allowLegacyGroups", True)
            else:
                args.putBoolean("allowChannels", True)
                args.putBoolean("allowUsers", False)
                args.putBoolean("allowBots", False)
                args.putBoolean("allowGroups", False)
                args.putBoolean("allowMegagroups", False)
                args.putBoolean("allowLegacyGroups", False)
            
            DialogsActivity = find_class("org.telegram.ui.DialogsActivity")
            dialogs = DialogsActivity(args)
            f.presentFragment(dialogs)
        except:
            pass

    def _hook_custom_privacy(self):
        if self.hook_custom_privacy_ref:
            return
        try:
            ProfileActivityClass = find_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivityClass:
                return
            
            method = None
            for m in ProfileActivityClass.getClass().getDeclaredMethods():
                if m.getName() == "createActionBarMenu":
                    method = m
                    break
            
            if not method:
                return
            
            plugin_ref = weakref.ref(self)
            
            class CreateActionBarMenuHook(MethodHook):
                def after_hooked_method(self, param):
                    plugin = plugin_ref()
                    if not plugin or not plugin.get_setting("custom_privacy", False):
                        return
                    try:
                        profile_activity = param.thisObject
                        chat_id = get_private_field(profile_activity, "chatId")
                        if chat_id and chat_id != 0:
                            return
                        user_id = get_private_field(profile_activity, "userId")
                        if not user_id or user_id == 0:
                            return
                        current_account = get_private_field(profile_activity, "currentAccount")
                        other_item = get_private_field(profile_activity, "otherItem")
                        if not other_item:
                            return
                        
                        user = MessagesController.getInstance(current_account).getUser(int(user_id))
                        if not user or user.self:
                            return    

                        def on_privacy_click(v):
                            try:
                                user = MessagesController.getInstance(current_account).getUser(int(user_id))
                                if not user:
                                    return
                                delegate = UserPrivacyDelegate(plugin, user, current_account)
                                fragment = UniversalFragment(delegate)
                                delegate.fragment = fragment
                                profile_activity.presentFragment(fragment)
                                other_item.closeSubMenu()
                            except:
                                pass

                        popup_layout = get_private_field(other_item, "popupLayout")
                        if popup_layout:
                            linear_layout = popup_layout.linearLayout
                            insert_index = -1
                            for i in range(linear_layout.getChildCount()):
                                tag = linear_layout.getChildAt(i).getTag()
                                if tag is not None:
                                    try:
                                        tag_val = int(str(tag))
                                        if tag_val == 5:
                                            insert_index = i + 1
                                            break
                                        elif tag_val == 1:
                                            insert_index = i + 1
                                    except:
                                        pass
                            ActionBarMenuSubItemClass = find_class("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
                            AndroidUtilitiesClass = find_class("org.telegram.messenger.AndroidUtilities")
                            LinearLayoutParamsClass = find_class("android.widget.LinearLayout$LayoutParams")
                            sub_item = ActionBarMenuSubItemClass(other_item.getContext(), False, False, False, None)
                            sub_item.setTextAndIcon(getString("custom_privacy_manage_privacy", "Manage Privacy"), R_tg.drawable.menu_privacy_policy, None)
                            sub_item.setMinimumWidth(AndroidUtilitiesClass.dp(196))
                            sub_item.setTag(plugin._custom_privacy_item_id)
                            sub_item.setOnClickListener(OnClickListener(on_privacy_click))
                            sub_item.setLayoutParams(LinearLayoutParamsClass(-1, AndroidUtilitiesClass.dp(48)))
                            if insert_index >= 0:
                                linear_layout.addView(sub_item, insert_index)
                            else:
                                linear_layout.addView(sub_item)
                        else:
                            sub_item = other_item.addSubItem(plugin._custom_privacy_item_id, R_tg.drawable.menu_privacy_policy, LocaleController.getString(R_tg.string.PrivacyTitle))
                            sub_item.setOnClickListener(OnClickListener(on_privacy_click))
                    except:
                        pass
            
            self.hook_custom_privacy_ref = self.hook_method(method, CreateActionBarMenuHook())
        except Exception:
            pass

    def _hook_remove_from_folders(self):
        if self.hook_remove_from_folders_ref:
            return
        try:
            AC = find_class("org.telegram.ui.Components.AlertsCreator")
            if not AC: return
            
            BF = find_class("org.telegram.ui.ActionBar.BaseFragment")
            CC = find_class("org.telegram.tgnet.TLRPC$Chat")
            UC = find_class("org.telegram.tgnet.TLRPC$User")
            BCC = find_class("org.telegram.messenger.MessagesStorage$BooleanCallback")
            RPC = find_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            BT = jclass("java.lang.Boolean").TYPE
            
            mth = AC.getClass().getDeclaredMethod("createClearOrDeleteDialogAlert", BF, BT, BT, BT, CC, UC, BT, BT, BT, BCC, RPC)
            mth.setAccessible(True)
            plugin_ref = weakref.ref(self)
            
            class CreateDialogHook(MethodHook):
                def before_hooked_method(self, param):
                    try:
                        p = plugin_ref()
                        if not p or not p.get_setting("remove_from_folders_on_leave", False):
                            return
                        fr, cl, ad, ch, cb = param.args[0], param.args[1], param.args[2], param.args[4], param.args[9]
                        if cl or ad or ch is None: return
                        chat_id = -ch.id
                        fwc = p._rff_get_filters_containing_chat(chat_id, fr)
                        if not fwc: return
                        cid = id(cb) if cb else 0
                        p._remove_from_folders_state[cid] = {'checked': False, 'chat_id': chat_id, 'filters_count': len(fwc), 'fragment': fr}
                        param.args[9] = p._rff_create_wrapped_callback(cb, cid)
                    except: pass
                    
                def after_hooked_method(self, param):
                    try:
                        p = plugin_ref()
                        if not p or not p.get_setting("remove_from_folders_on_leave", False):
                            return
                        fr, cl, ad, ch = param.args[0], param.args[1], param.args[2], param.args[4]
                        if cl or ad or ch is None: return
                        run_on_ui_thread(lambda: p._rff_inject_checkbox(fr, -ch.id))
                    except: pass
            
            self.hook_remove_from_folders_ref = self.hook_method(mth, CreateDialogHook())
        except: pass
            
    def _rff_create_wrapped_callback(self, original_callback, callback_id):
        plugin_ref = weakref.ref(self)
        BCC = find_class("org.telegram.messenger.MessagesStorage$BooleanCallback")
        
        class WrappedCallbackProxy(dynamic_proxy(BCC)):
            def run(self, delete_for_all):
                try:
                    p = plugin_ref()
                    if p:
                        st = p._remove_from_folders_state.get(callback_id, {})
                        if st.get('checked') and st.get('chat_id') and st.get('fragment'):
                            p._rff_remove_from_all_folders(st['chat_id'], st['fragment'])
                except: pass
                finally:
                    if original_callback: original_callback.run(delete_for_all)
                    p = plugin_ref()
                    if p: p._remove_from_folders_state.pop(callback_id, None)
        return WrappedCallbackProxy()
    
    def _rff_inject_checkbox(self, fragment, chat_id):
        try:
            if not hasattr(fragment, 'visibleDialog') or not fragment.visibleDialog: return
            dlg = fragment.visibleDialog
            
            cid = next((k for k, st in self._remove_from_folders_state.items() if st.get('chat_id') == chat_id), None)
            if cid is None: return
            st, fc = self._remove_from_folders_state[cid], self._remove_from_folders_state[cid].get('filters_count', 0)
            
            try:
                cvf = dlg.getClass().getDeclaredField("customView")
                cvf.setAccessible(True)
                fl = cvf.get(dlg)
            except:
                try:
                    cvf = dlg.getClass().getSuperclass().getDeclaredField("customView")
                    cvf.setAccessible(True)
                    fl = cvf.get(dlg)
                except: return
            
            if not fl: return
            ctx = fragment.getParentActivity()
            if not ctx: return
            
            ec, mtv, TextView = 0, None, find_class("android.widget.TextView")
            for i in range(fl.getChildCount()):
                child = fl.getChildAt(i)
                if child.getClass().getName().endswith("CheckBoxCell"): ec += 1
                elif TextView and isinstance(child, TextView): mtv = child
            
            if mtv:
                mtv.setPadding(mtv.getPaddingLeft(), mtv.getPaddingTop(), mtv.getPaddingRight(), mtv.getPaddingBottom() + AndroidUtilities.dp(48))
                
            CheckBoxCell = find_class("org.telegram.ui.Cells.CheckBoxCell")
            cbx = CheckBoxCell(ctx, 1, None)
            cbx.setBackgroundDrawable(Theme.getSelectorDrawable(False))
            cbx.setText(getString("remove_from_all_folders", "Remove from all folders") + f" ({fc})", "", False, False)
            
            LC = find_class("org.telegram.messenger.LocaleController")
            is_rtl = LC.isRTL if LC else False
            cbx.setPadding(AndroidUtilities.dp(8 if not is_rtl else 16), 0, AndroidUtilities.dp(16 if not is_rtl else 8), 0)
            cbx.setChecked(False, False)
            cbx.setOnClickListener(OnClickListener(lambda v: (st.__setitem__('checked', not st.get('checked', False)), cbx.setChecked(st['checked'], True))))
            fl.addView(cbx, LayoutHelper.createFrame(-1, 48, Gravity.BOTTOM | Gravity.LEFT, 0, 0, 0, 48 * ec))
        except: pass
            
    def _rff_get_filters_containing_chat(self, chat_id, fragment):
        try:
            flts = get_messages_controller().getDialogFilters()
            if not flts or flts.size() == 0: return []
            
            cid_l = jclass("java.lang.Long").valueOf(chat_id)
            res = []
            for i in range(flts.size()):
                f = flts.get(i)
                if f.id == 0: continue
                asf = f.getClass().getDeclaredField("alwaysShow")
                asf.setAccessible(True)
                asv = asf.get(f)
                if asv and asv.contains(cid_l): res.append(f)
            return res
        except: return []
            
    def _rff_remove_from_all_folders(self, chat_id, fragment):
        try:
            mc, flts = get_messages_controller(), get_messages_controller().getDialogFilters()
            if not flts or flts.size() == 0: return
            
            mod, cid_l = 0, jclass("java.lang.Long").valueOf(chat_id)
            for i in range(flts.size()):
                f = flts.get(i)
                if f.id == 0: continue
                asf = f.getClass().getDeclaredField("alwaysShow")
                asf.setAccessible(True)
                asv = asf.get(f)
                if asv and asv.contains(cid_l):
                    idx = asv.indexOf(cid_l)
                    if idx >= 0: asv.remove(idx)
                    f.pinnedDialogs.delete(chat_id)
                    self._rff_update_filter_on_server(f, fragment)
                    get_messages_storage().saveDialogFilter(f, False, True)
                    mod += 1
            if mod > 0:
                nc, NC = get_notification_center(), find_class("org.telegram.messenger.NotificationCenter")
                if nc and NC: nc.postNotificationName(NC.dialogFiltersUpdated)
        except: pass
            
    def _rff_update_filter_on_server(self, flt, fragment):
        try:
            mc, MC = get_messages_controller(), find_class("org.telegram.messenger.MessagesController")
            if not MC: return
            
            req = TLRPC.TL_messages_updateDialogFilter()
            req.id, req.flags = flt.id, req.flags | 1
            req.filter = TLRPC.TL_dialogFilter()
            req.filter.id, flags = flt.id, flt.flags
            
            req.filter.contacts = (flags & MC.DIALOG_FILTER_FLAG_CONTACTS) != 0
            req.filter.non_contacts = (flags & MC.DIALOG_FILTER_FLAG_NON_CONTACTS) != 0
            req.filter.groups = (flags & MC.DIALOG_FILTER_FLAG_GROUPS) != 0
            req.filter.broadcasts = (flags & MC.DIALOG_FILTER_FLAG_CHANNELS) != 0
            req.filter.bots = (flags & MC.DIALOG_FILTER_FLAG_BOTS) != 0
            req.filter.exclude_muted = (flags & MC.DIALOG_FILTER_FLAG_EXCLUDE_MUTED) != 0
            req.filter.exclude_read = (flags & MC.DIALOG_FILTER_FLAG_EXCLUDE_READ) != 0
            req.filter.exclude_archived = (flags & MC.DIALOG_FILTER_FLAG_EXCLUDE_ARCHIVED) != 0
            
            req.filter.title = TLRPC.TL_textWithEntities()
            req.filter.title.text = flt.name or ""
            req.filter.title.entities = flt.entities if hasattr(flt, 'entities') and flt.entities else jclass("java.util.ArrayList")()
            req.filter.title_noanimate = getattr(flt, 'title_noanimate', False)
            
            if hasattr(flt, 'emoticon') and flt.emoticon:
                req.filter.emoticon, req.filter.flags = flt.emoticon, req.filter.flags | 33554432
            if hasattr(flt, 'color') and flt.color >= 0:
                req.filter.color, req.filter.flags = flt.color, req.filter.flags | 134217728
                
            pinned_list = sorted([(flt.pinnedDialogs.keyAt(j), flt.pinnedDialogs.get(flt.pinnedDialogs.keyAt(j))) for j in range(flt.pinnedDialogs.size()) if flt.pinnedDialogs.keyAt(j) != 0], key=lambda x: x[1])
            for did, _ in pinned_list:
                ip = self._rff_create_input_peer(did, mc)
                if ip: req.filter.pinned_peers.add(ip)
            
            asf = flt.getClass().getDeclaredField("alwaysShow")
            asf.setAccessible(True)
            for j in range(asf.get(flt).size()):
                did = asf.get(flt).get(j)
                if flt.pinnedDialogs.indexOfKey(did) < 0:
                    ip = self._rff_create_input_peer(did, mc)
                    if ip: req.filter.include_peers.add(ip)
            
            nsf = flt.getClass().getDeclaredField("neverShow")
            nsf.setAccessible(True)
            for j in range(nsf.get(flt).size()):
                ip = self._rff_create_input_peer(nsf.get(flt).get(j), mc)
                if ip: req.filter.exclude_peers.add(ip)
                    
            send_request(req, lambda r, e: None)
        except: pass
            
    def _rff_create_input_peer(self, did, mc):
        try:
            DO = find_class("org.telegram.messenger.DialogObject")
            if DO.isEncryptedDialog(did): return None
            if did > 0:
                user = mc.getUser(did)
                if user:
                    ip = TLRPC.TL_inputPeerUser()
                    ip.user_id, ip.access_hash = did, user.access_hash
                    return ip
            else:
                chat = mc.getChat(-did)
                if chat:
                    if ChatObject.isChannel(chat):
                        ip = TLRPC.TL_inputPeerChannel()
                        ip.channel_id, ip.access_hash = -did, chat.access_hash
                    else:
                        ip = TLRPC.TL_inputPeerChat()
                        ip.chat_id = -did
                    return ip
            return None
        except: return None

    def _hook_bookmark_chat(self):
        if self.hook_bookmark_create_view_ref:
            return
        try:
            if not self._bookmark_helper:
                self._bookmark_helper = _BookmarksHelper(self)
            
            self._bm_add_bookmark_menu_item()
            self._bm_hook_chat_activity_create_view()
        except: pass
    
    def _bm_add_bookmark_menu_item(self):
        try:
            if self._bookmark_menu_handle:
                return
            self._bookmark_menu_handle = quantahut.utilities.register_message_menu_item(
                text=getString("bookmark", "Bookmark"), option_id=2045, icon_res=R_tg.drawable.msg_fave,
                condition_predicate=lambda m: m is not None and self.get_setting("enable_bookmark_chat", False),
                on_click=self._bm_on_bookmark_click, insert_at_top=False
            )
        except: pass
    
    def _bm_remove_bookmark_menu_item(self):
        try:
            if self._bookmark_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self._bookmark_menu_handle)
                self._bookmark_menu_handle = None
        except: pass
    
    def _bm_on_bookmark_click(self, chat_activity, message, grouped_messages=None):
        try:
            if not message or not chat_activity or not self._bookmark_helper: return
            acc, did = chat_activity.getCurrentAccount(), message.getDialogId()
            ids = [msg.getId() for msg in grouped_messages.messages] if grouped_messages and hasattr(grouped_messages, 'messages') and grouped_messages.messages else [message.getId()]
            result = self._bookmark_helper.toggle_bookmarks(acc, did, ids)
            self._bm_show_bulletin(chat_activity, result)
            self._bm_update_menu_visibility(chat_activity)
        except: pass
    
    def _bm_show_bulletin(self, chat_activity, result):
        try:
            from org.telegram.messenger import R
            if result == "limit_reached":
                BulletinHelper.show_simple(getString("bookmark_limit_reached", "You can save up to 30 messages per chat."), R.raw.error, chat_activity)
            elif result == "added":
                plugin_ref = weakref.ref(self)
                def on_view():
                    p = plugin_ref()
                    if p: p._bm_open_bookmarks_fragment(chat_activity)
                BulletinHelper.show_with_button(getString("bookmark_added", "Added to bookmarks."), R.raw.tag_icon_3, getString("view", "View"), on_view, chat_activity)
            else:
                BulletinHelper.show_simple(getString("bookmark_removed", "Removed from bookmarks."), R.raw.tag_icon_3, chat_activity)
        except: pass
    
    def _bm_hook_chat_activity_create_view(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            create_view_method = ChatActivityClass.getClass().getDeclaredMethod("createView", jclass("android.content.Context"))
            create_view_method.setAccessible(True)
            self.hook_bookmark_create_view_ref = self.hook_method(create_view_method, BookmarkCreateViewHook(self))
        except: pass
    
    def _bm_on_chat_activity_created(self, chat_activity):
        try:
            self._bm_add_bookmarks_manager_menu_item(chat_activity)
            self._bm_hook_action_bar_callback(chat_activity)
        except: pass
    
    def _bm_add_bookmarks_manager_menu_item(self, chat_activity):
        try:
            headerItem = get_private_field(chat_activity, "headerItem")
            if not headerItem: return
            
            try:
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list:
                    def find_position(target):
                        if target:
                            for i in range(lazy_list.size()):
                                if lazy_list.get(i) == target:
                                    return i
                        return None
                    
                    plugins_item = get_private_field(chat_activity, "pluginsMenuItem")
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = find_position(plugins_item) or find_position(admin_gap) or lazy_list.size()
                    
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    asSubItemMethod = ItemClass.getClass().getDeclaredMethod("asSubItem",
                        jclass("java.lang.Integer").TYPE, jclass("java.lang.Integer").TYPE,
                        jclass("android.graphics.drawable.Drawable"), jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE, jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    our_item = asSubItemMethod.invoke(None, Integer(2046), Integer(R_tg.drawable.msg_fave_solar),
                        None, getString("bookmarks", "Bookmarks"), jclass("java.lang.Boolean")(True), jclass("java.lang.Boolean")(False))
                    
                    lazy_list.add(insert_position, our_item)
                    if lazy_map:
                        lazy_map.put(Integer(2046), our_item)
                
                self._bm_update_menu_visibility(chat_activity)
            except:
                self._bm_update_menu_visibility(chat_activity)
        except: pass
    
    def _bm_update_menu_visibility(self, chat_activity):
        try:
            if not self._bookmark_helper: return
            h = get_private_field(chat_activity, "headerItem")
            if h:
                h.setSubItemShown(2046, bool(self._bookmark_helper.get_bookmarked_message_ids(chat_activity.getCurrentAccount(), chat_activity.getDialogId())))
        except: pass
    
    def _bm_hook_action_bar_callback(self, chat_activity):
        try:
            action_bar = get_private_field(chat_activity, "actionBar")
            if not action_bar: return
            
            current_callback = get_private_field(action_bar, "actionBarMenuOnItemClick")
            if not current_callback: return
            
            onItemClickMethod = current_callback.getClass().getDeclaredMethod("onItemClick", jclass("java.lang.Integer").TYPE)
            onItemClickMethod.setAccessible(True)
            
            if self.hook_bookmark_action_bar_ref:
                self.unhook_method(self.hook_bookmark_action_bar_ref)
            self.hook_bookmark_action_bar_ref = self.hook_method(onItemClickMethod, BookmarkActionBarClickHook(self))
        except: pass
    
    def _bm_open_bookmarks_fragment(self, chat_activity):
        try:
            self._bookmark_delegate = self._bm_create_bookmarks_delegate(chat_activity.getCurrentAccount(), chat_activity.getDialogId())
            self._bookmark_fragment = UniversalFragment(self._bookmark_delegate)
            chat_activity.presentFragment(self._bookmark_fragment)
        except: pass
    
    def _bm_create_bookmarks_delegate(self, current_account, dialog_id):
        plugin_ref = weakref.ref(self)
        mc = MessagesController.getInstance(current_account)
        
        if DialogObject.isUserDialog(dialog_id):
            user = mc.getUser(dialog_id)
            chat_name = (user.first_name if user else None) or "User"
        else:
            chat = mc.getChat(-dialog_id)
            chat_name = (chat.title if chat else None) or "Chat"
        
        CellDelegate = jclass("org.telegram.ui.Cells.ChatMessageCell$ChatMessageCellDelegate")
        class BookmarkCellDelegate(dynamic_proxy(CellDelegate)):
            def getTextSelectionHelper(self): return None
            def didPressUrl(self, cell, url, longPress): pass
            def canPerformActions(self): return False
            def hasSelectedMessages(self): return False
            def isProgressLoading(self, cell, type): return False
            def getProgressLoadingLink(self, cell): return None
            def getPinchToZoomHelper(self): return None
            def getProgressLoadingBotButtonUrl(self, cell): return None
            def keyboardIsOpened(self): return False
            def isLandscape(self): return False
            def canDrawOutboundsContent(self): return True
            def shouldDrawThreadProgress(self, cell, delayed): return False
            def getAdminRank(self, uid): return None
            def shouldRepeatSticker(self, message): return True
            def canPerformReply(self): return False
            def drawingVideoPlayerContainer(self): return False
            def needPlayMessage(self, cell, messageObject, muted): return False
            def didPressAnimatedEmoji(self, cell, span): return False
            def shouldShowTopicButton(self, cell): return False
            def shouldShowDialogButton(self, cell): return False
            def doNotShowLoadingReply(self, msg): return True
            def isReplyOrSelf(self): return False
            def videoTimerReached(self): pass
        
        class BookmarksDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):
            def __init__(s):
                super().__init__()
                s.acc = current_account
                s.dialog_id = dialog_id
                s.title = chat_name
                s.ctx = None
                s.messages_data = []
                s.shared_resources = None
                s.delegate = BookmarkCellDelegate()
            
            def getTitle(s): return s.title
            def beforeCreateView(s): return None
            
            def afterCreateView(s, v):
                s.ctx = v.getContext()
                try:
                    wallpaper = Theme.getCachedWallpaper()
                    if wallpaper:
                        copied_state = wallpaper.getConstantState()
                        if copied_state:
                            wallpaper_copy = copied_state.newDrawable().mutate()
                            v.setBackground(wallpaper_copy)
                    else:
                        v.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundGray))
                    
                    p = plugin_ref()
                    if p and p._bookmark_fragment:
                        listView = p._bookmark_fragment.listView
                        listView.layoutManager.setStackFromEnd(True)
                        listView.adapter.setUseSectionStyle(False)
                        listView.adapter.setApplyBackground(False)
                        
                        if listView.getParent() == v:
                            v.removeView(listView)
                            container = LinearLayout(s.ctx)
                            container.setOrientation(LinearLayout.VERTICAL)
                            container.setBackgroundColor(0x00000000)
                            container.addView(listView, LayoutHelper.createLinear(-1, -1))
                            v.addView(container, LayoutHelper.createFrame(-1, -1))
                except: pass
                
                s.shared_resources = ChatMessageSharedResources(s.ctx)
                s._load_messages()
                return None
            
            def _load_messages(s):
                try:
                    p = plugin_ref()
                    if not p or not p._bookmark_helper: return
                    storage = MessagesStorage.getInstance(s.acc)
                    message_ids = p._bookmark_helper.get_bookmarked_message_ids(s.acc, s.dialog_id)
                    
                    s.messages_data = []
                    for msg_id in message_ids:
                        try:
                            tlrpc_msg = storage.getMessage(s.dialog_id, msg_id)
                            if tlrpc_msg:
                                msg_obj = MessageObject(s.acc, tlrpc_msg, False, True)
                                s.messages_data.append({'message_object': msg_obj, 'message_id': msg_id})
                        except: pass
                    
                    s._update_list()
                    
                    if p._bookmark_fragment:
                        action_bar = get_private_field(p._bookmark_fragment, "actionBar")
                        if action_bar:
                            action_bar.setSubtitle(getString("bookmarks_count", "Bookmarks") + f" ({len(s.messages_data)}/30)")
                except: pass
            
            def _update_list(s):
                p = plugin_ref()
                run_on_ui_thread(lambda: p and p._bookmark_fragment and p._bookmark_fragment.listView and p._bookmark_fragment.listView.getAdapter() and p._bookmark_fragment.listView.getAdapter().update(True))
            
            def fillItems(s, items, adapter):
                if not s.messages_data or not s.ctx: return
                p = plugin_ref()
                if not p: return
                ChatMessageCell = find_class("org.telegram.ui.Cells.ChatMessageCell")
                for msg_item in s.messages_data:
                    try:
                        msg_obj, msg_id = msg_item['message_object'], msg_item['message_id']
                        container = FrameLayout(s.ctx)
                        cell = ChatMessageCell(s.ctx, s.acc, False, s.shared_resources, None)
                        cell.setMessageObject(msg_obj, None, True, True, False)
                        cell.setDelegate(s.delegate)
                        container.addView(cell, LayoutHelper.createFrame(-1, -2))
                        container.setOnClickListener(OnClickListener(lambda v, mo=msg_obj, mid=msg_id, did=s.dialog_id, acc=s.acc, cel=cell: p._bm_show_message_menu(cel, mo, mid, did, acc)))
                        container.setBackground(Theme.getSelectorDrawable(False))
                        item = UItem.asCustom(container)
                        item.transparent = True
                        items.add(item)
                    except: pass
            
            def onClick(s, item, view, pos, x, y): pass
            def onLongClick(s, item, view, pos, x, y): return False
            def onFragmentCreate(s): pass
            def onFragmentDestroy(s):
                s.messages_data = []; s.shared_resources = None; s.ctx = None
                p = plugin_ref()
                if p: p._bookmark_fragment = None; p._bookmark_delegate = None
            def onBackPressed(s):
                p = plugin_ref()
                if p: p._bookmark_fragment = None; p._bookmark_delegate = None
                return None
            def onMenuItemClick(s, mid): pass
        
        return BookmarksDelegate()
    
    def _bm_navigate_to_message(self, dialog_id, message_id, acc):
        def run():
            try:
                frag = self._bookmark_fragment
                if frag:
                    b = Bundle()
                    if DialogObject.isEncryptedDialog(dialog_id):
                        b.putInt("enc_id", DialogObject.getEncryptedChatId(dialog_id))
                    elif DialogObject.isUserDialog(dialog_id):
                        b.putLong("user_id", dialog_id)
                    else:
                        b.putLong("chat_id", -dialog_id)
                    b.putInt("message_id", message_id)
                    self._bookmark_fragment = None
                    frag.presentFragment(ChatActivity(b), True)
            except: pass
        run_on_ui_thread(run)
    
    def _bm_show_message_menu(self, cell, msg_obj, msg_id, dialog_id, acc):
        try:
            frag = self._bookmark_fragment
            if not frag: return
            activity = frag.getParentActivity()
            if not activity: return
            
            popupLayout = ActionBarPopupWindow.ActionBarPopupWindowLayout(activity, R_tg.drawable.popup_fixed_alert, frag.getResourceProvider(), 0)
            popupLayout.setMinimumWidth(AndroidUtilities.dp(200))
            popupLayout.setBackgroundColor(Theme.getColor(Theme.key_actionBarDefaultSubmenuBackground))
            
            plugin_ref, pw = weakref.ref(self), [None]
            
            def add_item(text, icon, action):
                item = ActionBarMenuSubItem(activity, False, False, frag.getResourceProvider())
                item.setMinimumWidth(AndroidUtilities.dp(200))
                item.setTextAndIcon(text, icon)
                item.setOnClickListener(OnClickListener(lambda v: (pw[0].dismiss() if pw[0] else None, action())))
                popupLayout.addView(item)
            
            add_item(getString("show_in_chat", "Show in Chat"), R_tg.drawable.msg_openin, lambda: self._bm_navigate_to_message(dialog_id, msg_id, acc))
            if msg_obj.messageOwner and msg_obj.messageOwner.message:
                from org.telegram.messenger import R
                add_item(getString("copy", "Copy"), R_tg.drawable.msg_copy, lambda: (AndroidUtilities.addToClipboard(msg_obj.messageOwner.message), BulletinHelper.show_simple(getString("text_copied", "Text copied"), R.raw.copy, frag)))
            
            def remove():
                p = plugin_ref()
                if not p or not p._bookmark_helper: return
                from org.telegram.messenger import R
                p._bookmark_helper.remove_bookmark(acc, dialog_id, msg_id)
                BulletinHelper.show_simple(getString("bookmark_removed", "Removed from bookmarks"), R.raw.ic_delete, frag)
                if p._bookmark_delegate and hasattr(p._bookmark_delegate, 'messages_data'):
                    p._bookmark_delegate.messages_data = [m for m in p._bookmark_delegate.messages_data if m['message_id'] != msg_id]
                if frag.listView and frag.listView.getAdapter(): frag.listView.getAdapter().update(True)
            add_item(getString("remove_bookmark", "Remove Bookmark"), R_tg.drawable.msg_unfave, remove)
            
            pw[0] = ActionBarPopupWindow(popupLayout, -2, -2)
            pw[0].setOutsideTouchable(True)
            pw[0].setClippingEnabled(True)
            pw[0].setAnimationStyle(R_tg.style.PopupContextAnimation)
            pw[0].setFocusable(True)
            popupLayout.setFitItems(True)
            loc = [0, 0]
            cell.getLocationInWindow(loc)
            pw[0].showAtLocation(cell, Gravity.TOP | Gravity.LEFT, loc[0], loc[1])
            pw[0].dimBehind()
        except: pass


class _BookmarksHelper:
    KEY_PREFIX = "bookmarks_"
    MAX_PER_CHAT = 30

    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        self.cache = {}
    
    @property
    def plugin(self):
        return self._plugin_ref()

    def _key(self, account_id, dialog_id):
        return f"{self.KEY_PREFIX}{account_id}_{dialog_id}"

    def _get_ids(self, key):
        if key in self.cache:
            return self.cache[key]
        try:
            raw = self.plugin.get_setting(key, "")
            if not raw:
                self.cache[key] = []
                return []
            seen, result = set(), []
            for part in str(raw).split(','):
                try:
                    msg_id = int(part.strip())
                    if msg_id and msg_id not in seen:
                        seen.add(msg_id)
                        result.append(msg_id)
                except: continue
            result = result[-self.MAX_PER_CHAT:]
            self.cache[key] = result
            return result
        except: return []

    def _persist(self, key, ids):
        try:
            normalized = list(dict.fromkeys(ids))[-self.MAX_PER_CHAT:] if ids else []
            self.plugin.set_setting(key, ",".join(str(i) for i in normalized) if normalized else "")
            self.cache[key] = normalized
        except: pass

    def is_bookmarked(self, account_id, dialog_id, message_id):
        return message_id and message_id in self._get_ids(self._key(account_id, dialog_id))

    def get_bookmarked_message_ids(self, account_id, dialog_id):
        return list(self._get_ids(self._key(account_id, dialog_id)))

    def toggle_bookmarks(self, account_id, dialog_id, message_ids):
        ids = [m for m in message_ids if m]
        if not ids: return "removed"
        key = self._key(account_id, dialog_id)
        current = self._get_ids(key)[:]
        current_set = set(current)
        if all(m in current_set for m in ids):
            current = [m for m in current if m not in ids]
            self._persist(key, current)
            return "removed"
        missing = [m for m in ids if m not in current_set]
        if len(current) + len(missing) > self.MAX_PER_CHAT:
            return "limit_reached"
        self._persist(key, current + missing)
        return "added"

    def remove_bookmark(self, account_id, dialog_id, message_id):
        key = self._key(account_id, dialog_id)
        current = [m for m in self._get_ids(key) if m != message_id]
        if len(current) != len(self._get_ids(key)):
            self._persist(key, current)
            return True
        return False


class BookmarkCreateViewHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    def after_hooked_method(self, param):
        try:
            p = self._plugin_ref()
            if p and p.get_setting("enable_bookmark_chat", False):
                p._bm_on_chat_activity_created(param.thisObject)
        except: pass


class BookmarkActionBarClickHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    def before_hooked_method(self, param):
        try:
            p = self._plugin_ref()
            if p and int(param.args[0]) == 2046:
                frag = get_last_fragment()
                ChatActivityClass = p._get_class("org.telegram.ui.ChatActivity")
                if frag and ChatActivityClass and isinstance(frag, ChatActivityClass):
                    p._bm_open_bookmarks_fragment(frag)
                    param.setResult(None)
        except: pass


class SetDefaultSendAsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def after_hooked_method(self, param):
        try:
            dialog_id, peer_id = param.args[0], param.args[1]
            current_account = UserConfig.selectedAccount
            chat = MessagesController.getInstance(current_account).getChat(-dialog_id)
            
            if not chat or not ChatObject.isMegagroup(chat) or not chat.creator:
                return

            current_user = UserConfig.getInstance(current_account).getCurrentUser()
            if not current_user or not chat.admin_rights:
                return

            self_id = current_user.id
            admin_rights = chat.admin_rights
            admin_rights.anonymous = peer_id != self_id
            rank = MessagesController.getInstance(current_account).getAdminRank(chat.id, self_id)
            MessagesController.getInstance(current_account).setUserAdminRole(
                chat.id, current_user, admin_rights, rank, False, None, False, False, None, None
            )

        except Exception:
            pass


class SendAsPopupHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(3), HookFilter.ArgumentNotNull(4))
    def after_hooked_method(self, param):
        try:
            send_as_peers, chat_full = param.args[4], param.args[3]
            if not send_as_peers or not chat_full:
                return

            chat_id = chat_full.id
            current_account = UserConfig.selectedAccount
            chat = MessagesController.getInstance(current_account).getChat(chat_id)
            
            if not chat or not ChatObject.isMegagroup(chat) or not chat.creator:
                return

            current_user = UserConfig.getInstance(current_account).getCurrentUser()
            if not current_user:
                return

            self_id = current_user.id
            peers = send_as_peers.peers
            
            for i in range(peers.size()):
                peer = peers.get(i)
                if hasattr(peer, 'peer') and hasattr(peer.peer, 'user_id') and peer.peer.user_id == self_id:
                    return

            personal_peer = TLRPC.TL_sendAsPeer()
            personal_peer.peer = TLRPC.TL_peerUser()
            personal_peer.peer.user_id = self_id
            personal_peer.peer.channel_id = 0
            personal_peer.peer.chat_id = 0
            peers.add(0, personal_peer)

        except Exception:
            pass


class BirthdayAlertHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        instance = param.thisObject
        if instance is None:
            return
        
        try:
            currentAccount = get_private_field(instance, "currentAccount")
            if currentAccount is None:
                return
            
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            messagesController = MessagesController.getInstance(currentAccount)
            pendingSuggestions = get_private_field(messagesController, "pendingSuggestions")
            
            if pendingSuggestions and pendingSuggestions.contains("BIRTHDAY_SETUP"):
                dialogsHintCell = get_private_field(instance, "dialogsHintCell")
                if dialogsHintCell:
                    dialogsHintCell.setVisibility(8)
        except Exception:
            pass





class ConfirmationHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.pending_params: List[Any] = [] 
        self.pending_group_id: Optional[str] = None 
        self.is_resending = False
        self.pending_sticker_doc = None

    def _reset_pending(self):
        self.pending_params.clear()
        self.pending_group_id = None
        self.pending_sticker_doc = None

    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param: Any):
        if self.is_resending:
            return

        try:
            send_params = param.args[0]
            if not send_params:
                return

            params_map = getattr(send_params, 'params', None)
            group_id = None
            is_group_final = False
            if params_map is not None:
                group_id = params_map.get("groupId")
                is_group_final = params_map.get("final") == "1"

            msg_text = getattr(send_params, 'message', None)
            is_command = isinstance(msg_text, str) and msg_text.strip().startswith('/')

            is_photo = getattr(send_params, 'photo', None) is not None
            doc = getattr(send_params, 'document', None)

            is_sticker = False
            is_voice = False
            is_round_video = False
            is_video_file = False
            is_gif = False
            is_generic_document = False

            if doc and hasattr(doc, 'attributes'):
                attributes_list = doc.attributes
                has_animated_attr = False
                has_video_attr = False
                has_sticker_attr = False
                
                mime_type = getattr(doc, 'mime_type', '')
                
                for i in range(attributes_list.size()):
                    attr = attributes_list.get(i)
                    if isinstance(attr, TL_documentAttributeSticker):
                        has_sticker_attr = True
                    elif isinstance(attr, TL_documentAttributeAudio) and attr.voice:
                        is_voice = True
                    elif isinstance(attr, TL_documentAttributeAnimated):
                        has_animated_attr = True
                    elif isinstance(attr, TL_documentAttributeVideo):
                        has_video_attr = True
                        if attr.round_message:
                            is_round_video = True
                        else:
                            is_video_file = True
                
                if has_sticker_attr:
                    is_round_video = False
                    is_video_file = False
                    is_sticker = True
                elif has_animated_attr:
                    is_gif = True
                    is_video_file = False
                elif has_video_attr and not is_round_video:
                    is_video_file = True

                if not (is_sticker or is_voice or is_round_video or is_video_file or is_gif):
                    is_generic_document = True

            should_confirm = False
            message_type = ""

            if not self.plugin.get_setting("enable_confirmation_settings", False):
                should_confirm = False
            elif is_command and self.plugin.get_setting("confirm_commands", False):
                if self.plugin.command_from_message_click:
                    should_confirm = True
                    message_type = getString("message_type_command", "command")
            elif is_photo and self.plugin.get_setting("confirm_photo", False):
                should_confirm = True
                message_type = getString("message_type_photo", "photo")
            elif is_sticker and self.plugin.get_setting("confirm_stickers", True):
                should_confirm = True
                message_type = getString("message_type_sticker", "sticker")
                self.pending_sticker_doc = doc
            elif is_voice and self.plugin.get_setting("confirm_voice", True):
                should_confirm = True
                message_type = getString("message_type_voice_message", "voice message")
            elif is_round_video and self.plugin.get_setting("confirm_round_video", True):
                should_confirm = True
                message_type = getString("message_type_round_video_message", "round video message")
            elif is_video_file and self.plugin.get_setting("confirm_video_file", False):
                should_confirm = True
                message_type = getString("message_type_video_file", "video file")
            elif is_gif and self.plugin.get_setting("confirm_gif", False):
                should_confirm = True
                message_type = getString("message_type_gif", "GIF")
            elif is_generic_document and self.plugin.get_setting("confirm_document", False):
                should_confirm = True
                message_type = getString("message_type_file", "file")

            if not should_confirm:
                if is_command:
                    self.plugin.command_from_message_click = False
                return 

            if is_command:
                self.pending_params.append(param)
                param.setResult(None)
                
                self_ref = weakref.ref(self)
                run_on_ui_thread(lambda: self_ref() and self_ref().show_confirmation_dialog(msg_text.strip()))
                self.plugin.command_from_message_click = False
                return

            if group_id and group_id != "0":
                if self.pending_group_id is None:
                    self.pending_group_id = group_id
                if group_id != self.pending_group_id:
                    return

                self.pending_params.append(param)
                param.setResult(None)

                if is_group_final:
                    count = len(self.pending_params)
                    if count > 1:
                        if is_photo:
                            message_type = getString("message_type_photo_plural", "photos")
                        elif is_video_file:
                            message_type = getString("message_type_video_file_plural", "video files")
                        elif is_round_video:
                            message_type = getString("message_type_round_video_message", "round video messages")
                        elif is_generic_document:
                            message_type = getString("message_type_file_plural", "files")
                    
                    self_ref = weakref.ref(self)
                    run_on_ui_thread(lambda: self_ref() and self_ref().show_confirmation_dialog(f"{count} {message_type}"))
                return
            else:
                self.pending_params.append(param)
                param.setResult(None)
                
                self_ref = weakref.ref(self)
                run_on_ui_thread(lambda: self_ref() and self_ref().show_confirmation_dialog(message_type, is_sticker, doc if is_sticker else None))

        except Exception as e:
            pass

    def show_confirmation_dialog(self, message_type: str, is_sticker: bool = False, sticker_doc = None):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None

        if not activity:
            self.proceed_sending(None, 0)
            return

        dialog_ref = None
        
        def cleanup():
            nonlocal dialog_ref
            dialog_ref = None

        builder = AlertDialogBuilder(activity)
        builder.set_title(getString("confirm_send_title", "Confirm Send"))
        
        confirmation_text = getString("confirm_send_message", "Do you really want to send this {message_type}?").format(message_type=message_type)

        if is_sticker and sticker_doc:
            try:
                container = LinearLayout(activity)
                container.setOrientation(LinearLayout.VERTICAL)
                container.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(16))

                sticker_view = BackupImageView(activity)
                sticker_view.setRoundRadius(0)
                sticker_size = AndroidUtilities.dp(120)
                sticker_params = LinearLayout.LayoutParams(sticker_size, sticker_size)
                sticker_params.gravity = Gravity.CENTER_HORIZONTAL
                sticker_params.bottomMargin = AndroidUtilities.dp(16)
                sticker_view.setLayoutParams(sticker_params)

                thumb_drawable = None
                if sticker_doc.thumbs and sticker_doc.thumbs.size() > 0:
                    from org.telegram.messenger import ImageLoader
                    for i in range(sticker_doc.thumbs.size()):
                        t = sticker_doc.thumbs.get(i)
                        if hasattr(t, 'bytes') and t.bytes:
                            thumb_drawable = ImageLoader.getStrippedPhotoBitmap(t.bytes, "b")
                            break

                image_location = ImageLocation.getForDocument(sticker_doc)
                if image_location:
                    sticker_view.setImage(image_location, "120_120", thumb_drawable, sticker_doc)

                container.addView(sticker_view)

                builder.set_view(container)
            except Exception:
                builder.set_message(confirmation_text)
        else:
            builder.set_message(confirmation_text)
        
        builder.set_positive_button(getString("send", "Send"), self.proceed_sending)
        
        builder.set_negative_button(getString("cancel", "Cancel"), lambda dialog, which: cleanup())
        builder.set_on_cancel_listener(lambda b: (self.cancel_sending(b, 0), cleanup()))
        dialog_ref = builder.show()
        builder.set_canceled_on_touch_outside(False)

    def proceed_sending(self, builder: Optional[AlertDialogBuilder], which: int):
        if builder:
            builder.dismiss()

        if not self.pending_params:
            return

        try:
            for stored_param in self.pending_params:
                original_method = stored_param.method
                arguments = stored_param.args
                instance = stored_param.thisObject
                self.is_resending = True
                original_method.invoke(instance, *arguments)
            
        except Exception as e:
            pass
        finally:
            self.is_resending = False
            self._reset_pending()

    def cancel_sending(self, builder: Optional[AlertDialogBuilder], which: int):
        if builder:
            builder.dismiss()
        
        self._reset_pending()


class DialogsActivityHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            dialogs_activity = param.thisObject
            if dialogs_activity is None:
                return
            
            if plugin.get_setting("hide_bot_open", False):
                    try:
                        plugin._hide_bot_open_buttons_on_resume(dialogs_activity)
                    except Exception as e:
                        pass
            

            
            if plugin.get_setting("fab_settings_shortcut", False):
                try:
                    plugin._setup_fab_settings_listener(dialogs_activity)
                except Exception as e:
                    pass
        except Exception as e:
            pass


class DialogsActivityDestroyHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            dialogs_activity = param.thisObject
            if dialogs_activity is None:
                return
            
            activity_id = id(dialogs_activity)
            plugin.cleanup_activity_references(activity_id)
        except Exception:
            pass


class ChatActivityCleanupHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin is None:
                return
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            
            activity_id = id(chat_activity)
            plugin.cleanup_activity_references(activity_id)
        except Exception:
            pass


class DialogCellHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin is None:
                return
            if plugin.get_setting("hide_bot_open", True):
                cell = param.thisObject
                if cell is not None:
                    try:
                        open_bot_field = cell.getClass().getDeclaredField("openBot")
                        open_bot_field.setAccessible(True)
                        open_bot_value = open_bot_field.get(cell)
                        
                        if open_bot_value:  
                            open_bot_field.set(cell, False)  
                            
                    except Exception as e:
                        pass
        except Exception as e:
            pass



class SwipePreventionHook(MethodReplacement):
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    def replace_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return True
            prevent_editing = plugin.get_setting("prevent_swipe_while_editing", False)
            prevent_typing = plugin.get_setting("prevent_swipe_while_typing", False)
            
            if not prevent_editing and not prevent_typing:
                return True
            
            activity = param.thisObject
            if activity is None:
                return True
            
            swipe_back_enabled = True
            try:
                swipe_back_enabled = get_private_field(activity, "swipeBackEnabled")
                if swipe_back_enabled is None:
                    swipe_back_enabled = True
            except:
                pass
            
            forwarding_preview_view = None
            try:
                forwarding_preview_view = get_private_field(activity, "forwardingPreviewView")
            except:
                pass
            
            if not swipe_back_enabled or (forwarding_preview_view is not None and hasattr(forwarding_preview_view, 'isShowing') and forwarding_preview_view.isShowing()):
                return False
            
            is_editing = False
            is_keyboard_open = False
            
            if prevent_editing:
                try:
                    editing_message = get_private_field(activity, "editingMessageObject")
                    is_editing = editing_message is not None
                except:
                    pass
            
            if prevent_typing:
                try:
                    is_keyboard_open = activity.isKeyboardVisible()
                except:
                    pass
            
            should_prevent = (prevent_editing and is_editing) or (prevent_typing and is_keyboard_open)
            
            if should_prevent:
                return False
            else:
                return True
        except Exception as e:
            return True


class DeepLinkHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)
        self.pending_intent = None
        self.pending_param = None
        self.is_processing = False

    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            if not plugin.get_setting("confirm_deeplinks", False) and not plugin.get_setting("confirm_ayugram_deeplinks", False):
                return

            if self.is_processing:
                return

            if len(param.args) < 7:
                return

            intent = param.args[0]
            if not intent:
                return

            for i in range(1, 7):
                if param.args[i] is None:
                    return

            action = intent.getAction()
            if action and "voice" in action.lower():
                return

            data = intent.getData()
            if not data:
                return

            url = str(data)
            if url.startswith("tg://Quanta") or url.startswith("tg://quanta") or url == "tg://refresh":
                return
            elif url.startswith("tg://ayu/"):
                plugin = self._plugin_ref()
                if not plugin or not plugin.get_setting("confirm_ayugram_deeplinks", False):
                    return
                
                excluded_links = ["tg://ayu/prefs", "tg://ayu/db_export", "tg://ayu/db_import"]
                if url in excluded_links:
                    self.pending_intent = intent
                    self.pending_param = param
                    param.setResult(None)
                    self_ref = weakref.ref(self)
                    run_on_ui_thread(lambda: self_ref() and self_ref().show_deeplink_confirmation_dialog(url))
                    return
                
                self.pending_intent = intent
                self.pending_param = param
                param.setResult(None)
                self_ref = weakref.ref(self)
                run_on_ui_thread(lambda: self_ref() and self_ref().show_ayugram_warning_dialog(url))
                return
            elif url.startswith("tg://"):
                plugin = self._plugin_ref()
                if not plugin or not plugin.get_setting("confirm_deeplinks", False):
                    return
                    
                self.pending_intent = intent
                self.pending_param = param
                param.setResult(None)
                self_ref = weakref.ref(self)
                run_on_ui_thread(lambda: self_ref() and self_ref().show_deeplink_confirmation_dialog(url))
                return

        except Exception as e:
            pass

    def show_ayugram_warning_dialog(self, url: str):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                self.proceed_deeplink()
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(getString("ayugram_deeplink_title", "AyuGram Deep Link"))
            builder.set_message(getString("ayugram_deeplink_message", "This AyuGram link may redirect to auto-playing content with blocked controls."))
            builder.set_positive_button(getString("proceed_anyway", "Proceed Anyway"), lambda b, w: self.proceed_deeplink())
            builder.set_negative_button(getString("cancel", "Cancel"), lambda b, w: self.cancel_deeplink())
            builder.set_on_cancel_listener(lambda b: self.cancel_deeplink())
            builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
            builder.show()

        except Exception as e:
            self.proceed_deeplink()

    def show_deeplink_confirmation_dialog(self, url: str):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                self.proceed_deeplink()
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(getString("confirm_deeplink_title", "Confirm Deep Link"))
            builder.set_message(getString("confirm_deeplink_message", "Do you really want to open this deep link?\n{url}").format(url=url))
            builder.set_positive_button(getString("open", "Open"), lambda b, w: self.proceed_deeplink())
            builder.set_negative_button(getString("cancel", "Cancel"), lambda b, w: self.cancel_deeplink())
            builder.set_on_cancel_listener(lambda b: self.cancel_deeplink())
            builder.show()

        except Exception as e:
            self.proceed_deeplink()

    def proceed_deeplink(self):
        try:
            if self.pending_param and self.pending_intent:
                
                self.is_processing = True
                
                instance = self.pending_param.thisObject
                original_method = self.pending_param.method
                arguments = [self.pending_intent, True, False, False, None, True, False]
                original_method.invoke(instance, *arguments)
                
                
                self.pending_intent = None
                self.pending_param = None
                self.is_processing = False
        except Exception as e:
            self.is_processing = False
            pass

    def cancel_deeplink(self):
        self.pending_intent = None
        self.pending_param = None
        self.is_processing = False


class SetCommandHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            message_object = param.args[0]  
            command = param.args[1] 
            long_press = param.args[2] 
            username = param.args[3] 
            
            if message_object is not None and command is not None and command.startswith('/'):
                plugin.command_from_message_click = True
            else:
                plugin.command_from_message_click = False
            
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.command_from_message_click = False


class StarReactionMenuHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)
        self._items_field = None
        self._visible_reactions_field = None

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            if not plugin.get_setting("hide_star_reaction", False):
                return
            
            hide_location = plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]: 
                return
                
            container = param.thisObject
            if container is None:
                return
                
            try:
                if self._items_field is None:
                    self._items_field = container.getClass().getDeclaredField("items")
                    self._items_field.setAccessible(True)
                items = self._items_field.get(container)
                
                if items is not None and items.size() > 0:
                    filtered_items = []
                    star_count = 0
                    for i in range(items.size()):
                        item = items.get(i)
                        if item is not None:
                            reaction = getattr(item, 'reaction', None)
                            if reaction is not None:
                                is_star_property = getattr(reaction, 'isStar', False)
                                is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                                is_star = is_star_property or is_star_class
                                if is_star:
                                    star_count += 1
                                    continue
                                else:
                                    filtered_items.append(item)
                            else:
                                filtered_items.append(item)
                    
                    if len(filtered_items) < items.size():
                        from java.util import ArrayList
                        new_items = ArrayList()
                        for item in filtered_items:
                            new_items.add(item)
                        self._items_field.set(container, new_items)
                            
                        if hasattr(container, 'notifyDataSetChanged'):
                            container.notifyDataSetChanged()
                        
            except Exception as e:
                try:
                    if self._visible_reactions_field is None:
                        self._visible_reactions_field = container.getClass().getDeclaredField("visibleReactions")
                        self._visible_reactions_field.setAccessible(True)
                    visible_reactions = self._visible_reactions_field.get(container)
                    
                    if visible_reactions is not None:
                        filtered_reactions = []
                        for i in range(visible_reactions.size()):
                            reaction = visible_reactions.get(i)
                            if reaction is not None:
                                is_star_property = getattr(reaction, 'isStar', False)
                                is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                                is_star = is_star_property or is_star_class
                                if is_star:
                                    continue
                                else:
                                    filtered_reactions.append(reaction)
                        
                        if len(filtered_reactions) < visible_reactions.size():
                            from java.util import ArrayList
                            new_list = ArrayList()
                            for reaction in filtered_reactions:
                                new_list.add(reaction)
                            self._visible_reactions_field.set(container, new_list)
                            
                except Exception as e2:
                    pass
                
        except Exception as e:
            pass


class StarReactionVisibleListHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]: 
                return
                
            reactions_list = param.args[0]
            if reactions_list is None or reactions_list.size() == 0:
                return
                
            
            filtered_reactions = []
            has_star = False
            for i in range(reactions_list.size()):
                reaction = reactions_list.get(i)
                if reaction is not None:
                    is_star_property = getattr(reaction, 'isStar', False)
                    is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                    is_star = is_star_property or is_star_class
                    if is_star:
                        has_star = True
                    else:
                        filtered_reactions.append(reaction)
            
            if has_star and len(filtered_reactions) < reactions_list.size():
                from java.util import ArrayList
                new_list = ArrayList()
                for reaction in filtered_reactions:
                    new_list.add(reaction)
                param.args[0] = new_list
                
        except Exception as e:
            pass


class StarReactionGradientHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]:
                return
                
            container = param.thisObject
            if container is None:
                return
                
            try:
                has_star_field = container.getClass().getDeclaredField("hasStar")
                has_star_field.setAccessible(True)
                has_star_field.set(container, False)
            except Exception as e:
                pass
                
        except Exception as e:
            pass


class StarReactionLayoutDrawHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            if not plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_cells = plugin.get_setting("star_reaction_hide_cells", False)
            if not hide_cells: 
                return
                
            message_object = param.args[0] if len(param.args) > 0 else None
            if message_object is None:
                return
            if (hasattr(message_object, 'messageOwner') and 
                message_object.messageOwner is not None and 
                hasattr(message_object.messageOwner, 'reactions') and 
                message_object.messageOwner.reactions is not None and
                hasattr(message_object.messageOwner.reactions, 'results') and
                message_object.messageOwner.reactions.results is not None):
                
                original_results = message_object.messageOwner.reactions.results
                filtered_results = []
                
                for i in range(original_results.size()):
                    reaction_count = original_results.get(i)
                    if reaction_count is not None and reaction_count.reaction is not None:
                        is_star_property = getattr(reaction_count.reaction, 'isStar', False)
                        is_star_class = isinstance(reaction_count.reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                        is_star = is_star_property or is_star_class
                        
                        if not is_star:
                            filtered_results.append(reaction_count)
                
                if len(filtered_results) < original_results.size():
                    from java.util import ArrayList
                    new_results = ArrayList()
                    for result in filtered_results:
                        new_results.add(result)
                    message_object.messageOwner.reactions.results = new_results
                        
        except Exception as e:
            pass


class DownloadManagerHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin.get_setting("always_show_download_manager", False):
                param.setResult(True)
        except Exception as e:
            pass

class ProxyButtonHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin or not plugin.get_setting("always_show_proxy_button", False):
                return
            
            dialogs_activity = param.thisObject
            
            try:
                proxy_item_field = dialogs_activity.getClass().getDeclaredField("proxyItem")
                proxy_item_field.setAccessible(True)
                proxy_item = proxy_item_field.get(dialogs_activity)
                
                if proxy_item is not None:
                    proxy_item.setVisibility(0)
                    
                    proxy_visible_field = dialogs_activity.getClass().getDeclaredField("proxyItemVisible")
                    proxy_visible_field.setAccessible(True)
                    proxy_visible_field.set(dialogs_activity, True)
                    
            except Exception as e:
                pass
                
        except Exception as e:
            pass

class ArticleViewerFixHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin.get_setting("disable_article_viewer_swipe", False):
                param.setResult(False)
        except Exception as e:
            pass


class WebAppSwipePreventionHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    def after_hooked_method(self, param):
        try:
            swipe_container = param.thisObject
            if swipe_container:
                swipe_container.setAllowSwipes(False)
        except Exception as e:
            pass


class PhoneFormatHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    def after_hooked_method(self, param):
        try:
            phone_str = param.args[0]
            if phone_str and str(phone_str).startswith('+'):
                is_other = self.is_other_user_profile()
                if is_other:
                    param.setResult(getString("MobileHidden", "Mobile hidden"))
        except:
            pass
    
    def is_other_user_profile(self):
        try:
            fragment = get_last_fragment()
            if not fragment or fragment.getClass().getSimpleName() != "ProfileActivity":
                return False
            
            userId_field = fragment.getClass().getDeclaredField("userId")
            userId_field.setAccessible(True)
            user_id = userId_field.getLong(fragment)
            
            if user_id == 0:
                return False
            
            from org.telegram.messenger import UserConfig
            current_user_id = UserConfig.getInstance(fragment.getCurrentAccount()).getClientUserId()
            return user_id != current_user_id
        except:
            return False


class MessagesControllerGetDialogsHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)
        self._processed_accounts = set()

    def _remove_folder_dialog(self, dialog_list, dialog_object):
        if dialog_list is None:
            return
        for i in range(dialog_list.size() - 1, -1, -1):
            if dialog_object.isFolderDialogId(dialog_list.get(i).id):
                dialog_list.remove(i)
                return

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin or not plugin.get_setting("hide_archived_chats", False):
                self._processed_accounts.clear()
                return

            mc = param.thisObject
            account_id = mc.currentAccount
            
            if account_id in self._processed_accounts:
                return
            
            dialog_object = jclass("org.telegram.messenger.DialogObject")
            archive_id = dialog_object.makeFolderDialogId(1)
            
            if mc.dialogs_dict.get(archive_id) is not None:
                mc.dialogs_dict.remove(archive_id)
            
            self._remove_folder_dialog(mc.allDialogs, dialog_object)
            
            folder_dialogs = mc.dialogsByFolder.get(0) if mc.dialogsByFolder else None
            self._remove_folder_dialog(folder_dialogs, dialog_object)
            
            self._processed_accounts.add(account_id)
        except Exception:
            pass


class ChatUtilsHasArchivedHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.RESULT_NOT_NULL)
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin.get_setting("hide_archived_chats", False) and not plugin.get_setting("hide_archived_from_drawer", False):
                param.setResult(True)
        except Exception:
            pass


class ExteraConfigArchivedHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin.get_setting("hide_archived_chats", False) and not plugin.get_setting("hide_archived_from_drawer", False):
                if len(param.args) >= 2 and param.args[0] == "archivedChats":
                    param.thisObject.setObj("archivedChats", True)
                    param.setResult(None)
        except Exception:
            pass


class MessagesControllerSendTypingHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin or not plugin.get_setting("typing_instead_sticker", False):
                return

            if len(param.args) < 3:
                return

            action = param.args[2]
            if action == 10:
                from java.lang import Integer
                param.args[2] = Integer(0)
        except Exception:
            pass


class UpdateBotButtonHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def replace_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin.get_setting("hide_bot_button", False):
                self_instance = param.thisObject
                bot_button = getattr(self_instance, 'botButton', None)
                if bot_button:
                    bot_button.setVisibility(8)
                
                bot_commands_menu_button = getattr(self_instance, 'botCommandsMenuButton', None)
                if bot_commands_menu_button:
                    bot_commands_menu_button.setVisibility(8)
            
            return None
        except Exception as e:
            return None








class VoiceMessageControlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentIsTrue(2))
    def before_hooked_method(self, param):
        try:
            by_voice_end = param.args[2]
            if not by_voice_end:
                return
            
            media_controller = param.thisObject
            if media_controller is None:
                return
            
            try:
                playlist_field = media_controller.getClass().getDeclaredField("voiceMessagesPlaylist")
                playlist_field.setAccessible(True)
                voice_playlist = playlist_field.get(media_controller)
                
                playing_field = media_controller.getClass().getDeclaredField("playingMessageObject")
                playing_field.setAccessible(True)
                playing_message = playing_field.get(media_controller)
                
                if (playing_message and 
                    hasattr(playing_message, 'isVoice') and 
                    playing_message.isVoice() and
                    voice_playlist and 
                    voice_playlist.size() > 1):
                    
                    playlist_field.set(media_controller, None)
                    
                    playlist_map_field = media_controller.getClass().getDeclaredField("voiceMessagesPlaylistMap")
                    playlist_map_field.setAccessible(True)
                    playlist_map_field.set(media_controller, None)
                    
            except Exception as e:
                pass
                
        except Exception as e:
            pass


class VideoMessageControlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentIsTrue(2))
    def before_hooked_method(self, param):
        try:
            if not param.args[2] or not param.thisObject:
                return
            try:
                playing_field = param.thisObject.getClass().getDeclaredField("playingMessageObject")
                playing_field.setAccessible(True)
                playing_message = playing_field.get(param.thisObject)
                if (playing_message and hasattr(playing_message, 'isRoundVideo') and playing_message.isRoundVideo()):
                    voice_playlist_field = param.thisObject.getClass().getDeclaredField("voiceMessagesPlaylist")
                    voice_playlist_field.setAccessible(True)
                    voice_playlist = voice_playlist_field.get(param.thisObject)
                    if voice_playlist and voice_playlist.size() > 1:
                        voice_playlist_field.set(param.thisObject, None)
                        voice_playlist_map_field = param.thisObject.getClass().getDeclaredField("voiceMessagesPlaylistMap")
                        voice_playlist_map_field.setAccessible(True)
                        voice_playlist_map_field.set(param.thisObject, None)
            except:
                pass
        except:
            pass




class GifSpoilerHook(MethodHook):
    def __init__(self, plugin: UiTweaksPlugin):
        MethodHook.__init__(self)
        self._plugin_ref = weakref.ref(plugin)
        self.added_items = []
        self._current_viewer_ref = None
        self._strong_viewer = None
        self._strong_document = None
        self._strong_delegate = None

    @property
    def current_viewer(self):
        return self._current_viewer_ref() if self._current_viewer_ref else None
    
    @current_viewer.setter
    def current_viewer(self, value):
        self._current_viewer_ref = weakref.ref(value) if value else None

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            viewer = get_private_field(param.thisObject, "this$0")
            if not viewer:
                return

            if self.current_viewer and self.current_viewer != viewer:
                self.cleanup_menu_items()
                plugin = self._plugin_ref()
                if plugin:
                    plugin.log("GIF Menu: Cleaned up previous menu items due to viewer change")

            self.current_viewer = viewer

            popup_window = get_private_field(viewer, "popupWindow")
            preview_menu = None
            if popup_window:
                preview_menu = popup_window.getContentView()
            else:
                preview_menu = get_private_field(viewer, "popupLayout")
            document = get_private_field(viewer, "currentDocument")

            if preview_menu and document:
                plugin = self._plugin_ref()
                if plugin:
                    plugin.log("GIF Menu: Adding spoiler and caption menu items")
                self.add_spoiler_menu(preview_menu, viewer, document)

        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"GIF Menu Error: {e}")
            pass

    def add_spoiler_menu(self, preview_menu, viewer, document):
        try:
            if not MessageObject.isGifDocument(document):
                plugin = self._plugin_ref()
                if plugin:
                    plugin.log("GIF Menu: Document is not a GIF, skipping menu addition")
                return

            resources_provider = get_private_field(viewer, "resourcesProvider")
            delegate = get_private_field(viewer, "delegate")

            if not delegate or not delegate.needSend(1):
                plugin = self._plugin_ref()
                if plugin:
                    plugin.log("GIF Menu: Delegate cannot send, skipping menu addition")
                return



            self.cleanup_menu_items()

            self._strong_viewer = viewer
            self._strong_document = document
            self._strong_delegate = delegate

            plugin = self._plugin_ref()
            if plugin:
                plugin.log("GIF Menu: Creating spoiler menu item")
            spoiler_item = ActionBarMenuItem.addItem(
                preview_menu,
                R_tg.drawable.msg_spoiler,
                getString("hide_with_spoiler", "Hide with spoiler"),
                False,
                resources_provider)
            def on_spoiler_click(*_, self_ref=weakref.ref(self)):
                try:
                    self_obj = self_ref()
                    if not self_obj:
                        return
                    v = self_obj._strong_viewer
                    d = self_obj._strong_document
                    dl = self_obj._strong_delegate
                    if not v or not d:
                        return
                    self.send_gif_with_spoiler(v, d, dl)
                except Exception as e:
                    pass
            spoiler_item.setOnClickListener(OnClickListener(on_spoiler_click))
            self.added_items.append(spoiler_item)

            self.plugin.log("GIF Menu: Creating caption menu item")
            caption_item = ActionBarMenuItem.addItem(
                preview_menu,
                R_tg.drawable.menu_tag_edit_solar,
                getString("send_with_caption", "Send with Caption"),
                False,
                resources_provider)
            def on_caption_click(*_, self_ref=weakref.ref(self)):
                try:
                    self_obj = self_ref()
                    if not self_obj:
                        return
                    v = self_obj._strong_viewer
                    d = self_obj._strong_document
                    dl = self_obj._strong_delegate
                    if not v or not d:
                        return
                    self.show_caption_dialog(v, d, dl)
                except Exception as e:
                    pass
            caption_item.setOnClickListener(OnClickListener(on_caption_click))
            self.added_items.append(caption_item)

            self.plugin.log(f"GIF Menu: Successfully added {len(self.added_items)} menu items")

        except Exception as e:
            self.plugin.log(f"GIF Menu: Error adding spoiler menu: {e}")
            pass

    def cleanup_menu_items(self):
        try:
            if not self.added_items:
                self._strong_viewer = None
                self._strong_document = None
                self._strong_delegate = None
                return
                
            self.plugin.log(f"GIF Menu: Cleaning up {len(self.added_items)} menu items")
            
            for item in self.added_items:
                try:
                    if item and hasattr(item, 'getParent'):
                        parent = item.getParent()
                        if parent:
                            parent.removeView(item)
                            self.plugin.log("GIF Menu: Removed menu item from parent")
                except Exception as e:
                    self.plugin.log(f"GIF Menu: Error removing menu item: {e}")
            
            self.added_items.clear()
            self._strong_viewer = None
            self._strong_document = None
            self._strong_delegate = None
            self.plugin.log("GIF Menu: Menu items cleanup completed")
            
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error during cleanup: {e}")

    def send_gif_with_spoiler(self, viewer, document, delegate):
        try:
            parent = get_private_field(viewer, "parentObject")
            current_account = get_private_field(viewer, "currentAccount")

            topic_id = 0
            user_reply_to_msg = None
            topic_reply_to_msg = None
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment:
                    if hasattr(current_fragment, 'getTopicId'):
                        topic_id = current_fragment.getTopicId()
                    
                    if hasattr(current_fragment, 'getChatActivityEnterView'):
                        enter_view = current_fragment.getChatActivityEnterView()
                        if enter_view and hasattr(enter_view, 'getReplyingMessageObject'):
                            user_reply_to_msg = enter_view.getReplyingMessageObject()
            except:
                pass

            send_messages_helper = SendMessagesHelper.getInstance(current_account)

            from org.telegram.messenger import AccountInstance
            account_instance = AccountInstance.getInstance(current_account)
            
            if topic_id != 0:
                try:
                    from org.telegram.tgnet import TLRPC
                    topic = account_instance.getMessagesController().getTopicsController().findTopic(-delegate.getDialogId(), topic_id)
                    if topic and topic.topicStartMessage:
                        topic_reply_to_msg = MessageObject(current_account, topic.topicStartMessage, False, False)
                        topic_reply_to_msg.isTopicMainMessage = True
                except:
                    pass

            send_message_params = self.plugin._create_send_message_params_document(
                document, delegate.getDialogId(), user_reply_to_msg, topic_reply_to_msg if topic_reply_to_msg else user_reply_to_msg, None, parent, True
            )

            send_messages_helper.sendMessage(send_message_params)

            from org.telegram.messenger import MediaDataController
            from java.lang import System
            MediaDataController.getInstance(current_account).addRecentGif(document, int(System.currentTimeMillis() / 1000), True)
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'hideFieldPanel'):
                    current_fragment.hideFieldPanel(False)
            except:
                pass

        except Exception:
            pass
        finally:
            self.dismiss_popup(viewer)

    def show_caption_dialog(self, viewer, document, delegate):
        try:
            from org.telegram.ui.Components import EditTextBoldCursor
            from android.text import InputType
            from android.util import TypedValue
            
            activity = get_last_fragment().getParentActivity()
            if not activity:
                return

            input_field = EditTextBoldCursor(activity)
            input_field.setHint(getString("enter_caption", "Message"))
            input_field.setInputType(InputType.TYPE_CLASS_TEXT)
            input_field.setMaxLines(1)
            input_field.setSingleLine(True)
            input_field.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            input_field.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            input_field.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            input_field.setBackground(Theme.createEditTextDrawable(activity, True))
            input_field.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            input_field.setCursorSize(AndroidUtilities.dp(20))
            input_field.setCursorWidth(1.5)
            input_field.setPadding(0, 0, 0, 0)
            input_field.setFocusable(True)
            
            def on_send_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(input_field)
                    caption = input_field.getText().toString()
                    self.send_gif_with_caption(viewer, document, delegate, caption)
                except Exception:
                    pass
                dialog.dismiss()
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(input_field)
                except Exception:
                    pass
                dialog.dismiss()
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(getString("add_caption_to_gif", "Caption"))
            builder.set_view(input_field)
            builder.set_negative_button(getString("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(getString("send", "Send"), on_send_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = input_field.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        input_field.setLayoutParams(layout_params)
                    
                    input_field.requestFocus()
                    text_length = input_field.getText().length() if input_field.getText() else 0
                    input_field.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(input_field)
                except Exception:
                    pass
            
            run_on_ui_thread(apply_layout_params, delay=100)
        except:
            pass

    def send_gif_with_caption(self, viewer, document, delegate, caption):
        try:
            current_account = get_private_field(viewer, "currentAccount")
            
            topic_id = 0
            user_reply_to_msg = None
            topic_reply_to_msg = None
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment:
                    if hasattr(current_fragment, 'getTopicId'):
                        topic_id = current_fragment.getTopicId()
                    
                    if hasattr(current_fragment, 'getChatActivityEnterView'):
                        enter_view = current_fragment.getChatActivityEnterView()
                        if enter_view and hasattr(enter_view, 'getReplyingMessageObject'):
                            user_reply_to_msg = enter_view.getReplyingMessageObject()
            except:
                pass

            if topic_id != 0:
                try:
                    from org.telegram.messenger import AccountInstance
                    from org.telegram.tgnet import TLRPC
                    account_instance = AccountInstance.getInstance(current_account)
                    topic = account_instance.getMessagesController().getTopicsController().findTopic(-delegate.getDialogId(), topic_id)
                    if topic and topic.topicStartMessage:
                        topic_reply_to_msg = MessageObject(current_account, topic.topicStartMessage, False, False)
                        topic_reply_to_msg.isTopicMainMessage = True
                except:
                    pass
            
            plugin = self._plugin_ref()
            SendMessagesHelper.getInstance(current_account).sendMessage(
                plugin._create_send_message_params_document(
                    document, delegate.getDialogId(), user_reply_to_msg, topic_reply_to_msg if topic_reply_to_msg else user_reply_to_msg, caption, get_private_field(viewer, "parentObject"), False
                ) if plugin else None
            )
            from org.telegram.messenger import MediaDataController
            from java.lang import System
            MediaDataController.getInstance(current_account).addRecentGif(document, int(System.currentTimeMillis() / 1000), True)
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'hideFieldPanel'):
                    current_fragment.hideFieldPanel(False)
            except:
                pass
            
            self.dismiss_popup(viewer)
        except:
            pass

    def dismiss_popup(self, viewer):
        try:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log("GIF Menu: Dismissing popup and cleaning up menu items")
            self.cleanup_menu_items()
            
            method = viewer.getClass().getDeclaredMethod("dismissPopupWindow")
            method.setAccessible(True)
            method.invoke(viewer)
            if plugin:
                plugin.log("GIF Menu: Popup dismissed successfully")
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"GIF Menu: Error dismissing popup: {e}")
            pass


class GifDismissHook(MethodHook):
    def __init__(self, plugin: UiTweaksPlugin):
        MethodHook.__init__(self)
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            if hasattr(plugin, 'hook_gif_spoiler_ref') and plugin.hook_gif_spoiler_ref:
                hook_instance = plugin.hook_gif_spoiler_ref
                if hasattr(hook_instance, 'cleanup_menu_items'):
                    plugin.log("GIF Menu: Auto-cleanup triggered by dismiss hook")
                    hook_instance.cleanup_menu_items()
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"GIF Menu: Error in dismiss hook cleanup: {e}")


class ProcessExternalUrlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(1))
    def before_hooked_method(self, param):
        try:
            url = param.args[1]
            if url and self.is_external(url):
                param.args[4] = True
        except Exception:
            pass

    def is_external(self, url):
        try:
            from android.net import Uri
            uri = Uri.parse(url)
            host = uri.getHost()
            if not host:
                return False
            host = host.lower()
            return not any(host == domain or host.endswith("." + domain) 
                          for domain in ["t.me", "telegram.me", "telegram.dog", "telegram.org", "telegram.com"])
        except Exception:
            return True


class CreateViewHook(MethodHook):
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            
            action_bar = chat_activity.actionBar
            if action_bar is None:
                return
            
            back_button = action_bar.backButtonImageView
            if back_button is None:
                return
            
            self.plugin._current_chat_activity_ref = weakref.ref(chat_activity)
            self.plugin._current_back_button_ref = weakref.ref(back_button)
            
            back_button_id = id(back_button)
            if back_button_id not in self.plugin.counter_views:
                self._create_badge(chat_activity, back_button)
            
            self._update_badge(chat_activity)
            
        except Exception:
            pass
    
    def _create_badge(self, chat_activity, back_button):
        try:
            CounterViewClass = find_class("org.telegram.ui.Components.CounterView")
            LayoutHelperClass = find_class("org.telegram.ui.Components.LayoutHelper")
            GravityClass = find_class("android.view.Gravity")
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            
            if not CounterViewClass:
                return
            
            context = back_button.getContext()
            counter_view = CounterViewClass(context, None)
            counter_view.setGravity(GravityClass.LEFT)
            counter_view.setReverse(True)
            
            layout_params = LayoutHelperClass.createFrame(
                -2,
                -2,
                GravityClass.LEFT | GravityClass.TOP,
                0, 0, 0, 0
            )
            
            action_bar = back_button.getParent()
            action_bar.addView(counter_view, layout_params)
            
            self.plugin.counter_views[id(back_button)] = counter_view
            
            from android_utils import run_on_ui_thread
            def force_layout():
                try:
                    ViewClass = find_class("android.view.View")
                    counter_view.setVisibility(ViewClass.VISIBLE)
                    
                    status_bar_height = AndroidUtilities.statusBarHeight if action_bar.getOccupyStatusBar() else 0
                    
                    badge_x = AndroidUtilities.dp(30)
                    badge_y = status_bar_height - AndroidUtilities.dp(30)
                    
                    counter_view.setX(badge_x)
                    counter_view.setY(badge_y)
                    counter_view.setElevation(AndroidUtilities.dp(2))
                    
                    counter_view.bringToFront()
                    counter_view.requestLayout()
                    action_bar.requestLayout()
                    action_bar.invalidate()
                    
                    self._update_badge(chat_activity)
                except Exception:
                    pass
            
            run_on_ui_thread(force_layout)
            
            def register_observer():
                try:
                    NotificationCenter = jclass("org.telegram.messenger.NotificationCenter")
                    notification_center = chat_activity.getNotificationCenter()
                    
                    from java import dynamic_proxy
                    NotificationCenterDelegate = plugin._get_class("org.telegram.messenger.NotificationCenter$NotificationCenterDelegate")
                    
                    ObserverProxy = dynamic_proxy(NotificationCenterDelegate)
                    
                    class UnreadObserver(ObserverProxy):
                        def __init__(self, plugin_ref, chat_ref, back_btn_id):
                            self.plugin = plugin_ref
                            ObserverProxy.__init__(self)
                            self._chat_activity_ref = weakref.ref(chat_ref)
                            self.back_button_id = back_btn_id
                        
                        @property
                        def chat_activity(self):
                            return self._chat_activity_ref() if self._chat_activity_ref else None
                        
                        def didReceivedNotification(self, notification_id, account, *args):
                            try:
                                if notification_id == NotificationCenter.dialogsUnreadCounterChanged:
                                    if self.back_button_id not in self.plugin.counter_views:
                                        return
                                    
                                    counter = self.plugin.counter_views[self.back_button_id]
                                    if not self.chat_activity:
                                        return
                                    storage = self.chat_activity.getMessagesStorage()
                                    
                                    if storage:
                                        count = storage.getMainUnreadCount()
                                        
                                        from android_utils import run_on_ui_thread
                                        def update():
                                            try:
                                                ViewClass = self.plugin._get_class("android.view.View")
                                                try:
                                                    in_preview = self.chat_activity.inPreviewMode
                                                except:
                                                    in_preview = False
                                                
                                                if count > 0 and not in_preview:
                                                    counter.setVisibility(ViewClass.VISIBLE)
                                                    counter.setCount(count, True)
                                                else:
                                                    counter.setVisibility(ViewClass.GONE)
                                            except Exception:
                                                pass
                                        
                                        run_on_ui_thread(update)
                            except Exception:
                                pass
                    
                    observer = UnreadObserver(plugin, chat_activity, id(back_button))
                    notification_center.addObserver(observer, NotificationCenter.dialogsUnreadCounterChanged)
                    
                    plugin.counter_views[id(back_button) + 1000000] = observer
                    
                except Exception:
                    pass
            
            run_on_ui_thread(register_observer)
            
        except Exception:
            pass
    
    def _update_badge(self, chat_activity):
        try:
            back_button = chat_activity.actionBar.backButtonImageView
            if back_button is None:
                return
            
            plugin = self._plugin_ref()
            if not plugin:
                return
            back_button_id = id(back_button)
            if back_button_id not in plugin.counter_views:
                return
            
            counter_view = plugin.counter_views[back_button_id]
            
            messages_storage = chat_activity.getMessagesStorage()
            if messages_storage:
                unread_count = messages_storage.getMainUnreadCount()
                
                ViewClass = find_class("android.view.View")
                try:
                    in_preview = chat_activity.inPreviewMode
                except:
                    in_preview = False
                
                if unread_count > 0 and not in_preview:
                    counter_view.setVisibility(ViewClass.VISIBLE)
                    counter_view.setCount(unread_count, True)
                else:
                    counter_view.setVisibility(ViewClass.GONE)
            
        except Exception:
            pass


class FragmentDestroyHook(MethodHook):
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            
            action_bar = chat_activity.actionBar
            if action_bar is None:
                return
            
            back_button = action_bar.backButtonImageView
            if back_button is None:
                return
            
            back_button_id = id(back_button)
            observer_id = back_button_id + 1000000
            
            plugin = self._plugin_ref()
            if not plugin:
                return
            if observer_id in plugin.counter_views:
                observer = plugin.counter_views[observer_id]
                notification_center = chat_activity.getNotificationCenter()
                
                NotificationCenter = jclass("org.telegram.messenger.NotificationCenter")
                notification_center.removeObserver(observer, NotificationCenter.dialogsUnreadCounterChanged)
                
                del plugin.counter_views[observer_id]
            
            if back_button_id in plugin.counter_views:
                del plugin.counter_views[back_button_id]
            
        except Exception:
            pass


class ForwardConfirmationHook:
    def __init__(self, plugin: UiTweaksPlugin, reflected_method):
        self._plugin_ref = weakref.ref(plugin)
        self.reflected_method = reflected_method
        self._suppress_next = False

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            if self._suppress_next:
                self._suppress_next = False
                return
            if not plugin.get_setting("enable_confirmation_settings", False) or not plugin.get_setting("confirm_forward", True):
                return
            args = list(param.args) if param.args else []
            def on_confirm():
                try:
                    self._suppress_next = True
                    self.reflected_method.setAccessible(True)
                    coerced = list(args)
                    if len(coerced) >= 6:
                        try:
                            coerced[4] = jclass("java.lang.Integer")(int(coerced[4]))
                        except Exception:
                            pass
                        try:
                            coerced[5] = jclass("java.lang.Long")(int(coerced[5]))
                        except Exception:
                            pass
                    self.reflected_method.invoke(chat_activity, *coerced)
                except Exception:
                    pass
  
            ctx = None
            try:
                fragment = get_last_fragment()
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            except Exception:
                ctx = None
            if ctx:
                def _show():
                    try:
                        builder = AlertDialogBuilder(ctx)
                        builder.set_title(getString("confirm_forward", "Confirm Forwarding Messages"))
                        builder.set_message(getString("confirm_forward_message", "Are you sure you want to forward this message?"))
                        builder.set_positive_button(getString("ok", "OK"), lambda dialog, which: on_confirm())
                        builder.set_negative_button(getString("cancel", "Cancel"), None)
                        builder.show()
                        builder.set_canceled_on_touch_outside(False)
                    except Exception:
                        pass
                run_on_ui_thread(_show)
                param.setResult(None)
            else:
                pass
        except Exception:
            pass


class JoinConfirmationClickListener(dynamic_proxy(find_class("android.view.View$OnClickListener"))):
    def __init__(self, original_listener):
        super().__init__()
        self.original_listener = original_listener

    def onClick(self, view):
        plugin_instance = uitweaks_plugin_instance() if uitweaks_plugin_instance else None
        if (not plugin_instance or 
            not plugin_instance.get_setting("enable_confirmation_settings", False) or 
            not plugin_instance.get_setting("confirm_join_chat", False) or 
            not self._is_join_action()):
            self.original_listener.onClick(view)
            return
            
        def show_confirmation():
            try:
                builder = AlertDialogBuilder(view.getContext())
                
                chat_name = self._get_chat_name()
                
                builder.set_title(getString("join_confirmation", "Join Confirmation"))
                message = getString("join_confirmation_message", "Are you sure you want to join **{chat_name}**?").format(chat_name=chat_name)
                builder.set_message(AndroidUtilities.replaceTags(message))
                
                def on_confirm(dialog, which):
                    dialog.dismiss()
                    self.original_listener.onClick(view)
                
                def on_cancel(dialog, which):
                    dialog.dismiss()
                
                builder.set_positive_button(getString("join", "Join"), on_confirm)
                builder.set_negative_button(getString("cancel", "Cancel"), on_cancel)
                builder.show()
                builder.set_canceled_on_touch_outside(False)
                
            except Exception as e:
                self.original_listener.onClick(view)

        run_on_ui_thread(show_confirmation)

    def _is_join_action(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return False
            
            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                try:
                    chat_activity_class = find_class("org.telegram.ui.ChatActivity")
                    overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
                    overlay_field.setAccessible(True)
                    overlay_text_view = overlay_field.get(fragment)
                    
                    if overlay_text_view and hasattr(overlay_text_view, 'getText'):
                        try:
                            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                                chat_object_class = find_class("org.telegram.messenger.ChatObject")
                                if chat_object_class:
                                    is_not_in_chat_method = chat_object_class.getClass().getDeclaredMethod("isNotInChat", find_class("org.telegram.tgnet.TLRPC$Chat"))
                                    is_not_in_chat = is_not_in_chat_method.invoke(None, fragment.currentChat)
                                    return is_not_in_chat
                        except Exception as e:
                            pass
                except Exception as e:
                    pass
                
                return False
            
            return False
        except Exception as e:
            return False

    def _get_chat_name(self):
        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, 'currentChat') and fragment.currentChat and hasattr(fragment.currentChat, 'title'):
                return fragment.currentChat.title
            return "this chat"
        except:
            return "this chat"


class FillActionModeMenuHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            menu = param.args[0]
            
            if menu.findItem(CUSTOM_CODE_ID) is not None:
                return
            
            string_builder = SpannableStringBuilder(getString("code_menu_item", "Code"))
            string_builder.setSpan(TypefaceSpan(Typeface.MONOSPACE), 0, string_builder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            menu.add(R_tg.id.menu_groupbolditalic, CUSTOM_CODE_ID, 7, string_builder)
            
            mention_string_builder = SpannableStringBuilder(getString("mention_menu_item", "Mention"))
            menu.add(R_tg.id.menu_groupbolditalic, CUSTOM_MENTION_ID, 8, mention_string_builder)
            
        except Exception as e:
            traceback.print_exc()

class PerformMenuActionHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            item_id = param.args[0]
            edit_text = param.thisObject
            
            if item_id == CUSTOM_CODE_ID:
                import time
                current_time = time.time()
                plugin = self._plugin_ref()
                if not plugin:
                    return
                if not hasattr(plugin, '_last_code_click'):
                    plugin._last_code_click = 0
                
                if current_time - plugin._last_code_click > DEBOUNCE_TIME:
                    plugin._last_code_click = current_time
                    plugin._make_selected_code(edit_text)
                return
                
            elif item_id == CUSTOM_MENTION_ID:
                import time
                current_time = time.time()
                plugin = self._plugin_ref()
                if not plugin:
                    return
                if not hasattr(plugin, '_last_mention_click'):
                    plugin._last_mention_click = 0
                
                if current_time - plugin._last_mention_click > DEBOUNCE_TIME:
                    plugin._last_mention_click = current_time
                    plugin._make_selected_mention(edit_text)
                return
                
        except Exception as e:
            traceback.print_exc()


class JoinConfirmationHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param: Any):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            chat_activity = param.thisObject
            if not chat_activity:
                return

            chat_activity_class = plugin._get_class("org.telegram.ui.ChatActivity")
            overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
            overlay_field.setAccessible(True)
            overlay_text_view = overlay_field.get(chat_activity)
            
            if not overlay_text_view:
                return

            view_class = plugin._get_class("android.view.View")
            listener_info_method = view_class.getClass().getDeclaredMethod("getListenerInfo")
            listener_info_method.setAccessible(True)
            listener_info = listener_info_method.invoke(overlay_text_view)
            
            if not listener_info:
                return

            click_listener_field = listener_info.getClass().getDeclaredField("mOnClickListener")
            click_listener_field.setAccessible(True)
            original_listener = click_listener_field.get(listener_info)
            
            if original_listener and not isinstance(original_listener, JoinConfirmationClickListener):
                custom_listener = JoinConfirmationClickListener(original_listener)
                overlay_text_view.setOnClickListener(custom_listener)
                
        except Exception as e:
            pass



uitweaks_plugin_instance = None

def uitweaks_log(message: str):
    if uitweaks_plugin_instance and uitweaks_plugin_instance.get_setting("show_logs", False):
        log(f"[UiTweaks] {message}")


class MessagePreviewViewHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            preview_view = param.thisObject
            if preview_view and preview_view not in plugin.added_send_media_buttons:
                run_on_ui_thread(lambda: plugin._add_send_media_button(preview_view), 100)
        except:
            pass


class DisableAutoWebLoginHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        uitweaks_log("DisableAutoWebLoginHook initialized")

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            from org.telegram.messenger import AccountInstance, UserConfig
            currentAccount = UserConfig.selectedAccount
            messagesController = AccountInstance.getInstance(currentAccount).getMessagesController()
            if hasattr(messagesController, 'autologinDomains'):
                uitweaks_log("Clearing autologinDomains to prevent token injection")
                messagesController.autologinDomains.clear()
        except Exception as e:
            uitweaks_log("Error clearing autologinDomains: " + str(e))




class PreferCommonGroupsTabHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            userInfo = param.args[0]
            sharedMediaLayout = param.thisObject
            
            if userInfo and hasattr(userInfo, 'common_chats_count') and userInfo.common_chats_count > 0:
                try:
                    scrollSlidingTextTabStrip = getattr(sharedMediaLayout, 'scrollSlidingTextTabStrip', None)
                    if scrollSlidingTextTabStrip:
                        currentTabId = scrollSlidingTextTabStrip.getCurrentTabId()
                        if currentTabId == 14:
                            sharedMediaLayout.scrollToPage(6)
                except Exception as e:
                    pass
        except Exception as e:
            pass




class ChatActionBarItemsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            chat_activity = param.thisObject
            activity_id = id(chat_activity)
            
            if activity_id not in plugin.chat_action_bar_hooked_activities:
                plugin.chat_action_bar_hooked_activities.add(activity_id)
                
                if plugin.get_setting("enable_goto_message", False):
                    self.add_goto_message_menu_item(chat_activity)
                
                if plugin.get_setting("enable_ai_summarize", False):
                    self.add_summarize_menu_item(chat_activity)
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error in Chat Action Bar Items Hook: {e}")
    
    def add_summarize_menu_item(self, chat_activity):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            AiController = plugin._get_class("com.exteragram.messenger.ai.AiController")
            if not AiController:
                return

            if hasattr(AiController, 'canUseAI') and not AiController.canUseAI():
                return
            
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = plugin._get_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                ai_icon = R.drawable.ai_chat
                summarize_text = getString("summarize_menu_item", "Summarize")
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    def find_position(target):
                        if target is not None:
                            for i in range(lazy_list.size()):
                                if lazy_list.get(i) == target:
                                    return i
                        return None

                    plugins_item = get_private_field(chat_activity, "pluginsMenuItem")
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = find_position(plugins_item) or find_position(admin_gap) or lazy_list.size()
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(plugin.ai_summarize_menu_id),
                        Integer(ai_icon),
                        None,
                        summarize_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(plugin.ai_summarize_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        plugin.ai_summarize_menu_id,
                        ai_icon,
                        summarize_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                plugin = self._plugin_ref()
                if plugin:
                    plugin.log(f"Error adding AI Summarize menu item: {e}")
                
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error in add_summarize_menu_item: {e}")
    
    def add_goto_message_menu_item(self, chat_activity):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = plugin._get_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                goto_icon = R.drawable.msg_to_beginning_solar
                goto_text = getString("goto_message", "Go to Message")
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    def find_position(target):
                        if target is not None:
                            for i in range(lazy_list.size()):
                                if lazy_list.get(i) == target:
                                    return i
                        return None

                    plugins_item = get_private_field(chat_activity, "pluginsMenuItem")
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = find_position(plugins_item) or find_position(admin_gap) or lazy_list.size()
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(plugin.goto_message_menu_id),
                        Integer(goto_icon),
                        None,
                        goto_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(plugin.goto_message_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        plugin.goto_message_menu_id,
                        goto_icon,
                        goto_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                plugin = self._plugin_ref()
                if plugin:
                    plugin.log(f"Error adding Goto Message menu item: {e}")
                
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error in add_goto_message_menu_item: {e}")
    
    def hook_action_bar_callback(self, chat_activity):
        try:
            action_bar = get_private_field(chat_activity, "actionBar")
            if action_bar is None:
                return
            
            current_callback = get_private_field(action_bar, "actionBarMenuOnItemClick")
            if current_callback is None:
                return
            
            callback_class = current_callback.getClass()
            jint = jclass("java.lang.Integer").TYPE
            
            onItemClickMethod = callback_class.getDeclaredMethod("onItemClick", jint)
            onItemClickMethod.setAccessible(True)
            
            plugin = self._plugin_ref()
            if not plugin:
                return
            hook_handler = ChatActionBarMenuItemClickHook(plugin, chat_activity)
            
            if plugin.hook_ai_summarize_item_click_ref:
                plugin.unhook_method(plugin.hook_ai_summarize_item_click_ref)
            
            plugin.hook_ai_summarize_item_click_ref = plugin.hook_method(
                onItemClickMethod,
                hook_handler
            )
            
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error hooking AI Summarize action bar callback: {e}")


class ChatActionBarMenuItemClickHook:
    def __init__(self, plugin, chat_activity):
        self._plugin_ref = weakref.ref(plugin)
        self.chat_activity = chat_activity


    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None
    
    def get_unread_count(self, chat_activity):
        try:
            mc = get_messages_controller()
            dialog = mc.getDialog(chat_activity.getDialogId()) if mc else None
            if dialog:
                unread_count = getattr(dialog, 'unread_count', 0) or 0
                return unread_count if unread_count > 0 else 200
        except Exception:
            pass
        return 200
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            item_id = int(param.args[0])
            
            if item_id == plugin.ai_summarize_menu_id:
                self.open_summarize_view(self.chat_activity)
                param.setResult(None)
            elif item_id == plugin.goto_message_menu_id:
                plugin.show_goto_message_dialog(self.chat_activity)
                param.setResult(None)
                
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error in Chat Action Bar Menu Item Click Hook: {e}")
    
    def open_summarize_view(self, chat_activity):
        plugin = self._plugin_ref()
        if not plugin:
            return
        GenerateFromMessageBottomSheet = plugin._get_class("com.exteragram.messenger.ai.ui.GenerateFromMessageBottomSheet")
        if not GenerateFromMessageBottomSheet:
            return
        
        LocaleController = plugin._get_class("org.telegram.messenger.LocaleController")
        R = plugin._get_class("org.telegram.messenger.R")
        
        if LocaleController and R:
            getStringMethod = LocaleController.getClass().getDeclaredMethod("getString", jclass("java.lang.Integer").TYPE)
            
            class LocaleHook:
                def __init__(self):
                    self.role_prompt_id = R.string.RolePrompt
                    self.proceed_id = R.string.Proceed
                    self.generate_id = R.string.Generate
                
                def after_hooked_method(self, param):
                    string_id = param.args[0]
                    if string_id == self.role_prompt_id:
                        param.setResult(getString("message_count_label", "Message Count"))
                    elif string_id == self.proceed_id:
                        param.setResult(getString("summarize_button", "Summarize"))
                    elif string_id == self.generate_id:
                        param.setResult(getString("summarize_title", "Summarize"))
            
            unhook_locale = plugin.hook_method(getStringMethod, LocaleHook())
        
        Callback = jclass("org.telegram.messenger.Utilities$Callback")
        
        class DataCallback(dynamic_proxy(Callback)):
            def __init__(self, plugin_ref, activity_ref):
                self.plugin = plugin_ref
                super().__init__()
                self._activity_ref = weakref.ref(activity_ref)
            
            @property
            def activity(self):
                return self._activity_ref() if self._activity_ref else None
            
            def run(self, data):
                if not self.activity:
                    return
                default_count = ChatActionBarMenuItemClickHook(self.plugin, self.activity).get_unread_count(self.activity)
                count = int(str(data.prompt() or str(default_count)).strip())
                count = max(1, count)
                self.fetch_and_summarize(self.activity, count)
            
            def fetch_and_summarize(self, chat_activity, count):
                loading = AlertDialogBuilder(chat_activity.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                loading.show()
                loading.set_cancelable(False)
                
                
                def process():
                    try:
                        messages = ChatActionBarMenuItemClickHook.get_messages(chat_activity, count, self.plugin)
                        run_on_ui_thread(loading.dismiss)
                        
                        if messages:
                            chat_activity_ref_inner = weakref.ref(chat_activity)
                            def do_show_alert(*args, ca_ref=chat_activity_ref_inner, msgs=messages):
                                ca = ca_ref()
                                if ca:
                                    ChatActionBarMenuItemClickHook(self.plugin, ca).show_alert(ca, msgs)
                            run_on_ui_thread(do_show_alert)
                        else:
                            chat_activity_ref_inner = weakref.ref(chat_activity)
                            def do_show_bulletin(*args, ca_ref=chat_activity_ref_inner):
                                ca = ca_ref()
                                if ca:
                                    BulletinHelper.of(ca).createErrorBulletin("No messages to summarize").show()
                            run_on_ui_thread(do_show_bulletin)
                    except Exception as e:
                        self.plugin.log(f"Error fetching messages for summarization: {e}")
                        run_on_ui_thread(loading.dismiss)
                
                run_on_queue(process)
        
        callback = DataCallback(self.plugin, chat_activity)
        
        unread_count = self.get_unread_count(chat_activity)
        
        sheet = GenerateFromMessageBottomSheet(
            str(unread_count),
            None,
            chat_activity,
            chat_activity.getContext(),
            callback,
            False
        )
        sheet.show()
        
        if 'unhook_locale' in locals():
            self.plugin.unhook_method(unhook_locale)
    
    def show_alert(self, chat_activity, messages):
        try:
            AiConfig = self.plugin._get_class("com.exteragram.messenger.ai.AiConfig")
            if AiConfig:
                AiConfig.showResponseOnly = True
            
            context = self.build_message_context(messages)
            full_prompt = context
            
            AiController = self.plugin._get_class("com.exteragram.messenger.ai.AiController")
            controller = AiController.getInstance()
            
            summarizer_role = None
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == "Quanta!":
                        summarizer_role = role
                        break
            
            client_builder = self.plugin._get_class("com.exteragram.messenger.ai.network.Client").Builder()
            if summarizer_role:
                client_builder.roleOverride(summarizer_role)
            client = client_builder.build()
            
            if not client:
                return
            
            current_chat = get_private_field(chat_activity, "currentChat")
            no_forwards = self.plugin._get_class("org.telegram.messenger.MessagesController").getInstance(0).isChatNoForwards(current_chat) if current_chat else False
            
            setText = jclass("android.widget.TextView").getClass().getDeclaredMethod("setText", jclass("java.lang.CharSequence"))
            
            class TextViewHook:
                def __init__(self, full_text, display_text):
                    self.full_text = full_text
                    self.display_text = display_text
                    self.hooked = False
                
                def before_hooked_method(self, param):
                    if not self.hooked:
                        text = str(param.args[0]) if param.args[0] else ""
                        if self.full_text in text:
                            param.args[0] = self.display_text
                            self.hooked = True
            
            unhook = self.plugin.hook_method(setText, TextViewHook(full_prompt, getString("ai_summarizing", "Summarizing...")))
            
            Callback2 = jclass("org.telegram.messenger.Utilities$Callback2")
            class InsertCallback(dynamic_proxy(Callback2)):
                def run(self, prompt, response):
                    chatActivityEnterView = get_private_field(chat_activity, "chatActivityEnterView")
                    if chatActivityEnterView:
                        AiConfig = find_class("com.exteragram.messenger.ai.AiConfig")
                        if AiConfig and AiConfig.insertAsQuote:
                            editField = chatActivityEnterView.getEditField()
                            editField.setText(str(response) + "\n")
                            QuoteSpan = find_class("org.telegram.ui.Components.QuoteSpan")
                            if QuoteSpan:
                                QuoteSpan.putQuoteToEditable(chatActivityEnterView.getEditText(), 0, len(str(response)), True)
                        else:
                            chatActivityEnterView.getEditField().setText(str(response))
                        chatActivityEnterView.getEditField().setSelection(chatActivityEnterView.getEditText().length())
                        chatActivityEnterView.openKeyboard()
            
            find_class("com.exteragram.messenger.ai.ui.ResponseAlert").showAlert(
                chat_activity,
                client,
                full_prompt,
                True,
                no_forwards,
                None,
                None,
                InsertCallback()
            )
            
            if unhook:
                self.plugin.unhook_method(unhook)
            
        except Exception as e:
            self.plugin.log(f"Error opening AI Summarize view: {e}")
            import traceback
            self.plugin.log(f"Traceback: {traceback.format_exc()}")
    
    @staticmethod
    def get_messages(chat_activity, count, plugin):
        try:
            from client_utils import get_messages_controller, send_request, RequestCallback
            from org.telegram.tgnet import TLRPC
            import time
            
            dialog_id = get_private_field(chat_activity, "dialog_id")
            if dialog_id is None:
                return []
            
            result_container = {'messages': [], 'done': False, 'offset_id': 0}
            
            def fetch_batch():
                remaining = count - len(result_container['messages'])
                if remaining <= 0:
                    result_container['done'] = True
                    return
                
                batch_size = min(100, remaining)
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = get_messages_controller().getInputPeer(dialog_id)
                req.offset_id = result_container['offset_id']
                req.limit = batch_size
                req.add_offset = 0
                req.max_id = 0
                req.min_id = 0
                req.hash = 0
                
                def handle_response(response, error):
                    if error or not response or not hasattr(response, 'messages'):
                        result_container['done'] = True
                        return
                    
                    messages_count = response.messages.size()
                    if messages_count == 0:
                        result_container['done'] = True
                        return
                    
                    last_id = result_container['offset_id']
                    for i in range(messages_count):
                        msg = response.messages.get(i)
                        if msg and hasattr(msg, 'message') and msg.message:
                            result_container['messages'].append(msg)
                            if hasattr(msg, 'id'):
                                last_id = msg.id
                    
                    result_container['offset_id'] = last_id
                    
                    if len(result_container['messages']) >= count or messages_count < batch_size:
                        result_container['done'] = True
                    else:
                        fetch_batch()
                
                callback = RequestCallback(handle_response)
                send_request(req, callback)
            
            fetch_batch()
            
            timeout = 30
            start_time = time.time()
            while not result_container['done'] and (time.time() - start_time) < timeout:
                time.sleep(0.1)
            
            messages = result_container['messages'][:count]
            messages.reverse()
            return messages
            
        except Exception as e:
            plugin.log(f"Error getting messages for summarization: {e}")
            return []
    
    def build_message_context(self, messages):
        try:
            from client_utils import get_messages_controller
            mc = get_messages_controller()
            parts = []
            
            for msg in messages:
                if not (hasattr(msg, 'message') and msg.message):
                    continue
                
                text = str(msg.message).strip()
                if not text:
                    continue
                
                sender = "User"
                
                if hasattr(msg, 'post_author') and msg.post_author:
                    if hasattr(msg, 'peer_id') and msg.peer_id and hasattr(msg.peer_id, 'channel_id'):
                        if hasattr(msg, 'from_id') and msg.from_id and hasattr(msg.from_id, 'channel_id'):
                            if msg.peer_id.channel_id == msg.from_id.channel_id:
                                sender = str(msg.post_author).strip()
                                chat = mc.getChat(msg.peer_id.channel_id)
                                if chat and hasattr(chat, 'title'):
                                    sender = f"{chat.title} ({sender})"
                        else:
                            sender = str(msg.post_author).strip()
                elif hasattr(msg, 'from_id') and msg.from_id:
                    fid = msg.from_id
                    if hasattr(fid, 'user_id'):
                        user = mc.getUser(fid.user_id)
                        if user:
                            name = f"{user.first_name or ''} {user.last_name or ''}".strip()
                            sender = name or "User"
                    elif hasattr(fid, 'channel_id'):
                        chat = mc.getChat(fid.channel_id)
                        if chat and hasattr(chat, 'title'):
                            sender = str(chat.title)
                
                parts.append(f"{sender}: {text}")
            
            return "\n".join(parts)
        except Exception as e:
            self.plugin.log(f"Error building AI Summarize context: {e}")
            return ""


RIGHT_DURATION = 20

def show_duration_selector_sheet(context, on_duration_selected, plugin=None):
    if plugin:
        BottomSheet = plugin._get_class("org.telegram.ui.ActionBar.BottomSheet")
        LinearLayout = plugin._get_class("android.widget.LinearLayout")
        HeaderCell = plugin._get_class("org.telegram.ui.Cells.HeaderCell")
        Theme = plugin._get_class("org.telegram.ui.ActionBar.Theme")
        LayoutHelper = plugin._get_class("org.telegram.ui.Components.LayoutHelper")
        LocaleController = plugin._get_class("org.telegram.messenger.LocaleController")
        R_string = plugin._get_class("org.telegram.messenger.R$string")
        ConnectionsManager = plugin._get_class("org.telegram.tgnet.ConnectionsManager")
        AlertsCreator = plugin._get_class("org.telegram.ui.Components.AlertsCreator")
        UserConfig = plugin._get_class("org.telegram.messenger.UserConfig")
        AndroidUtilities = plugin._get_class("org.telegram.messenger.AndroidUtilities")
    else:
        BottomSheet = find_class("org.telegram.ui.ActionBar.BottomSheet")
        LinearLayout = find_class("android.widget.LinearLayout")
        HeaderCell = find_class("org.telegram.ui.Cells.HeaderCell")
        Theme = find_class("org.telegram.ui.ActionBar.Theme")
        LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
        LocaleController = find_class("org.telegram.messenger.LocaleController")
        R_string = find_class("org.telegram.messenger.R$string")
        ConnectionsManager = find_class("org.telegram.tgnet.ConnectionsManager")
        AlertsCreator = find_class("org.telegram.ui.Components.AlertsCreator")
        UserConfig = find_class("org.telegram.messenger.UserConfig")
        AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
    
    builder = BottomSheet.Builder(context)
    builder.setApplyTopPadding(False)
    
    linear_layout = LinearLayout(context)
    linear_layout.setOrientation(LinearLayout.VERTICAL)
    
    header_cell = HeaderCell(context, Theme.key_dialogTextBlue2, 23, 15, False)
    header_cell.setHeight(47)
    header_cell.setText(LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration))
    linear_layout.addView(header_cell)
    
    buttons_container = LinearLayout(context)
    buttons_container.setOrientation(LinearLayout.VERTICAL)
    linear_layout.addView(buttons_container, LayoutHelper.createLinear(-1, -2))
    durations = [
        (LocaleController.getString("UserRestrictionsUntilForever", R_string.UserRestrictionsUntilForever), 0),
        (LocaleController.formatPluralString("Days", 1), 86400),
        (LocaleController.formatPluralString("Weeks", 1), 604800),
        (LocaleController.formatPluralString("Months", 1), 2592000),
        (LocaleController.getString("UserRestrictionsCustom", R_string.UserRestrictionsCustom), -1)
    ]
    
    current_account = UserConfig.selectedAccount
    
    for idx, (label, duration_seconds) in enumerate(durations):
        cell = BottomSheet.BottomSheetCell(context, 0)
        cell.setPadding(AndroidUtilities.dp(7), 0, AndroidUtilities.dp(7), 0)
        cell.setTag(idx)
        cell.setBackgroundDrawable(Theme.getSelectorDrawable(False))
        cell.setTextAndIcon(label, 0)
        buttons_container.addView(cell, LayoutHelper.createLinear(-1, -2))
        
        def create_click_listener(duration, is_custom):
            def on_click(view=None):
                if is_custom:
                    current_time = ConnectionsManager.getInstance(current_account).getCurrentTime()
                    
                    ScheduleDatePickerDelegate = plugin._get_class("org.telegram.ui.Components.AlertsCreator$ScheduleDatePickerDelegate") if plugin else find_class("org.telegram.ui.Components.AlertsCreator$ScheduleDatePickerDelegate")
                    DateDelegateProxy = dynamic_proxy(ScheduleDatePickerDelegate)
                    
                    class DateDelegate(DateDelegateProxy):
                        def __init__(self):
                            super().__init__()
                        
                        def didSelectDate(self, notify, schedule_date):
                            on_duration_selected(schedule_date)
                    
                    date_builder = AlertsCreator.createDatePickerDialog(
                        context,
                        LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration),
                        LocaleController.getString("Set", R_string.Set),
                        current_time,
                        DateDelegate()
                    )
                    if date_builder:
                        date_builder.show()
                else:
                    if duration == 0:
                        on_duration_selected(0)
                    else:
                        current_time = ConnectionsManager.getInstance(current_account).getCurrentTime()
                        on_duration_selected(current_time + duration)
                builder.getDismissRunnable().run()
            return on_click
        
        cell.setOnClickListener(OnClickListener(create_click_listener(duration_seconds, duration_seconds == -1)))
    
    builder.setCustomView(linear_layout)
    sheet = builder.create()
    sheet.show()

class DeleteWithDurationFillItemsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            sheet_instance = param.thisObject
            items = param.args[0]
            banOrRestrict = get_private_field(sheet_instance, 'banOrRestrict')
            restrict = get_private_field(sheet_instance, 'restrict')
            bannedRights = get_private_field(sheet_instance, 'bannedRights')
            
            if banOrRestrict and bannedRights:
                checks = get_private_field(banOrRestrict, 'checks')
                if checks and (checks[0] or restrict):
                    plugin = self._plugin_ref()
                    if not plugin:
                        return
                    UItem = plugin._get_class("org.telegram.ui.Components.UItem")
                    LocaleController = plugin._get_class("org.telegram.messenger.LocaleController")
                    R_string = plugin._get_class("org.telegram.messenger.R$string")
                    
                    if bannedRights.until_date == 0 or abs(bannedRights.until_date - int(time.time())) > 10 * 365 * 24 * 60 * 60:
                        value = LocaleController.getString("UserRestrictionsUntilForever", R_string.UserRestrictionsUntilForever)
                    else:
                        value = LocaleController.formatDateForBan(bannedRights.until_date)
                    
                    duration_item = UItem.asButton(
                        RIGHT_DURATION,
                        LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration),
                        value
                    )
                    items.add(duration_item)
                    
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error adding duration item: {e}")

class DeleteWithDurationOnClickHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            sheet_instance = param.thisObject
            item = param.args[0]
            
            if item.id == RIGHT_DURATION:
                context = sheet_instance.getContext()
                
                bannedRights = get_private_field(sheet_instance, 'bannedRights')
                adapter = get_private_field(sheet_instance, 'adapter')
                
                def on_duration_selected(duration):
                    if bannedRights:
                        bannedRights.until_date = duration
                        if adapter:
                            adapter.update(True)
                
                plugin = self._plugin_ref()
                show_duration_selector_sheet(context, on_duration_selected, plugin)
                param.setResult(None)
                return
                
        except Exception as e:
            plugin = self._plugin_ref()
            if plugin:
                plugin.log(f"Error handling duration click: {e}")


class SleepTimerConstructorHook(MethodHook):
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            alert = param.thisObject
            options_button = get_private_field(alert, "optionsButton")
            if not options_button:
                return
            
            options_button.addSubItem(1390, R_tg.drawable.menu_premium_clock, getString("sleep_timer_menu", "Sleep Timer"))
        except Exception as e:
            pass


class SleepTimerClickHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            item_id = param.args[0]
            if item_id != 1390:
                return
            
            alert = param.thisObject
            self._show_sleep_timer_dialog(alert)
        except Exception as e:
            pass
    
    def _show_sleep_timer_dialog(self, alert):
        try:
            preset_labels = [
                getString("sleep_timer_disable", "Disable"),
                LocaleController.formatPluralString("Minutes", 1),
                LocaleController.formatPluralString("Minutes", 5),
                LocaleController.formatPluralString("Minutes", 10),
                LocaleController.formatPluralString("Minutes", 20),
                LocaleController.formatPluralString("Minutes", 40),
                LocaleController.formatPluralString("Hours", 1),
                LocaleController.getString(R_tg.string.AutoDownloadCustom)
            ]
            
            preset_values = [0, 1, 5, 10, 20, 40, 60]
            hook_instance = self
            
            def on_preset_click(builder, which):
                if which < len(preset_values):
                    minutes = preset_values[which]
                    hook_instance._set_sleep_timer(alert, minutes * 60)
                else:
                    Callback = jclass("org.telegram.messenger.Utilities$Callback")
                    CallbackProxy = dynamic_proxy(Callback)
                    
                    class TimePickerCallback(CallbackProxy):
                        def run(self, picked_minutes):
                            hook_instance._set_sleep_timer(alert, picked_minutes * 60)
                    
                    from org.telegram.ui.Components import AlertsCreator
                    AlertsCreator.createTimePickerDialog(
                        alert.getContext(),
                        getString("sleep_timer_custom", "Sleep Timer"),
                        0,
                        0,
                        12 * 60,
                        TimePickerCallback()
                    )
            
            resources_provider = get_private_field(alert, "resourcesProvider")
            builder = AlertDialogBuilder(alert.getContext(), resources_provider=resources_provider)
            builder.set_title(getString("sleep_timer_title", "Sleep Timer"))
            builder.set_items(preset_labels, on_preset_click)
            builder.set_negative_button(LocaleController.getString(R_tg.string.Cancel))
            builder.show()
        except:
            pass
    
    def _set_sleep_timer(self, alert, seconds):
        try:
            self.plugin.log(f"Setting sleep timer to {seconds} seconds")
            if not hasattr(self.plugin, '_sleep_handler') or self.plugin._sleep_handler is None:
                self.plugin._sleep_handler = Handler(Looper.getMainLooper())
            if hasattr(self.plugin, '_sleep_runnable') and self.plugin._sleep_runnable is not None:
                self.plugin._sleep_handler.removeCallbacks(self.plugin._sleep_runnable)
            
            if seconds > 0:
                def pause_music():
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    if not media_controller.isMessagePaused():
                        media_controller.pauseMessage(media_controller.getPlayingMessageObject())
                    self.plugin.sleep_timer_active = False
                
                from android_utils import R as Runnable
                self.plugin._sleep_runnable = Runnable(pause_music)
                self.plugin._sleep_handler.postDelayed(self.plugin._sleep_runnable, seconds * 1000)
                
                self.plugin.sleep_timer_active = True
                if seconds < 3600:
                    minutes = seconds // 60
                    formatted_time = LocaleController.formatPluralString("Minutes", minutes)
                else:
                    hours = seconds // 3600
                    formatted_time = LocaleController.formatPluralString("Hours", hours)
                
                from org.telegram.ui.Components import BulletinFactory
                container_view = get_private_field(alert, "containerView")
                resources_provider = get_private_field(alert, "resourcesProvider")
                if container_view and isinstance(container_view, FrameLayout):
                    message = getString("sleep_timer_set", "Sleep timer is set to {time}").format(time=formatted_time)
                    BulletinFactory.of(container_view, resources_provider).createSimpleBulletin(
                        R_tg.raw.done,
                        AndroidUtilities.replaceTags(message)
                    ).show()
            else:
                if self.plugin.sleep_timer_active:
                    from org.telegram.ui.Components import BulletinFactory
                    container_view = get_private_field(alert, "containerView")
                    resources_provider = get_private_field(alert, "resourcesProvider")
                    if container_view and isinstance(container_view, FrameLayout):
                        BulletinFactory.of(container_view, resources_provider).createSimpleBulletin(
                            R_tg.raw.done,
                            getString("sleep_timer_disabled", "Sleep timer is disabled")
                        ).show()
                self.plugin.sleep_timer_active = False
        except Exception as e:
            self.plugin.log(f"Error in sleep timer: {e}")


class AdaptiveAudioHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            
            documentAttachTypeField = cell.getClass().getDeclaredField("documentAttachType")
            documentAttachTypeField.setAccessible(True)
            documentAttachType = documentAttachTypeField.getInt(cell)
            
            if documentAttachType != 3:
                return
            
            currentMessageObjectField = cell.getClass().getDeclaredField("currentMessageObject")
            currentMessageObjectField.setAccessible(True)
            messageObject = currentMessageObjectField.get(cell)
            
            if messageObject is None:
                return
            
            documentAttachField = cell.getClass().getDeclaredField("documentAttach")
            documentAttachField.setAccessible(True)
            documentAttach = documentAttachField.get(cell)
            
            if documentAttach is None:
                return
            
            duration = 0
            attributes = documentAttach.attributes
            for i in range(attributes.size()):
                attr = attributes.get(i)
                attr_class_name = attr.getClass().getName()
                if "TL_documentAttributeAudio" in attr_class_name:
                    duration = attr.duration
                    break
            
            if duration <= 0:
                return
            
            backgroundWidthField = cell.getClass().getDeclaredField("backgroundWidth")
            backgroundWidthField.setAccessible(True)
            currentBackgroundWidth = backgroundWidthField.getInt(cell)
            
            extra = 0
            if duration >= 180:
                extra = AndroidUtilities.dp(120)
            elif duration >= 120:
                extra = AndroidUtilities.dp(80)
            elif duration >= 60:
                extra = AndroidUtilities.dp(40)
            
            if extra > 0:
                from java.lang import Class
                AndroidUtilitiesClass = Class.forName("org.telegram.messenger.AndroidUtilities")
                displaySizeField = AndroidUtilitiesClass.getDeclaredField("displaySize")
                displaySizeField.setAccessible(True)
                displaySize = displaySizeField.get(None)
                
                screenLimit = displaySize.x - AndroidUtilities.dp(75)
                
                newBackgroundWidth = min(currentBackgroundWidth + extra, screenLimit)
                backgroundWidthField.setInt(cell, newBackgroundWidth)
        except:
            pass


class MusicSpeedControlHook:
    def __init__(self, plugin):
        self.plugin = plugin
        self._is_music_field = None
        self._playback_button_field = None
        self._title_text_view_field = None
        self._subtitle_text_view_field = None
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            instance = param.thisObject
            if self._is_music_field is None or self._playback_button_field is None:
                c = instance.getClass()
                self._is_music_field = c.getDeclaredField("isMusic")
                self._is_music_field.setAccessible(True)
                self._playback_button_field = c.getDeclaredField("playbackSpeedButton")
                self._playback_button_field.setAccessible(True)
                try:
                    self._title_text_view_field = c.getDeclaredField("titleTextView")
                    self._title_text_view_field.setAccessible(True)
                except Exception:
                    pass
                try:
                    self._subtitle_text_view_field = c.getDeclaredField("subtitleTextView")
                    self._subtitle_text_view_field.setAccessible(True)
                except Exception:
                    pass
            is_music = self._is_music_field.getBoolean(instance)
            btn = self._playback_button_field.get(instance)
            if is_music and btn is not None:
                btn.setVisibility(0)
                btn.setAlpha(1.0)
                btn.setEnabled(True)
                speed_btn_width = AndroidUtilities.dp(36)
                try:
                    if self._title_text_view_field is not None:
                        title_view = self._title_text_view_field.get(instance)
                        if title_view is not None:
                            current_right = title_view.getPaddingRight()
                            if current_right < speed_btn_width:
                                title_view.setPadding(
                                    title_view.getPaddingLeft(),
                                    title_view.getPaddingTop(),
                                    current_right + speed_btn_width,
                                    title_view.getPaddingBottom()
                                )
                except Exception:
                    pass
                try:
                    if self._subtitle_text_view_field is not None:
                        subtitle_view = self._subtitle_text_view_field.get(instance)
                        if subtitle_view is not None:
                            current_right = subtitle_view.getPaddingRight()
                            if current_right < speed_btn_width:
                                subtitle_view.setPadding(
                                    subtitle_view.getPaddingLeft(),
                                    subtitle_view.getPaddingTop(),
                                    current_right + speed_btn_width,
                                    subtitle_view.getPaddingBottom()
                                )
                except Exception:
                    pass
                try:
                    methods = instance.getClass().getDeclaredMethods()
                    target = None
                    for m in methods:
                        if m.getName() == "updatePlaybackButton" and len(m.getParameterTypes()) == 1:
                            target = m
                            break
                    if target is not None:
                        target.setAccessible(True)
                        target.invoke(instance, False)
                except Exception:
                    pass
        except Exception as e:
            pass


class SendCommentsAfterForwardHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    def before_hooked_method(self, param):
        return None


class CheckSendButtonHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            enter_view.updateScheduleButton(True)
        except Exception:
            pass


class AlwaysVisibleScheduleButtonHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def replace_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            animated = param.args[0]
            
            schedule_button_hidden = get_private_field(enter_view, "scheduleButtonHidden")
            recording_audio_video = get_private_field(enter_view, "recordingAudioVideo")
            is_in_schedule_mode = enter_view.isInScheduleMode()
            
            has_text = enter_view.hasText()
            
            visible = (not schedule_button_hidden) and (not recording_audio_video) and (not has_text) and (not is_in_schedule_mode)
            scheduled_button = get_private_field(enter_view, "scheduledButton")
            
            if visible and not scheduled_button:
                try:
                    ChatActivityEnterViewClass = find_class("org.telegram.ui.Components.ChatActivityEnterView")
                    create_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod("createScheduledButton")
                    create_method.setAccessible(True)
                    create_method.invoke(enter_view)
                    scheduled_button = get_private_field(enter_view, "scheduledButton")
                    self._update_schedule_button_icon(scheduled_button, enter_view)
                except Exception:
                    pass
            
            if scheduled_button:
                if visible:
                    scheduled_button.setVisibility(0)
                    scheduled_button.setAlpha(1.0)
                    scheduled_button.setScaleX(1.0)
                    scheduled_button.setScaleY(1.0)
                    scheduled_button.setTag(1)
                else:
                    scheduled_button.setVisibility(8)
                    
        except Exception:
            pass
        
        return None
    
    def _update_schedule_button_icon(self, scheduled_button, enter_view):
        try:
            if not scheduled_button:
                return
            
            Theme = find_class("org.telegram.ui.ActionBar.Theme")
            R_tg = find_class("org.telegram.messenger.R")
            PorterDuff = find_class("android.graphics.PorterDuff")
            PorterDuffColorFilter = find_class("android.graphics.PorterDuffColorFilter")
            
            context = scheduled_button.getContext()
            
            key_color = getattr(Theme, 'key_chat_messagePanelIcons')
            color = Theme.getColor(key_color)
            
            drawable = context.getResources().getDrawable(R_tg.drawable.msg_calendar2).mutate()
            drawable.setColorFilter(PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY))
            scheduled_button.setImageDrawable(drawable)
        except Exception:
            pass


class DisableEmojiSuggestionsHook:
    def before_hooked_method(self, param):
        param.setResult(None)


class DisableFireUpdateHook:
    def before_hooked_method(self, param):
        param.setResult(None)



class RemoveHttpsHook(MethodHook):
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            clip_data = param.args[0]
            if clip_data:
                item = clip_data.getItemAt(0)
                if item:
                    text = item.getText()
                    if text:
                        text_str = str(text)
                        if text_str.startswith("https://t.me/") or text_str.startswith("https://"):
                            modified_text = text_str.replace("https://", "", 1)
                            ClipDataClass = find_class("android.content.ClipData")
                            new_clip = ClipDataClass.newPlainText("label", modified_text)
                            param.args[0] = new_clip
        except Exception as e:
            pass


class DirectProfileHook:
    
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        try:
            delegate = param.thisObject
            if not delegate:
                return
            
            if len(param.args) < 1:
                return
            
            view = param.args[0]
            
            member_request_cell_class = find_class("org.telegram.ui.Cells.MemberRequestCell")
            if not member_request_cell_class:
                return
                
            if not isinstance(view, member_request_cell_class):
                return
            
            is_search_expanded = get_private_field(delegate, "isSearchExpanded")
            if is_search_expanded:
                fragment = get_private_field(delegate, "fragment")
                if fragment and fragment.getParentActivity():
                    AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
                    AndroidUtilities.hideKeyboard(fragment.getParentActivity().getCurrentFocus())
            
            cell = view
            
            def open_profile_directly():
                try:
                    importer = cell.getImporter()
                    if not importer:
                        return
                    
                    users = get_private_field(delegate, "users")
                    if not users:
                        return
                    
                    user = users.get(importer.user_id)
                    if not user:
                        return
                    
                    fragment = get_private_field(delegate, "fragment")
                    if not fragment:
                        return
                    
                    fragment.getMessagesController().putUser(user, False)
                    
                    set_private_field(delegate, "isNeedRestoreList", True)
                    
                    fragment.dismissCurrentDialog()
                    
                    Bundle = jclass("android.os.Bundle")
                    args = Bundle()
                    args.putLong("user_id", user.id)
                    args.putBoolean("removeFragmentOnChatOpen", False)
                    
                    ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
                    profileActivity = ProfileActivity(args)
                    
                    fragment.presentFragment(profileActivity)
                    
                except Exception:
                    pass
            
            from android_utils import R
            
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            delay = 100 if is_search_expanded else 0
            AndroidUtilities.runOnUIThread(R(open_profile_directly), delay)
            
            param.setResult(None)
            
        except Exception:
            pass


class RemoveGreetingStickerHook(MethodReplacement):
    def replace_hooked_method(self, param):
        result = self.invoke_original_method(param)
        
        try:
            chat_activity = param.thisObject
            greetings_container = get_private_field(chat_activity, "greetingsViewContainer")
            
            if greetings_container is not None:
                parent = greetings_container.getParent()
                if parent is not None:
                    parent.removeView(greetings_container)
                set_private_field(chat_activity, "greetingsViewContainer", None)
                
        except Exception:
            pass
        
        return result


class MotionEventSwipeHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        MethodHook.__init__(self)
        self.last_x = 0
        self.last_y = 0
        self.swipe_threshold = 100
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            motion_event = param.args[0] if len(param.args) > 0 else None
            if not motion_event:
                return
            
            action = motion_event.getAction()
            x = motion_event.getX()
            y = motion_event.getY()
            
            if action == 0:
                self.last_x = x
                self.last_y = y
            
            elif action == 1:
                dx = x - self.last_x
                dy = y - self.last_y
                
                if abs(dx) > self.swipe_threshold and abs(dy) < 50:
                    swipe_action = self.plugin.get_setting("swipe_action", 0)
                    if swipe_action != 0:
                        chat_activity = param.thisObject
                        try:
                            current_message = get_private_field(chat_activity, "selectedObject")
                            chat_activity_ref = weakref.ref(chat_activity)
                            msg_ref = weakref.ref(current_message)
                            if swipe_action == 1:
                                def do_save_1(*args, ca_ref=chat_activity_ref, m_ref=msg_ref):
                                    ca, msg = ca_ref(), m_ref()
                                    if ca and msg:
                                        self.plugin._save_to_saved_messages(ca, msg)
                                run_on_ui_thread(do_save_1)
                            elif swipe_action == 2:
                                def do_translate_1(*args, ca_ref=chat_activity_ref, m_ref=msg_ref):
                                    ca, msg = ca_ref(), m_ref()
                                    if ca and msg:
                                        self.plugin._show_translate_alert(ca, msg)
                                run_on_ui_thread(do_translate_1)
                            elif swipe_action == 3:
                                def do_share_1(*args, ca_ref=chat_activity_ref, m_ref=msg_ref):
                                    ca, msg = ca_ref(), m_ref()
                                    if ca and msg:
                                        self.plugin._show_share_alert(ca, msg)
                                run_on_ui_thread(do_share_1)
                        except Exception as e:
                            pass
        
        except Exception as e:
            pass


class SwipeReplyHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            message_object = param.args[0] if len(param.args) > 0 else None
            
            if not message_object:
                return
            
            Thread = jclass("java.lang.Thread")
            stack_trace = Thread.currentThread().getStackTrace()
            
            is_from_swipe = False
            for element in stack_trace:
                method_name = str(element.getMethodName())
                if method_name == "processTouchEvent":
                    is_from_swipe = True
                    break
            
            if not is_from_swipe:
                return
            
            action = self.plugin.get_setting("swipe_action", 0)
            
            if action == 0:
                return
            
            param.setResult(None)
            
            if action == 1:
                chat_activity_ref = weakref.ref(chat_activity)
                msg_ref = weakref.ref(message_object)
                def do_save(*args, ca_ref=chat_activity_ref, m_ref=msg_ref):
                    ca, msg = ca_ref(), m_ref()
                    if ca and msg:
                        self.plugin._save_to_saved_messages(ca, msg)
                run_on_ui_thread(do_save)
            
            elif action == 2:
                chat_activity_ref = weakref.ref(chat_activity)
                msg_ref = weakref.ref(message_object)
                def do_translate(*args, ca_ref=chat_activity_ref, m_ref=msg_ref):
                    ca, msg = ca_ref(), m_ref()
                    if ca and msg:
                        self.plugin._show_translate_alert(ca, msg)
                run_on_ui_thread(do_translate)
            
            elif action == 3:
                chat_activity_ref = weakref.ref(chat_activity)
                msg_ref = weakref.ref(message_object)
                def do_share(*args, ca_ref=chat_activity_ref, m_ref=msg_ref):
                    ca, msg = ca_ref(), m_ref()
                    if ca and msg:
                        self.plugin._show_share_alert(ca, msg)
                run_on_ui_thread(do_share)
        
        except Exception as e:
            pass


SEARCH_FILTER_NONE = 0
SEARCH_FILTER_PHOTOS = 1
SEARCH_FILTER_VIDEOS = 2
SEARCH_FILTER_VOICE_MESSAGES = 3
SEARCH_FILTER_VIDEO_MESSAGES = 4
SEARCH_FILTER_FILES = 5
SEARCH_FILTER_MUSIC = 6
SEARCH_FILTER_GIFS = 7
SEARCH_FILTER_GEO = 8
SEARCH_FILTER_CONTACTS = 9
SEARCH_FILTER_MENTIONS = 10


class PlaySoundHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        setting = self.plugin.get_setting("notification_sound", 1)
        vibrate_setting = self.plugin.get_setting("in_chat_vibration", 0)
        
        if vibrate_setting != 0:
            try:
                Vibrator = jclass("android.os.Vibrator")
                ApplicationLoader = self.plugin._get_class("org.telegram.messenger.ApplicationLoader")
                context = ApplicationLoader.applicationContext
                vibrator = context.getSystemService("vibrator")
                
                if vibrate_setting == 1:
                    vibrator.vibrate(30)
                elif vibrate_setting == 2:
                    vibrator.vibrate(50)
                elif vibrate_setting == 3:
                    pattern = [0, 50, 50, 50]
                    vibrator.vibrate(pattern, -1)
                elif vibrate_setting == 4:
                    vibrator.vibrate(200)
            except Exception as e:
                pass
        
        if setting == 0:
            param.setResult(None)
        elif setting == 2:
            try:
                from android.media import MediaPlayer, AudioManager
                
                if os.path.exists(self.plugin.ios_sound_path):
                    mp = MediaPlayer()
                    mp.setAudioStreamType(AudioManager.STREAM_NOTIFICATION)
                    mp.setDataSource(self.plugin.ios_sound_path)
                    mp.prepare()
                    mp.setVolume(1.0, 1.0)
                    mp.start()
                    
                    def release_player():
                        try:
                            mp.release()
                        except:
                            pass
                    
                    import threading
                    threading.Timer(3.0, release_player).start()
                
                param.setResult(None)
            except Exception as e:
                pass


class SoundPoolLoadHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def after_hooked_method(self, param):
        try:
            context = param.args[0]
            res_id = param.args[1]
            
            R = find_class("org.telegram.messenger.R")
            if R and res_id == R.raw.sound_in:
                setting = self.plugin.get_setting("notification_sound", 1)
                if setting == 2 and os.path.exists(self.plugin.ios_sound_path):
                    soundpool = param.thisObject
                    ios_id = soundpool.load(self.plugin.ios_sound_path, 1)
                    self.plugin.soundpool_instance = soundpool
                    self.plugin.ios_sound_id = ios_id
                    param.setResult(ios_id)
        except Exception as e:
            pass


class SetVisibleReactionsListHook(MethodHook):
    
    def __init__(self, plugin):
        self.plugin = plugin
        MethodHook.__init__(self)
        self.processed_count = 0
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            container = param.thisObject
            
            is_channel = self._is_channel_context(container)
            
            pinned_reactions = self.plugin.get_pinned_reactions(is_channel)
            
            if not pinned_reactions:
                return
            
            original_list = param.args[0]
            
            allowed_reactions_type = self._get_allowed_reactions_type(is_channel)
            
            star_reactions = []
            allowed_reactions = []
            for i in range(original_list.size()):
                reaction = original_list.get(i)
                if hasattr(reaction, 'isStar') and reaction.isStar:
                    star_reactions.append((i, reaction))
                else:
                    allowed_reactions.append(reaction)
            
            ArrayList = jclass("java.util.ArrayList")
            new_list = ArrayList()
            
            added_hashes = set()
            for pinned in pinned_reactions:
                found = False
                for allowed in allowed_reactions:
                    if pinned.hash == allowed.hash:
                        new_list.add(pinned)
                        added_hashes.add(pinned.hash)
                        found = True
                        break
                
                if not found:
                    if "All" in str(allowed_reactions_type):
                        new_list.add(pinned)
                        added_hashes.add(pinned.hash)
            
            for allowed in allowed_reactions:
                if allowed.hash not in added_hashes:
                    new_list.add(allowed)
 
            for original_pos, star_reaction in star_reactions:
                if original_pos <= new_list.size():
                    new_list.add(original_pos, star_reaction)
                else:
                    new_list.add(star_reaction)
            
            param.args[0] = new_list
            
            self.processed_count += 1
            
        except Exception:
            pass
    
    def _is_channel_context(self, container):
        try:
            from client_utils import get_last_fragment
            fragment = get_last_fragment()
            
            if fragment is None:
                return False
            
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if isinstance(fragment, ChatActivity):
                current_chat = fragment.getCurrentChat()
                if current_chat is not None:
                    if hasattr(current_chat, 'megagroup'):
                        return not current_chat.megagroup
                    else:
                        return False
            
            return False
        except Exception:
            return False
    
    def _get_allowed_reactions_type(self, is_channel):
        try:
            from client_utils import get_last_fragment
            
            fragment = get_last_fragment()
            if fragment is None:
                return "TL_chatReactionsAll"
            
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if isinstance(fragment, ChatActivity):
                current_chat = fragment.getCurrentChat()
                if current_chat is not None:
                    if not hasattr(current_chat, 'megagroup'):
                        return "TL_chatReactionsAll"
                    
                    MessagesController = find_class("org.telegram.messenger.MessagesController")
                    if MessagesController:
                        mc = MessagesController.getInstance(0)
                        chat_full = mc.getChatFull(current_chat.id)
                        if chat_full and hasattr(chat_full, 'available_reactions'):
                            reactions_obj = chat_full.available_reactions
                            if reactions_obj:
                                class_name = reactions_obj.getClass().getSimpleName()
                                return class_name
            
            return "TL_chatReactionsAll"
        except Exception:
            return "TL_chatReactionsAll"


class SearchLinksReplacement(MethodHook):
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            text = param.args[0] if len(param.args) > 0 else None
            if not text:
                param.setResult(None)
                return
            
            text_str = str(text)
            exclude_pattern = self.plugin.get_setting("disable_link_preview_exclude_pattern", "")
            
            if not exclude_pattern or exclude_pattern.strip() == "":
                param.setResult(None)
                return
            
            try:
                if re.search(exclude_pattern, text_str, re.IGNORECASE):
                    return
                else:
                    param.setResult(None)
                    return
            except re.error as e:
                param.setResult(None)
                return
            
        except Exception as e:
            param.setResult(None)
            return


class EnterViewConstructorHook:
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            field = enter_view.getClass().getDeclaredField("messageWebPageSearch")
            field.setAccessible(True)
            field.setBoolean(enter_view, False)
        except:
            pass


class SendMessageParamsHook:
    @hook_filters(HookFilter.RESULT_NOT_NULL)
    def after_hooked_method(self, param):
        try:
            params = param.getResult()
            if params is not None:
                field = params.getClass().getDeclaredField("searchLinks")
                field.setAccessible(True)
                field.setBoolean(params, False)
        except:
            pass


class SearchFilterOpenSearchHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        try:
            from android.view import View
            chat_activity = param.thisObject
            def create_and_show_button():
                self.plugin._create_search_filter_button(chat_activity)
                activity_id = id(chat_activity)
                if activity_id in self.plugin.search_filter_buttons:
                    filter_button = self.plugin.search_filter_buttons[activity_id]
                    filter_button.setVisibility(View.VISIBLE)
            run_on_ui_thread(create_and_show_button)
        except:
            pass


class SearchFilterSendRequestHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            if self.plugin.search_filter_current == SEARCH_FILTER_NONE:
                return
            
            request = param.args[0]
            request_class_name = request.getClass().getName()
            
            if "TL_messages_search" in request_class_name:
                filter_obj = self.plugin._get_search_filter_type()
                
                try:
                    filter_field = request.getClass().getDeclaredField("filter")
                    filter_field.setAccessible(True)
                    filter_field.set(request, filter_obj)
                except:
                    pass
                    
        except:
            pass


class PinnedReactionsDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):
    
    def __init__(self, plugin):
        super().__init__()
        self._plugin_ref = weakref.ref(plugin)
        self.listView = None
        self.current_tab = 0
        self.emoji_spans = {}

    @property
    def plugin(self):
        return self._plugin_ref()
    
    def getTitle(self):
        return getString("pinned_reactions_title", "Pinned Reactions")
    
    def onFragmentCreate(self):
        pass
    
    def onFragmentDestroy(self):
        pass
    
    def onBackPressed(self):
        return None
    
    def beforeCreateView(self):
        return None

    def onLongClick(self, item, view, position, x, y):
        return False
    
    def _get_emoji_for_document_id(self, document_id):
        try:
            from android.text import SpannableString, Spanned
            from org.telegram.ui.Components import AnimatedEmojiSpan
            
            spannable = SpannableString(" ")
            span = AnimatedEmojiSpan(document_id, None)
            spannable.setSpan(span, 0, spannable.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        except Exception:
            return f"ID: {document_id}"    
    
    def afterCreateView(self, view):
        from org.telegram.ui.Components import UniversalRecyclerView
        if hasattr(view, 'getChildAt'):
            for i in range(view.getChildCount()):
                child = view.getChildAt(i)
                if isinstance(child, UniversalRecyclerView):
                    self.listView = child
                    break
        return None
    
    def fillItems(self, items, adapter):
        try:
            from org.telegram.ui.Components import UItem
            from org.telegram.messenger import Utilities
            from java import jarray, jclass, dynamic_proxy
            
            def on_tab_change(tab_index):
                self.current_tab = tab_index
                if self.listView is not None:
                    self.listView.adapter.update(True)
            
            CallbackInterface = Utilities.Callback
            class TabCallback(dynamic_proxy(CallbackInterface)):
                def __init__(self, callback):
                    super().__init__()
                    self.callback = callback
                
                def run(self, value):
                    self.callback(value)
            
            String = jclass('java.lang.String')
            tab_names = jarray(String)([getString("chats", "Chats"), getString("channels", "Channels")])
            
            items.add(UItem.asSlideView(
                tab_names,
                self.current_tab,
                TabCallback(on_tab_change)
            ))
        
            is_channel = self.current_tab == 1
            reactions_list = self._get_reactions_list(is_channel)
            
            enable_key = "pinned_reactions_enabled_channels" if is_channel else "pinned_reactions_enabled_chats"
            is_enabled = self.plugin.get_setting(enable_key, "true") == "true"
            
            def on_switch_change(enabled):
                self.plugin.set_setting(enable_key, "true" if enabled else "false")
                if self.listView:
                    self.listView.adapter.update(True)
            
            switch_title = getString("channels_switch", "Enable Pinned Reactions in Channels") if is_channel else getString("chats_switch", "Enable Pinned Reactions in Chats")
            items.add(UItem.asCheck(
                1,
                switch_title
            ).setChecked(is_enabled))
            
            items.add(UItem.asShadow(getString("pin_reactions_info", "You can pin reactions from any pack")))
            
            header_text = getString("pinned_reactions_count", "Pinned Reactions ({count}/7)").format(count=len(reactions_list))
            items.add(UItem.asHeader(header_text))
            
            if reactions_list:
                for idx, reaction in enumerate(reactions_list):
                    if "document_id" in reaction:
                        document_id = reaction["document_id"]
                        emoji_span = self._get_emoji_for_document_id(document_id)
                        
                        from android.text import SpannableStringBuilder
                        combined = SpannableStringBuilder()
                        combined.append(emoji_span)
                        combined.append(f"  {getString('tap_to_remove', 'Tap to remove')}")
                        
                        self.emoji_spans[100 + idx] = combined
                        button_item = UItem.asButton(100 + idx, combined).accent()
                    else:
                        emoji = reaction.get("emoticon", "?")
                        button_text = f"{emoji}  {getString('tap_to_remove', 'Tap to remove')}"
                        button_item = UItem.asButton(100 + idx, button_text).accent()
                    
                    items.add(button_item)
            else:
                items.add(UItem.asShadow(getString("no_reactions_pinned", "No reactions pinned yet")))
            
            if len(reactions_list) < 7:
                items.add(UItem.asButton(200, getString("add_reaction", "Add Reaction")).accent())
            
            items.add(UItem.asShadow(
                getString("add_reaction_hint", "Tap Add Reaction to select an emoji from the picker")
            ))
        
        except Exception:
            pass
    
    def onClick(self, item, view, position, x, y):
        from ui.alert import AlertDialogBuilder
        from android_utils import run_on_ui_thread
        
        item_id = item.id
        
        if item_id == 1:
            is_channel = self.current_tab == 1
            enable_key = "pinned_reactions_enabled_channels" if is_channel else "pinned_reactions_enabled_chats"
            current_value = self.plugin.get_setting(enable_key, "true") == "true"
            self.plugin.set_setting(enable_key, "false" if current_value else "true")
            if self.listView:
                self.listView.adapter.update(True)
        elif 100 <= item_id < 200:
            idx = item_id - 100
            is_channel = self.current_tab == 1
            reactions = self._get_reactions_list(is_channel)
            if idx < len(reactions):
                reactions.pop(idx)
                self.plugin.save_pinned_reactions(is_channel, reactions)
                if self.listView is not None:
                    self.listView.adapter.update(True)
        elif item_id == 200:
            self._show_add_reaction_dialog()
    
    def _show_add_reaction_dialog(self):
        from org.telegram.ui.ActionBar import Theme, BottomSheet
        from client_utils import get_last_fragment
        from org.telegram.messenger import AndroidUtilities, UserConfig
        from android.widget import FrameLayout, LinearLayout
        from android.view import View, ViewGroup
        from android_utils import run_on_ui_thread
        from ui.bulletin import BulletinHelper
        from java import jclass, dynamic_proxy
        import weakref
        
        fragment = get_last_fragment()
        if fragment is None:
            return
        
        activity = fragment.getParentActivity()
        if activity is None:
            return
        
        dp = AndroidUtilities.dp
        
        plugin_ref = weakref.ref(self.plugin)
        listView_ref = weakref.ref(self.listView) if self.listView else None
        current_tab = self.current_tab
        sheet_ref = [None]
        
        container = LinearLayout(activity)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        emoji_container = FrameLayout(activity)
        
        EmojiView = jclass("org.telegram.ui.Components.EmojiView")
        EmojiViewDelegate = jclass("org.telegram.ui.Components.EmojiView$EmojiViewDelegate")
        
        def add_reaction(emoticon=None, document_id=None):
            plugin = plugin_ref()
            if not plugin:
                return
            
            is_channel = current_tab == 1
            reactions = self._get_reactions_list(is_channel)
            
            if document_id:
                if not UserConfig.getInstance(UserConfig.selectedAccount).isPremium():
                    BulletinHelper.show_simple(getString("premium_required", "Premium required"), R_tg.raw.star_premium_2, fragment)
                    return
                
                for reaction in reactions:
                    if reaction.get("document_id") == document_id:
                        BulletinHelper.show_simple(getString("already_pinned", "Already pinned"), R_tg.raw.ic_pin, fragment)
                        return
                
                reactions.append({"document_id": document_id})
            elif emoticon:
                for reaction in reactions:
                    if reaction.get("emoticon") == emoticon:
                        BulletinHelper.show_simple(getString("already_pinned", "Already pinned"), R_tg.raw.ic_pin, fragment)
                        return
                
                reactions.append({"emoticon": emoticon})
            else:
                return
            
            plugin.save_pinned_reactions(is_channel, reactions)
            lv = listView_ref() if listView_ref else None
            run_on_ui_thread(lambda: lv.adapter.update(True) if lv else None, 100)
            
            if sheet_ref[0]:
                sheet_ref[0].dismiss()
        
        class EmojiDelegate(dynamic_proxy(EmojiViewDelegate)):
            def onEmojiSelected(self_delegate, emoji):
                if emoji:
                    add_reaction(emoticon=str(emoji))
            
            def onCustomEmojiSelected(self_delegate, documentId, document, emoticon, isRecent):
                if documentId:
                    add_reaction(document_id=int(documentId))
            
            def onBackspace(self_delegate):
                return False
            
            def isSearchOpened(self_delegate):
                return False
            
            def isExpanded(self_delegate):
                return False
            
            def isUserSelf(self_delegate):
                return False
            
            def getDialogId(self_delegate):
                return 0
            
            def getThreadId(self_delegate):
                return 0
            
            def canSchedule(self_delegate):
                return False
            
            def isInScheduleMode(self_delegate):
                return False
            
            def getProgressToSearchOpened(self_delegate):
                return 0.0
            
            def onStickerSelected(self_delegate, view, sticker, query, parent, sendAnimationData, notify, scheduleDate, scheduleRepeatPeriod):
                pass
            
            def onStickersSettingsClick(self_delegate):
                pass
            
            def onEmojiSettingsClick(self_delegate, frozenEmojiPacks):
                pass
            
            def onStickersGroupClick(self_delegate, chatId):
                pass
            
            def onGifSelected(self_delegate, view, gif, query, parent, notify, scheduleDate, scheduleRepeatPeriod):
                pass
            
            def onTabOpened(self_delegate, type):
                pass
            
            def onClearEmojiRecent(self_delegate):
                pass
            
            def onShowStickerSet(self_delegate, stickerSet, inputStickerSet, edit):
                pass
            
            def onStickerSetAdd(self_delegate, stickerSet):
                pass
            
            def onStickerSetRemove(self_delegate, stickerSet):
                pass
            
            def onSearchOpenClose(self_delegate, type):
                pass
            
            def onAnimatedEmojiUnlockClick(self_delegate):
                pass
            
            def showTrendingStickersAlert(self_delegate, layout):
                pass
            
            def invalidateEnterView(self_delegate):
                pass
        
        emoji_view = EmojiView(fragment, True, False, False, activity, False, None, None, True, None, False)
        emoji_view.setDelegate(EmojiDelegate())
        emoji_view.setVisibility(View.VISIBLE)
        
        emoji_container.addView(emoji_view, FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            dp(300)
        ))
        
        container.addView(emoji_container, LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            dp(300)
        ))
        
        builder = BottomSheet.Builder(activity, True)
        builder.setCustomView(container)
        sheet = builder.create()
        sheet.setCanDismissWithSwipe(False)
        sheet_ref[0] = sheet
        sheet.show()
    
    def _get_reactions_list(self, is_channel):
        if is_channel:
            reactions_json = self.plugin.get_setting("pinned_reactions_channels", "[]")
        else:
            reactions_json = self.plugin.get_setting("pinned_reactions_chats", "[]")
        
        try:
            return json.loads(reactions_json)
        except:
            return []


class ProcessSelectedOptionHook(MethodHook):
    @hook_filters(HookFilter.ArgumentEqual(0, 2))
    def before_hooked_method(self, param):
        if param.args[0] == 2:
            activity = param.thisObject
            activity_class = activity.getClass()
            
            selected = activity_class.getDeclaredField("selectedObject")
            selected.setAccessible(True)
            
            selected_group = activity_class.getDeclaredField("selectedObjectGroup")
            selected_group.setAccessible(True)
            
            forwarding = activity_class.getDeclaredField("forwardingMessage")
            forwarding.setAccessible(True)
            forwarding.set(activity, selected.get(activity))
            
            forwarding_group = activity_class.getDeclaredField("forwardingMessageGroup")
            forwarding_group.setAccessible(True)
            forwarding_group.set(activity, selected_group.get(activity))
            
            try:
                scrim = activity_class.getDeclaredField("scrimPopupWindow")
                scrim.setAccessible(True)
                popup = scrim.get(activity)
                if popup:
                    popup.dismiss()
            except:
                pass
            
            method = activity_class.getDeclaredMethod("openForward", jclass("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            method.invoke(activity, False)
            
            param.setResult(None)


class UnifyUsernameProcessClickHook(MethodHook):
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            profile_activity = param.thisObject
            position = param.args[0]
            
            username_row = get_private_field(profile_activity, "usernameRow")
            set_username_row = get_private_field(profile_activity, "setUsernameRow")
            
            if position != username_row and position != set_username_row:
                return
            
            user_id = get_private_field(profile_activity, "userId")
            chat_id = get_private_field(profile_activity, "chatId")
            
            if user_id != 0:
                return
            
            if chat_id == 0:
                return
            
            param.setResult(True)
            
        except:
            pass


class UnifyUsernameBindViewHook(MethodHook):
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        MethodHook.__init__(self)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def after_hooked_method(self, param):
        try:
            list_adapter = param.thisObject
            holder = param.args[0]
            position = param.args[1]
            
            this_class = list_adapter.getClass()
            outer_field = this_class.getDeclaredField("this$0")
            outer_field.setAccessible(True)
            profile_activity = outer_field.get(list_adapter)
            
            username_row = get_private_field(profile_activity, "usernameRow")
            
            if position != username_row:
                return
            
            user_id = get_private_field(profile_activity, "userId")
            chat_id = get_private_field(profile_activity, "chatId")
            
            if user_id != 0:
                return
            
            if chat_id == 0:
                return
            
            from org.telegram.messenger import MessagesController, ChatObject, LocaleController, R
            
            current_account = get_private_field(profile_activity, "currentAccount")
            messages_controller = MessagesController.getInstance(current_account)
            chat = messages_controller.getChat(chat_id)
            
            if not chat:
                return
            
            username = ChatObject.getPublicUsername(chat)
            if not username:
                return
            
            view = holder.itemView
            plugin = self._plugin_ref()
            if not plugin:
                return
            text_detail_cell_class = plugin._get_class("org.telegram.ui.Cells.TextDetailCell")
            
            if not text_detail_cell_class.getClass().isInstance(view):
                return
            
            new_text = "@" + username
            new_label = LocaleController.getString(R.string.Username)
            
            view.setTextAndValue(new_text, new_label, True)
            
            from android_utils import OnClickListener, OnLongClickListener
            from org.telegram.messenger import AndroidUtilities
            from android.view import HapticFeedbackConstants
            
            def on_click(v):
                text = "@" + username
                AndroidUtilities.addToClipboard(text)
                from ui.bulletin import BulletinHelper
                from org.telegram.messenger import R as R_tg
                BulletinHelper.show_simple(LocaleController.getString(R.string.UsernameCopied), R_tg.raw.copy, profile_activity)
            
            def on_long_click(v):
                v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
                link = "https://t.me/" + username
                AndroidUtilities.addToClipboard(link)
                from ui.bulletin import BulletinHelper
                from org.telegram.messenger import R as R_tg
                BulletinHelper.show_simple(LocaleController.getString(R.string.LinkCopied), R_tg.raw.copy, profile_activity)
                return True
            
            from org.telegram.ui.ActionBar import Theme as UITheme
            view.setForeground(UITheme.createSelectorDrawable(UITheme.getColor(UITheme.key_listSelector), 2))
            view.setOnClickListener(OnClickListener(on_click))
            view.setOnLongClickListener(OnLongClickListener(on_long_click))
            
        except:
            pass


class EditFileNameSetItemOptionsHook(MethodHook):
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if not plugin:
                return
            options = param.args[0] if param and hasattr(param, "args") and param.args else None
            if not options:
                return
            
            if getattr(plugin, "_last_item_options", None) is not options:
                plugin._last_item_options = options
                plugin._menu_item_added = False
            
            message_send_preview = param.thisObject if param and hasattr(param, "thisObject") else None
            plugin._message_send_preview = message_send_preview
            
            if getattr(plugin, "_menu_item_added", False):
                return
            
            if not plugin._has_document_selected():
                return
            
            from org.telegram.messenger import R
            from java.lang import Runnable
            from java import dynamic_proxy
            
            class RunnableFactory(dynamic_proxy(Runnable)):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                
                def run(self):
                    try:
                        self.fn()
                    except Exception:
                        pass
            
            action = RunnableFactory(lambda opts=options, preview=message_send_preview, p=plugin: p._on_edit_filename_click(opts, preview))
            
            try:
                icon_id = R.drawable.msg_edit
            except:
                icon_id = 0
            
            if icon_id > 0:
                options.add(icon_id, getString("edit_file_name", "Edit File Name"), action)
            else:
                options.add(getString("edit_file_name", "Edit File Name"), action)
            
            plugin._menu_item_added = True
            
        except Exception:
            pass


class OpenForwardHook(MethodHook):
    @hook_filters(HookFilter.ArgumentIsTrue(0))
    def before_hooked_method(self, param):
        if param.args[0]:
            param.args[0] = False


class UiTweaksSettingsHeaderHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            activity = param.thisObject
            items = param.args[0]
            if not items or items.size() == 0:
                return
            
            plugin_obj = get_private_field(activity, "plugin")
            if not plugin_obj or str(plugin_obj.getId()) != "ui_tweaks":
                return
            
            if get_private_field(activity, "createSubFragmentCallback") is not None:
                return
            
            try:
                qh = getattr(quantahut, 'QuantaHut', None)
                if qh and hasattr(qh, 'instance') and qh.instance:
                    state = qh.instance._search_state.get(id(activity))
                    if state and (state.get("active") or state.get("show_history")):
                        return
            except:
                pass
            
            plugin = self._plugin_ref()
            if not plugin:
                return
            header = plugin._create_settings_header(activity.getContext())
            if header:
                from org.telegram.ui.Components import UItem
                from com.exteragram.messenger.plugins.models import HeaderSetting
                item = UItem.asCustom(header)
                item.settingItem = HeaderSetting("uitweaks_header")
                try: item.setTransparent(True)
                except: pass
                items.add(0, item)
                items.add(1, UItem.asShadow())
        except:
            pass


class HideViaBotHook(MethodHook):
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)
        MethodHook.__init__(self)
    
    @hook_filters(HookFilter.ArgumentNotNull(2))
    def before_hooked_method(self, param):
        try:
            result = param.args[2]
            if result is None:
                return
            
            document = getattr(result, 'document', None)
            photo = getattr(result, 'photo', None)
            
            if not isinstance(document, TLRPC.TL_document) and not isinstance(photo, TLRPC.TL_photo):
                return
            
            send_message_obj = getattr(result, 'send_message', None)
            caption = getattr(send_message_obj, 'caption', "") if send_message_obj else ""
            
            send_params = {
                "peer": param.args[4],
                "document": document if isinstance(document, TLRPC.TL_document) else None,
                "photo": photo if isinstance(photo, TLRPC.TL_photo) else None,
                "message": caption or None,
                "replyToMsg": param.args[5],
                "replyToTopMsg": param.args[6],
                "scheduleDate": param.args[10]
            }
            send_message(send_params)
            param.setResult(None)
        except Exception:
            pass


class UserPrivacyDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):

    PRIVACY_TYPES = {
        0:  LocaleController.getString("PrivacyLastSeen", R_tg.string.PrivacyLastSeen),
        1:  LocaleController.getString("PrivacyInvites", R_tg.string.PrivacyInvites),
        2:  LocaleController.getString("Calls", R_tg.string.Calls),
        3:  LocaleController.getString("PrivacyP2PHeader", R_tg.string.PrivacyP2PHeader),
        4:  LocaleController.getString("PrivacyProfilePhoto", R_tg.string.PrivacyProfilePhoto),
        5:  LocaleController.getString("PrivacyForwards", R_tg.string.PrivacyForwards),
        6:  LocaleController.getString("PrivacyPhone", R_tg.string.PrivacyPhone),
        7:  getString("custom_privacy_type_added_by_phone", "Added by Phone"),
        8:  LocaleController.getString("PrivacyVoiceMessages", R_tg.string.PrivacyVoiceMessages),
        9:  LocaleController.getString("PrivacyBio", R_tg.string.PrivacyBio),
        10: LocaleController.getString("PrivacyMessages", R_tg.string.PrivacyMessages),
        11: LocaleController.getString("PrivacyBirthday", R_tg.string.PrivacyBirthday),
        12: LocaleController.getString("PrivacyGifts", R_tg.string.PrivacyGifts),
        13: LocaleController.getString("PremiumPreviewPaidMessages", R_tg.string.PremiumPreviewPaidMessages),
        14: LocaleController.getString("PrivacyMusic", R_tg.string.PrivacyMusic),
    }

    INPUT_PRIVACY_KEYS = {
        0:  lambda: TLRPC.TL_inputPrivacyKeyStatusTimestamp(),
        1:  lambda: TLRPC.TL_inputPrivacyKeyChatInvite(),
        2:  lambda: TLRPC.TL_inputPrivacyKeyPhoneCall(),
        3:  lambda: TLRPC.TL_inputPrivacyKeyPhoneP2P(),
        4:  lambda: TLRPC.TL_inputPrivacyKeyProfilePhoto(),
        5:  lambda: TLRPC.TL_inputPrivacyKeyForwards(),
        6:  lambda: TLRPC.TL_inputPrivacyKeyPhoneNumber(),
        7:  lambda: TLRPC.TL_inputPrivacyKeyAddedByPhone(),
        8:  lambda: TLRPC.TL_inputPrivacyKeyVoiceMessages(),
        9:  lambda: TLRPC.TL_inputPrivacyKeyAbout(),
        10: lambda: TLRPC.TL_inputPrivacyKeyNoPaidMessages(),
        11: lambda: TLRPC.TL_inputPrivacyKeyBirthday(),
        12: lambda: TLRPC.TL_inputPrivacyKeyStarGiftsAutoSave(),
        13: lambda: TLRPC.TL_inputPrivacyKeyNoPaidMessages(),
        14: lambda: TLRPC.TL_inputPrivacyKeySavedMusic(),
    }

    STATE_DEFAULT = 0
    STATE_ALWAYS  = 1
    STATE_NEVER   = 2

    STATE_LABELS = {
        STATE_DEFAULT: LocaleController.getString("Default", R_tg.string.Default),
        STATE_ALWAYS:  getString("custom_privacy_state_enabled", "Enabled"),
        STATE_NEVER:   getString("custom_privacy_state_disabled", "Disabled"),
    }

    def __init__(self, plugin, user, account):
        super().__init__()
        self._plugin_ref = weakref.ref(plugin)
        self.user = user
        self.account = account
        self.fragment = None
        self.current_states = {}
        self.loading = True
        self._pending_fetches = len(self.PRIVACY_TYPES)

    @property
    def plugin(self):
        return self._plugin_ref()

    def getTitle(self):
        return LocaleController.getString(R_tg.string.PrivacyTitle)

    def onFragmentCreate(self):
        self_ref = weakref.ref(self)
        run_on_ui_thread(lambda: self_ref() and self_ref()._fetch_all_privacy(), 1200)

    def onFragmentDestroy(self): pass

    def beforeCreateView(self): return None

    def afterCreateView(self, view):
        if self.fragment and self.fragment.listView:
            adapter = self.fragment.listView.getAdapter()
            if adapter:
                try:
                    adapter.setUseSectionStyle(True)
                except Exception:
                    pass
        return view

    def onBackPressed(self):
        return None

    def onMenuItemClick(self, id): pass

    def _fetch_all_privacy(self):
        for privacy_type in self.PRIVACY_TYPES:
            self._fetch_privacy(privacy_type)

    def _fetch_privacy(self, privacy_type):
        key_factory = self.INPUT_PRIVACY_KEYS.get(privacy_type)
        if not key_factory: return
        req = TL_account.getPrivacy()
        req.key = key_factory()
        
        self_ref = weakref.ref(self)

        def on_response(response, error):
            if error or not response: return
            adapter_self = self_ref()
            if not adapter_self: return
            
            def process():
                adapter_self = self_ref()
                if not adapter_self: return
                
                contacts = ContactsController.getInstance(adapter_self.account)
                MessagesController.getInstance(adapter_self.account).putUsers(response.users, False)
                MessagesController.getInstance(adapter_self.account).putChats(response.chats, False)
                contacts.setPrivacyRules(response.rules, privacy_type)

                state = adapter_self.STATE_DEFAULT
                for i in range(response.rules.size()):
                    rule = response.rules.get(i)
                    if isinstance(rule, TLRPC.TL_privacyValueAllowUsers):
                        if rule.users.contains(adapter_self.user.id):
                            state = adapter_self.STATE_ALWAYS
                            break
                    elif isinstance(rule, TLRPC.TL_privacyValueDisallowUsers):
                        if rule.users.contains(adapter_self.user.id):
                            state = adapter_self.STATE_NEVER
                            break

                adapter_self.current_states[privacy_type] = state
                adapter_self._pending_fetches -= 1

                if adapter_self._pending_fetches <= 0:
                    adapter_self.loading = False

                if adapter_self.fragment and adapter_self.fragment.listView:
                    adapter = adapter_self.fragment.listView.getAdapter()
                    if adapter_self.loading == False and adapter_self._pending_fetches <= 0:
                        adapter.update(True)
                    else:
                        search_id = 1000 if privacy_type == 0 else privacy_type
                        for i in range(adapter.getItemCount()):
                            item = adapter.getItem(i)
                            if item and int(item.id) == search_id:
                                effective = adapter_self._is_allowed_by_rules(adapter_self.user, response.rules, state)
                                item.subtext = adapter_self.STATE_LABELS.get(state, "")
                                item.checked = effective
                                adapter.notifyItemChanged(i)
                                break
            
            run_on_ui_thread(process)

        send_request(req, RequestCallback(on_response))

    def _set_state(self, privacy_type, new_state):
        if self.current_states.get(privacy_type) == new_state: return
        self.current_states[privacy_type] = new_state

        if self.fragment and self.fragment.listView:
            adapter = self.fragment.listView.getAdapter()
            search_id = 1000 if privacy_type == 0 else privacy_type

            for i in range(adapter.getItemCount()):
                item = adapter.getItem(i)
                if item and int(item.id) == search_id:
                    contacts = ContactsController.getInstance(self.account)
                    rules = contacts.getPrivacyRules(privacy_type)
                    effective = self._is_allowed_by_rules(self.user, rules, new_state)

                    item.subtext = self.STATE_LABELS.get(new_state, "")
                    item.checked = effective
                    adapter.notifyItemChanged(i)
                    break

        self._update_user_privacy(
            self.account, self.user, privacy_type, new_state, self._on_update_done
        )

    def _on_update_done(self, privacy_type, success):
        if not success:
            self._fetch_all_privacy()
            if self.fragment and self.fragment.listView:
                self.fragment.listView.getAdapter().update(True)

    def fillItems(self, items, adapter):
        try:
            from org.telegram.ui.Cells import ProfileSearchCell
            last_frag = get_last_fragment()
            if not last_frag:
                return

            context = last_frag.getContext()
            if not context:
                return

            user_cell = ProfileSearchCell(context)
            user_cell.setData(self.user, None, None, None, False, False)
            items.add(UItem.asCustom(-1, user_cell))

            is_contact = ContactsController.getInstance(self.account).contactsDict.get(int(self.user.id)) is not None
            if is_contact:
                delete_item = UItem.asButton(100, R_tg.drawable.msg_delete, LocaleController.getString("DeleteContactTitle", R_tg.string.DeleteContactTitle)).red()
                items.add(delete_item)
                name = UserObject.getFirstName(self.user)
                items.add(UItem.asShadow(getString("custom_privacy_also_added_you", "Also {name} added you to their contacts.").format(name=name)))

            if self.loading:
                items.add(UItem.asHeader(getString("custom_privacy_section_see", "What can they see?")))
                for _ in range(6):
                    items.add(UItem.asFlicker(6))
                items.add(UItem.asHeader(getString("custom_privacy_section_do", "What can they do?")))
                for _ in range(5):
                    items.add(UItem.asFlicker(6))
                return

            items.add(UItem.asHeader(getString("custom_privacy_section_see", "What can they see?")))
            for p_type in [0, 4, 6, 9, 11, 14]:
                self._add_privacy_item(items, p_type)

            items.add(UItem.asHeader(getString("custom_privacy_section_do", "What can they do?")))
            for p_type in [1, 2, 3, 5, 8]:
                self._add_privacy_item(items, p_type)

            items.add(UItem.asShadow(None))

        except Exception:
            pass

    def _add_privacy_item(self, items, p_type):
        label = self.PRIVACY_TYPES[p_type]
        state = self.current_states.get(p_type, self.STATE_DEFAULT)

        contacts = ContactsController.getInstance(self.account)
        rules = contacts.getPrivacyRules(p_type)
        effective = self._is_allowed_by_rules(self.user, rules, state)

        subtext = self.STATE_LABELS.get(state, "")
        uitem_id = 1000 if p_type == 0 else p_type

        item = UItem.asButtonCheck(uitem_id, label, subtext)
        item.checked = effective
        items.add(item)

    def onClick(self, item, view, position, x, y):
        actual_id = 0 if item.id == 1000 else item.id

        if actual_id in self.PRIVACY_TYPES:
            current_state = self.current_states.get(actual_id, self.STATE_DEFAULT)

            contacts = ContactsController.getInstance(self.account)
            rules = contacts.getPrivacyRules(actual_id)
            global_allows = self._is_allowed_by_rules(self.user, rules, self.STATE_DEFAULT)

            if global_allows:
                new_state = self.STATE_DEFAULT if current_state == self.STATE_NEVER else self.STATE_NEVER
            else:
                new_state = self.STATE_DEFAULT if current_state == self.STATE_ALWAYS else self.STATE_ALWAYS

            self._set_state(actual_id, new_state)
            return

        if item.id == 100:
            self._delete_contact()

    def onLongClick(self, item, view, position, x, y): return False

    def _delete_contact(self):
        last_frag = get_last_fragment()
        if not last_frag: return
        activity = last_frag.getParentActivity()
        if not activity: return

        self_ref = weakref.ref(self)
        builder = AlertDialogBuilder(activity)
        builder.set_title(LocaleController.getString("DeleteContactTitle", R_tg.string.DeleteContactTitle))
        builder.set_message(LocaleController.getString("DeleteContactSubtitle", R_tg.string.DeleteContactSubtitle))
        builder.set_positive_button(LocaleController.getString(R_tg.string.Delete), lambda d, w: self_ref() and self_ref()._do_delete_contact())
        builder.set_negative_button(LocaleController.getString(R_tg.string.Cancel), None)
        builder.show()

    def _do_delete_contact(self):
        users = ArrayList()
        users.add(self.user)
        ContactsController.getInstance(self.account).deleteContact(users, True)
        run_on_ui_thread(lambda: get_last_fragment().finishFragment())

    def _is_allowed_by_rules(self, user, rules, state):
        if state == self.STATE_ALWAYS: return True
        if state == self.STATE_NEVER: return False
        if not rules: return True
        for i in range(rules.size()):
            rule = rules.get(i)
            if isinstance(rule, TLRPC.TL_privacyValueAllowUsers):
                if rule.users.contains(user.id):
                    return True
            elif isinstance(rule, TLRPC.TL_privacyValueDisallowUsers):
                if rule.users.contains(user.id):
                    return False

        for i in range(rules.size()):
            rule = rules.get(i)
            if isinstance(rule, TLRPC.TL_privacyValueAllowAll):
                return True
            if isinstance(rule, TLRPC.TL_privacyValueDisallowAll):
                return False
            if isinstance(rule, TLRPC.TL_privacyValueAllowContacts):
                return user.contact
            if isinstance(rule, TLRPC.TL_privacyValueDisallowContacts):
                return not user.contact

        return True

    def _update_user_privacy(self, account, user, privacy_type, new_state, callback):
        contacts = ContactsController.getInstance(account)
        rules = contacts.getPrivacyRules(privacy_type)
        input_rules = ArrayList()
        user_id = user.id

        key_factory = self.INPUT_PRIVACY_KEYS.get(privacy_type)
        if not key_factory:
            run_on_ui_thread(lambda: callback(privacy_type, False))
            return
        input_key = key_factory()

        found_allow = None
        found_disallow = None

        if rules:
            for i in range(rules.size()):
                rule = rules.get(i)
                input_rule = self._to_input_rule(account, rule)
                if not input_rule:
                    continue

                if isinstance(input_rule, TLRPC.TL_inputPrivacyValueAllowUsers):
                    if not found_allow:
                        found_allow = TLRPC.TL_inputPrivacyValueAllowUsers()
                    for j in range(input_rule.users.size()):
                        cur_u = input_rule.users.get(j)
                        is_target = isinstance(cur_u, (TLRPC.TL_inputUser, TLRPC.TL_inputUserSelf)) and cur_u.user_id == user_id
                        if not is_target:
                            found_allow.users.add(cur_u)

                elif isinstance(input_rule, TLRPC.TL_inputPrivacyValueDisallowUsers):
                    if not found_disallow:
                        found_disallow = TLRPC.TL_inputPrivacyValueDisallowUsers()
                    for j in range(input_rule.users.size()):
                        cur_u = input_rule.users.get(j)
                        is_target = isinstance(cur_u, (TLRPC.TL_inputUser, TLRPC.TL_inputUserSelf)) and cur_u.user_id == user_id
                        if not is_target:
                            found_disallow.users.add(cur_u)

                else:
                    input_rules.add(input_rule)

        if found_allow:
            input_rules.add(0, found_allow)
        if found_disallow:
            input_rules.add(0, found_disallow)

        input_user = MessagesController.getInstance(account).getInputUser(user)

        if new_state == self.STATE_ALWAYS:
            if not found_allow:
                found_allow = TLRPC.TL_inputPrivacyValueAllowUsers()
                input_rules.add(0, found_allow)
            found_allow.users.add(input_user)

        elif new_state == self.STATE_NEVER:
            if not found_disallow:
                found_disallow = TLRPC.TL_inputPrivacyValueDisallowUsers()
                input_rules.add(0, found_disallow)
            found_disallow.users.add(input_user)

        for i in range(input_rules.size() - 1, -1, -1):
            r = input_rules.get(i)
            if isinstance(r, (TLRPC.TL_inputPrivacyValueAllowUsers, TLRPC.TL_inputPrivacyValueDisallowUsers)):
                if r.users.isEmpty():
                    input_rules.remove(i)

        req = TL_account.setPrivacy()
        req.key = input_key
        req.rules = input_rules

        def on_response(response, error):
            if error:
                run_on_ui_thread(lambda: callback(privacy_type, False))
            else:
                def process():
                    contacts.setPrivacyRules(response.rules, privacy_type)
                    callback(privacy_type, True)
                run_on_ui_thread(process)

        send_request(req, RequestCallback(on_response))

    def _to_input_rule(self, account, rule):
        mc = MessagesController.getInstance(account)

        if isinstance(rule, TLRPC.TL_privacyValueAllowAll):
            return TLRPC.TL_inputPrivacyValueAllowAll()

        if isinstance(rule, TLRPC.TL_privacyValueAllowContacts):
            return TLRPC.TL_inputPrivacyValueAllowContacts()

        if isinstance(rule, TLRPC.TL_privacyValueDisallowAll):
            return TLRPC.TL_inputPrivacyValueDisallowAll()

        if isinstance(rule, TLRPC.TL_privacyValueDisallowContacts):
            return TLRPC.TL_inputPrivacyValueDisallowContacts()

        if isinstance(rule, TLRPC.TL_privacyValueAllowUsers):
            res = TLRPC.TL_inputPrivacyValueAllowUsers()
            for i in range(rule.users.size()):
                u = mc.getUser(rule.users.get(i))
                if u:
                    res.users.add(mc.getInputUser(u))
            return res

        if isinstance(rule, TLRPC.TL_privacyValueDisallowUsers):
            res = TLRPC.TL_inputPrivacyValueDisallowUsers()
            for i in range(rule.users.size()):
                u = mc.getUser(rule.users.get(i))
                if u:
                    res.users.add(mc.getInputUser(u))
            return res

        if isinstance(rule, TLRPC.TL_privacyValueAllowChatParticipants):
            res = TLRPC.TL_inputPrivacyValueAllowChatParticipants()
            for i in range(rule.chats.size()):
                res.chats.add(rule.chats.get(i))
            return res

        if isinstance(rule, TLRPC.TL_privacyValueDisallowChatParticipants):
            res = TLRPC.TL_inputPrivacyValueDisallowChatParticipants()
            for i in range(rule.chats.size()):
                res.chats.add(rule.chats.get(i))
            return res

        return None


class _AccountSwitcherUpdateSendAsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    def after_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin.get_setting("enable_account_switcher", False):
                run_on_ui_thread(lambda: plugin._account_switcher_setup_for_private_chat(param.thisObject))
        except:
            pass


class _AccountSwitcherSetDefaultSendAsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    def before_hooked_method(self, param):
        try:
            plugin = self._plugin_ref()
            if plugin and plugin._account_switcher_chat_info:
                param.setResult(None)
        except:
            pass


