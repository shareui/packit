"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

Кража кода без указания авторства является публичным неуважением к работе автора.
Уважайте чужой труд: если используете этот код, пожалуйста, указывайте @mihailkotovski и источник (@mishabotov)
Берёте — но делайте это с уважением :)
"""

__id__ = "voice_timing"
__name__ = "Voice Timing"
__description__ = "Автоматически добавляет тайминг при ответе на голосовые/видео/музыку.\nAutomatically adds timing when replying to voice messages, video messages, and music."
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "1.3.0"
__icon__ = "DateRegBot_by_MoiStikiBot/17"
__min_version__ = "11.12.1"

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Switch, Input, Divider
from java.util import Locale
from hook_utils import find_class
from android_utils import run_on_ui_thread
from java import dynamic_proxy, jclass

class Locales:
    en = {
        "header_media": "Media Types",
        "header_appearance": "Appearance",
        "voice_title": "Voice messages",
        "round_title": "Video messages",
        "music_title": "Music",
        "format_title": "Timing format",
        "format_hint": "Example: [{time}] or ({time})",
        "suffix_title": "Add to the end",
        "suffix_hint": "Place timing after your text",
        "insert_on_type_title": "Insert when typing",
        "insert_on_type_hint": "Insert timing when you start typing",
        "ignore_zeros_title": "Ignore 00:00",
        "ignore_zeros_hint": "Do not add timing if time is 00:00",
    }
    ru = {
        "header_media": "Типы медиа",
        "header_appearance": "Внешний вид",
        "voice_title": "Голосовые",
        "round_title": "Видеокружки",
        "music_title": "Музыка",
        "format_title": "Формат времени",
        "format_hint": "Пример: [{time}] или ({time})",
        "suffix_title": "В конец сообщения",
        "suffix_hint": "Размещать тайминг после вашего текста",
        "insert_on_type_title": "Вставлять при наборе",
        "insert_on_type_hint": "Вставлять таймкод при наборе",
        "ignore_zeros_title": "Не вставлять 00:00",
        "ignore_zeros_hint": "Не добавлять тайминг, если время равно 00:00",
    }
    default = en

LOCALE = Locale.getDefault().getLanguage()

def localise(key: str) -> str:
    locale_dict = getattr(Locales, LOCALE, Locales.default)
    return locale_dict.get(key, Locales.default.get(key, key))

DEFAULT_FORMAT = "[{time}]"
DEFAULT_VOICE_ENABLED = True
DEFAULT_ROUND_ENABLED = True
DEFAULT_MUSIC_ENABLED = True
DEFAULT_SUFFIX_MODE = False
DEFAULT_INSERT_ON_TYPE = False
DEFAULT_IGNORE_ZEROS = False


class VoiceTimingPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.MediaController = None
        self.ChatActivityEnterView = None
        self.TextWatcherClass = None
        self._loaded = False
        self._unhook_reply = None
        self._watchers = {}
        self._inserted_replies = set()
        self._skip_next_change = False
    
    def on_plugin_load(self):
        self._load_classes()
        self._setup_hooks()
        self.add_on_send_message_hook()
        self._message_edit_text_field = None
    
    def on_plugin_unload(self):
        if self._unhook_reply:
            self.unhook_method(self._unhook_reply)
            self._unhook_reply = None
        self._watchers.clear()
        self._inserted_replies.clear()
    
    def _load_classes(self):
        if self._loaded: return True
        try:
            self.MediaController = jclass("org.telegram.messenger.MediaController")
            self.ChatActivityEnterView = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            self.TextWatcherClass = find_class("android.text.TextWatcher")
            self._loaded = True
            return True
        except Exception as e:
            self.log(f"Failed to load classes: {e}")
            return False
    
    def _setup_hooks(self):
        if not self._loaded: return
        try:
            MessageObject = find_class("org.telegram.messenger.MessageObject")
            ReplyQuote = find_class("org.telegram.ui.ChatActivity$ReplyQuote")
            
            method = self.ChatActivityEnterView.getClass().getDeclaredMethod(
                "setReplyingMessageObject", 
                MessageObject,
                ReplyQuote,
                MessageObject
            )
            method.setAccessible(True)
            self._unhook_reply = self.hook_method(method, ReplyHook(self))
        except Exception as e:
            self.log(f"Failed to setup hook: {e}")
    
    def create_settings(self):
        settings = [
            Header(text=localise("header_media")),
            Switch(key="voice_enabled", text=localise("voice_title"), default=DEFAULT_VOICE_ENABLED, icon="msg_voice_unmuted"),
            Switch(key="round_enabled", text=localise("round_title"), default=DEFAULT_ROUND_ENABLED, icon="msg_videocall"),
            Switch(key="music_enabled", text=localise("music_title"), default=DEFAULT_MUSIC_ENABLED, icon="files_music"),
            Divider(),
            
            Header(text=localise("header_appearance")),
            Input(key="format", text=localise("format_title"), subtext=localise("format_hint"), default=DEFAULT_FORMAT, icon="msg_stories_timer"),
        ]
        
        if self.get_setting("insert_on_type", DEFAULT_INSERT_ON_TYPE):
            if self.get_setting("suffix_mode", DEFAULT_SUFFIX_MODE):
                self.set_setting("suffix_mode", False)
        else:
            settings.append(Switch(key="suffix_mode", text=localise("suffix_title"), subtext=localise("suffix_hint"), default=DEFAULT_SUFFIX_MODE, icon="msg2_chats_add"))
            
        settings.append(Switch(key="insert_on_type", text=localise("insert_on_type_title"), subtext=localise("insert_on_type_hint"), default=DEFAULT_INSERT_ON_TYPE, icon="fab_compose_small_solar"))
        settings.append(Switch(key="ignore_zeros", text=localise("ignore_zeros_title"), subtext=localise("ignore_zeros_hint"), default=DEFAULT_IGNORE_ZEROS, icon="filled_stop_location"))
        return settings
    
    def _format_time(self, seconds: float) -> str:
        try:
            s = int(seconds)
            if s == 0 and self.get_setting("ignore_zeros", DEFAULT_IGNORE_ZEROS):
                return None
            return f"{s // 60:02d}:{s % 60:02d}"
        except: return "00:00"
    
    def _get_current_playback_position(self, reply_msg) -> float:
        try:
            if not self._load_classes(): return 0.0
            mc = self.MediaController.getInstance()
            playing_msg = mc.getPlayingMessageObject()
            
            if playing_msg and reply_msg and reply_msg.getId() == playing_msg.getId():
                progress_ms = mc.getProgressMs(reply_msg)
                if progress_ms > 0: return float(progress_ms) / 1000.0
            return 0.0
        except: return 0.0
    
    def _check_reply_type(self, reply_msg) -> bool:
        if not reply_msg: return False
        try:
            is_v = bool(reply_msg.isVoice())
            is_r = bool(reply_msg.isRoundVideo())
            is_m = bool(reply_msg.isMusic())
            
            if is_v and not self.get_setting("voice_enabled", DEFAULT_VOICE_ENABLED): return False
            if is_r and not self.get_setting("round_enabled", DEFAULT_ROUND_ENABLED): return False
            if is_m and not self.get_setting("music_enabled", DEFAULT_MUSIC_ENABLED): return False
            
            return is_v or is_r or is_m
        except: return False
    
    def on_reply_changed(self, reply_msg):
        if reply_msg is None:
            self._inserted_replies.clear()
    
    def _create_watcher_class(self):
        plugin = self
        TextWatcher = self.TextWatcherClass
        
        class TimingTextWatcher(dynamic_proxy(TextWatcher)):
            def __init__(self, enter_view):
                super().__init__()
                self.enter_view = enter_view
            
            def beforeTextChanged(self, s, start, count, after):
                pass
            
            def onTextChanged(self, s, start, before, count):
                if not plugin.get_setting("insert_on_type", DEFAULT_INSERT_ON_TYPE):
                    return
                
                if plugin._skip_next_change:
                    plugin._skip_next_change = False
                    return
                
                try:
                    reply_msg = self.enter_view.getReplyingMessageObject()
                    if not reply_msg:
                        return
                    
                    reply_id = reply_msg.getId()
                    
                    if reply_id in plugin._inserted_replies:
                        return
                    
                    if not plugin._check_reply_type(reply_msg):
                        return
                    
                    text = str(s) if s else ""
                    
                    if count > 0 and before == 0 and start == 0 and len(text) == count and len(text.strip()) > 0:
                        time_str = plugin._format_time(plugin._get_current_playback_position(reply_msg))
                        if not time_str:
                             return
                        
                        timing = plugin.get_setting("format", DEFAULT_FORMAT).replace("{time}", time_str)
                        suffix_mode = False 
                        
                        plugin._inserted_replies.add(reply_id)
                        enter_view = self.enter_view
                        
                        def insert():
                            try:
                                et_field = plugin._get_message_edit_text_field(enter_view)
                                current_text = ""
                                et_view = None
                                if et_field:
                                    et_view = et_field.get(enter_view)
                                    if et_view:
                                        current_text = str(et_view.getText())
                                
                                if not et_view:
                                     current_text = text
                                
                                if timing in current_text:
                                    plugin._skip_next_change = False
                                    return

                                plugin._skip_next_change = True
                                if suffix_mode:
                                    new_text = current_text + " " + timing
                                else:
                                    new_text = timing + " " + current_text
                                enter_view.setFieldText(new_text)
                            except Exception as e:
                                plugin.log(f"Insert error: {e}")
                                plugin._skip_next_change = False
                        
                        run_on_ui_thread(insert)
                except Exception as e:
                    plugin.log(f"TextWatcher error: {e}")
            
            def afterTextChanged(self, s):
                pass
        
        return TimingTextWatcher
    
    def attach_watcher(self, enter_view):
        try:
            view_id = id(enter_view)
            if view_id in self._watchers:
                return
            
            WatcherClass = self._create_watcher_class()
            watcher = WatcherClass(enter_view)
            enter_view.addTextChangedListener(watcher)
            self._watchers[view_id] = watcher
        except Exception as e:
            self.log(f"Failed to attach watcher: {e}")

    def on_send_message_hook(self, account: int, params) -> HookResult:
        try:
            if self.get_setting("insert_on_type", DEFAULT_INSERT_ON_TYPE):
                return HookResult()
            
            reply_msg = getattr(params, 'replyToMsg', None)
            if not reply_msg: 
                return HookResult()
            
            if not self._check_reply_type(reply_msg):
                return HookResult()
            
            msg_text = getattr(params, 'message', None)
            if not isinstance(msg_text, str) or not msg_text.strip(): 
                return HookResult()
            
            time_str = self._format_time(self._get_current_playback_position(reply_msg))
            if not time_str:
                return HookResult()

            timing = self.get_setting("format", DEFAULT_FORMAT).replace("{time}", time_str)
            
            if timing in msg_text:
                return HookResult()
            
            if self.get_setting("suffix_mode", DEFAULT_SUFFIX_MODE):
                params.message = f"{msg_text} {timing}"
            else:
                params.message = f"{timing} {msg_text}"
            
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        except: 
            return HookResult()
            
    def _get_message_edit_text_field(self, enter_view=None):
        if hasattr(self, '_message_edit_text_field') and self._message_edit_text_field:
            return self._message_edit_text_field
            
        if not enter_view:
            return None
            
        try:
            current_class = enter_view.getClass()
            while current_class:
                try:
                    field = current_class.getDeclaredField("messageEditText")
                    field.setAccessible(True)
                    self._message_edit_text_field = field
                    return field
                except:
                    current_class = current_class.getSuperclass()
            
            self.log("messageEditText field not found in hierarchy")
            return None
        except Exception as e:
            self.log(f"Failed to find field: {e}")
            return None


class ReplyHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            reply_msg = param.args[0] if len(param.args) > 0 else None
            
            self.plugin.on_reply_changed(reply_msg)
            self.plugin.attach_watcher(enter_view)
        except Exception as e:
            self.plugin.log(f"ReplyHook error: {e}")